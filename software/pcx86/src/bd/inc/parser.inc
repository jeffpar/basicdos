;
; BASIC-DOS Parsing Support
;
; @author Jeff Parsons <Jeff@pcjs.org>
; @copyright (c) 2020-2021 Jeff Parsons
; @license MIT <https://basicdos.com/LICENSE.txt>
;
; This file is part of PCjs, a computer emulation software project at pcjs.org
;

;
; DOS_UTL_ITOA flags
;
PF_LEFT   equ	01h		; left-alignment requested
PF_HASH   equ	02h		; prefix requested (eg, "0x")
PF_ZERO   equ	04h		; zero padding requested
PF_LONG   equ	08h		; long value (32 bits); default is 16
PF_SIGN   equ	10h		; signed value
PF_WIDTH  equ	20h		; width encountered
PF_PRECIS equ	40h		; precision encountered (after '.')
PF_BYTE   equ	80h		; byte value (8 bits); default is 16

BUFLEN	equ	120		; max stack space to use as printf buffer

;
; DOS_TTY_INPUT buffer format
;
INPBUF		struc
INP_MAX		db	?
INP_CNT		db	?
INP_DATA	db	256 dup (?)
INPBUF		ends

;
; Token data (eg, as generated by DOS_UTL_TOKEN)
;
; Whereas INP_DATA consists of bytes, TOK_DATA consists of TOKLETs.
;
TOKLET		struc
TOKLET_CLS	db	?	; 00h: token class
TOKLET_LEN	db	?	; 01h: token length
TOKLET_OFF	dw	?	; 02h: token offset
TOKLET		ends

TOKBUF		struc
TOK_MAX		db	?
TOK_CNT		db	?
TOK_DATA	db	128 * (size TOKLET) dup (?)
TOKBUF		ends

TOKTYPE_BASIC	equ	0	; default parsing
TOKTYPE_GENERIC	equ	1	; generic whitespace-separated parsing

;
; TOKTYPE_BASIC parsing includes some knowledge of BASIC variable types
; (eg, CLS_VAR_LONG), which is why these variable types are defined here
; rather than in the interpreter.
;
VAR_NONE	equ	000h
VAR_PARM	equ	020h	; 2 bytes of var data (var type, parm offset)
VAR_LONG	equ	040h	; 4 bytes of var data
VAR_STR		equ	060h	; 4 bytes of ptr data (string ptr)
VAR_SINGLE	equ	080h	; 4 bytes of var data
VAR_DOUBLE	equ	0A0h	; 8 bytes of var data
VAR_FUNC	equ	0C0h	; variable data based on func signature
VAR_ARRAY	equ	0E0h	; variable data based on array signature
VAR_TYPE	equ	0E0h

;
; Token class (CLS) bits, used during token classification.  There aren't
; enough discrete bits in a byte for all the classes we care about, so some
; must use non-sensical combinations (eg, CLS_FLOAT is CLS_OCT + CLS_DEC).
;
; However, it's only semi-non-sensical, because you know you have *either*
; a decimal integer *or* a decimal float whenever CLS_DEC is set; if you need
; more specificity, then you must determine whether the CLS_FLOAT bits
; contain *only* CLS_DEC.
;
; Other seemingly contradictory combinations are used internally; for example,
; CLS_OCT + CLS_HEX temporarily indicates that an ampersand has been detected,
; and therefore either an octal or hex value may follow it.
;
CLS_OCT		equ	01h	; octal value
CLS_HEX		equ	02h	; hexadecimal value
CLS_DEC		equ	04h	; decimal value
CLS_FLOAT	equ	05h	; floating-point value
CLS_NUM		equ	07h	; some type of numeric constant
CLS_STR		equ	08h	; string constant
CLS_VAR		equ	10h	; identifier (eg, keyword, var, keyop)
CLS_SYM		equ	20h	; symbol
CLS_KEYWORD	equ	30h	; identifier later identified as a keyword
CLS_ANY		equ	3Fh	;
CLS_DQUOTE	equ	40h	; double quotes
CLS_WHITE	equ	80h	; whitespace
CLS_VAR_LONG	equ	CLS_VAR OR VAR_LONG	; 050h (var ending with '%')
CLS_VAR_STR	equ	CLS_VAR OR VAR_STR	; 070h (var ending with '$')
CLS_VAR_SINGLE	equ	CLS_VAR OR VAR_SINGLE	; 090h (var ending with '!')
CLS_VAR_DOUBLE	equ	CLS_VAR OR VAR_DOUBLE	; 0B0h (var ending with '#')

;
; After DOS_UTL_TOKEN breaks a string into tokens, use DOS_UTL_TOKID
; to identify each token, based on a table of sorted TOKDEF structures.
;
; The table must begin with two bytes: # tokens (255 max) and TOKDEF size.
;
TOKTBL		struc
TOKTBL_NUM	db	?	; # of tokens in table
TOKTBL_SIZE	db	?	; default is size TOKDEF
				; sorted array of TOKDEF structures follows
TOKTBL		ends

TOKDEF		struc
TOKDEF_ID	db	?	; ID of token
TOKDEF_LEN	db	?	; length of token string
TOKDEF_OFF	dw	?	; offset of token string
TOKDEF		ends

;
; Use TESTSW to test for switches that have been parsed with DOS_UTL_PARSESW;
; eg:
;
;	TESTSW	<'D'>
;	jnz	doSwitch
;
; WARNING: You can test multiple switches (eg, <'D','E'>) with a single
; test, but the burden is on you to make sure all the switch bits are in the
; same word (ie, PSP_DIGITS, PSP_LETTERS.LOW, or PSP_LETTERS.HIW).
;
TESTSW	macro	syms
	_SWVAL = 0
	_SWOFF = -1
	IRP	sym,<syms>
	 IF	sym GE 'Q'
	_SWVAL = _SWVAL OR (1 SHL (sym - 'Q'))
	_SWOFF = 4
	 ELSE
	  IF	sym GE 'A'
	_SWVAL = _SWVAL OR (1 SHL (sym - 'A'))
	_SWOFF = 2
	  ELSE
	   IF	sym GE '0'
	_SWVAL = _SWVAL OR (1 SHL (sym - '0'))
	_SWOFF = 0
	   ELSE
	ERROR <Unrecognized switch: sym>
	EXITM
	   ENDIF
	  ENDIF
	 ENDIF
	ENDM
	IF	(_SWOFF GE 0) AND (_SWVAL NE 0)
	 IFE	(_SWVAL AND 0FF00h)
	test	byte ptr ds:[PSP_DIGITS + _SWOFF],_SWVAL
	EXITM
	 ENDIF
	 IFE	(_SWVAL AND 000FFh)
	test	byte ptr ds:[PSP_DIGITS + _SWOFF + 1],_SWVAL SHR 8
	EXITM
	 ENDIF
	test	ds:[PSP_DIGITS + _SWOFF],_SWVAL
	EXITM
	ENDIF
	ERROR <No switches tested: syms>
	endm
