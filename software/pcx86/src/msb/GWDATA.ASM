; [ This translation created 10-Feb-83 by Version 4.3 ]

	.RADIX  8		; To be safe

CSEG	SEGMENT PUBLIC 'CODESG'
	ASSUME  CS:CSEG

INCLUDE	BINTRP.INC

	TITLE   GWDATA copied from BINTRP.MAC

	.RADIX	10

	.XLIST

SLASHI=0			;Runtime Switch to include IBM Compat.-Features
FETOK=0				;For FE extended tokens
FDTOK=0				;For FD tokens too.  (Must have
				;FETOK==1.)
				;tokens.
INTDEX=0			;For Intelledex version.
NMPAGE=1			;Number of text pages (for GW
				;Multi-page)
				;KPOS, etc.
LNREAD=0			;For LINE READ statement
MELCO=0				;Mitsubishi Electronics Co.
SIRIUS=0
MCI=0
ZENITH=0			;ZENITH 8086
TETRA=0
CPM86=0
HAL=0
GENFLS=0
PANDBL=0
TSHIBA=0
SGS=0
ALPS=0
ALPCPM=0
GENWID=0
NNECBS=0
CAN8=0
PC8A=0

	FN2SW=0			;IBMTOK versions dispatch from IBMRES.MAC
	LABEL=PC8A
	HLPEDT=PC8A

OKI=0
BUBL=0
	NORNF=0
IEESLV=0
TRSHHC=0
OLVPPC=0
NECPPC=0
USA=0				;For HHC-USA version
EUROPE=0			;For HHC-EUROPE version
	.LIST

;Local Switches
;
	LTRACE=ALPCPM		;trace output selectable
	LABEL=PC8A
	HLPEDT=PC8A
	UCEMSG=NNECBS		;Upper case error messages.
	OLD86=MELCO AND CPM86	;For "old" 8086 error messages (prior
				;to alignment for IBM compatibility).

	OLDBLD=ALPCPM OR ALPS OR OKI OR HAL OR PC8A OR BUBL OR GW OR TSHIBA

	INCLUDE	GIO86U.INC
	INCLUDE	MSDOSU.INC	;MSDOS constants

	EXTRN	_DVTBL:NEAR,_DVPTR:NEAR,_DVINI:NEAR,_DVTRM:NEAR
	EXTRN	INIT:NEAR,INTDIV:NEAR,CONCON:NEAR,CONCN2:NEAR



	BUFOFS=0

	BUFOFS=2		;MUST CRUNCH INTO ERALIER PLACE FOR
				; SINGLE QUOTE

	KBFLEN=BUFLEN+(BUFLEN/4)	;MAKE KRUNCH BUFFER SOMEWHAT
				; LARGER THAN SOURCE BUFFER (BUF)

	EXTRN	NAME:NEAR

	EXTRN	INLIN:NEAR,CRDO:NEAR,CRDONZ:NEAR,STRCMP:NEAR,FININL:NEAR
	EXTRN	PPSWRT:NEAR

	EXTRN	OUTDO:NEAR

	EXTRN	BLTU:NEAR,BLTUC:NEAR,CLEAR:NEAR,CLEARC:NEAR,GTMPRT:NEAR
	EXTRN	ISLET:NEAR,ISLET2:NEAR,PTRGET:NEAR
	EXTRN	QINLIN:NEAR,SCRTCH:NEAR,STKINI:NEAR,RUNC:NEAR,RESFIN:NEAR
	EXTRN	PTRGT2:NEAR,STPEND:NEAR,DIM:NEAR

	EXTRN	DCOMPR:NEAR,SYNCHR:NEAR

	EXTRN	SIGN:NEAR

	EXTRN	OPEN:NEAR,CLOSE:NEAR,PRGFIN:NEAR,FILIND:NEAR

	EXTRN	FILINP:NEAR,CLSALL:NEAR,INDSKC:NEAR


	EXTRN	LRUN:NEAR

	EXTRN	FILGET:NEAR


	EXTRN	INXHRT:NEAR
	EXTRN	SGN:NEAR,ABSFN:NEAR,SQR:NEAR,FDIV:NEAR,FSUB:NEAR
	EXTRN	FMULT:NEAR,RND:NEAR	;MATHPK INTERNALS
	EXTRN	ZERO:NEAR,MOVE:NEAR,FOUT:NEAR,FIN:NEAR,FCOMP:NEAR
	EXTRN	FADD:NEAR,PUSHF:NEAR,INT:NEAR
	EXTRN	ENDST:NEAR,NEXT:NEAR,RESTORE:NEAR,SCRATH:NEAR,CONT:NEAR
	EXTRN	FRE:NEAR
	EXTRN	MOVFR:NEAR,MOVRF:NEAR,MOVRM:NEAR,INPRT:NEAR,LINPRT:NEAR
	EXTRN	FDIVT:NEAR
	EXTRN	MOVFM:NEAR,MOVMF:NEAR,FADDS:NEAR
	EXTRN	INRART:NEAR,NEG:NEAR
	EXTRN	BSERR:NEAR
	EXTRN	CAT:NEAR,FREFAC:NEAR,FRESTR:NEAR,FRETMP:NEAR,FRETMS:NEAR
	EXTRN	STRCPY:NEAR,GETSTK:NEAR
	EXTRN	STRLIT:NEAR,STRLT2:NEAR,STRLT3:NEAR,STRLTI:NEAR,STROUT:NEAR
	EXTRN	STRPRT:NEAR,STROUI:NEAR
	EXTRN	GETSPA:NEAR,PUTNEW:NEAR,STOP:NEAR,OMERR:NEAR,REASON:NEAR

	EXTRN	GARBA2:NEAR	;We have our own G. C.


	EXTRN	INSTR:NEAR

	EXTRN	PRINUS:NEAR,PUTTMP:NEAR

	EXTRN	FOUTH:NEAR,FOUTO:NEAR,STRO$:NEAR,STRH$:NEAR

	EXTRN	STR$:NEAR,LEN:NEAR,ASC:NEAR,CHR$:NEAR,LEFT$:NEAR
	EXTRN	RIGHT$:NEAR,MID$:NEAR,VAL:NEAR


	EXTRN	STRNG$:NEAR
	EXTRN	TON:NEAR,TOFF:NEAR
	EXTRN	SPACE$:NEAR

	EXTRN	SIGNS:NEAR




	EXTRN	UMULT:NEAR

	EXTRN	SIGNC:NEAR,POPHRT:NEAR

	EXTRN	FINLPT:NEAR

	EXTRN	CONSIH:NEAR,VMOVFA:NEAR,VMOVAF:NEAR,ISIGN:NEAR,CONIA:NEAR
	EXTRN	VSIGN:NEAR,VDFACS:NEAR
	EXTRN	VMOVMF:NEAR,VMOVFM:NEAR,FRCINT:NEAR,FRCSNG:NEAR,FRCDBL:NEAR
	EXTRN	VNEG:NEAR,PUFOUT:NEAR,DCXBRT:NEAR,IADD:NEAR
	EXTRN	ISUB:NEAR,IMULT:NEAR,ICOMP:NEAR,INEG:NEAR,DADD:NEAR
	EXTRN	DSUB:NEAR,DMULT:NEAR,DDIV:NEAR,DCOMP:NEAR,VINT:NEAR
	EXTRN	FINDBL:NEAR,INEG2:NEAR
	EXTRN	IDIV:NEAR,IMOD:NEAR
	EXTRN	VMOVE:NEAR,VALINT:NEAR,VALSNG:NEAR,FRCSTR:NEAR,CHKSTR:NEAR
	EXTRN	MAKINT:NEAR
	EXTRN	MOVE1:NEAR


	EXTRN	SCNSEM:NEAR
	EXTRN	WHILE:NEAR,WEND:NEAR
	EXTRN	CALLS:NEAR
	EXTRN	PROCHK:NEAR
	EXTRN	WRITE:NEAR
	EXTRN	CHAIN:NEAR,COMMON:NEAR




;
; This label must be the first one in the code segment as it is
; where the SYSTEM command will jump to
;
PUBLIC	BEGCSG
BEGCSG:
PUBLIC	CPMWRM
CPMWRM:
	ORG	5O
PUBLIC	CPMENT
CPMENT:

	ORG	400O		; Leave room in the CS for OS control block

PUBLIC	$START
$START:
PUBLIC	START
START:





JMPINI:	JMP	INIT		;INIT IS THE INTIALIZATION ROUTINE
				;IT SETS UP CERTAIN
				;LOCATIONS DELETES FUNCTIONS IF
				;DESIRED AND
				;CHANGES THIS TO JMP READY






;IFE    <I8086-1>!<LENGTH-2>,<> ;Seems to be a relic, screws up
				;conditional nesting. 16-Feb-82/NGT


	SUBTTL ROM VERSION INITALIZATION, AND CONSTANTS



;
; The reserved word tables are in another module.  Consequently
; many things must be declared external.  All of these things
; are in the code segement or are absolutes (like tokens).
; I.e., they are not in the data segment.
;

	EXTRN	ALPTAB:NEAR,ATNTK:NEAR
	EXTRN	CLINTK:NEAR
	EXTRN	EQULTK:NEAR,ERCTK:NEAR,ERLTK:NEAR
	EXTRN	FNTK:NEAR,FUNDSP:NEAR,STMDSP:NEAR
	EXTRN	GREATK:NEAR
	EXTRN	INSRTK:NEAR
	EXTRN	LESSTK:NEAR,LSTOPK:NEAR
	EXTRN	MIDTK:NEAR,MINUTK:NEAR
	EXTRN	NMREL:NEAR,NOTTK:NEAR,NUMCMD:NEAR
	EXTRN	ONEFUN:NEAR
	EXTRN	POS:NEAR,PLUSTK:NEAR,PRINT:NEAR
	EXTRN	RESLST:NEAR
	EXTRN	SNGQTK:NEAR,SPCTAB:NEAR,SQRTK:NEAR,STEPTK:NEAR
	EXTRN	THENTK:NEAR
	EXTRN	USRTK:NEAR
	EXTRN	$AUTO:NEAR
	EXTRN	$DATA:NEAR,$DATCO:NEAR,$DELETE:NEAR
	EXTRN	$EDIT:NEAR,$ELSE:NEAR,$END:NEAR,$ERL:NEAR,$ERROR:NEAR
	EXTRN	$FN:NEAR,$FOR:NEAR
	EXTRN	$GOSUB:NEAR,$GOTO:NEAR
	EXTRN	$IF:NEAR,$INKEY$:NEAR,$INPUT:NEAR
	EXTRN	$LIST:NEAR,$LLIST:NEAR
	EXTRN	$NEXT:NEAR
	EXTRN	$POINT:NEAR,$PRINT:NEAR
	EXTRN	$REM:NEAR,$REMCO:NEAR,$RENUM:NEAR,$RESTORE:NEAR,$RESUME:NEAR
	EXTRN	$RETURN:NEAR,$RND:NEAR,$RUN:NEAR
	EXTRN	$SCREEN:NEAR,$STOP:NEAR,$STRING$:NEAR
	EXTRN	$THEN:NEAR,$TO:NEAR
	EXTRN	$USR:NEAR
	EXTRN	$VARPTR:NEAR
	EXTRN	$WEND:NEAR,$WHILE:NEAR
ADRP	MACRO	X
ENDM


PUBLIC	OPTAB
OPTAB:	DB	121		;OPERATOR TABLE CONTAINS
				;PRECEDENCE FOLLOWED BY
				;THE ROUTINE ADDRESS
	ADRP	FADDT
	DB	121
	ADRP	FSUBT
	DB	124
	ADRP	FMULTT
	DB	124
	ADRP	FDIVT
	DB	127
	ADRP	FPWRT
	DB	80
	ADRP	ANDO
	DB	70
	ADRP	ORO
	DB	60		;PRECEDENCE OF "XOR"
	DB	50		;PRECEDENCE OF "EQV"
	DB	40		;PRECEDENCE OF "IMP"
	DB	122		;PRECEDENCE OF "MOD"
	DB	123		;PRECEDENCE OF "IDIV"

;
; USED BY ASSIGNMENT CODE TO FORCE THE RIGHT HAND VALUE
; TO CORRESPOND TO THE VALUE TYPE OF THE VARIABLE BEING
; ASSIGNED TO.
;
PUBLIC	FRCTBL
FRCTBL:	ADR	FRCDBL
	DB	2 DUP(?)
	ADR	FRCINT
	ADR	CHKSTR
	ADR	FRCSNG
;
; THESE TABLES ARE USED AFTER THE DECISION HAS BEEN MADE
; TO APPLY AN OPERATOR AND ALL THE NECESSARY CONVERSION HAS
; BEEN DONE TO MATCH THE TWO ARGUMENT TYPES (APPLOP)
;
PUBLIC	DBLDSP
DBLDSP:	ADR	DADD		;DOUBLE PRECISION ROUTINES
	ADR	DSUB
	ADR	DMULT
	ADR	DDIV
	ADR	DCOMP
PUBLIC	OPCNT
	OPCNT=(($-DBLDSP)/2)-1
PUBLIC	SNGDSP
SNGDSP:	ADR	FADD		;SINGLE PRECISION ROUTINES
	ADR	FSUB
	ADR	FMULT
	ADR	FDIV
	ADR	FCOMP
PUBLIC	INTDSP
INTDSP:	ADR	IADD		;INTEGER ROUTINES
	ADR	ISUB
	ADR	IMULT
	ADR	INTDIV
	ADR	ICOMP

	PAGE
	SUBTTL  ERROR MESSAGE TABLE

DCUL	MACRO	X
	DC	X
ENDM


	QQ=QQ-2

PUBLIC	ERRTAB
ERRTAB:
	DB	0
	QQ=0
DCE	MACRO	X
ENDM
DCL	MACRO	X
	QQ=QQ+1
	DCUL	X
	DB	0
ENDM
	DCE	"NF"
	DCL	"NEXT without FOR"
PUBLIC	ERRNF
	ERRNF=QQ
	DCE	"SN"
	DCL	"Syntax error"
PUBLIC	ERRSN
	ERRSN=QQ
	DCE	"RG"
	DCL	"RETURN without GOSUB"
PUBLIC	ERRRG
	ERRRG=QQ
	DCE	"OD"
	DCL	"Out of DATA"
PUBLIC	ERROD
	ERROD=QQ
	DCE	"FC"
	DCL	"Illegal function call"
PUBLIC	ERRFC
	ERRFC=QQ
PUBLIC	$OVMSG
$OVMSG:
PUBLIC	OVRMSG
OVRMSG:
	DCE	"OV"
	DCL	"Overflow"
PUBLIC	ERROV
	ERROV=QQ
	DCE	"OM"
	DCL	"Out of memory"
PUBLIC	ERROM
	ERROM=QQ
	DCE	"UL"
	DCL	"Undefined line number"
PUBLIC	ERRUS
	ERRUS=QQ
	DCE	"BS"
	DCL	"Subscript out of range"
PUBLIC	ERRBS
	ERRBS=QQ
	DCE	"DD"
	DCL	"Duplicate Definition"
PUBLIC	ERRDD
	ERRDD=QQ
PUBLIC	$DIV0M
$DIV0M:
PUBLIC	DIVMSG
DIVMSG:
	DCE	"/0"
	DCL	"Division by zero"
PUBLIC	ERRDV0
	ERRDV0=QQ
	DCE	"ID"
	DCL	"Illegal direct"
PUBLIC	ERRID
	ERRID=QQ
	DCE	"TM"
	DCL	"Type mismatch"
PUBLIC	ERRTM
	ERRTM=QQ
	DCE	"OS"
	DCL	"Out of string space"
PUBLIC	ERRSO
	ERRSO=QQ
	DCE	"LS"
	DCL	"String too long"
PUBLIC	ERRLS
	ERRLS=QQ
	DCE	"ST"
	DCL	"String formula too complex"
PUBLIC	ERRST
	ERRST=QQ
	DCE	"CN"
	DCL	"Can't continue"
PUBLIC	ERRCN
	ERRCN=QQ
	DCE	"UF"
	DCL	"Undefined user function"
PUBLIC	ERRUF
	ERRUF=QQ
	DCE	"NR"
	DCL	"No RESUME"
PUBLIC	ERRNR
	ERRNR=QQ
	DCE	"RW"
	DCL	"RESUME without error"
PUBLIC	ERRRE
	ERRRE=QQ
	DCE	"UE"
	DCL	"Unprintable error"
PUBLIC	ERRUE
	ERRUE=QQ
	DCE	"MO"
	DCL	"Missing operand"
PUBLIC	ERRMO
	ERRMO=QQ
	DCE	"BO"
	DCL	"Line buffer overflow"
PUBLIC	ERRLBO
	ERRLBO=QQ
	DCE	"DT"
	DCL	"Device Timeout"
PUBLIC	ERRDTO
	ERRDTO=QQ
	DCE	"DF"
	DCL	"Device Fault"
PUBLIC	ERRDVF
	ERRDVF=QQ
	DCE	"FN"
	DCL	"FOR Without NEXT"
PUBLIC	ERRFN
	ERRFN=QQ
	DCE	"OP"
	DCL	"Out of Paper"
PUBLIC	ERROTP
	ERROTP=QQ
	DCE	"??"
	DCL	"?"
	DCE	"WH"
	DCL	"WHILE without WEND"
PUBLIC	ERRWH
	ERRWH=QQ
	DCE	"WE"
	DCL	"WEND without WHILE"
PUBLIC	ERRWE
	ERRWE=QQ
PUBLIC	NONDSK
	NONDSK=QQ		;LAST NON DISK ERROR.
;
;       Following are DISK errors
;
	QQ=49D			;DISK ERRORS START AT 50.
PUBLIC	DSKERR
	DSKERR=QQ		;FIRST DISK ERROR
PUBLIC	ERRUE1
	ERRUE1=ERRUE+DSKERR-NONDSK
PUBLIC	DSKER1
	DSKER1=DSKERR-NONDSK

	DCE	"FO"
	DCL	"FIELD overflow"
PUBLIC	ERRFOV
	ERRFOV=QQ
	DCE	"IE"
	DCL	"Internal error"
PUBLIC	ERRIER
	ERRIER=QQ
	DCE	"BN"
	DCL	"Bad file number"
PUBLIC	ERRBFN
	ERRBFN=QQ
PUBLIC	ERRBFN
	ERRBFN=QQ
	DCE	"FF"
	DCL	"File not found"
PUBLIC	ERRFNF
	ERRFNF=QQ
	DCE	"BM"
	DCL	"Bad file mode"
PUBLIC	ERRBFM
	ERRBFM=QQ
PUBLIC	ERRFNO
	ERRFNO=QQ		;Map "File Not Open" to "Bad file mode".
	DCE	"AO"
	DCL	"File already open"
PUBLIC	ERRFAO
	ERRFAO=QQ
	DCE	"??"
	DCL	"?"
PUBLIC	DSKLOC
	DSKLOC=$+6
	DCE	"IO"
	DCL	"Device I/O Error"
PUBLIC	ERRDIO
	ERRDIO=QQ
PUBLIC	ERRDPE
	ERRDPE=QQ		;Map "Device Parity Error" to
				;"Device I/O Error".
PUBLIC	ERRIOE
	ERRIOE=QQ
	DCE	"FE"
	DCL	"File already exists"
PUBLIC	ERRFAE
	ERRFAE=QQ
	DCE	"??"
	DCL	"?"
	DCE	"??"
	DCL	"?"
	DCE	"DF"
	DCL	"Disk full"
PUBLIC	ERRDFL
	ERRDFL=QQ
	DCE	"EF"
	DCL	"Input past end"
PUBLIC	ERRRPE
	ERRRPE=QQ
	DCE	"RN"
	DCL	"Bad record number"
PUBLIC	ERRBRN
	ERRBRN=QQ
	DCE	"NM"
	DCL	"Bad file name"
PUBLIC	ERRIFN
	ERRIFN=QQ		;Map "Illegal filename" to "Bad file
				;name".
PUBLIC	ERRNMF
	ERRNMF=QQ
	DCE	"??"
	DCL	"?"
PUBLIC	ERRMMM
	ERRMMM=QQ
	DCE	"DS"
	DCL	"Direct statement in file"
PUBLIC	ERRFDR
	ERRFDR=QQ
	DCE	"FL"
	DCL	"Too many files"
PUBLIC	ERRTMF
	ERRTMF=QQ
	DCL	"Device Unavailable"
PUBLIC	ERRDNA
	ERRDNA=QQ
	DCL	"Communication buffer overflow"
PUBLIC	ERRCBO
	ERRCBO=QQ
	DCL	"Disk write protected"
PUBLIC	ERRDWP
	ERRDWP=QQ
	DCL	"Disk not Ready"
PUBLIC	ERRDNR
	ERRDNR=QQ
	DCL	"Disk media error"
PUBLIC	ERRDME
	ERRDME=QQ
	DCL	"Advanced Feature"
PUBLIC	ERRADV
	ERRADV=QQ
	DCL	"Rename across disks"
PUBLIC	ERRRAD
	ERRRAD=QQ

PUBLIC	LSTERR
	LSTERR=QQ+1		;LAST ERROR USED FOR RANGE CHECKS IN LEN2
	PAGE

	SUBTTL CONSTANTS FOR ROM BASIC I/O, RNDX, FDIV, USRGO


;********************************************************************
;
;       NOTE!!!         THIS RAM CODE IS REPRODUCED LATER IN THIS
;                       LISTING WITHOUT LABELS AND TARGETED
;                       FOR ROM. THIS ALLOWS THE CODE TO BE COPIED
;                       INTO RAM FOR EXECUTION. IF THERE IS A CHANGE
;                       TO BE MADE TO THE RAM CODE MAKE THE SIMULAR
;                       CHANGE TO THE ROM AREA CODE WITHOUT LABELS.
;                       THE ROM CODE IS BRACKETED BY AN IFN CONVRT
;                       AND A COMMENT INDICATING THE CODE IS FOR
;                       TARGET MACHINE COMPILATIONS.
;
;******************************************************************

	PUBLIC	CONSTR,RAMLOW
PUBLIC	CNSLEN
	CNSLEN=ENDCNS-CONSTR

				;FOR ON-MACHINE COMPILATIONS
PUBLIC	CONSTR
	CONSTR=$
;************************************************************
;****** BEGDSG: is the begining of the data segment.  *******
;****** It MUST be the first label in DSEG, as it is  *******
;****** used by GWINIT to insert the OS control block *******
;************************************************************
DSEG	SEGMENT PUBLIC 'DATASG'
	ASSUME DS:DSEG
PUBLIC	BEGDSG
BEGDSG	LABEL WORD
	ORG	2D
PUBLIC	CPMMEM
CPMMEM	LABEL WORD
DSEG	ENDS
; ======== Code Phase ========
	RAMLOW=$		;WHERE CONSTANTS GET DEPOSITED
	INS86	352		;INTER-SEGMENT DIRECT JUMP
	DB	4 DUP(?)
;
;THE FOLLOWING IS THE LAST RANDOM NUMBER GENERATED BY RND
;IT MUST NOT BE ZERO, IT MUST BE BETWEEN 0 AND 1.
;

	.RADIX	8

	DB	0
; RNDCNT:
	DB	0
	DB	0
	RET			;THIS IS A KLUDGE TO MAKE CHRGET WORK
PUBLIC	NUMCON
; NUMCON:
	DB	OFFSET CONCON	;THESE FAKE TOKENS FORCE CHRGET
	DB	OFFSET CONCN2	;TO EFFECTIVELY RE-SCAN THE EMBEDED CONSTANT
PUBLIC	DSEGZ
; DSEGZ:
	DB	0		;DATA SEGMENT-LOCATED ZERO
PUBLIC	RNDCOP
; RNDCOP:
	DB	122		;COPY OF THE RANDOM NUMBER SEED
	DB	307		;BETWEEN 0 AND 1
	DB	117
	DB	200
PUBLIC	$RNDX
; $RNDX:
PUBLIC	RNDX
; RNDX:
	DB	122		;LAST RANDOM NUMBER GENERATED
	DB	307		;BETWEEN 0 AND 1
	DB	117
	DB	200
	.RADIX	10
; STAINP:
	IN	AL,0
	INS86	313		;"LONG" RETURN
PUBLIC	ENDPRG
; ENDPRG:
	DB	":"
	DB	0,0,0,0		;FAKE END OF PROGRAM FOR RESUME NEXT
	PAGE

	SUBTTL LOW SEGMENT -- RAM-- IE THIS STUFF IS NOT CONSTANT
;
; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
; PROGRAM INSTRUCTIONS IN ROM.
;

PUBLIC	USRTAB
; USRTAB:
REPT	10
	DW	65535D
ENDM
PUBLIC	NULCNT
; NULCNT:
	DB	1		;STORE HERE THE NUMBER OF NULLS
				;TO PRINT AFTER CRLF
PUBLIC	MSDCCF
; MSDCCF:
	DB	0		;Ctl-C flag set by Ctl-C int handler
PUBLIC	CTLCAD
; CTLCAD:
	DB	4 DUP(?)	;Store pre-BASIC CTL-C int vector
PUBLIC	DINTAD
; DINTAD:
	DB	4 DUP(?)	;Store BASIC Disk error int vector
PUBLIC	LSTCHR
; LSTCHR:
	DB	0		;used by SCNSOT to remember last chr out
PUBLIC	ERRFLG
; ERRFLG:
	DB	0		;USED TO SAVE THE ERROR NUMBER
				; SO EDIT CAN BE CALLED ON "SN" ERR.
PUBLIC	LPTLST
; LPTLST:
	DB	0		;LAST LINE PRINTER OPERATION. ZERO
				;MEANS LINEFEED. NON-ZERO MEANS PRINT
				;COMMAND (OKIA ONLY)
PUBLIC	LPTPOS
; LPTPOS:
	DB	0		;POSITION OF LPT PRINT HEAD -initially 0
PUBLIC	PRTFLG
; PRTFLG:
	DB	0		;WHETHER OUTPUT GOES TO LPT
	LNCMPS=(((LPTLEN/CLMWID)-1)*CLMWID)	;LAST COMMA FIELD POSIT
PUBLIC	NLPPOS
; NLPPOS:
	DB	OFFSET LNCMPS	;LAST COL # BEYOND WHICH NO MORE COMMA FIELDS
PUBLIC	LPTSIZ
; LPTSIZ:
	DB	OFFSET LPTLEN	;DEFAULT LINE PRINTER WIDTH
PUBLIC	DAYSPM
; DAYSPM:
	DB	31D,28D,31D,30D,31D,30D
	DB	31D,31D,30D,31D,30D,31D
	NCMPOS=(((LINLN/CLMWID)-1)*CLMWID)	;POSITION BEYOND WHICH THERE ARE
				;NO MORE COMMA FIELDS
; CLMLST:
	DB	OFFSET NCMPOS	;POSITION OF LAST COMMA COLUMN
PUBLIC	RUBSW
; RUBSW:
	DB	0		;RUBOUT SWITCH =1 INSIDE
				;THE PROCESSING OF A RUBOUT (INLIN)
PUBLIC	CNTOFL
; CNTOFL:
	DB	0		;SUPRESS OUTPUT FLAG
				;NON-ZERO MEANS SUPRESS
				;RESET BY "INPUT",READY AND ERRORS
				;COMPLEMENTED BY INPUT OF ^O
PUBLIC	PTRFIL
; PTRFIL:
	DW	0
				;POINTER TO DATA BLOCK OF CURRENT FILE
				;USED BY DISK AND NCR CASSETTE CODE
PUBLIC	TOPMEM
; TOPMEM:
	ADR	TSTACK+100	;TOP LOCATION TO USE FOR THE STACK
				;INITIALLY SET UP BY INIT
				;ACCORDING TO MEMORY SIZE
				;TO ALLOW FOR 50 BYTES OF STRING SPACE.
				;CHANGED BY A CLEAR COMMAND WITH
				;AN ARGUMENT.
PUBLIC	CURLIN
; CURLIN:
	ADR	0+65534D	;CURRENT LINE #
				;SET TO 65534 IN PURE VERSION DURING INIT EXECUTION
				;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE
PUBLIC	TXTTAB
; TXTTAB:
	ADR	TSTACK+1	;POINTER TO BEGINNING OF TEXT
				;DOESN'T CHANGE AFTER BEING
				;SETUP BY INIT.
PUBLIC	OVERRI
; OVERRI:
	ADR	OVRMSG		;ADDRESS OF MESSAGE TO PRINT (OVERFLOW)
PUBLIC	CSRTYP
; CSRTYP:
	DB	0		;Type of next cursor
PUBLIC	CSRFLG
; CSRFLG:
	DB	0		;Type of current cursor
;
;Generalized I/O initialized data definitions
;
; EXTERN        .DVTBL, .DVPTR, .DVINI, .DVTRM
; INTERNs and EXTERNs moved out of the PHASE block for ASM86 translator.
; 9/2/82/NGT

PUBLIC	DEVTBL
; DEVTBL:
	ADR	_DVTBL		;points to array of device names
PUBLIC	DEVPTR
; DEVPTR:
	ADR	_DVPTR		;points to array of device dispatch tables
PUBLIC	DEVINI
; DEVINI:
	ADR	_DVINI		;points to array of device initalize routines
PUBLIC	DEVTRM
; DEVTRM:
	ADR	_DVTRM		;points to array of device termination routines
PUBLIC	SAVKEY
; SAVKEY:
	DB	0		;for saving 2nd byte of 2-byte seq.
PUBLIC	SAVKYF
; SAVKYF:
	DB	0		;Flag nonzero when SAVKEY is active (SAVKEY may be 0)
PUBLIC	FREFDB
; FREFDB:
	DW	0		;Used by Device Open Routines to release FDB
				;if error occurs after FDB is allocated but
				;before File actually becomes OPEN.
				;FDB is Freed by routine FINPRT.
	DATSTR=$
;
; ======== Data Phase ========
;
DSEG	SEGMENT PUBLIC 'DATASG'
	ORG	0+400O
	RAMLOW=$		;WHERE CONSTANTS GET DEPOSITED
	INS86	352		;INTER-SEGMENT DIRECT JUMP
	DB	4 DUP(?)
;
;THE FOLLOWING IS THE LAST RANDOM NUMBER GENERATED BY RND
;IT MUST NOT BE ZERO, IT MUST BE BETWEEN 0 AND 1.
;

	.RADIX	8

	DB	1 DUP (?)
RNDCNT	LABEL WORD
	DB	1 DUP (?)
	DB	1 DUP (?)
	RET			;THIS IS A KLUDGE TO MAKE CHRGET WORK
PUBLIC	NUMCON
NUMCON	LABEL WORD
	DB	1 DUP (?)	;THESE FAKE TOKENS FORCE CHRGET
	DB	1 DUP (?)	;TO EFFECTIVELY RE-SCAN THE EMBEDED CONSTANT
PUBLIC	DSEGZ
DSEGZ	LABEL WORD
	DB	1 DUP (?)	;DATA SEGMENT-LOCATED ZERO
PUBLIC	RNDCOP
RNDCOP	LABEL WORD
	DB	1 DUP (?)	;COPY OF THE RANDOM NUMBER SEED
	DB	1 DUP (?)	;BETWEEN 0 AND 1
	DB	1 DUP (?)
	DB	1 DUP (?)
PUBLIC	$RNDX
$RNDX	LABEL WORD
PUBLIC	RNDX
RNDX	LABEL WORD
	DB	1 DUP (?)	;LAST RANDOM NUMBER GENERATED
	DB	1 DUP (?)	;BETWEEN 0 AND 1
	DB	1 DUP (?)
	DB	1 DUP (?)
	.RADIX	10
STAINP	LABEL WORD
	IN	AL,0
	INS86	313		;"LONG" RETURN
PUBLIC	ENDPRG
ENDPRG	LABEL WORD
	DB	1 DUP (?)
	DB	4 DUP (?)	;FAKE END OF PROGRAM FOR RESUME NEXT
	PAGE

	SUBTTL LOW SEGMENT -- RAM-- IE THIS STUFF IS NOT CONSTANT
;
; THIS IS THE "VOLATILE" STORAGE AREA AND NONE OF IT
; CAN BE KEPT IN ROM. ANY CONSTANTS IN THIS AREA CANNOT
; BE KEPT IN A ROM, BUT MUST BE LOADED IN BY THE
; PROGRAM INSTRUCTIONS IN ROM.
;

PUBLIC	USRTAB
USRTAB	LABEL WORD
REPT	10
	DW	1 DUP (?)
ENDM
PUBLIC	NULCNT
NULCNT	LABEL WORD
	DB	1 DUP (?)	;STORE HERE THE NUMBER OF NULLS
				;TO PRINT AFTER CRLF
PUBLIC	MSDCCF
MSDCCF	LABEL WORD
	DB	1 DUP (?)	;Ctl-C flag set by Ctl-C int handler
PUBLIC	CTLCAD
CTLCAD	LABEL WORD
	DB	4 DUP(?)	;Store pre-BASIC CTL-C int vector
PUBLIC	DINTAD
DINTAD	LABEL WORD
	DB	4 DUP(?)	;Store BASIC Disk error int vector
PUBLIC	LSTCHR
LSTCHR	LABEL WORD
	DB	1 DUP (?)	;used by SCNSOT to remember last chr out
PUBLIC	ERRFLG
ERRFLG	LABEL WORD
	DB	1 DUP (?)	;USED TO SAVE THE ERROR NUMBER
				; SO EDIT CAN BE CALLED ON "SN" ERR.
PUBLIC	LPTLST
LPTLST	LABEL WORD
	DB	1 DUP (?)	;LAST LINE PRINTER OPERATION. ZERO
				;MEANS LINEFEED. NON-ZERO MEANS PRINT
				;COMMAND (OKIA ONLY)
PUBLIC	LPTPOS
LPTPOS	LABEL WORD
	DB	1 DUP (?)	;POSITION OF LPT PRINT HEAD -initially 0
PUBLIC	PRTFLG
PRTFLG	LABEL WORD
	DB	1 DUP (?)	;WHETHER OUTPUT GOES TO LPT
	LNCMPS=(((LPTLEN/CLMWID)-1)*CLMWID)	;LAST COMMA FIELD POSIT
PUBLIC	NLPPOS
NLPPOS	LABEL WORD
	DB	1 DUP (?)	;LAST COL # BEYOND WHICH NO MORE COMMA FIELDS
PUBLIC	LPTSIZ
LPTSIZ	LABEL WORD
	DB	1 DUP (?)	;DEFAULT LINE PRINTER WIDTH
PUBLIC	DAYSPM
DAYSPM	LABEL WORD
	DB	6 DUP (?)
	DB	6 DUP (?)
	NCMPOS=(((LINLN/CLMWID)-1)*CLMWID)	;POSITION BEYOND WHICH THERE ARE
				;NO MORE COMMA FIELDS
CLMLST	LABEL WORD
	DB	1 DUP (?)	;POSITION OF LAST COMMA COLUMN
PUBLIC	RUBSW
RUBSW	LABEL WORD
	DB	1 DUP (?)	;RUBOUT SWITCH =1 INSIDE
				;THE PROCESSING OF A RUBOUT (INLIN)
PUBLIC	CNTOFL
CNTOFL	LABEL WORD
	DB	1 DUP (?)	;SUPRESS OUTPUT FLAG
				;NON-ZERO MEANS SUPRESS
				;RESET BY "INPUT",READY AND ERRORS
				;COMPLEMENTED BY INPUT OF ^O
PUBLIC	PTRFIL
PTRFIL	LABEL WORD
	DW	1 DUP (?)
				;POINTER TO DATA BLOCK OF CURRENT FILE
				;USED BY DISK AND NCR CASSETTE CODE
PUBLIC	TOPMEM
TOPMEM	LABEL WORD
	ADR	TSTACK+100	;TOP LOCATION TO USE FOR THE STACK
				;INITIALLY SET UP BY INIT
				;ACCORDING TO MEMORY SIZE
				;TO ALLOW FOR 50 BYTES OF STRING SPACE.
				;CHANGED BY A CLEAR COMMAND WITH
				;AN ARGUMENT.
PUBLIC	CURLIN
CURLIN	LABEL WORD
	ADR	0+65534D	;CURRENT LINE #
				;SET TO 65534 IN PURE VERSION DURING INIT EXECUTION
				;SET TO 65535 WHEN DIRECT STATEMENTS EXECUTE
PUBLIC	TXTTAB
TXTTAB	LABEL WORD
	ADR	TSTACK+1	;POINTER TO BEGINNING OF TEXT
				;DOESN'T CHANGE AFTER BEING
				;SETUP BY INIT.
PUBLIC	OVERRI
OVERRI	LABEL WORD
	ADR	OVRMSG		;ADDRESS OF MESSAGE TO PRINT (OVERFLOW)
PUBLIC	CSRTYP
CSRTYP	LABEL WORD
	DB	1 DUP (?)	;Type of next cursor
PUBLIC	CSRFLG
CSRFLG	LABEL WORD
	DB	1 DUP (?)	;Type of current cursor
;
;Generalized I/O initialized data definitions
;
; EXTERN        .DVTBL, .DVPTR, .DVINI, .DVTRM
; INTERNs and EXTERNs moved out of the PHASE block for ASM86 translator.
; 9/2/82/NGT

PUBLIC	DEVTBL
DEVTBL	LABEL WORD
	ADR	_DVTBL		;points to array of device names
PUBLIC	DEVPTR
DEVPTR	LABEL WORD
	ADR	_DVPTR		;points to array of device dispatch tables
PUBLIC	DEVINI
DEVINI	LABEL WORD
	ADR	_DVINI		;points to array of device initalize routines
PUBLIC	DEVTRM
DEVTRM	LABEL WORD
	ADR	_DVTRM		;points to array of device termination routines
PUBLIC	SAVKEY
SAVKEY	LABEL WORD
	DB	1 DUP (?)	;for saving 2nd byte of 2-byte seq.
PUBLIC	SAVKYF
SAVKYF	LABEL WORD
	DB	1 DUP (?)	;Flag nonzero when SAVKEY is active (SAVKEY may be 0)
PUBLIC	FREFDB
FREFDB	LABEL WORD
	DW	1 DUP (?)	;Used by Device Open Routines to release FDB
				;if error occurs after FDB is allocated but
				;before File actually becomes OPEN.
				;FDB is Freed by routine FINPRT.
	DATSTR=$
DSEG	ENDS
;
;========== End of Phase ==========
;
	ENDCNS=$
DSEG	SEGMENT PUBLIC 'DATASG'		;Start the data segment
;
;
;GIO86 uninitialized data definitions:
;
PUBLIC	FILDEV
	FILDEV=FILNAM
PUBLIC	FILNM
	FILNM=FILNAM+1
PUBLIC	FILEXT
	FILEXT=FILNM+FNAML-3
PUBLIC	IOJUMP
IOJUMP	LABEL WORD
	DB	2 DUP(?)
PUBLIC	FILTAB
FILTAB	LABEL WORD
	DB	2 DUP(?)	;points to 1st FDB (=STKLOW if no FDB's)
PUBLIC	STKLOW
STKLOW	LABEL WORD
	DB	2 DUP(?)	;lowest legal value of [SP]
PUBLIC	FILMOD
FILMOD	LABEL WORD
	DB	1 DUP(?)
PUBLIC	NLONLY
NLONLY	LABEL WORD
	DB	1 DUP(?)
PUBLIC	RUNFLG
RUNFLG	LABEL WORD
	DB	1 DUP(?)

F_PCOM	LABEL WORD
	DB	1 DUP(?)	;Flags comma terminator for number print
PUBLIC	DATIME
DATIME	LABEL WORD
	DB	5 DUP(?)	;days(2), hours(1), minutes(1), secs(1)
PUBLIC	CPMEXT
CPMEXT	LABEL WORD
	DB	4 DUP(?)	;Exit jump vector.  Set to DS:0 at INIT.
				;MSDOS 2.0 exit must be made through the
				;initialization segment prefix - not at CS:0
				;for .EXE files.
PUBLIC	NAMCNT
NAMCNT	LABEL WORD
	DB	1 DUP(?)	;THE NUMBER OF CHARACTER BEYOND #2 IN A VAR NAME
PUBLIC	NAMBUF
NAMBUF	LABEL WORD
	DB	NAMLEN-2 DUP(?)	;STORAGE FOR CHARS BEYOND #2. USED IN PTRGET
PUBLIC	NAMTMP
NAMTMP	LABEL WORD
	DB	2 DUP(?)	;TEMP STORAGE DURING NAME SAVE AT INDLOP
PUBLIC	DIRTMP
	DIRTMP=CPMWRM+128	;USE CPM DEFAULT BUFFER IN LOW MEMORY
PUBLIC	FILNA2
FILNA2	LABEL WORD
	DB	16 DUP(?)	;USED BY NAME CODE
	DB	17 DUP(?)	;this is used for FILES in SCP version
PUBLIC	FILNAM
FILNAM	LABEL WORD
	DB	33 DUP(?)	;BECAUSE CPM MUST HAVE BUFFER FOR DIRECTORY READS
;
;       CP/M 1.4 and 2.x Support
;

PUBLIC	CPMVRN
CPMVRN	LABEL WORD
	DB	1 DUP(?)	;CP/M Version Number (#0 is 2.x)
PUBLIC	CPMREA
CPMREA	LABEL WORD
	DB	1 DUP(?)	;CP/M Read Call
PUBLIC	CPMWRI
CPMWRI	LABEL WORD
	DB	1 DUP(?)	;CP/M Write Call
	DB	":"		;a colon for restarting input
PUBLIC	KBUF
KBUF	LABEL WORD
	DB	KBFLEN DUP(?)	;THIS IS THE KRUNCH BUFFER
PUBLIC	BUFMIN
BUFMIN	LABEL WORD
	DB	44		;A COMMA (PRELOAD OR ROM)
				;USED BY INPUT STATEMENT SINCE THE
				;DATA POINTER ALWAYS STARTS ON A
				;COMMA OR TERMINATOR
PUBLIC	BUF
BUF	LABEL WORD
	DB	BUFLEN+1 DUP(?)	;TYPE IN STORED HERE
				;DIRECT STATEMENTS EXECUTE OUT OF
				;HERE. REMEMBER "INPUT" SMASHES BUF.
				;MUST BE AT A LOWER ADDRESS
				;THAN DSCTMP OR ASSIGNMENT OF STRING
				;VALUES IN DIRECT STATEMENTS WON'T COPY
				;INTO STRING SPACE -- WHICH IT MUST
	DB	2 DUP(?)	;ALLOW FOR SINGLE QUOTE IN BIG LINE
PUBLIC	ENDBUF
ENDBUF	LABEL WORD
	DB	1 DUP(?)	;PLACE TO STOP BIG LINES

PUBLIC	TTYPOS
TTYPOS	LABEL WORD
	DB	1 DUP(?)	;STORE TERMINAL POSITION HERE
PUBLIC	DIMFLG
DIMFLG	LABEL WORD
	DB	1 DUP(?)	;IN GETTING A POINTER TO A VARIABLE
				;IT IS IMPORTANT TO REMEMBER WHETHER IT
				;IS BEING DONE FOR "DIM" OR NOT
				;DIMFLG AND VALTYP MUST BE
				;CONSECUTIVE LOCATIONS
PUBLIC	$VALTP
$VALTP	LABEL WORD
PUBLIC	VALTYP
VALTYP	LABEL WORD
	DB	1 DUP(?)	;THE TYPE INDICATOR
				;IN THE 8K 0=NUMERIC 1=STRING
PUBLIC	OPRTYP
OPRTYP	LABEL WORD		;USED TO STORE OPERATOR NUMBER
				;IN THE EXTENDED MOMENTARILY BEFORE
				;OPERATOR APPLICATION (APPLOP)
PUBLIC	DORES
DORES	LABEL WORD
	DB	1 DUP(?)	;WHETHER CAN OR CAN'T CRUNCH RES'D WORDS
				;TURNED ON IN THE 8K WHEN "DATA"
				;BEING SCANNED BY CRUNCH SO UNQUOTED
				;STRINGS WON'T BE CRUNCHED.
PUBLIC	DONUM
DONUM	LABEL WORD
	DB	1 DUP(?)	;FLAG FOR CRUNCH =0 MEANS
				;NUMBERS ALLOWED, (FLOATING,INT, DBL)
				;1 MEANS NUMBERS ALLOWED, KRUNCH BY CALLING LINGET
				;-1 (377) MEANS NUMBERS DISALLOWED
				;(SCANNING VARIABLE NAME)
PUBLIC	CONTXT
CONTXT	LABEL WORD
	DB	2 DUP(?)	;SAVED TEXT POINTER USED BY CHRGET
				;TO SAVE THE TEXT POINTER AFTER CONSTANT
				;HAS BEEN SCANNED.
PUBLIC	CONSAV
CONSAV	LABEL WORD
	DB	1 DUP(?)	;THE SAVED TOKEN FOR A CONSTANT
				;AFTER CHRGET HAS BEEN CALLED
PUBLIC	CONTYP
CONTYP	LABEL WORD
	DB	1 DUP(?)	;SAVED CONSTANT VALTYPE
PUBLIC	CONLO
CONLO	LABEL WORD
	DB	4 DUP(?)	;SAVED CONSTANT VALUE
	DB	4 DUP(?)	;EXTRA 4 BYTES FOR DBL PRECISION


PUBLIC	MAXMEM
MAXMEM	LABEL WORD
	DB	2 DUP(?)	;Maximum size of BASIC's Data Segment
PUBLIC	MEMSIZ
MEMSIZ	LABEL WORD
	DB	2 DUP(?)	;HIGHEST LOCATION IN MEMORY
PUBLIC	TEMPPT
TEMPPT	LABEL WORD
	DB	2 DUP(?)	;POINTER AT FIRST FREE TEMP DESCRIPTOR
				;INITIALIZED TO POINT TO TEMPST
PUBLIC	TEMPST
TEMPST	LABEL WORD
	DB	STRSIZ*NUMTMP DUP(?)	;STORAGE FOR NUMTMP TEMP DESCRIPTORS
PUBLIC	DSCTMP
DSCTMP	LABEL WORD
	DB	STRSIZ DUP(?)	;STRING FUNCTIONS BUILD ANSWER DESCRIPTOR HERE
				;MUST BE AFTER TEMPST AND BEFORE PARM1
PUBLIC	DSCPTR
	DSCPTR=$-2		;WHERE STRING ADDRESS IS STORE IN DSCTMP
PUBLIC	FRETOP
FRETOP	LABEL WORD
	DB	2 DUP(?)	;TOP OF STRING FREE SPACE
PUBLIC	TEMP3
TEMP3	LABEL WORD
	DB	2 DUP(?)	;USED TO STORE THE ADDRESS OF THE END OF
				;STRING ARRAYS IN GARBAGE COLLECTION
				;AND USED MOMENTARILY BY FRMEVL
				;USED IN EXTENDED BY FOUT AND
				;USER DEFINED FUNCTIONS
				;ARRAY VARIABLE HANDLING TEMPORARY
PUBLIC	TEMP8
TEMP8	LABEL WORD
	DB	2 DUP(?)	;7/3/79 Now used by garbage collection
				;not TEMP3 due to conflict
PUBLIC	ENDFOR
ENDFOR	LABEL WORD
	DB	2 DUP(?)	;SAVED TEXT POINTER AT END OF "FOR" STATEMENT
PUBLIC	DATLIN
DATLIN	LABEL WORD
	DB	2 DUP(?)	;DATA LINE # -- REMEMBER FOR ERRORS
PUBLIC	SUBFLG
SUBFLG	LABEL WORD
	DB	1 DUP(?)	;FLAG WHETHER SUBSCRIPTED VARIABLE ALLOWED
				;"FOR" AND USER-DEFINED FUNCTION
				;POINTER FETCHING TURN
				;THIS ON BEFORE CALLING PTRGET
				;SO ARRAYS WON'T BE DETECTED.
				;STKINI AND PTRGET CLEAR IT.
PUBLIC	SARYFL
SARYFL	LABEL WORD
	DB	1 DUP(?)	;SCANED-ARRAY-FLAG: SET BY PTRGET WHEN
				;IT SCANS AN ARRAY ELEMENT.  TESTED BY
				;CALL86 SO UNDEFINED SCALERS WON'T
				;BE PERMITED AFTER ARRAY REFERENCES
				;IN CALL PARAMETER LIST.
PUBLIC	USFLG
USFLG	LABEL WORD
PUBLIC	FLGINP
FLGINP	LABEL WORD
	DB	1 DUP(?)	;FLAGS WHETHER WE ARE DOING "INPUT"
				;OR A READ
PUBLIC	TEMP
TEMP	LABEL WORD
	DB	2 DUP(?)	;TEMPORARY FOR STATEMENT CODE
				;NEWSTT SAVES [H,L] HERE FOR INPUT AND ^C
				;"LET" SAVES VARIABLE
				;POINTERS HERE FOR "FOR"
				;"NEXT" SAVES ITS TEXT POINTER HERE
				;CLEARC SAVES [H,L] HERE
PUBLIC	PTRFLG
PTRFLG	LABEL WORD
	DB	1 DUP(?)	;=0 IF NO LINE NUMBERS CONVERTED
				;TO POINTERS, NON ZERO IF POINTERS EXIST
PUBLIC	AUTFLG
AUTFLG	LABEL WORD
	DB	1 DUP(?)	;FLAG TO INICATE AUTO COMMAND IN
				;PROGRESS =0 IF NOT, NON-ZERO IF SO.
PUBLIC	AUTLIN
AUTLIN	LABEL WORD
	DB	2 DUP(?)	;CURRENT LINE BEING INSERTED BY AUTO
PUBLIC	AUTINC
AUTINC	LABEL WORD
	DB	2 DUP(?)	;THE AUTO INCREMENT
PUBLIC	SAVTXT
SAVTXT	LABEL WORD
	DB	2 DUP(?)	;PLACE WHERE NEWSTT SAVES TEXT POINTER
				;FOR "RESUME" STATEMENT
PUBLIC	SAVSTK
SAVSTK	LABEL WORD
	DB	2 DUP(?)	;NEWSTT SAVES STACK HERE BEFORE
				;SO THAT ERROR RECOVERY CAN
				;RESTORE THE STACK WHEN AN
				;ERROR OCCURS
PUBLIC	ERRLIN
ERRLIN	LABEL WORD
	DB	2 DUP(?)	;LINE NUMBER WHERE LAST ERROR OCCURED.

PUBLIC	DOT
DOT	LABEL WORD
	DB	2 DUP(?)	;KEEPS CURRENT LINE FOR EDIT & LIST
PUBLIC	ERRTXT
ERRTXT	LABEL WORD
	DB	2 DUP(?)	;TEXT POINTER FOR USE BY "RESUME"
PUBLIC	ONELIN
ONELIN	LABEL WORD
	DB	2 DUP(?)	;THE LINE TO GOTO WHEN AN ERROR
				;OCCURS
PUBLIC	ONEFLG
ONEFLG	LABEL WORD
	DB	1 DUP(?)	;ONEFLG=1 IF WERE ARE EXECUTING
				;AN ERROR TRAP ROUTINE, OTHERWISE 0
PUBLIC	SAVSEG
SAVSEG	LABEL WORD
	DB	2 DUP(?)	;SEGMENT Number Save Area.
PUBLIC	$DPADR
$DPADR	LABEL WORD
PUBLIC	TEMP2
TEMP2	LABEL WORD
	DB	2 DUP(?)	;FORMULA EVALUATOR TEMP
				;MUST BE PRESERVED BY OPERATORS
				;USED IN EXTENDED BY FOUT AND
				;USER-DEFINED FUNCTIONS
				;ARRAY VARIABLE HANDLER TEMPORARY
PUBLIC	OLDLIN
OLDLIN	LABEL WORD
	DB	2 DUP(?)	;OLD LINE NUMBER (SETUP BY ^C,"STOP"
				;OR "END" IN A PROGRAM)
PUBLIC	OLDTXT
OLDTXT	LABEL WORD
	DB	2 DUP(?)	;OLD TEXT POINTER
				;POINTS AT STATEMENT TO BE EXECUTED NEXT
PUBLIC	VARTAB
VARTAB	LABEL WORD
	DB	2 DUP(?)	;POINTER TO START OF SIMPLE
				;VARIABLE SPACE
				;UPDATED WHENEVER THE SIZE OF THE
				;PROGRAM CHANGES, SET TO [TXTTAB]+2
				;BY SCRATCH ("NEW").
PUBLIC	ARYTAB
ARYTAB	LABEL WORD
	DB	2 DUP(?)	;POINTER TO BEGINNING OF ARRAY
				;TABLE
				;INCREMENTED BY 6 WHENEVER
				;A NEW SIMPLE VARIABLE IS FOUND, AND
				;SET TO [VARTAB] BY CLEARC.
PUBLIC	STREND
STREND	LABEL WORD
	DB	2 DUP(?)	;END OF STORAGE IN USE
				;INCREASED WHENEVER A NEW ARRAY
				;OR SIMPLE VARIABLE IS ENCOUNTERED
				;SET TO [VARTAB] BY CLEARC.
PUBLIC	DATPTR
DATPTR	LABEL WORD
	DB	2 DUP(?)	;POINTER TO DATA. INITIALIZED TO POINT
				;AT THE ZERO IN FRONT OF [TXTTAB]
				;BY "RESTORE" WHICH IS CALLED BY CLEARC
				;UPDATED BY EXECUTION OF A "READ"
PUBLIC	DEFTBL
DEFTBL	LABEL WORD
	DB	26 DUP(?)	;THIS GIVES THE DEFAULT VALTYP FOR EACH
				;LETTER OF THE ALPHABET
				;IT IS SET UP BY "CLEAR" AND CHANGED BY
				;"DEFSTR" "DEFINT" "DEFSNG" "DEFDBL" AND USED
				;BY PTRGET WHEN ! # % OR $ DON'T FOLLOW
				;A VARAIBLE NAME
;
; RAM STORAGE FOR USER DEFINED FUNCTION PARAMETER INFORMATION
;
	PUBLIC	PRMLEN,PRMLN2,PRMFLG,NOFUNS,PARM1,TEMP9,FUNACT
PUBLIC	PRMSIZ
	PRMSIZ=100D		;NUMBER OF BYTES FOR DEFINITION BLOCK
PRMSTK	LABEL WORD
	DB	2 DUP(?)	;PREVIOUS DEFINITION BLOCK ON STACK
				;BLOCK (FOR GARBAGE COLLECTION)
PRMLEN	LABEL WORD
	DB	2 DUP(?)	;THE NUMBER OF BYTES IN THE ACTIVE TABLE
PARM1	LABEL WORD
	DB	PRMSIZ DUP(?)	;THE ACTIVE PARAMETER DEFINITION TABLE
	PUBLIC	PRMPRV,PRMSTK	;ALLOW INIT TO INITIALIZE THIS CONSTANT
PRMPRV	LABEL WORD
	DB	2 DUP(?)	;INIIALLY PRMSTK,THE POINTER AT THE PREVIOUS PARAMETER
				;BLOCK (FOR GARBAGE COLLECTION)
PRMLN2	LABEL WORD
	DB	2 DUP(?)	;SIZE OF PARAMETER BLOCK BEING BUILT
PUBLIC	PARM2
PARM2	LABEL WORD
	DB	PRMSIZ DUP(?)	;PLACE TO KEEP PARAMETERS BEING MADE
PRMFLG	LABEL WORD
	DB	1 DUP(?)	;USED BY PTRGET TO FLAG IF PARM1 HAS BEEN SEARCHED
PUBLIC	ARYTA2
ARYTA2	LABEL WORD
	DB	2 DUP(?)	;STOPPING POINT FOR SIMPLE SEARCH
				;(EITHER [ARYTAB] OR PARM1+[PRMLEN])
NOFUNS	LABEL WORD
	DB	1 DUP(?)	;ZERO IF NO FUNCTIONS ACTIVE. SAVES TIME IN SIMPLE SEARCH
TEMP9	LABEL WORD
	DB	2 DUP(?)	;GARBAGE COLLECTION TEMP TO CHAIN THROUGH PARAMETER BLOCKS
FUNACT	LABEL WORD
	DB	2 DUP(?)	;COUNT OF ACTIVE FUNCTIONS
PUBLIC	INPPAS
INPPAS	LABEL WORD
	DB	1 DUP(?)	;FLAG TELLING WHETHER INPUT IS SCANNING FIRST OR
				;SECOND TIME. ZERO IF FIRST.
PUBLIC	NXTTXT
NXTTXT	LABEL WORD
	DB	2 DUP(?)	;USED TO SAVE TEXT POINTER AT START OF NEXT
PUBLIC	NXTFLG
NXTFLG	LABEL WORD
	DB	1 DUP(?)	;ZERO IF "FOR" IS USING NEXT CODE
				;TO CHECK FOR EMPTY LOOP
PUBLIC	FVALSV
FVALSV	LABEL WORD
	DB	4 DUP(?)	;USE TO STORE THE START VALUE OF THE LOOP VARIABLE
				;SINCE ANSI SAYS START AND END ARE EVALUATED
				;BEFORE ASSIGNMENT TAKES PLACE.
PUBLIC	NXTLIN
NXTLIN	LABEL WORD
	DB	2 DUP(?)	;THE LINE NUMBER DURING SCAN FOR "NEXT"
PUBLIC	OPTVAL
OPTVAL	LABEL WORD
	DB	1 DUP(?)	;ZERO FOR OPTION BASE 0 ONE FOR OPTION BASE 1
PUBLIC	OPTFLG
OPTFLG	LABEL WORD
	DB	1 DUP(?)	;NON-ZERO IF "OPTION BASE" HAS BEEN SCANNED
PUBLIC	TOPTVL
TOPTVL	LABEL WORD
	DB	1 DUP(?)	;temp- holds OPTVAL during Chain
PUBLIC	TOPTFG
TOPTFG	LABEL WORD
	DB	1 DUP(?)	;temp- holds OPTFLG during Chain
PUBLIC	TEMPA
TEMPA	LABEL WORD
	DB	2 DUP(?)	;MISC TEMP USED BY CALL AND LIST
PUBLIC	SAVFRE
SAVFRE	LABEL WORD
	DB	2 DUP(?)	;FRETOP SAVED HERE BY CHAIN
PUBLIC	PROFLG
PROFLG	LABEL WORD
	DB	1 DUP(?)	;NON-ZERO IF WE HAVE LOADED A PROTECTED FILE W/O PASSWRD
PUBLIC	MRGFLG
MRGFLG	LABEL WORD
	DB	1 DUP(?)	;NON-ZERO IF CHAIN W/ MERGE IN PROGRESS
PUBLIC	MDLFLG
MDLFLG	LABEL WORD
	DB	1 DUP(?)	;NON-ZERO I CHAIN W/ MERGE AND DELETE IN PROGRESS
PUBLIC	CMEPTR
CMEPTR	LABEL WORD
	DB	2 DUP(?)	;POINTER TO END LINE TO DELETE
PUBLIC	CMSPTR
CMSPTR	LABEL WORD
	DB	2 DUP(?)	;POINTER TO START LINE TO DELETE
PUBLIC	CHNFLG
CHNFLG	LABEL WORD
	DB	1 DUP(?)	;NON-ZERO IF CHAIN IN PROGRESS
PUBLIC	CHNLIN
CHNLIN	LABEL WORD
	DB	2 DUP(?)	;DESTINATION LINE IN NEW PROGRAM
PUBLIC	SWPTMP
SWPTMP	LABEL WORD
	DB	4 DUP(?)	;VALUE OF FIRST "SWAP" VARIABLE STORED HERE
	DB	4 DUP(?)	;ENOUGH ROOM FOR DBL PRECISION
PUBLIC	TRCFLG
TRCFLG	LABEL WORD
	DB	1 DUP(?)	;ZERO MEANS NO TRACE IN PROGRESS

;-------------------------------------------------------------
; THIS IS THE RAM TEMPORARY AREA FOR THE MATH PACKAGE ROUTINES
;-------------------------------------------------------------
PUBLIC	EXPAF
EXPAF	LABEL WORD
	DB	1 DUP(?)	;Exponent adjustment factor
				;used during E format to adjust exp
				;if field overflow occurs
PUBLIC	EXPTMP
EXPTMP	LABEL WORD
	DB	8 DUP(?)	;Temp FAC save area used while
				;testing FAC for field overflow
				;of E formated output
PUBLIC	TEMPB
TEMPB	LABEL WORD		;Used by FIELD
PUBLIC	RECRD
RECRD	LABEL WORD
	DB	2 DUP(?)	;Record #
PUBLIC	LBUFF
LBUFF	LABEL WORD
	DB	2 DUP(?)	;Logical buffer address
PUBLIC	PBUFF
PBUFF	LABEL WORD
	DB	2 DUP(?)	;Physical buffer address
PUBLIC	PGTFLG
PGTFLG	LABEL WORD
	DB	1 DUP(?)	;PUT/GET flag (Non zero=PUT)
	DB	1 DUP(?)	;DOUBLE PRECISION BUFFER
PUBLIC	$DBUFF
$DBUFF	LABEL WORD
	DB	9 DUP(?)
PUBLIC	$FMTCX
$FMTCX	LABEL WORD
	DB	2 DUP(?)
PUBLIC	$FMTAX
$FMTAX	LABEL WORD
PUBLIC	$FMTAL
$FMTAL	LABEL WORD
	DB	2 DUP(?)
	DB	1 DUP(?)
PUBLIC	$ZLO
$ZLO	LABEL WORD
	DB	0
	DB	6 DUP(?)
PUBLIC	$ZX
$ZX	LABEL WORD
	DB	0
PUBLIC	$Z1LO
$Z1LO	LABEL WORD
	DB	7 DUP(?)
PUBLIC	$Z1
$Z1	LABEL WORD
	DB	0
	.RADIX	10
;
;THE FLOATING ACCUMULATOR
;
	DB	1 DUP(?)	;[TEMPORARY LEAST SIGNIFICANT BYTE]
	DB	8 DUP(?)	;EXTRA STORAGE FOR D.P. MULTIPLY
PUBLIC	$DFACL
$DFACL	LABEL WORD
PUBLIC	DFACLO
DFACLO	LABEL WORD
	DB	4 DUP(?)	;FOUR LOWEST ORDERS FOR DOUBLE PRECISION
PUBLIC	$FACLO
$FACLO	LABEL WORD
PUBLIC	FACLO
FACLO	LABEL WORD
	DB	2 DUP(?)
PUBLIC	$FACM1
$FACM1	LABEL WORD
	DB	1 DUP(?)
				;[MIDDLE ORDER OF MANTISSA]
				;[HIGH ORDER OF MANTISSA]
PUBLIC	$FAC
$FAC	LABEL WORD
PUBLIC	FAC
FAC	LABEL WORD
	DB	2 DUP(?)	;[EXPONENT]
				;[TEMPORARY COMPLEMENT OF SIGN IN MSB]
PUBLIC	$FLGOV
$FLGOV	LABEL WORD
PUBLIC	FLGOVC
FLGOVC	LABEL WORD
	DB	1 DUP(?)	;OVERFLOW PRINT FLAG,=0,1 PRINT
				;FURTHER =1 CHANGE TO 2
PUBLIC	OVCSTR
OVCSTR	LABEL WORD
	DB	1 DUP(?)	;PLACE TO STORE OVERFLOW FLAG AFTER FIN
PUBLIC	FLGSCN
FLGSCN	LABEL WORD
	DB	1 DUP(?)	;FLAGS INPUT CODE EXECUTING FOR SCNVAL
	DB	1 DUP(?)	;[TEMPORARY LEAST SIGNIFICANT BYTE]
PUBLIC	$ARGLO
$ARGLO	LABEL WORD
PUBLIC	ARGLO
ARGLO	LABEL WORD
	DB	7 DUP(?)	;[LOCATION OF SECOND ARGUMENT FOR DOUBLE
				; PRECISION]
PUBLIC	$ARG
$ARG	LABEL WORD
PUBLIC	ARG
ARG	LABEL WORD
	DB	1 DUP(?)
PUBLIC	$FBUFF
$FBUFF	LABEL WORD
PUBLIC	FBUFFR
FBUFFR	LABEL WORD
	DB	13 DUP(?)	;BUFFER FOR FOUT
	DB	43-13 DUP(?)	;THE LAST 3 LOCATIONS ARE TEMP FOR ROM FMULT
PUBLIC	FMLTT1
	FMLTT1=FBUFFR+40
PUBLIC	FMLTT2
	FMLTT2=FBUFFR+41


	PUBLIC	TSTACK
TSTACK	LABEL WORD

DSEG	ENDS			; End of the data segment

	__RET=0			;SO WE DON'T GET PHASE ERRORS IN 8086 VERSION


	SUBTTL TEXT CONSTANTS FOR PRINT OUT
;
; NEEDED FOR MESSAGES IN ALL VERSIONS
;

PUBLIC	INTXT
INTXT:	DB" in "
	DB	0

PUBLIC	REDDY
REDDY:
	DB"Ok"
	DB	377O		;FLAG AS NOT BEING USER INPUT
	ACRLF
	DB	0

PUBLIC	BRKTXT
BRKTXT:	DB"Break"
	DB	0


;
; The reserve word tables have dispatch address the could be external.
; ASM86 can only output external declarations during pass 1, so we
; have to construct a chain of possible externals and check each one.
; The following macro runs through the chain and declares any undefined
; addresses as external :NEAR.  For more information, see the file
; PS1:<BASIC.ASM86>BINTRP.H
;
	DO_EXT
;
CSEG	ENDS
	END
