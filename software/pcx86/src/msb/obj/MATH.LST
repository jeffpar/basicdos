Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-1
                                                            

                             C  	include	math1.asm 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
 0008                        C  	.RADIX	8		; To be safe 
                             C   
 0000                        C  CSEG	SEGMENT PUBLIC 'CODESG' 
                             C  	ASSUME	CS:CSEG 
                             C   
                             C  INCLUDE OEM.INC 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
                             C  	PAGE	,132D 
                             C  	SUBTTL  Common file to produce 2-segment 8086 GW-CPM BASIC 
                             C   
                             C  	.SALL 
                             C   
 000A                        C  	.RADIX	10 
 = 0000                      C  	OEMRAM=0D 
                             C  ;Pascal program HFILE searches for the following line - DO NOT MODIFY 
                             C  ;** (VERSION SPECIFIC VALUES) ************************************************ 
 = 0019                      C  	NMLINE=25		;Max screen display text lines 
 = 0001                      C  	NBANKS=1		;Number of graphic planes 
 = 0000                      C  	PALSIZ=0		;Size of OEM color palette 
 = 0000                      C  	DBLCHR=0		;Editor support for KANJI chars 
 = 0000                      C  	KANABS=0		;Kana BASIC (Japanese JIS codes) 
 = 0000                      C  	KANJFN=0		;KANJI String Functions KPOS, KLEN .. 
 = 0000                      C  	JISKTN=0		;&K, &J constants (KANJI) 
 = 0001                      C  	SUPRSH=1		;1=super shift key feature 
 = 000A                      C  	NMKEYF=10		;number of function keys 
 = 000E                      C  	NMKEYT=14		;number of function key traps 
 = 0001                      C  	FKEYON=1		;yes=display function keys 
 = 0001                      C  	SCROLT=1		;Line 25 allocated for status only 
 = 0001                      C  	PLAYSW=1		;for PLAY statement 
 = 0001                      C  	BEEPSW=1		;for SOUND, BEEP statements 
 = 0003                      C  	NMLPT=3			;number of line printers 
 = 0001                      C  	CONSSW=1		;Device CONS: 
 = 0002                      C  	NMCOMT=2		;number of COMmunications ports 
 = 0001                      C  	NMPENT=1		;number of light pens 
 = 0004                      C  	NMSTRT=4		;number of joysticks 
 = 0000                      C  	GWCASS=0		;Cassette switch (CSAVE,CLOAD,MOTOR) 
 = 0001                      C  	IBMLIK=1		;IBM compatibility package 
 = 0001                      C  	IBMTOK=1		;IBM token compatibility 
 = 0001                      C  	DYNCOM=1		;Dynamic communication buffers 
                             C  ;** (END OF VERSION SPECIFIC VALUES) ***************************************** 
                             C  ;Pascal program HFILE searches for the previous line - DO NOT MODIFY 
                             C  ; 
 = 0015                      C  	NUMTRP=NMKEYT+NMCOMT+NMPENT+NMSTRT 
 = 0001                      C  	GW=1			;GW BASIC 
 = 0000                      C  	ESCCTL=0		;Escape Sequence processing in SCROUT 
 = 0000                      C  	GWDBUG=0		;DEBUG statement (TEST VERSIONS ONLY) 
                             C  				; Support is in BINTRP.MAC and GWSTS.MAC 
 = 0000                      C  	SIXDIG=0		;# of digits of accuracy assumed when formatting 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-2
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  				;single precision numbers for output. 
                             C  				; 0 := 7 digits 
                             C  				; 1 := 6 digits 
 = 0000                      C  	CASSW=0			;CASSETTE SWITCH 
 = 0001                      C  	LABKEY=1		;^T (LABEL) key capability 
 = 0001                      C  	HGHBIT=1		;8-bit characters (ASCII & Graphics) 
 = 0001                      C  	QUEUE=1			;Queued painting algorithm (vs. stack) 
 = 0001                      C  	GIO86=1			;BASIC-86 Generalized I/O 
 = 0001                      C  	SCRNIO=1		;Screen editor 
 = 0001                      C  	SCRN86=1		;8086 Screen editor 
 = 0001                      C  	I8086=1			;CROSS ASSEMBLING FOR 8086 
 = 0001                      C  	MULSEG=1		;MULTI-SEGMENT 8086 BASIC 
 = 0000                      C  	SMALL=0			;"SMALL" VERSION OF 8086 BASIC IF SET 
 = 0001                      C  	TRUROM=1 
 = 0000                      C  	SBC86=0			;SBC 86/02 BOARD? 
 = 0001                      C  	SHORTJ=1		;USE INTRA-SEGMENT SHORT JUMPS 
                             C  				;IN 8086 CODE 
 = 0001                      C  	LNGVAR=1		;LONG VARIABLE NAME SUPPORT (EXTENDED ONLY) 
 = 0000                      C  	SHTERR=0		;SHORT (2 CHAR) ERROR MESSAGES 
 = 0000                      C  	SHTINS=0		;INSTR IN NON-FAST LEN2 VERSIONS 
 = 0000                      C  	SHTLHM=0		;LEFT HAND SIDE MID IN NON FAST LEN2 VERSIONS 
 = 0000                      C  	SHTCHN=0		;ALLOW CHAIN IN NON-5.0 
 = 0000                      C  	SHTPRO=0		;ALLOW PROTECTED FILES IN NON-FIVDSK 
 = 0000                      C  	SHTLIN=0		;ALLOW LINE INPUT IN NON-EXTENDED NON-FAST 
 = 0000                      C  	SHTREN=0		;ALLOW RENUM IN NON-FST VERSIONS 
 = 0001                      C  	INKEYF=1		;ADDS INKEY$ FUNCTION 
 = 0000                      C  	NOIOS=0			;NO I/O STATMENTS (INP,OUT, WAIT) 
 = 0000                      C  	NOPEKS=0		;NO PEEK, POKE 
 = 0000                      C  	NOUSR=0			;NO USR 
 = 0000                      C  	NOCTLA=0		;NO CONTROL-A IN EXTENDED 
 = 0000                      C  	NORUBT=0		;NO RUBOUT 
 = 0000                      C  	NOROMP=0		;NO ROM PROGRAM FEATURE 
 = 0000                      C  	NOATDL=0		;NO AUTO DELETE IN NON-FAST EXTENDED 
 = 0000                      C  	NODOT=0			;NO DOT IN LEN2 
 = 0000                      C  	NOEDIT=0		;NO EDIT COMMAND 
 = 0000                      C  	CRONLY=0		;ONLY PUT OUT CR, NOT CRLF TO TERMINAL 
                             C  				;AND FILES 
 = 0000                      C  	NONULL=0		;NO NULL COMMAND, PUT OUT NULLS IN CRDO & OUTCH1 
 = 0000                      C  	NOVARP=0		;NO VARPTR FUNCTION 
 = 0001                      C  	FIVEO=1			;GENERATE VERSION WITH RELEASE 5.0 FEATURES 
 = 0001                      C  	FIVMEM=1 
 = 0001                      C  	ANSI=1 
 = 0001                      C  	FIVDSK=1		;5.0 NEW DSK CODE 
 = 0001                      C  	FIVLPT=1		;WIDTH LPRINT AND 255 FEATURE 
 = 0001                      C  	HEXOCT=1		;&H..., HEX$, &O..., OCT$ 
 = 0000                      C  	BINCSW=0		;&B..., BIN$ 
 = 0001                      C  	BLODSW=1		;BLOAD, BSAVE COMMANDS 
 = 0001                      C  	MEMIMG=1		;MEMORY IMAGE FILES 
 = 0001                      C  	GENBIN=1 
                             C   
 = 0000                      C  	TRUANS=0		;TRUE ANSI VERSION (STATIC SCAN, ON ERROR) 
 = 0000                      C  	COMMNT=0		;DONT WANT BIG COMMENT 
 = 0000                      C  	INTEL=0			;INTEL PROPRIETARY 
 = 0000                      C  	INTFSW=0		;INTEL FLOATING POINT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-3
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	INTFHW=0 
 = 0000                      C  	RMX=0			;INTEL RMX VERSION 
 = 0000                      C  	EDIT80=0		;FOR EDIT80 I/O ROUTINES 
 = 0000                      C  	RSHACK=0 
 = 0000                      C  	INTLEC=0 
 = 0002                      C  	LENGTH=2		;  1 MEANS 8K, 2 MEANS 12K 
 = 0000                      C  	BASDEB=0		;WHETHER DBG WILL BE LOADED WITH BASIC 
 = 0001                      C  	RSTLES=1		;WHETHER BASIC WILL USE RST LOCATIONS 
                             C  				;TO MAKE ITSELF SMALLER & QUICKER 
 = 0001                      C  	REALIO=1		;WHETHER SIMULATE (=0) OR ON MACHINE (=1) 
 = 0001                      C  	GENIO=1			;USE G/P ROUTINES 
 = 0001                      C  	CHSEAT=1		;CHSNS eats chars 
 = 0000                      C  	GENDSK=0		;USE G/P DSK CODE 
 = 0000                      C  	LONGI=0			;WHETHER WE ASK "TERMINAL WIDTH?" 
                             C  				;AND WANT SIN-TAN-COS-ATN? 
 = 0000                      C  	INSTSW=0		;FOR INSTR INSTRUCTION 
 = 0001                      C  	SWAPSW=1		;FOR SWAP STATEMENT 
 = 0000                      C  	MDS=0			;FOR INTEL MDS SYSTEMS 
 = 0000                      C  	SBC=0			;FOR INTEL SINGLE BOARD COMPUTER 
                             C  				;1=SBC 80/10, 2=SBC 80/20 
 = 0001                      C  	PURE=1			;ON FOR PURE CODE 
 = 0000                      C  	KILLER=0		;FOR ROM VERSION THAT WONT RUN IN RAM 
 = 0000                      C  	INTROM=0 
 = 0001                      C  	LPTSW=1 
 = 0001                      C  	NCRLPT=1 
 = 0000                      C  	NCRCAS=0 
 = 0000                      C  	ISC=0			;FOR ISC VERSION 
 = 0000                      C  	LPT3=0			;THREE LPT DRIVER VERSION(QUME,OKIA,CENT) 
 = 0000                      C  	TSLPT=0 
                             C   
 = 0000                      C  	DOS=0			;ON TO GEN ROUTINES FOR DOS 
 = 0001                      C  	DISK=1			;FILE I/O FEATURES 
 = 0000                      C  	TIMSHR=0		;NO TIME-SHARING DISK 
 = 0000                      C  	TSDISK=0		;NO TIME-SHARING DISK FOR US 
 = 0000                      C  	SPCDSK=0		;MAY HAVE MM'S DISK CODE 
 = 0000                      C  	SPCNDS=0 
 = 0001                      C  	FAST=1			;CONSTANT COMPRESSION, RENUM & FRIENDS 
 = 0000                      C  	KEYSTA=0 
 = 0000                      C  	ISIS=0			;FOR VERSION TO RUN UNDER INTEL'S ISIS II DOS 
 = 0000                      C  	MDSISS=0		;FOR MDS VERSION THAT RUNS UNDER ISIS-II 
 = 0001                      C  	CPM=1			;FOR CPM compatible operating systems 
 = 0001                      C  	CPM2=1			;VERSION 2. CPM 
 = 0000                      C  	CPM86=0			;FOR CP/M-86 operating system 
 = 0001                      C  	SCP=1			;MS-DOS operating system 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	CPMSER=0		;CHECK CPM SERIAL #'S 
 = 0000                      C  	CPMADD=0		;FOR VERSION TO RUN ON ADDS CPM 
 = 0000                      C  	CPMA75=0		;FOR VERSION TO RUN ON ADDS SYSTEM 75 
                             C  				;CP/M 
 = 0000                      C  	CPMRSH=0		;FOR RADIO SHACK CPM/M 
 = 0000                      C  	CPM110=0		;FOR CP/M @1100 HEX (INTERALIA) 
 = 0000                      C  	CPMSBC=0		;FOR VERSION TO RUN ON SBC CP/M AT 4100H 
 = 0000                      C  	CPMPER=0		;FOR PERTEC VERSION OF CPM 
 = 0000                      C  	CPMLIF=0		;LIFEBOAT CP/M AT 4200H 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-4
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	CPMMDS=0		;MOHAWK DATA SYSTEMS CP/M 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	Z80=0 
 = 0001                      C  	DISK=1 
 = 0001                      C  	NCRLPT=1 
 = 0001                      C  	RSTLES=1 
 = 0000                      C  	DRVPOS=CPMADD 
 = 0000                      C  	TRNCHR=CPMADD 
 = 0000                      C  	INLADD=CPMADD 
 = 0001                      C  	LISTEN=1		;ON MEANS LISTEN FOR ^C 
 = 0001                      C  	LISTEN=1 
 = 0000                      C  	LEN2=0 
 = 0001                      C  	LEN2=1 
 = 0001                      C  	HEXOCT=1 
 = 0002                      C  	LENGTH=2 
 = 0001                      C  	RSTLES=1 
 = 0001                      C  	FIVLPT=1 
 = 0000                      C  	I8251=0			;THIS SWITCH IS USED FOR ROSEMOUNT VERSION 
 = 0001                      C  	CONTRO=1		;ALLOW ^O 
 = 0001                      C  	LEN3=LEN2 OR CASSW 
                             C   
                             C   
                             C   
 = 0001                      C  	STRING=1 
 = 0001                      C  	NCRLPT=1 
                             C   
                             C  ; *** OEM Switches which need to be defaulted to 0 
                             C  ; 
 = 0000                      C  	CMPUTN=0 
 = 0000                      C  	DUPONT=0 
 = 0000                      C  	EXIDY=0 
 = 0000                      C  	GESBC=0 
 = 0000                      C  	HEATH=0 
 = 0000                      C  	LOKHED=0 
 = 0000                      C  	MOSTEK=0 
 = 0000                      C  	TEK=0 
 = 0000                      C  	TRSER2=0 
 = 0000                      C  	NASCOM=0 
 = 0000                      C  	NATROM=0 
 = 0000                      C  	NCRBAS=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRELS=0 
 = 0000                      C  	ONTEL=0 
 = 0000                      C  	PCS=0 
 = 0000                      C  	SGSATS=0 
 = 0000                      C  	ALTAIR=0 
 = 0000                      C  	DMC=0 
 = 0000                      C  	PANBAS=0 
 = 0000                      C  	XTNSYS=0 
 = 0000                      C  	NECBAS=0 
                             C  ;******************************************************************* 
                             C  ; Z80 related macros 
                             C  ;******************************************************************* 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-5
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0001                      C  	Z80=1			;FOR VERSION THAT RUNS ON BOTH 
                             C  				;8080'S AND ZILOG Z-80'S 
 = 0001                      C  	Z80MAC=1		;USE 8080 MACROS INSTEAD OF Z80 INSTRUCTIONS 
 = 0000                      C  	Z80=0 
 = 0001                      C  	Z80=1 
                             C  LDIR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	INXF	H 
                             C  	INXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  LDDR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	DCXF	H 
                             C  	DCXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  DJNZ	MACRO	    DEST 
                             C  	DCR	B 
                             C  	JNZ	DEST 
                             C  ENDM 
                             C  ;******************************************************************* 
                             C  ; Define reset routines. 
                             C  ;******************************************************************* 
                             C  FSIGN	MACRO 
                             C  	CALL	SIGN 
                             C  ENDM 
                             C  PUSHM	MACRO 
                             C  	MOV	WORD PTR C,WORD PTR M 
                             C  	INX	H 
                             C  	MOV	WORD PTR B,WORD PTR M 
                             C  	INX	H 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  SYNCHK	MACRO	X 
                             C  	CALL	SYNCHR 
                             C  	DB	OFFSET X 
                             C  ENDM 
                             C  OUTCHR	MACRO 
                             C  	CALL	OUTDO 
                             C  ENDM 
                             C  CHRGET	MACRO 
                             C  	CALL	CHRGTR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	CALL	DCOMPR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-6
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  ENDM 
                             C  GETYPE	MACRO 
                             C  	CALL	GETYPR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	DB	73O 
                             C  	DB	332O 
                             C   ENDM 
                             C  ACRLF	MACRO 
                             C  	DB	13D 
                             C  	DB	10D 
                             C  ENDM 
                             C  PUSHR	MACRO 
                             C  	PUSH	WORD PTR D 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  POPR	MACRO 
                             C  	POP	WORD PTR B 
                             C  	POP	WORD PTR D 
                             C  ENDM 
                             C  MOVRI	MACRO	B,C,D,E 
                             C  	DB	1O		; "LXI  B" 
                             C  	DB	OFFSET C 
                             C  	DB	OFFSET B 
                             C  	DB	21O		; "LXI  D" 
                             C  	DB	OFFSET E 
                             C  	DB	OFFSET D 
                             C  ENDM 
                             C  INST	MACRO	X 
                             C  	DB	OX 
                             C  ENDM 
                             C   
                             C   
 = 000F                      C  	CONTO=15		;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O) 
 = 0000                      C  	DBLTRN=0		;FOR DOUBLE PRECISION TRANSCENDENTALS 
                             C   
 = 000E                      C  	CLMWID=14D		;MAKE COMMA COLUMNS FOURTEEN CHARACTERS 
 = 0080                      C  	DATPSC=128D		;NUMBER OF DATA BYTES IN DISK SECTOR 
 = 0050                      C  	LINLN=80D		;TERMINAL LINE LENGTH 
 = 0084                      C  	LPTLEN=132D 
 = 00FF                      C  	BUFLEN=255		;LONG LINES 
 = 0028                      C  	NAMLEN=40D		;MAXIMUM LENGTH NAME -- 3 TO 127 
                             C   
 = 006E                      C  	NUMLEV=110D		;NUMBER OF STACK LEVELS RESERVED 
                             C  				;BY AN EXPLICIT CALL TO GETSTK 
 = 0004                      C  	STRSIZ=4 
 = 0003                      C  	STRSIZ=3 
 = 0003                      C  	NUMTMP=3		;NUMBER OF STRING TEMPORARIES 
 = 000A                      C  	NUMTMP=10 
                             C   
 0008                        C  	.RADIX	8 
                             C  ; 
                             C  ; Useful macros 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-7
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C   
                             C  ACRLF   MACRO 
                             C          DB      13D 
                             C          DB      10D 
                             C  ENDM 
                             C   
                             C  INS86   MACRO   A,B,C,D 
                             C          DB      A&O 
                             C  IFNB    <B> 
                             C          DB      B&O 
                             C  ENDIF 
                             C  IFNB    <D> 
                             C          DB      C&O 
                             C          DB      D&O 
                             C  ENDIF 
                             C  IFB     <D> 
                             C   IFNB   <C> 
                             C          DW      C 
                             C    ENDIF 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  CALLOS  MACRO 
                             C          CALL    CPMENT 
                             C  ENDM 
                             C   
                             C  POPR    MACRO 
                             C          POP     CX 
                             C          POP     DX 
                             C  ENDM 
                             C   
                             C  ADR     MACRO   X 
                             C          DW      X 
                             C  ENDM 
                             C   
                             C  DC      MACRO   ARG 
                             C          IRPC    ZZ,<ARG> 
                             C              IFDIF       <ZZ>,<">
                             C                  DB      "&ZZ&" 
                             C                  _A="&ZZ&" 
                             C              ENDIF 
                             C          ENDM 
                             C  ENDM 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-8
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C          PAGE 
                             C   
                             C  DBGBRK	MACRO 
                             C  	DB	0CDh,06h,0CCh 
                             C  	ENDM 
                             C   
                             C   
                             C  	TITLE MATH86 8086 MATH PACK 
                             C   
                             C  	.SALL 
 0008                        C  	.RADIX	8 
                             C   
 = 0000                      C  SIXDIG=0			;Floating pnt output 6 bit S.P. numbers 
                             C   
                             C  	PUBLIC	ABSFN,ATN,COS,DADD 
                             C  	PUBLIC	DDIV,DMULT,EXP,FINDBL,FIN,FOUT,FRCDBL 
                             C  	PUBLIC	FRCINT,FRCSNG,INEG,INEG2,INT,LOG,LOPFND,NEG 
                             C  	PUBLIC	PUFOUT,RND,SIGN,SIN,SQR,TAN 
                             C  	PUBLIC	VALINT,VINT,VNEG,ZERO,$CDS,$CSD,$CSI 
                             C  	PUBLIC	$DCMPA,$DIV0S,$DZERO,$EXPCN,$FADDS,$FCOMP,$FDIVS 
                             C  	PUBLIC	$FI,$FLT,$FMULS,$FOUTH,$FOUTO,$FOUT2,$FPWR 
                             C  	PUBLIC	$FSUBD,$FSUBS,$FS,$GETYP,$LOGP,$MOVFA,$MOVFM 
                             C  	PUBLIC	$MOVFR,$MOVMF,$MOVRF,$NEG,$NORMD,$NORMS,$POPA 
                             C  	PUBLIC	$SIGNS,$VINT,$VPSHF 
                             C   
                             C  	PUBLIC	SIGNS,DCXBRT,FADD,VSIGN,MOVFR,ISIGN,INEG2 
                             C  	PUBLIC	IMOD,GETBCD,ISUB,FPWRQ,INRART,MOVRF,DCOMP 
                             C  	PUBLIC	VDFACS,MOVFM,FDIVT,ICOMP,VMOVAF,UMULT,FOUTH,FSUB 
                             C  	PUBLIC	ICMPA,VMOVFA,IDIV,VMOVFM,IMULT,RNDMN2,BLTU,FMULT 
                             C  	PUBLIC	FRCSTR,POPHRT,MOVE,MOVMF,CONIA,VMOVE,RNDMON,CHKSTR 
                             C  	PUBLIC	LOPFD1,INPRT,MAKINT,FDIV,SGN,SIGNC,FCOMP,INXHRT 
                             C  	PUBLIC	IADD,FOUTO,DSUB,VALSNG,BLTUC,FIXER,MOVRM 
                             C  	PUBLIC	FADDS,LINPRT,MOVE1,CONSIH,PUSHF,VMOVMF 
                             C   
                             C  	PUBLIC	STROUT 
                             C  	EXTRN	CRFIN:NEAR,OUTDO:NEAR 
                             C   
                             C   
                             C  	EXTRN	ARYEXT:NEAR,BSERR:NEAR,CHRGTR:NEAR,DV0ERR:NEAR,FRQINT:NEAR 
                             C  	EXTRN	INTXT:NEAR,NOTFDD:NEAR,NOTFNS:NEAR,OVERR:NEAR 
                             C  	EXTRN	REASON:NEAR,STROUI:NEAR,TMERR:NEAR 
                             C  	EXTRN	$CATTY:NEAR,$CLROV:NEAR,$DIV0M:NEAR,$FLGOC:NEAR 
                             C  	EXTRN	$OHCNS:NEAR,$OVERR:NEAR,$OVMSG:NEAR,$FCERR:NEAR 
                             C  	EXTRN	$SNERR:NEAR,$STPRN:NEAR,$TMERR:NEAR 
                             C   
 0000                        C  DSEG	SEGMENT PUBLIC 'DATASG' 
                             C  	ASSUME DS:DSEG 
                             C  	EXTRN	ARYTA2:WORD,NAMBUF:WORD,NAMCNT:WORD,ONELIN:WORD 
                             C  	EXTRN	STREND:WORD,TEMP3:WORD,VALTYP:WORD 
                             C  	EXTRN	$ARG:WORD,$ARGLO:WORD,$DBUFF:WORD,$DFACL:WORD 
                             C  	EXTRN	$DPADR:WORD,$FAC:WORD,$FACLO:WORD,$FACM1:WORD,$FBUFF:WORD 
                             C  	EXTRN	$FLGOV:WORD,$FMTAL:WORD,$FMTAX:WORD,$FMTCX:WORD,$RNDX:WORD 
                             C  	EXTRN	$VALTP:WORD,$ZLO:WORD,$Z1LO:WORD,$Z1:WORD 
 0000                        C  DSEG	ENDS 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-9
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C   
                             C   
                             C  	SUBTTL	 $FOTCI  CONVERT INTEGER IN (FACLO) TO ASCII DIGITS 
                             C  ;************************************************************* 
                             C  ; 
                             C  ;       $FOTCI  CONVERT THE INTEGER IN (FACLO)-TWO BYTES TO 
                             C  ;               ASCII DIGITS. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTCI 
                             C  ;               WITH DECIMAL POINT AND COMMA COUNTS IN (CX) 
                             C  ;       $FOUTO  CONVERT INTEGER IN $FACLO:FACLO+1 TO OCTAL 
                             C  ;       $FOUTH  CONVERT INTEGER IN $FACLO:FACLO+1 TO HEXIDECIMAL 
                             C  ;       CALLING SEQUENCE:       CALL    $FOUTO/$FOUTH 
                             C  ;               WITH $FACLO:FACLO+1 CONTAINING INTEGER TO BE 
                             C  ;               PRINTED. RETURNS WITH (BX) POINTING TO $FBUFF 
                             C  ; 
                             C  ;************************************************************** 
                             C  	PUBLIC	$FOTCI 
 0000  B4 05                 C  $FOTCI: MOV	AH,LOW 5	;MAX DIGITS TO CONVERT 
 0002  BD 0524 R             C  	MOV	BP,OFFSET $FOITB 
 0005                        C  $FCI4:				;ENTRY FOR FOTCV SO WE WILL ONLY CONVERT 4 DIGITS 
 0005  E8 19A9 R             C  FCI10:	CALL	$FOTED		;CHECK FOR NEEDED D.P. OR "," 
                             C  				;TABLE IN CODE SEGMENT 
 0008  2E: 8B 56 00          C  	MOV	DX,WORD PTR CS:0[BP]	;FETCH POWER OF TEN TO DX 
 000C  45                    C  	INC	BP		;POINT (BP) TO NEXT PWR 10 
 000D  45                    C  	INC	BP 
 000E  8B 36 0000 E          C  	MOV	SI,WORD PTR $FACLO	;FETCH INTEGER TO BE CONVERTED 
 0012  B0 2F                 C  	MOV	AL,LOW OFFSET "0"-1     ;WILL BUILD DIGIT IN (AL) 
 0014  FE C0                 C  FCI20:	INC	AL 
 0016  2B F2                 C  	SUB	SI,DX		;SUBTRACT OUT POWER OF TEN 
 0018  73 FA                 C  	JNB	FCI20		;CONTINUE UNTIL DIGIT FORMED 
 001A  03 F2                 C  	ADD	SI,DX		;SUBTRACTED OUT ONE TOO MANY 
 001C  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;MOVE DIGIT TO BUFFER 
 001E  43                    C  	INC	BX		;POINT (BX) TO NEXT BUFF POS. 
 001F  89 36 0000 E          C  	MOV	WORD PTR $FACLO,SI	;SAVE UPDATED INTEGER 
 0023  FE CC                 C  	DEC	AH		;LOOP TILL DIGITS FORMED 
 0025  75 DE                 C  	JNZ	FCI10 
 0027  E8 19A9 R             C  	CALL	$FOTED		;SEE IF DECIMAL POINT NEEDED 
 002A  C6 07 00              C  	MOV	BYTE PTR 0[BX],LOW 0	;AND PUT BINARY 
 002D  C3                    C  	RET			;ZERO AFTER. 
 002E                        C  $FOUTO:			;OCTAL OUTPUT OF INTEGER IN $FACLO:FACLO+1 
 002E  B9 0301               C  	MOV	CX,OFFSET 3*400+1	;WILL PROCESS 3 BITS AT A TIME 
 0031  BE 0006               C  	MOV	SI,6		;OCTAL DIGITS 
 0034  EB 06                 C  	JMP	SHORT FTH10 
 0036                        C  $FOUTH:			;HEXIDECIMAL OUTPUT OF INTEGER IN FACLO:FACLO+1 
 0036  B9 0404               C  	MOV	CX,OFFSET 4*400+4	;WILL PROCESS 4 BITS AT A TIME 
 0039  BE 0004               C  	MOV	SI,4		;HEX DIGITS 
 003C  BF 0000 E             C  FTH10:	MOV	DI,OFFSET $FBUFF	;POINT DI TO OUTPUT LOCATION 
 003F  FC                    C  	CLD			;SO SUBSEQUENT STOC WILL INC 
 0040  BB 05A3 R             C  	MOV	BX,OFFSET $NUMB 
 0043  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH INTEGER 
 0047  56                    C  	PUSH	SI		;SAVE FOR ZERO SUPPRESS CODE 
 0048  8A C6                 C  FTH20:	MOV	AL,DH		;GET INTEGER 
 004A  32 E4                 C  	XOR	AH,AH		;CLEAR UPPER AX 
 004C  D3 E0                 C  	SHL	AX,CL		;SHIFT HIGH ORDER BITS INTO AH 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-10
$FOTCI  CONVERT INTEGER IN (FACLO) TO ASCII DIGITS          

 004E  86 E0                 C  	XCHG	AH,AL		;NOW IN AL 
                             C  				;LOOK FROM CODE SEGMENT 
 0050                        C  ?CSLAB:			; Code segment dummy label 
 0050  2E: D7                C  	XLAT	BYTE PTR ?CSLAB ;LOOK-UP ASCII 
 0052  AA                    C  	STOSB 
 0053  D3 E2                 C  	SHL	DX,CL		;SHIFT NUMBER 
 0055  8A CD                 C  	MOV	CL,CH		;GET NO. BITS TO SHIFT 
 0057  4E                    C  	DEC	SI		;DECREMENT NO. OF DIGITS 
 0058  75 EE                 C  	JNZ	FTH20 
 005A  C6 05 00              C  	MOV	BYTE PTR 0[DI],LOW 0	;DENOTE END OF NO. 
 005D  BB 0000 E             C  	MOV	BX,OFFSET $FBUFF 
 0060  59                    C  	POP	CX		;RECALL FOR ZERO SUPPRESS 
 0061  FE C9                 C  	DEC	CL		;CAN'T DELETE ALL THE ZEROS 
 0063  80 3F 30              C  FTH40:	CMP	BYTE PTR 0[BX],LOW "0"  ;DO ZERO SUPPRESS 
 0066  75 03                 C  	JNZ	FTH50		;NO MORE SUPPRESS 
 0068  43                    C  	INC	BX 
 0069  E2 F8                 C  	LOOP	FTH40 
 006B  C3                    C  FTH50:	RET 
                             C   
                             C  	SUBTTL	 $PUFXE  PRINT USING FIX-UP CODE 
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;       $PUFXE  THIS CODE IS CALLED ONCE PRINT-USING ROUTINES 
                             C  ;               HAVE BUILT THE NUMBER IN THE OUTPUT BUFFER (FBUFF) 
                             C  ;               ITS JOB IS TO ASSURE THE NUMBER MEETS OUTPUT 
                             C  ;               SPECIFICATIONS. IF THE NUMBER TRULY OVERFLOWS THE 
                             C  ;               OUTPUT BUFFER A "%" SIGN WILL BE INSERTED AS THE 
                             C  ;               LEADING CHARACTER. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUFXE 
                             C  ;               WITH $FBUFF CONTAINING THE FORMATTED NUMBER 
                             C  ; 
                             C  ;***************************************************************** 
                             C   
 = 0024                      C  	CURNCY="$"	      ;Default floating currency is dollars. 
 006C  53                    C  $PUFXE: PUSH	BX		;SAVE END OF BUFFER POINTER 
 006D  E8 00D4 R             C  	CALL	$FOTZS		;DO ZERO SUPPRESSION 
                             C  				;$FOTZS WILL LEAVE ZF=0 IF THERE IS 
                             C  				;TO BE A TRAILING SIGN AND THE SIGN 
                             C  				;WILL BE LEFT IN (CH) 
 0070  5B                    C  	POP	BX		;RECALL END-OF-BUFFER POINTER 
 0071  74 03                 C  	JZ	PFX10		;IF NO TRAILING SIGN PROCEED 
 0073  88 2F                 C  	MOV	BYTE PTR 0[BX],CH	;PUT IN TRAILING SIGN 
 0075  43                    C  	INC	BX		;MUST NOW PUT IN BINARY ZERO 
 0076  C6 07 00              C  PFX10:	MOV	BYTE PTR 0[BX],LOW 0	;TO SIGNIFY END OF PRINT 
 0079  BB 0000 E             C  	MOV	BX,OFFSET $FBUFF	;FETCH START OF BUFFER ADDRESS 
 007C  43                    C  PFX20:	INC	BX		;INCREMENT (BX) TO NEXT BUFFER POSITION 
 007D  8B 3E 0000 E          C  PFX30:	MOV	DI,WORD PTR $DPADR	;GET DECIMAL POINT ADDRESS 
 0081  8B 16 0000 E          C  	MOV	DX,WORD PTR $FMTCX	;FETCH DECIMAL POINT INFO. 
 0085  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;FETCH NO. DIGITS TO LEFT OF D.P. 
 0088  32 E4                 C  	XOR	AH,AH		;(AX) = DIGITS LEFT OF DECIMAL POINT 
 008A  2B FB                 C  	SUB	DI,BX		;WILL FORM THE SUBTRACTION: 
 008C  2B F8                 C  	SUB	DI,AX		;D.P. ADDR.-BUFF PTR-DIGITS LEFT OF D.P 
 008E  74 43                 C  	JZ	PFX90		;RETURN IF ALL IS OK. 
                             C  ;******************************************************************** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-11
$PUFXE  PRINT USING FIX-UP CODE                             

                             C  ;FIELD IS CURRENTLY TOO LARGE. WE CAN SHORTEN THE FIELD BY ELIMINATING 
                             C  ;LEADING " " AND "*" CHARACTERS AND A LEADING "0" IF THE CHARACTER 
                             C  ;FOLLOWING THE DECIMAL POINT IS A NUMERIC DIGIT. DOING THIS ANALYSIS 
                             C  ;WILL BE WHAT THE FOLLOWING SONG & DANCE IS ALL ABOUT 
                             C  ;THE INCREMENT OF (BX) AT PFX20 IN EFFECT SHORTENS THE FIELD BECAUSE 
                             C  ;(BX) WILL POINT TO THE STARTING LOCATION FOR PRINTOUT UPON RETURN 
                             C  ;FROM THIS ROUTINE. 
                             C  ;****************************************************************** 
 0090  8A 07                 C  	MOV	AL,BYTE PTR 0[BX]	;FETCH NEXT CHARACTER IN BUFFER 
 0092  3C 20                 C  	CMP	AL,LOW " "      ;SPACE? 
 0094  74 E6                 C  	JZ	PFX20		;IF SO ELIMINATE AND SEE IF NOW OK 
 0096  3C 2A                 C  	CMP	AL,LOW "*"      ;IF ASTERISK FILL THEN ASTERISK? 
 0098  74 E2                 C  	JZ	PFX20 
 009A  B4 01                 C  	MOV	AH,LOW 1	;TO SIGNAL END OF CHARACTERS IN 
                             C  				;THE FOLLOWING CODE 
 009C  4B                    C  	DEC	BX		;BECAUSE $CHRGT WILL DO INC BX FIRST 
 009D  53                    C  	PUSH	BX		;SAVE THIS LOCATION FOR POSSIBLE "%" 
 009E  50                    C  PFX40:	PUSH	AX 
 009F  E8 0E5F R             C  	CALL	$CHRGT		;GET NEXT CHARACTER( NOTE THAT THIS 
                             C  				;RE-FETCHES THE PREVIOUS FAILING 
                             C  				;CHARACTER THE FIRST TIME THROUGH) 
 00A2  32 E4                 C  	XOR	AH,AH		;CLEAR (AH) 
 00A4  3C 2D                 C  	CMP	AL,LOW "-"      ;IF EQUAL NEED TO SAVE THIS GUY 
 00A6  74 F6                 C  	JZ	PFX40		;GO SAVE AND GET NEXT CHAR. 
 00A8  3C 2B                 C  	CMP	AL,LOW "+" 
 00AA  74 F2                 C  	JZ	PFX40		;GO SAVE THIS GUY IF EQUAL 
 00AC  3C 24                 C  	CMP	AL,LOW OFFSET CURNCY 
 00AE  74 EE                 C  	JZ	PFX40		;GO SAVE IF EQUAL 
 00B0  3C 30                 C  	CMP	AL,LOW "0"      ;IF EQUAL POSSIBLE TO ELIMINATE 
 00B2  75 16                 C  	JNZ	PFX70		;MUST GIVE UP AND PUT LEADING "%" 
                             C  ;************************************************************** 
                             C  ;AT THIS POINT WE HAVE A LEADING ZERO. IT CAN BE ELIMINATED 
                             C  ;ONLY IF THERE ARE DIGITS BEYOND THE DECIMAL POINT. IF THIS 
                             C  ;IS THE CASE WE HAVE POSITIONED TO THE CORRECT PLACE AND 
                             C  ;HAVE CHARACTERS TO MOVE DOWN IN THE STACK AND CAN ELIMINATE 
                             C  ;THE ZERO BY NOT PUSHING IT ON THE STACK SINCE ALL 
                             C  ;CHARACTERS TO BE RE-INSERTED WILL COME FROM THE STACK. 
                             C  ;*************************************************************** 
 00B4  43                    C  	INC	BX		;THIS WILL CAUSE ELIMINATION OF "0" 
 00B5  E8 0E5F R             C  	CALL	$CHRGT		;GET CHARACTER AFTER DECIMAL POINT 
 00B8  73 10                 C  	JNB	PFX70		;NO HOPE GIVE UP AND PUT IN "%" 
 00BA  4B                    C  	DEC	BX		;(BX) NOW POINTS TO DECIMAL POINT 
 00BB  EB 03                 C  	JMP	SHORT PFX60 
 00BD  4B                    C  PFX50:	DEC	BX		;NEXT CHARACTER POSITION TO MOVE INTO 
 00BE  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;MOVE IT IN 
 00C0  58                    C  PFX60:	POP	AX		;FETCH CHARACTER OFF THE STACK 
 00C1  0A E4                 C  	OR	AH,AH		;ONCE (AH)=1 IS REACHED CHARS. 
                             C  				;HAVE BEEN RE-ENSTATED 
 00C3  74 F8                 C  	JZ	PFX50		;KEEP GOING IF (AH)=0 
 00C5  83 C4 02              C  	ADD	SP,2		;GET OLD START OF BUFFER ADDRESS OFF 
                             C  				;THE STACK 
 00C8  EB B3                 C  	JMP	SHORT PFX30	;AND SEE IF WE NOW FIT INTO THE 
                             C  				;REQUIRED SPACE 
 00CA                        C  PFX70: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-12
$PUFXE  PRINT USING FIX-UP CODE                             

                             C  ;****************************************************************** 
                             C  ;WE COULD NOT FIT THE NUMBER INTO THE BUFFER DESPITE OUR VALIENT 
                             C  ;EFFORTS WE MUST POP ALL THE CHARACTERS BACK OFF THE STACK AND 
                             C  ;POP OFF THE BEGINNING BUFFER PRINT LOCATION AND INPUT A "%" SIGN 
                             C  ;THERE 
                             C  ;****************************************************************** 
 00CA  58                    C  	POP	AX		;GET CHARACTER OFF THE STACK 
 00CB  0A E4                 C  	OR	AH,AH		;IF ZF=1 AFTER THIS-MORE CHARS. 
 00CD  74 FB                 C  	JZ	PFX70 
 00CF  5B                    C  	POP	BX		;GET BEGINNING BUFFER POINTER 
 00D0  C6 07 25              C  	MOV	BYTE PTR 0[BX],LOW "%"  ;INSERT OVERFLOW FLAG 
 00D3  C3                    C  PFX90:	RET 
                             C   
                             C  	SUBTTL	 $FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE 
                             C  ;************************************************************* 
                             C  ; 
                             C  ;       $FOTZS  THIS ROUTINE WILL LOOK AT THE OUTPUT GENERATED 
                             C  ;               BY THE REST OF THE PUFOT ROUTINES AND SUPRESS 
                             C  ;               LEADING ZEROES. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTZS 
                             C  ;               ONLY PREREQUISITE IS THAT OTHER PUFOT ROUTINES 
                             C  ;               HAVE EXECUTED TO PROVIDE FOTZS WITH $FBUFF 
                             C  ;               CONTAINING OUTPUT TEXT. 
                             C  ; 
                             C  ;       $FOTZ   THIS ROUTINE PUTS IN (AL) LEADING ZEROS 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTZ 
                             C  ;               WITH (AL) SET TO NO. OF LEADING ZEROS DESIRED 
                             C  ;       $FOTZC  THIS ROUTINE PUTS IN (AL) LEADING ZEROS AND 
                             C  ;               PAYS ATTENTION TO DECIMAL POINT AND COMMA COUNTS 
                             C  ;               AND FURTHER PUTS IN COMMAS AND A D.P. AS NECESSARY 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTZC 
                             C  ;               WITH (CX) SET TO NO. PLACES TO LEFT/RIGHT OF D.P. 
                             C  ;               AND (AL) TO NO. LEADING ZEROS 
                             C  ;************************************************************* 
                             C   
                             C   
 = 0024                      C  	CURNCY="$"	      ;Default floating currency is dollars. 
                             C   
 00D4  BB 0001 E             C  $FOTZS: MOV	BX,OFFSET $FBUFF+1	;ADDRESS OF SIGN(IF LEADING) 
 00D7  8A 2F                 C  	MOV	CH,BYTE PTR 0[BX]	;FETCH LEADING CHARACTER 
 00D9  B1 20                 C  	MOV	CL,LOW " "      ;SPACE TO CL 
 00DB  8A 26 0000 E          C  	MOV	AH,BYTE PTR $FMTAL	;FETCH FORMAT SPECIFICATIONS 
                             C  				;BIT    76543210        OF AH 
                             C  				;       ABCDEFGH        WHERE 
                             C  				;A=FREE FORMAT FLAG 
                             C  				;B=GROUP INTEGER DIGITS IN 3'S AND 
                             C  				;  SEPARATE WITH COMMAS 
                             C  				;C=FILL LEADING SPACES WITH "*" 
                             C  				;D=OUTPUT WITH FLOATING "$" 
                             C  				;E=PRINT SIGN WITH "+" INSTEAD OF" " 
                             C  				;F=PRINT SIGN AS TRAILING 
                             C  				;G=UNUSED 
                             C  				;H=USE SCIENTIFIC NOTATION 
 00DF  F6 C4 20              C  	TEST	AH,LOW 40	;WILL TEST FOR LEADING "*" FIRST 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-13
$FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE                 

 00E2  74 0D                 C  	JZ	FZ10		;LEADING ASTERISKS NOT DESIRED IF JMP 
 00E4  3A E9                 C  	CMP	CH,CL		;SPACE? 
 00E6  B1 2A                 C  	MOV	CL,LOW "*"      ;SINCE IT'S ASTERISK FILL DESIRED 
 00E8  75 07                 C  	JNZ	FZ10		;JUMP IF NOT SPACE 
 00EA  F6 C4 04              C  	TEST	AH,LOW 4	;WILL NOW CHECK FOR TRAILING SIGN 
 00ED  75 02                 C  	JNZ	FZ10 
 00EF  8A E9                 C  	MOV	CH,CL 
 00F1  88 0F                 C  FZ10:	MOV	BYTE PTR 0[BX],CL	;REPLACE SIGN AS NECESSARY 
 00F3  E8 0E5F R             C  	CALL	$CHRGT		;GET NEXT CHARACTER AND SET CONDITION 
 00F6  74 31                 C  	JZ	FZ50		;CODES. JUMP IF END OF NUMBER 
 00F8  BD 04D4 R             C  	MOV	BP,OFFSET $FINCH+11 
 00FB                        C  FZ20: 
 00FB  2E: 3A 46 00          C  	CMP	AL,BYTE PTR CS:0[BP]	;SEE IF SPECIAL CHARACTER 
 00FF  74 09                 C  	JZ	FZ30		; 
 0101  81 FD 04CB R          C  	CMP	BP,OFFSET $FINCH	;SEE IF         SEARCHED ALL TABLE 
 0105  74 26                 C  	JZ	FZ60		;IF SO GO CHECK FOR FLOATING "$" 
 0107  4D                    C  	DEC	BP		;POINT TO NEXT SPECIAL CHARACTER 
 0108  EB F1                 C  	JMP	SHORT FZ20	;AND CONTINUE   SEARCH 
 010A  81 ED 04CB R          C  FZ30:	SUB	BP,OFFSET $FINCH	;CALCULATE TABLE OFFSET 
 010E  D1 E5                 C  	SHL	BP,1		;TO ACCOUNT FOR 2 BYTE TABLE ENTRY 
                             C  				;ADD BASE ADDRESS (BP) NOW HAS ADDR. 
 0110                        C  FZ40: 
                             C  				;CODE SEGMENT OVERRIDE 
 0110  2E: FF A6 0115 R      C  	JMP	 WORD PTR CS:FZ45[BP] 
 0115                        C  FZ45  LABEL WORD 
 0115  0129 R                C  	DW	OFFSET FZ50	;"." 
 0117  0129 R                C  	DW	OFFSET FZ50	;"E" 
 0119  012D R                C  	DW	OFFSET FZ60	;"E"+40 
 011B  012D R                C  	DW	OFFSET FZ60	;"%" 
 011D  012D R                C  	DW	OFFSET FZ60	;"#" 
 011F  012D R                C  	DW	OFFSET FZ60	;"!" 
 0121  0129 R                C  	DW	OFFSET FZ50	;"D" 
 0123  012D R                C  	DW	OFFSET FZ60	;"D"+40 
 0125  00F1 R                C  	DW	OFFSET FZ10	;"," 
 0127  00F1 R                C  	DW	OFFSET FZ10	;"0" 
 0129  4B                    C  FZ50:	DEC	BX		;NEED TO PUT IN LEADING "0" 
 012A  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0" 
 012D  8A 26 0000 E          C  FZ60:	MOV	AH,BYTE PTR $FMTAL	;GET FORMAT SPECS AGAIN 
 0131  F6 C4 10              C  	TEST	AH,LOW 20	;TEST FOR FLOATING "$" 
                             C  				;FLOATING "$" DESIRED? 
 0134  74 04                 C  	JZ	FZ70		;IF NOT PROCEED 
 0136  4B                    C  	DEC	BX		; 
 0137  C6 07 24              C  	MOV	BYTE PTR 0[BX],LOW OFFSET CURNCY	;PUT IN FLOATING "$" 
 013A  F6 C4 04              C  FZ70:	TEST	AH,LOW 4	;RECALL FORMAT SPECS 
                             C  				;SEE IF TRAILING SIGN 
 013D  75 05                 C  	JNZ	FZ90		;IF SO RETURN 
 013F  4B                    C  	DEC	BX 
 0140  88 2F                 C  	MOV	BYTE PTR 0[BX],CH	;PUT IN SIGN 
 0142  32 ED                 C  	XOR	CH,CH		;MUST RETURN ZF=1 IF NOT TRAILING 
                             C  				;SIGN. 
 0144  C3                    C  FZ90:	RET 
 0145                        C  $FOTZ:				;PUT (AL) LEADING ZEROS IN BUFFER POINTED TO BY (BX) 
 0145  0A C0                 C  	OR	AL,AL		;SEE IF FURTHER WORK TO DO 
 0147  EB 06                 C  	JMP	SHORT FTZ15 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-14
$FOTZS  ZERO SUPRESSION UPON OUTPUT ROUTINE                 

 0149  C6 07 30              C  FTZ10:	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN LEADING ZERO 
 014C  43                    C  	INC	BX		;NEXT BUFFER POSITION 
 014D  FE C8                 C  	DEC	AL 
 014F  75 F8                 C  FTZ15:	JNZ	FTZ10 
 0151  C3                    C  	RET 
                             C   
 0152  E8 19A9 R             C  FTZC10: CALL	$FOTED		;PUT IN COMMA AND DECIMAL POINT AS 
                             C  				;NECESSARY 
 0155  C6 07 30              C  $FOTZC: MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN LEADING ZERO 
 0158  43                    C  	INC	BX		;NEXT BUFFER POSITION 
 0159  FE C8                 C  	DEC	AL		; 
 015B  75 F5                 C  	JNZ	FTZC10 
 015D  C3                    C  	RET 
                             C   
                             C   
                             C  	SUBTTL	 $PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT 
                             C  ;************************************************************ 
                             C  ; 
                             C  ;       $PUFE   THIS ROUTINE IS CALLED TO FORMAT A SINGLE 
                             C  ;               OR DOUBLE PRECISION NUMBER WITH A DESIRED 
                             C  ;               "E" TYPE OUTPUT FORMAT. FURTHER SPECIFICATIONS 
                             C  ;               CAN BE THE NUMBER DESIRED PRINT POSITIONS 
                             C  ;               TO THE LEFT AND RIGHT OF THE DECIMAL POINT. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUFE 
                             C  ;               WITH (BX) POINTING TO THE CURRENT OUTPUT POSITION 
                             C  ;               AND ZF=1 IF THE OUTPUT NUMBER IS SINGLE 
                             C  ;               PRECISION, ZF=0 IF DOUBLE PRECISION. 
                             C  ; 
                             C  ;************************************************************* 
                             C   
 015E  E8 08EF R             C  $PUFE:	CALL	$GETYP		;SET CONDITION CODES ACCORDING TO TYPE 
                             C   
                             C   
 0161  B4 07                 C  	MOV	AH,LOW 7	;7 print positions if single precision 
                             C   
 0163  72 02                 C  	JB	PFE10		;AND JUMP IF SINGLE PRECISION 
 0165  B4 10                 C  	MOV	AH,LOW 20	;IT'S DOUBLE 
 0167  E8 08BF R             C  PFE10:	CALL	$SIGNS		;SET COND CODES ACCORDING TO NO. 
 016A  5B                    C  	POP	BX		;GET BUFFER PTR IN CASE NO. IS ZERO 
 016B  F9                    C  	STC			;CF WILL BE OUR FLAG TO REMEMBER 
 016C  74 09                 C  	JZ	PFE20		;IF THE NO. WAS ZERO SINCE $FOTNV 
                             C  				;WILL RETURN WITH CF=0 
 016E  53                    C  	PUSH	BX		;SAVE BUFFER PTR 
 016F  50                    C  	PUSH	AX		;SAVE NO. DIGITS IN NUMBER 
 0170  E8 1AC4 R             C  	CALL	$FOTNV		;BRACKET NO. SO DIGITS TO PRINT ARE 
                             C  				;IN THE INTEGER PART 
 0173  5A                    C  	POP	DX		;$FOTNV ALSO RETURNS WITH EXPONENT 
                             C  				;IN (AL) 
 0174  5B                    C  	POP	BX		;CF=0 
 0175  8A E6                 C  	MOV	AH,DH		;(AH)=NO DIGITS RETURNED FROM $FOTNV 
 0177  9C                    C  PFE20:	PUSHF			;SAVE CF FLAG IN CASE NO. IS ZERO 
 0178  50                    C  	PUSH	AX		;SAVE EXP. AND NO. SIG. DIGITS 
 0179  8B 16 0000 E          C  	MOV	DX,WORD PTR $FMTCX	;DIG LEFT/RT.OF D.P. 
 017D  0A F6                 C  	OR	DH,DH		;WILL NEED TO KNOW IF SIGN DESIRED 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-15
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

 017F  9C                    C  	PUSHF 
 0180  0A D2                 C  	OR	DL,DL		;SEE IF DECIMAL POINT DESIRED. 
 0182  74 02                 C  	JZ	PFE30		;IF NOT PROCEED 
 0184  FE CA                 C  	DEC	DL		; 
 0186  02 F2                 C  PFE30:	ADD	DH,DL		;NO. DIGITS DESIRED 
 0188  9D                    C  	POPF			;SEE IF SIGN DESIRED 
 0189  74 09                 C  	JZ	PFE40		;JUMP IF NOT DESIRED 
 018B  F6 06 0000 E 04       C  	TEST	BYTE PTR $FMTAX,LOW 4	;SEE IF TRAILING SIGN DESIRED 
 0190  75 02                 C  	JNZ	PFE40		;IF SO PROCEED 
 0192  FE CE                 C  	DEC	DH		;MUST USE ONE PRINT POSITION FOR SIGN 
 0194  2A F4                 C  PFE40:	SUB	DH,AH		;MUST SEE IF HAVE EXCESS DIGITS AVAIL. 
 0196  8A E6                 C  	MOV	AH,DH		;IF TO MANY WE MUST DIVIDE NO BY 
                             C  				;10 UNTIL CORRECT DIGITS . 
 0198  50                    C  	PUSH	AX		;SAVE COMPAREISON OF DESIRED-AVAILABLE 
                             C  				;DIGITS. AH IS GREATER THAN 0 IF 
                             C  				;TRAILING ZEROS. 
 0199  78 03                 C  	JS	PFE45 
 019B  EB 4F 90              C  	JMP	PFE65		;IF NO INTERNAL ROUNDING PROCEED 
                             C  ;********************************************************************* 
                             C  ;WHAT IS HAPPENING HERE IS THAT IF WE HAVE MORE DIGITS THAN REQUIRED 
                             C  ;WE MUST DIVIDE OUT THE EXCESS DIGITS SO THAT WE CAN ROUND AT THE 
                             C  ;CORRECT PRINT POSITION. ONCE WE HAVE PERFORMED THIS DIVISION WE 
                             C  ;WILL NEED TO CALCULATE THE CORRECT DECIMAL POINT POSITION BY ADDING 
                             C  ;THE DESIRED PRINT POSITIONS TO THE LEFT TO THE NUMBER OF POSITIONS 
                             C  ;WE SHIFTED OUT. THE REASON FOR THIS IS THAT REGARDLESS OF THE SIZE 
                             C  ;OF THE NUMBER WE GO TO $FOTCV WITH , A FIXED NUMBER OF DIGITS 
                             C  ;WILL BE PLACED IN THE OUTPUT BUFFER. FOR EXAMPLE, SAY WE REQUESTED 
                             C  ;A PRINT LIKE ##.###^^^^  FOR A SINGLE PRECISION NUMBER. $FOTNV WILL 
                             C  ;PRODUCE AN INTEGER OF 7 DIGITS SAY AXXXXXX WHERE A IS NON-ZERO 
                             C  ;USING THE LEADING POSITION FOR THE SIGN WE NEED ONLY FOUR DIGITS 
                             C  ;PRINTED SO WE NEED IT ROUNDED AT THE FOURTH POSITION. TO DO THIS WE 
                             C  ;DIVIDE THE AXXXXXX BY 10 THREE TIMES TO GET AXXX.XXX  ,  WHEN 
                             C  ;WE GO TO $FOTCV , HE WILL ROUND THIS NUMBER AND PRODUCE AN OUTPUT 
                             C  ; OF   000AXXX  IN THE OUTPUT BUFFER. THE CORRECT PRINT POSITION 
                             C  ;FOR THE DECIMAL POINT IS BETWEEN "A" AND "X". THIS IS CALCULATED 
                             C  ;AS  PRINT POSITION= POSITIONS TO LEFT+SIGN+NO. POSITIONS DIVIDED 
                             C  ;OFF. 
                             C  ;***************************************************************** 
 019E  53                    C  PFE45:	PUSH	BX		;SAVE BUFFER PTR. 
 019F  50                    C  	PUSH	AX		;SAVE NO TIMES TO DIVIDE 
 01A0  50                    C  PFE50:	PUSH	AX		;SAVE DIVIDE COUNT 
 01A1  E8 0915 R             C  	CALL	$DIV10		;SHIFT NO TO GET CORRECT ROUNDING 
 01A4  58                    C  	POP	AX		;RECALL DIVIDE COUNT 
 01A5  FE C4                 C  	INC	AH		;INCREMENT TO REFLECT DIVIDE 
 01A7  75 F7                 C  	JNZ	PFE50		;CONTINUE UNTIL GET CORRECT NO. 
 01A9  E8 08FB R             C  	CALL	$VADDH		;ROUND UP AT THE CORRECT POSITION 
 01AC  E8 0BEF R             C  	CALL	$VINT		;AND MAKE INTEGER 
 01AF  58                    C  	POP	AX		;RECALL NO. DIVIDES 
 01B0  50                    C  	PUSH	AX		;SAVE # DIVIDES 
 01B1  B9 0003               C  	MOV	CX,3		;WILL SHIFT AH 3 BITS LEFT 
 01B4  D2 E4                 C  	SHL	AH,CL		;BECAUSE DP TABLE IS 8 BYTES/ENTRY 
 01B6  E8 08EF R             C  	CALL	$GETYP		;DETERMINE TYPE 
 01B9  72 10                 C  	JB	PFE55		;JUMP IF SINGLE PRECISION 
 01BB  8A C4                 C  	MOV	AL,AH		;WILL CONVERT AH TO WORD IN AX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-16
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

 01BD  98                    C  	CBW 
 01BE  BB 03E1 R             C  	MOV	BX,OFFSET $DP16 ;ADDRESS OF 10^16 
 01C1  03 D8                 C  	ADD	BX,AX		;FAC SHOULD BE LESS THAN NO. POINTED 
 01C3  E8 09BC R             C  	CALL	$MOVBF		;MOVE CODE SEG NO. TO DBUFF 
 01C6  E8 0AD3 R             C  	CALL	$DCMPM		;TO BY BX 
 01C9  EB 0E                 C  	JMP	SHORT PFE57 
 01CB                        C  PFE55: 
                             C   
                             C   
 01CB  BB 039D R             C  	MOV	BX,OFFSET $DP07+4	;address of 10^7 
                             C   
 01CE  8A C4                 C  	MOV	AL,AH		;WILL CONVERT AH TO WORD IN AX 
 01D0  98                    C  	CBW 
 01D1  03 D8                 C  	ADD	BX,AX		;FAC SHOULD BE LESS THAN THIS NO 
 01D3  E8 09B4 R             C  	CALL	$MOVBS		;MOVE CODE SEG NO. TO DBUFF 
 01D6  E8 0A81 R             C  	CALL	$COMPM		;UNLESS ROUND UP HAS OCCURRED 
 01D9  58                    C  PFE57:	POP	AX		;RECALL NO. DIVIDES. WE MAY NEED 
 01DA  5B                    C  	POP	BX		;GET BUFFER PTR BACK 
 01DB  78 11                 C  	JS	PFE66		;ROUND-UP DID NOT OCCUR 
 01DD  58                    C  	POP	AX		;MUST GET TO ORIGINAL COPY 
 01DE  59                    C  	POP	CX		;EXPONENT NOW IN CL 
 01DF  FE C1                 C  	INC	CL		;MUST INCREMENT EXPONENT 
 01E1  51                    C  	PUSH	CX		;SAVE EXP ON STACK 
 01E2  50                    C  	PUSH	AX		;SAVE FOR POSSIBLE TRAILING ZEROS 
 01E3  53                    C  	PUSH	BX		;SAVE BUFFER PTR 
 01E4  50                    C  	PUSH	AX		;SAVE DIVIDED OUT DIGITS & EXPONENT 
 01E5  E8 0915 R             C  	CALL	$DIV10		;SO CORRECT DIGITS TO RIGHT OF 
 01E8  58                    C  	POP	AX 
 01E9  5B                    C  	POP	BX		;DECIMAL POINT ARE PRINTED 
 01EA  EB 02                 C  	JMP	SHORT PFE66 
 01EC  32 E4                 C  PFE65:	XOR	AH,AH		;NO DIVIDES 
 01EE  F6 DC                 C  PFE66:	NEG	AH		;IF PREVIOUSLY NEGATIVE MAKE POSITIVE 
 01F0  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;GET DESIRED PLACES TO LEFT OF DEC. PT. 
 01F3  02 E0                 C  	ADD	AH,AL		;NEW TOTAL 
 01F5  FE C4                 C  	INC	AH		;BECAUSE FOTED DECREMENTS AT FIRST 
 01F7  0A C0                 C  	OR	AL,AL		;SEE IF PLACES LEFT DESIRED 
 01F9  74 09                 C  	JZ	PFE70 
 01FB  F6 06 0000 E 04       C  	TEST	BYTE PTR $FMTAX,LOW 4	;SEE IF TRAILING SIGN 
 0200  75 02                 C  	JNZ	PFE70		;IF TRAILING SIGN PROCEED 
 0202  FE CC                 C  	DEC	AH		;ALLOW PRINT POSITION FOR SIGN 
 0204  8A EC                 C  PFE70:	MOV	CH,AH		;SET DECIMAL POINT POSITION 
 0206  32 C9                 C  	XOR	CL,CL		;NO COMMAS FOR EXPONENTIAL PRINTOUT 
 0208  58                    C  	POP	AX		;RECALL SIG. DIGIT COMPARISON 
 0209  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE FORMAT SPECS 
 020D  50                    C  	PUSH	AX		;SAVE SIG. DIGIT COMPARISON 
 020E  88 2E 0001 E          C  	MOV	BYTE PTR $FMTCX+1,CH	;UPDATE DIGITS TO LEFT 
 0212  E8 19C8 R             C  	CALL	$FOTCV		;CONVERT TO ASCII DIGITS 
 0215  58                    C  	POP	AX		;RECALL SIG. DIGIT COMPARISON 
 0216  0A E4                 C  	OR	AH,AH		;WILL SET SF=0 IF TRAILING ZEROS 
 0218  7E 08                 C  	JLE	PFE80		;IF TRAILING ZEROS NOT REQ. JUMP 
 021A  8A C4                 C  	MOV	AL,AH		;NO. TRAILING ZEROS TO AL 
 021C  E8 0155 R             C  	CALL	$FOTZC		;put in trailing zeros 
 021F  E8 19A9 R             C  	CALL	$FOTED		;put in decimal point (if necessary) 
 0222  58                    C  PFE80:	POP	AX		;FETCH DIGITS TO LEFT/RT. OF D.P. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-17
$PUFE	 PRINT USING FLOATING IN "E" TYPE FORMAT              

 0223  A3 0000 E             C  	MOV	WORD PTR $FMTCX,AX	;KEEP COPY FORMAT SPECS 
 0226  0A C0                 C  	OR	AL,AL		;SEE IF DECIMAL POINT DESIRED 
 0228  75 0C                 C  	JNZ	PFE100		;IF SO PROCEED 
 022A  4B                    C  	DEC	BX		;NOT DESIRED SEE IF CAN ELIMINATE 
 022B  8A 07                 C  	MOV	AL,BYTE PTR 0[BX]	;FETCH LAST PRINT POSITION 
 022D  3C 2E                 C  	CMP	AL,LOW "."      ;DECIMAL POINT? 
 022F  74 01                 C  	JZ	PFE90		;IF SO THIS JUMP WILL ELIMINATE 
 0231  43                    C  	INC	BX		;MUST RETAIN AS IS 
 0232  89 1E 0000 E          C  PFE90:	MOV	WORD PTR $DPADR,BX	;SAVE ADDRESS OF DECIMAL POINT 
 0236  58                    C  PFE100: POP	AX		;RECALL EXPONENT 
 0237  9D                    C  	POPF			;RECALL CF (=1 IF NO. IS ZERO) 
 0238  72 15                 C  	JB	PFE110		;JUMP IF NO. IS ZERO 
 023A  02 C4                 C  	ADD	AL,AH		;ADD EXP. AND NO SIG. DIGITS 
 023C  8A 26 0001 E          C  	MOV	AH,BYTE PTR $FMTCX+1	;SUBTRACT OUT DIGITS TO LEFT OF D.P. 
 0240  2A C4                 C  	SUB	AL,AH		;SUBTRACT DIGITS TO LEFT 
 0242  0A E4                 C  	OR	AH,AH		;IF NONE THEN NO SIGN 
 0244  74 09                 C  	JZ	PFE110 
 0246  F6 06 0000 E 04       C  	TEST	BYTE PTR $FMTAX,LOW 4	;IF SO WILL NEED TO INCREMENT AL 
 024B  75 02                 C  	JNZ	PFE110 
 024D  FE C0                 C  	INC	AL		;MUST ACCOUNT FOR SIGN POSITION 
 024F  0A C0                 C  PFE110: OR	AL,AL 
 0251  E8 0861 R             C  	CALL	$PUEXP		;PUT EXPONENT IN BUFFER 
                             C  				;$PUEXP IS LOCATED IN THE FILE WITH 
                             C  				;$FOFMT. WHEN HE FINISHES BUILDING 
                             C  				;THE EXPONENT IN $FBUFF HE LEAVES 
                             C  				;THE END-OF-BUFFER POINTER IN CX 
                             C  				;AND START OF BUFFER IN BX. 
 0254  8B D9                 C  	MOV	BX,CX		;MUST GO TO PUFXE WITH END OF 
                             C  				;BUFFER PTR. IN BX 
 0256  E9 006C R             C  	JMP	$PUFXE		;DO FIX-UP 
                             C   
                             C  	SUBTTL	 CON86	 8086 BASIC CONSTANTS 
                             C  ;***************************************************************** 
                             C  ; 
                             C  ;       THIS FILE CONTAINS 8086 CONSTANT TABLES 
                             C  ; 
                             C  ;***************************************************************** 
 0259                        C  $FOTB: 
 000A                        C  	.RADIX	10 
 0259  26 26 26 26 26 26 26  C  	DB	38,38,38,38,38,38,38,38 
       26                    C  
 0261  26 26 26 26 26 26 26  C  	DB	38,38,38,38,38,38,38,38 
       26                    C  
 0269  26 26 26 26 26 26 26  C  	DB	38,38,38,38,38,38,38,38 
       26                    C  
 0271  26 25 25 25 24 24 24  C  	DB	38,37,37,37,36,36,36,35 
       23                    C  
 0279  23 23 22 22 22 22 21  C  	DB	35,35,34,34,34,34,33,33 
       21                    C  
 0281  21 20 20 20 1F 1F 1F  C  	DB	33,32,32,32,31,31,31,31 
       1F                    C  
 0289  1E 1E 1E 1D 1D 1D 1D  C  	DB	30,30,30,29,29,29,29,28 
       1C                    C  
 0291  1C 1C 1B 1B 1B 1A 1A  C  	DB	28,28,27,27,27,26,26,26 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-18
CON86	 8086 BASIC CONSTANTS                                 

       1A                    C  
 0299  19 19 19 19 18 18 18  C  	DB	25,25,25,25,24,24,24,23 
       17                    C  
 02A1  17 17 17 16 16 16 16  C  	DB	23,23,23,22,22,22,22,21 
       15                    C  
 02A9  15 15 14 14 14 13 13  C  	DB	21,21,20,20,20,19,19,19 
       13                    C  
 02B1  13 12 12 12 11 11 11  C  	DB	19,18,18,18,17,17,17,16 
       10                    C  
 02B9  10 10 10 0F 0F 0F 0E  C  	DB	16,16,16,15,15,15,14,14 
       0E                    C  
 02C1  0E 0D 0D 0D 0D 0C 0C  C  	DB	14,13,13,13,13,12,12,12 
       0C                    C  
 02C9  0B 0B 0B 0A 0A 0A 0A  C  	DB	11,11,11,10,10,10,10,09 
       09                    C  
 02D1  09 09 08 08 08 07 07  C  	DB	09,09,08,08,08,07,07,07 
       07                    C  
 02D9  06 06 06 06 05 05 05  C  	DB	06,06,06,06,05,05,05,04 
       04                    C  
 02E1  04 04 03 03 03 03 02  C  	DB	04,04,03,03,03,03,02,02 
       02                    C  
 02E9  02 01 01 01 00 00 00  C  	DB	02,01,01,01,00,00,00,00 
       00                    C  
 02F1  FF FF FF FE FE FE FD  C  	DB	-01,-01,-01,-02,-02,-02,-03,-03 
       FD                    C  
 02F9  FD FD FC FC FC FB FB  C  	DB	-03,-03,-04,-04,-04,-05,-05,-05 
       FB                    C  
 0301  FA FA FA FA F9 F9 F9  C  	DB	-06,-06,-06,-06,-07,-07,-07,-08 
       F8                    C  
 0309  F8 F8 F7 F7 F7 F7 F6  C  	DB	-08,-08,-09,-09,-09,-09,-10,-10 
       F6                    C  
 0311  F6 F5 F5 F5 F4 F4 F4  C  	DB	-10,-11,-11,-11,-12,-12,-12,-12 
       F4                    C  
 0319  F3 F3 F3 F2 F2 F2 F1  C  	DB	-13,-13,-13,-14,-14,-14,-15,-15 
       F1                    C  
 0321  F1 F1 F0 F0 F0 EF EF  C  	DB	-15,-15,-16,-16,-16,-17,-17,-17 
       EF                    C  
 0329  EE EE EE EE ED ED ED  C  	DB	-18,-18,-18,-18,-19,-19,-19,-20 
       EC                    C  
 0331  EC EC EB EB EB EB EA  C  	DB	-20,-20,-21,-21,-21,-21,-22,-22 
       EA                    C  
 0339  EA E9 E9 E9 E8 E8 E8  C  	DB	-22,-23,-23,-23,-24,-24,-24,-25 
       E7                    C  
 0341  E7 E7 E7 E6 E6 E6 E5  C  	DB	-25,-25,-25,-26,-26,-26,-27,-27 
       E5                    C  
 0349  E5 E4 E4 E4 E4 E3 E3  C  	DB	-27,-28,-28,-28,-28,-29,-29,-29 
       E3                    C  
 0351  E2 E2 E2 E1 E1 E1 E1  C  	DB	-30,-30,-30,-31,-31,-31,-31,-32 
       E0                    C  
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;TABLE DXX CONTAINS DOUBLE PRECISION POWERS OF TEN 
                             C  ;FROM -38 TO +38 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-19
CON86	 8086 BASIC CONSTANTS                                 

                             C  ; 20-May-82 / MLC - Most of the negative powers of ten have been 
                             C  ; removed.  Routines which used to multiply by these negative powers of 
                             C  ; ten have been changed to divide by the corresponding positive power 
                             C  ; of ten.  ($FINE and $FOTNV) 
                             C  ; 
                             C  ;************************************************************* 
 0008                        C  	.RADIX	8 
 0359  CD CC CC CC CC CC 4C  C  $DPM01: DB	315,314,314,314,314,314,114,175 ;10^-01 
       7D                    C  
 0361  00 00 00 00 00 00 00  C  $DP00:	DB	000,000,000,000,000,000,000,201 ;10^00 
       81                    C  
 0369  00 00 00 00 00 00 20  C  $DP01:	DB	000,000,000,000,000,000,040,204 ;10^01 
       84                    C  
 0371  00 00 00 00 00 00 48  C  	DB	000,000,000,000,000,000,110,207 ;10^02 
       87                    C  
 0379  00 00 00 00 00 00 7A  C  	DB	000,000,000,000,000,000,172,212 ;10^03 
       8A                    C  
 0381  00 00 00 00 00 40 1C  C  	DB	000,000,000,000,000,100,034,216 ;10^04 
       8E                    C  
 0389  00 00 00 00 00 50 43  C  	DB	000,000,000,000,000,120,103,221 ;10^05 
       91                    C  
 0391  00 00 00 00 00 24 74  C  $DP06:	DB	000,000,000,000,000,044,164,224 ;10^06 
       94                    C  
 0399  00 00 00 00 80 96 18  C  $DP07:	DB	000,000,000,000,200,226,030,230 ;10^07 
       98                    C  
 03A1  00 00 00 00 20 BC 3E  C  	DB	000,000,000,000,040,274,076,233 ;10^08 
       9B                    C  
 03A9  00 00 00 00 28 6B 6E  C  $DP09:	DB	000,000,000,000,050,153,156,236 ;10^09 
       9E                    C  
 03B1  00 00 00 00 F9 02 15  C  	DB	000,000,000,000,371,002,025,242 ;10^10 
       A2                    C  
 03B9  00 00 00 40 B7 43 3A  C  	DB	000,000,000,100,267,103,072,245 ;10^11 
       A5                    C  
 03C1  00 00 00 10 A5 D4 68  C  	DB	000,000,000,020,245,324,150,250 ;10^12 
       A8                    C  
 03C9  00 00 00 2A E7 84 11  C  	DB	000,000,000,052,347,204,021,254 ;10^13 
       AC                    C  
 03D1  00 00 80 F4 20 E6 35  C  	DB	000,000,200,364,040,346,065,257 ;10^14 
       AF                    C  
 03D9  00 00 A0 31 A9 5F 63  C  	DB	000,000,240,061,251,137,143,262 ;10^15 
       B2                    C  
 03E1  00 00 04 BF C9 1B 0E  C  $DP16:	DB	000,000,004,277,311,033,016,266 ;10^16 
       B6                    C  
 03E9  00 00 C5 2E BC A2 31  C  	DB	000,000,305,056,274,242,061,271 ;10^17 
       B9                    C  
 03F1  00 40 76 3A 6B 0B 5E  C  	DB	000,100,166,072,153,013,136,274 ;10^18 
       BC                    C  
 03F9  00 E8 89 04 23 C7 0A  C  	DB	000,350,211,004,043,307,012,300 ;10^19 
       C0                    C  
 0401  00 62 AC C5 EB 78 2D  C  	DB	000,142,254,305,353,170,055,303 ;10^20 
       C3                    C  
 0409  80 7A 17 B7 26 D7 58  C  	DB	200,172,027,267,046,327,130,306 ;10^21 
       C6                    C  
 0411  90 AC 6E 32 78 86 07  C  	DB	220,254,156,062,170,206,007,312 ;10^22 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-20
CON86	 8086 BASIC CONSTANTS                                 

       CA                    C  
 0419  B4 57 0A 3F 16 68 29  C  	DB	264,127,012,077,026,150,051,315 ;10^23 
       CD                    C  
 0421  A1 ED CC CE 1B C2 53  C  	DB	241,355,314,316,033,302,123,320 ;10^24 
       D0                    C  
 0429  85 14 40 61 51 59 04  C  	DB	205,024,100,141,121,131,004,324 ;10^25 
       D4                    C  
 0431  A6 19 90 B9 A5 6F 25  C  	DB	246,031,220,271,245,157,045,327 ;10^26 
       D7                    C  
 0439  0F 20 F4 27 8F CB 4E  C  	DB	017,040,364,047,217,313,116,332 ;10^27 
       DA                    C  
 0441  0A 94 F8 78 39 3F 01  C  	DB	012,224,370,170,071,077,001,336 ;10^28 
       DE                    C  
 0449  0C B9 36 D7 07 8F 21  C  	DB	014,271,066,327,007,217,041,341 ;10^29 
       E1                    C  
 0451  4F 67 04 CD C9 F2 49  C  	DB	117,147,004,315,311,362,111,344 ;10^30 
       E4                    C  
 0459  23 81 45 40 7C 6F 7C  C  	DB	043,201,105,100,174,157,174,347 ;10^31 
       E7                    C  
 0461  B6 70 2B A8 AD C5 1D  C  	DB	266,160,053,250,255,305,035,353 ;10^32 
       EB                    C  
 0469  E3 4C 36 12 19 37 45  C  	DB	343,114,066,022,031,067,105,356 ;10^33 
       EE                    C  
 0471  1C E0 C3 56 DF 84 76  C  	DB	034,340,303,126,337,204,166,361 ;10^34 
       F1                    C  
 0479  11 6C 3A 96 0B 13 1A  C  	DB	021,154,072,226,013,023,032,365 ;10^35 
       F5                    C  
 0481  16 07 C9 7B CE 97 40  C  	DB	026,007,311,173,316,227,100,370 ;10^36 
       F8                    C  
 0489  DB 48 BB 1A C2 BD 70  C  	DB	333,110,273,032,302,275,160,373 ;10^37 
       FB                    C  
 0491  89 0D B5 50 99 76 16  C  	DB	211,015,265,120,231,166,026,377 ;10^38 
       FF                    C  
 0499                        C  $DHALF:			;DOUBLE PRECISION .5D00 
 0499  00                    C  	DB	000		;.5D00 
 049A  00                    C  	DB	000 
 049B  00                    C  	DB	000 
 049C  00                    C  	DB	000 
 049D                        C  $SHALF:			;SINGLE PRECISION .5E00 
 049D  00                    C  	DB	000		;.5E00 
 049E  00                    C  	DB	000 
 049F  00                    C  	DB	000 
 04A0  80                    C  	DB	200 
 04A1  F1                    C  $SQRH:	DB	361		;SQR(.5) 
 04A2  04                    C  	DB	004 
 04A3  35                    C  	DB	065 
 04A4  80                    C  	DB	200 
                             C  ;********************************************************** 
                             C  ;FOR LOG CALCULATIONS HART ALGORITHM 2524 WILL BE USED 
                             C  ;IN THIS ALGORITHM WE WILL CALCULATE BASE 2 LOG AS FOLLOWS 
                             C  ;LOG(X)=P(X)/Q(X) 
                             C  ;*************************************************************** 
 04A5  04                    C  $LOGP:	DB	4 
 04A6  9A                    C  	DB	232		;4.8114746 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-21
CON86	 8086 BASIC CONSTANTS                                 

 04A7  F7                    C  	DB	367 
 04A8  19                    C  	DB	031 
 04A9  83                    C  	DB	203 
 04AA  24                    C  	DB	044		;6.105852 
 04AB  63                    C  	DB	143 
 04AC  43                    C  	DB	103 
 04AD  83                    C  	DB	203 
 04AE  75                    C  	DB	165		;-8.86266 
 04AF  CD                    C  	DB	315 
 04B0  8D                    C  	DB	215 
 04B1  84                    C  	DB	204 
 04B2  A9                    C  	DB	251		;-2.054667 
 04B3  7F                    C  	DB	177 
 04B4  83                    C  	DB	203 
 04B5  82                    C  	DB	202 
 04B6  04                    C  $LOGQ:	DB	4 
 04B7  00                    C  	DB	000		;1. 
 04B8  00                    C  	DB	000 
 04B9  00                    C  	DB	000 
 04BA  81                    C  	DB	201 
 04BB  E2                    C  	DB	342		;6.427842 
 04BC  B0                    C  	DB	260 
 04BD  4D                    C  	DB	115 
 04BE  83                    C  	DB	203 
 04BF  0A                    C  	DB	012		;4.545171 
 04C0  72                    C  	DB	162 
 04C1  11                    C  	DB	021 
 04C2  83                    C  	DB	203 
 04C3  F4                    C  	DB	364		;.3535534 
 04C4  04                    C  	DB	004 
 04C5  35                    C  	DB	065 
 04C6  7F                    C  	DB	177 
                             C  ;LOG BASE E OF 2.0 
 04C7  18                    C  $LN2:	DB	030 
 04C8  72                    C  	DB	162 
 04C9  31                    C  	DB	061 
 04CA  80                    C  	DB	200 
 04CB                        C  $FINCH:			;SPECIAL CHARACTERS FOR INPUT/OUTPUT 
 04CB  2E                    C  	DB	"." 
 04CC  65                    C  	DB	OFFSET "E"+40   ;LOWER CASE "E" 
 04CD  45                    C  	DB	"E" 
 04CE  25                    C  	DB	"%" 
 04CF  23                    C  	DB	"#" 
 04D0  21                    C  	DB	"!" 
 04D1  44                    C  	DB	"D" 
 04D2  64                    C  	DB	OFFSET "D"+40   ;LOWER CASE "D" 
 04D3  2C                    C  	DB	54		;COMMA 
 04D4  30                    C  	DB	"0" 
 04D5  00                    C  $FODTB: DB	000		; 1D15 
 04D6  80                    C  	DB	200 
 04D7  C6                    C  	DB	306 
 04D8  A4                    C  	DB	244 
 04D9  7E                    C  	DB	176 
 04DA  8D                    C  	DB	215 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-22
CON86	 8086 BASIC CONSTANTS                                 

 04DB  03                    C  	DB	003 
 04DC  00                    C  	DB	000		; 1D14 
 04DD  40                    C  	DB	100 
 04DE  7A                    C  	DB	172 
 04DF  10                    C  	DB	020 
 04E0  F3                    C  	DB	363 
 04E1  5A                    C  	DB	132 
 04E2  00                    C  	DB	000 
 04E3  00                    C  	DB	000		; 1D13 
 04E4  A0                    C  	DB	240 
 04E5  72                    C  	DB	162 
 04E6  4E                    C  	DB	116 
 04E7  18                    C  	DB	030 
 04E8  09                    C  	DB	011 
 04E9  00                    C  	DB	000 
 04EA  00                    C  	DB	000		; 1D12 
 04EB  10                    C  	DB	020 
 04EC  A5                    C  	DB	245 
 04ED  D4                    C  	DB	324 
 04EE  E8                    C  	DB	350 
 04EF  00                    C  	DB	000 
 04F0  00                    C  	DB	000 
 04F1  00                    C  	DB	000		; 1D11 
 04F2  E8                    C  	DB	350 
 04F3  76                    C  	DB	166 
 04F4  48                    C  	DB	110 
 04F5  17                    C  	DB	027 
 04F6  00                    C  	DB	000 
 04F7  00                    C  	DB	000 
 04F8  00                    C  	DB	000		; 1D10 
 04F9  E4                    C  	DB	344 
 04FA  0B                    C  	DB	013 
 04FB  54                    C  	DB	124 
 04FC  02                    C  	DB	002 
 04FD  00                    C  	DB	000 
 04FE  00                    C  	DB	000 
 04FF  00                    C  	DB	000		; 1D9 
 0500  CA                    C  	DB	312 
 0501  9A                    C  	DB	232 
 0502  3B                    C  	DB	073 
 0503  00                    C  	DB	000 
 0504  00                    C  	DB	000 
 0505  00                    C  	DB	000 
 0506  00                    C  	DB	000		; 1D8 
 0507  E1                    C  	DB	341 
 0508  F5                    C  	DB	365 
 0509  05                    C  	DB	005 
 050A  00                    C  	DB	000 
 050B  00                    C  	DB	000 
 050C  00                    C  	DB	000 
 050D  80                    C  	DB	200		; 1D7 
 050E  96                    C  	DB	226 
 050F  98                    C  	DB	230 
 0510  00                    C  	DB	000 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-23
CON86	 8086 BASIC CONSTANTS                                 

 0511  00                    C  	DB	000 
 0512  00                    C  	DB	000 
 0513  00                    C  	DB	000 
 0514  40                    C  	DB	100		; 1D6 
 0515  42                    C  	DB	102 
 0516  0F                    C  	DB	017 
 0517  00                    C  	DB	000 
 0518  00                    C  	DB	000 
 0519  00                    C  	DB	000 
 051A  00                    C  	DB	000 
                             C  ;SINGLE PRECISION POWER OF TEN TABLE 
 051B  40                    C  $FOSTB: DB	100		;1,000,000 
 051C  42                    C  	DB	102 
 051D  0F                    C  	DB	017 
 051E  A0                    C  	DB	240		; 1E5 
 051F  86                    C  	DB	206 
 0520  01                    C  	DB	001 
 0521  10                    C  	DB	020		; 1E4 
 0522  27                    C  	DB	047 
 0523  00                    C  	DB	000 
                             C  ;INTEGER POWER OF TEN TABLE 
 0524  10                    C  $FOITB: DB	020		; 10000 
 0525  27                    C  	DB	047 
 0526  E8                    C  	DB	350		; 1000 
 0527  03                    C  	DB	003 
 0528  64                    C  	DB	144		; 100 
 0529  00                    C  	DB	000 
 052A  0A                    C  	DB	012		; 10 
 052B  00                    C  	DB	000 
 052C  01                    C  	DB	001		; 1 
 052D  00                    C  	DB	000 
 052E  00                    C  $S32KM: DB	000		;SINGLE PRECISION -32768 
 052F  00                    C  	DB	000 
 0530  80                    C  	DB	200 
 0531  90                    C  	DB	220 
 0532  FF                    C  $INFPD: DB	377		;DOUBLE PRECISION +INFINITY 
 0533  FF                    C  	DB	377 
 0534  FF                    C  	DB	377 
 0535  FF                    C  	DB	377 
 0536  FF                    C  	DB	377		;SINGLE PREC. +INFINITY 
 0537  FF                    C  	DB	377 
 0538  7F                    C  	DB	177 
 0539  FF                    C  	DB	377 
                             C   
 053A  FF                    C  $INFMD: DB	377		;DOUBLE PRECISION -INFINITY 
 053B  FF                    C  	DB	377 
 053C  FF                    C  	DB	377 
 053D  FF                    C  	DB	377 
 053E  FF                    C  	DB	377		;SINGLE PREC. -INFINITY 
 053F  FF                    C  	DB	377 
 0540  FF                    C  	DB	377 
 0541  FF                    C  	DB	377 
 0542  3B                    C  $LG2E:	DB	073		;LOG BASE 2 OF E 
 0543  AA                    C  	DB	252 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-24
CON86	 8086 BASIC CONSTANTS                                 

 0544  38                    C  	DB	070 
 0545  81                    C  	DB	201 
                             C  ;********************************************************* 
                             C  ;$EXPCN CONTAINS THE COEFFICIENTS FOR POLYNOMIAL EVALUATION 
                             C  ;OF LOG BASE 2 OF X WHERE .5.LE.X.LE.1 
                             C  ;THE COEFFICIENTS ARE FROM HART #1302 
                             C  ;*********************************************************** 
 0546  07                    C  $EXPCN: DB	7		;DEGREE + 1 
 0547  7C                    C  	DB	174		;.00020745577403- 
 0548  88                    C  	DB	210 
 0549  59                    C  	DB	131 
 054A  74                    C  	DB	164 
 054B  E0                    C  	DB	340		;.00127100574569- 
 054C  97                    C  	DB	227 
 054D  26                    C  	DB	046 
 054E  77                    C  	DB	167 
 054F  C4                    C  	DB	304		;.00965065093202+ 
 0550  1D                    C  	DB	035 
 0551  1E                    C  	DB	036 
 0552  7A                    C  	DB	172 
 0553  5E                    C  	DB	136		;.05549656508324+ 
 0554  50                    C  	DB	120 
 0555  63                    C  	DB	143 
 0556  7C                    C  	DB	174 
 0557  1A                    C  	DB	032		;.24022713817633- 
 0558  FE                    C  	DB	376 
 0559  75                    C  	DB	165 
 055A  7E                    C  	DB	176 
 055B  18                    C  	DB	030		;.69314717213716+ 
 055C  72                    C  	DB	162 
 055D  31                    C  	DB	061 
 055E  80                    C  	DB	200 
 055F  00                    C  	DB	000		;1.0 
 0560  00                    C  	DB	000 
 0561  00                    C  	DB	000 
 0562  81                    C  	DB	201 
 0563                        C  $SINCN: 
                             C  ;       COEFFICIENTS FOR SINE FUNCTION 
                             C  ;       SEE HART'S #3341 
                             C  ;       RELATIVE ERROR 8.27 
                             C   
 0563  05                    C  	DB	5		;NUMBER OF CONSTANTS 
 0564  FB                    C  	DB	373		;39.71091766+ 
 0565  D7                    C  	DB	327 
 0566  1E                    C  	DB	036 
 0567  86                    C  	DB	206 
 0568  65                    C  	DB	145		;-76.57498378- 
 0569  26                    C  	DB	046 
 056A  99                    C  	DB	231 
 056B  87                    C  	DB	207 
 056C  58                    C  	DB	130		;81.60223119+ 
 056D  34                    C  	DB	064 
 056E  23                    C  	DB	043 
 056F  87                    C  	DB	207 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-25
CON86	 8086 BASIC CONSTANTS                                 

 0570  E1                    C  	DB	341		;-41.34167747+ 
 0571  5D                    C  	DB	135 
 0572  A5                    C  	DB	245 
 0573  86                    C  	DB	206 
 0574  DB                    C  	DB	333		;6.283185272+ 
 0575  0F                    C  	DB	017 
 0576  49                    C  	DB	111 
 0577  83                    C  	DB	203 
 0578                        C  $ATNC1:			;CONSTANTS FOR ARCTANGENT RANGE REDUCTION 
 0578  02                    C  	DB	2 
 0579  D7                    C  	DB	327		;SQR(3) 
 057A  B3                    C  	DB	263 
 057B  5D                    C  	DB	135 
 057C  81                    C  	DB	201 
 057D  00                    C  	DB	000		;-1.0 
 057E  00                    C  	DB	000 
 057F  80                    C  	DB	200 
 0580  81                    C  	DB	201 
 0581                        C  $ATNC2:			;HART ALGORITHM 4940 COEFFICIENTS 
 0581  04                    C  	DB	4 
 0582  62                    C  	DB	142		;-.1281333 
 0583  35                    C  	DB	065 
 0584  83                    C  	DB	203 
 0585  7E                    C  	DB	176 
 0586  50                    C  	DB	120		;.1993573 
 0587  24                    C  	DB	044 
 0588  4C                    C  	DB	114 
 0589  7E                    C  	DB	176 
 058A  79                    C  	DB	171		;-.3333324 
 058B  A9                    C  	DB	251 
 058C  AA                    C  	DB	252 
 058D  7F                    C  	DB	177 
 058E  00                    C  	DB	000		;1.0 
 058F  00                    C  	DB	000 
 0590  00                    C  	DB	000 
 0591  81                    C  	DB	201 
                             C  ;************************************************************ 
                             C  ;THE FOLLOWING CONSTANT LABELED $IN2PI IS USED FOR RANGE 
                             C  ;REDUCTION IN SIN,COS, & TAN. THE LOW ORDER BYTES ARE PURPOSELY 
                             C  ;ZERO TO PROVIDE A MORE ACCURATE REDUCTION OF SINGLE PRECISION 
                             C  ;NUMBERS. THIS CONSTANT SHOULD NOT BE USED WITH ORDINARY DOUBLE 
                             C  ;PRECISION NUMBERS. 
                             C  ;************************************************************ 
 0592  0B                    C  $IN2PI: DB	013		;1/(2*PI) 
 0593  44                    C  	DB	104 
 0594  4E                    C  	DB	116 
 0595  6E                    C  	DB	156 
 0596  83                    C  	DB	203 
 0597  F9                    C  	DB	371 
 0598  22                    C  	DB	042 
 0599  7E                    C  	DB	176 
                             C  ;*********************************************************** 
                             C  ;CONSTANTS FOR THE RANDOM NUMBER GENERATOR FOLLOW 
                             C  ;DO NOT CHANGE THESE WITHOUT CONSULTING KNUTH VOL 2 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-26
CON86	 8086 BASIC CONSTANTS                                 

                             C  ;CHAPTER 3 FIRST 
                             C  ;************************************************************ 
 059A  FD                    C  $RNDA:	DB	375		;214013 
 059B  43                    C  	DB	103 
 059C  03                    C  	DB	003 
 059D  C3                    C  $RNDC:	DB	303		;2531011 
 059E  9E                    C  	DB	236 
 059F  26                    C  	DB	046 
 05A0  01                    C  $RND0:	DB	001 
 05A1  00                    C  	DB	000		;1 
 05A2  00                    C  	DB	000 
 05A3  30                    C  $NUMB:	DB	"0"	      ;TABLE FOR OCTAL/HEX OUTPUT 
 05A4  31                    C  	DB	"1" 
 05A5  32                    C  	DB	"2" 
 05A6  33                    C  	DB	"3" 
 05A7  34                    C  	DB	"4" 
 05A8  35                    C  	DB	"5" 
 05A9  36                    C  	DB	"6" 
 05AA  37                    C  	DB	"7" 
 05AB  38                    C  	DB	"8" 
 05AC  39                    C  	DB	"9" 
 05AD  41                    C  	DB	"A" 
 05AE  42                    C  	DB	"B" 
 05AF  43                    C  	DB	"C" 
 05B0  44                    C  	DB	"D" 
 05B1  45                    C  	DB	"E" 
 05B2  46                    C  	DB	"F" 
                             C   
                             C  	SUBTTL	 $SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT 
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;       $SIN,$COS,$TAN  CALCULATE THE SINE/COSINE/TAN OF NO. 
                             C  ;                       IN THE $FAC.USES HART POLYNOMIAL EVALUATION 
                             C  ;                       WITH COEFFICIENTS FROM #3341 
                             C  ;       CALLING SEQUENCE:       CALL    $SIN 
                             C  ;                       OR      CALL    $COS 
                             C  ;                       OR      CALL    $TAN 
                             C  ;                       WITH ARGUMENT IN THE $FAC 
                             C  ; 
                             C  ;       $ATAN           CALCULATE THE ARCTANGENT OF THE VALUE IN THE 
                             C  ;                       FAC. USES COEFFICIENTS FROM HART 4940 
                             C  ;       CALLING SEQUENCE:       CALL    $ATAN 
                             C  ;                       WITH THE ARGUMENT IN THE FAC 
                             C  ; 
                             C  ;       Changed COS to double precision range reduction 24-JUN-82/NGT 
                             C  ; 
                             C  ;****************************************************************** 
                             C   
                             C   
 05B3                        C  COS: 
 05B3                        C  $COS: 
 05B3  80 26 0000 E 7F       C  	AND	BYTE PTR $FACM1,LOW 177O	;clear sign bit ( cos(-x) = cos(x) ) 
 05B8  E8 063F R             C  	CALL	RR		; Do range reduction, FAC=REM(FAC/2pi) 
 05BB  E8 0661 R             C  	CALL	ONEARG		; Zero the accumulator 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-27
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

 05BE  C6 06 0000 E 7F       C  	MOV	BYTE PTR $ARG,LOW 177O	; ARG = DP 1/4 
 05C3  E8 12E7 R             C  	CALL	$FADDD		; FAC = reduced angle + PI/2 
 05C6  E8 064B R             C  	CALL	RR1		; Make sure we are still in 0 - 2*PI 
 05C9  EB 19                 C  	JMP	SHORT SIN30 
                             C   
 05CB                        C  SIN: 
 05CB                        C  $SIN:				;Will now take advantage of identity SIN(-X)=-SIN(X) 
 05CB  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;FETCH SIGN BYTE 
 05CE  80 FC 77              C  	CMP	AH,LOW 167O	;IF EXP SMALLER THEN RETURN X 
 05D1  73 01                 C  	JNB	SIN10 
 05D3  C3                    C  	RET 
 05D4                        C  SIN10: 
 05D4  0A C0                 C  	OR	AL,AL 
 05D6  79 09                 C  	JNS	SIN20 
                             C  ;(FAC) is negative will make positive and push neg on stack 
 05D8  24 7F                 C  	AND	AL,LOW 177O	;CLEAR SIGN BYTE 
 05DA  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL 
 05DD  B8 0B25 R             C  	MOV	AX,OFFSET $NEG	;FETCH ADDRESS OF NEG 
 05E0  50                    C  	PUSH	AX		;AND PUSH ON STACK 
 05E1                        C  SIN20: 
 05E1  E8 063F R             C  	CALL	RR		; Do DP range reduction 
                             C  ; 
                             C  ; At this point the FAC has the remainder of the angle / 2*PI 
                             C  ; 
 05E4                        C  SIN30: 
                             C  ; 
                             C  ; The next instruction was originally: 
                             C  ; 
                             C  ;	MOV	AL,LOW OFFSET $FAC 
                             C  ; 
                             C  ; but as written, it makes little sense, because it's loading a constant 
                             C  ; (the low 8 bits of the address of $FAC) into AL.  Someone else eventually 
                             C  ; noticed this too, because in BASICA.EXE for COMPAQ DOS 3.00, this same 
                             C  ; sequence of instructions now looks like: 
                             C  ; 
                             C  ;	MOV	AL,[05EB] 
                             C  ;	OR	AL,AL 
                             C  ;	JZ	D475 
                             C  ;	ADD	Byte Ptr [05EB],2 
                             C  ; 
 05E4  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC 
 05E7  0A C0                 C  	OR	AL,AL 
 05E9  74 05                 C  	JZ	SIN31 
 05EB  80 06 0000 E 02       C  	ADD	BYTE PTR $FAC,LOW 2	; FAC = FAC*4 = Reduce angle / PI/2 
 05F0                        C  SIN31: 
 05F0  E8 0654 R             C  	CALL	RR3		;ARG= INT(FAC) 
                             C  ; 
                             C  ; Now we have the reduced angle mod PI/2, so that we can find what quadrant 
                             C  ; it's in.  The FAC should have a value in the range 0-3 corresponding to 
                             C  ; the quadrant.  If the value is 2 or 3, corresponding to the interval 
                             C  ; PI - 2*PI, we must return a negative value for the Sine.  If the value is 
                             C  ; in quadrants 1 or 3, we must subtract the reduced angle from 1 (PI/2). 
                             C  ; Algorithm: 
                             C  ;       FAC = (angle / (2*PI))*4      ; Yields number in 0.LE.FAC.LT.4 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-28
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

                             C  ;       Save FAC 
                             C  ;       ARG = INT( FAC )            ; ARG = quadrant 0-3 
                             C  ;       Restore FAC 
                             C  ;       FAC = (FAC - ARG)/4         ; FAC = angle in range 0 - PI/2 
                             C  ;       IF quadrant = 1 or 3 THEN 
                             C  ;           FAC = 1 - FAC           ; FAC = PI/2 - angle 
                             C  ;       Calculate polynomial 
                             C  ;       IF quadrant = 2 or 3 THEN 
                             C  ;           Negate result           ; Negative for PI - 2*PI 
                             C  ; 
                             C  ;         LOW              HIGH (octal bytes) 
                             C  ; D.P. 0 = 0,0,0,0,0,0,000,000 
                             C  ; D.P. 1 = 0,0,0,0,0,0,000,201 
                             C  ; D.P. 2 = 0,0,0,0,0,0,000,202      ; Which implies that FAC = 202 for 2 and 3 
                             C  ; D.P. 3 = 0,0,0,0,0,0,100,202 
                             C  ; 
 05F3  A1 FFFF E             C  	MOV	AX,WORD PTR $ARG-1 
 05F6  80 FC 82              C  	CMP	AH,LOW 202O	; ARG now has quadrant information 
 05F9  9C                    C  	PUSHF			; Z set if we need to negate when done 
 05FA  F6 C4 01              C  	TEST	AH,LOW 1	; Now set NZ if in quadrant 1 
 05FD  75 02                 C  	JNZ	SIN40 
 05FF  A8 40                 C  	TEST	AL,LOW 100O	; Set NZ if in quadrant 3 
 0601                        C  SIN40: 
 0601  9C                    C  	PUSHF			; NZ if we must subtract from 1 
 0602  E8 064E R             C  	CALL	RR2		; FAC = X-INT(X) = angle MOD PI/2 
 0605  9D                    C  	POPF 
 0606  74 09                 C  	JZ	SIN50		; Nothing more to do, calculate the SIN 
 0608  BB 0361 R             C  	MOV	BX,OFFSET $DP00 ; Point to a D.P. 1 (10^0) 
 060B  E8 09D0 R             C  	CALL	$MOVAC		; ARG = 1 
 060E  E8 12DB R             C  	CALL	$FSUBD		; FAC = 1 - FAC = PI/2 - angle MOD PI/2 
 0611                        C  SIN50: 
 0611  80 2E 0000 E 02       C  	SUB	BYTE PTR $FAC,LOW 2	; FAC = FAC/4 = ( angle / 2*PI ) 
 0616  73 03                 C  	JNB	SIN51 
 0618  E8 08A8 R             C  	CALL	$DZERO		;Return 0 if Underflow 
 061B                        C  SIN51: 
 061B  E8 17AE R             C  	CALL	$CSD		; Convert DP reduced angle back to SP 
 061E  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;WILL SEE IF SMALL ENOUGH 
                             C  				;SUCH THAT X=SIN(X) 
 0621  3C 74                 C  	CMP	AL,LOW 164O	;IF FAC SMALLER THAN THIS JUST 
 0623  73 0B                 C  	JNB	SIN60 
 0625  BA 0FDB               C  	MOV	DX,7733O	;2*PI 
 0628  BB 8349               C  	MOV	BX,101511O 
 062B  E8 1921 R             C  	CALL	$FMULS 
 062E  EB 06                 C  	JMP	SHORT SIN65	; Go set sign properly 
 0630                        C  SIN60: 
 0630  BB 0563 R             C  	MOV	BX,OFFSET $SINCN	;POINT TO HART 3341 COEFFS. 
 0633  E8 1D1B R             C  	CALL	$POLYX		;EVALUATE THE POLYNOMIAL 
 0636                        C  SIN65: 
 0636  9D                    C  	POPF			;RECALL SIGN 
 0637  75 05                 C  	JNZ	SIN70 
 0639  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200O	;FLIP SIGN 
 063E                        C  SIN70: 
 063E  C3                    C  	RET 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-29
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

                             C  ; Converts FAC to double precision and reduces the result to a 
                             C  ; value in the range 0 - 2*PI. 
                             C  ; The RR1 entry point can be used to extract the fractional part of the FAC. 
                             C  ;DOUBLE PRECISION REDUCTION OF RANGE BY 2*PI 
                             C  ; 
 063F                        C  RR: 
 063F  BB 0592 R             C  	MOV	BX,OFFSET $IN2PI	;POINT TO 1/(2*PI) 
 0642  E8 09D0 R             C  	CALL	$MOVAC		;MOVE TO ARG 
 0645  E8 17DB R             C  	CALL	$CDS		;CONVERT TO DOUBLE 
 0648  E8 1877 R             C  	CALL	$FMULD		;X 
 064B                        C  RR1: 
 064B  E8 0654 R             C  	CALL	RR3 
 064E                        C  RR2: 
 064E  E8 12DB R             C  	CALL	$FSUBD		;INT(X)-X 
 0651  E9 0B25 R             C  	JMP	$NEG		;X-INT(X) 
 0654                        C  RR3: 
 0654  E8 0BB6 R             C  	CALL	$VPSHF		;SAVE X 
 0657  E8 1B69 R             C  	CALL	$DINT		;($FAC)=INT(X) 
 065A  E8 09E8 R             C  	CALL	$MOVAF		;SAVE IN ARG 
 065D  E8 0BD5 R             C  	CALL	$VPOPF		;FETCH X 
 0660  C3                    C  	RET 
 0661                        C  ONEARG: 
 0661  BB 0361 R             C  	MOV	BX,OFFSET $DP00 
 0664  E9 09D0 R             C  	JMP	$MOVAC 
                             C   
                             C   
                             C   
                             C  ; 
                             C  ; Tangent Code 
                             C  ; 
 0667                        C  TAN: 
 0667  FF 36 0000 E          C  $TAN:	PUSH	WORD PTR $FACM1 ;SAVE ARG 
 066B  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 066F  E8 05CB R             C  	CALL	$SIN		;CALCULATE SINE 
 0672  5A                    C  	POP	DX		;RECALL ARGUMENT 
 0673  5B                    C  	POP	BX 
 0674  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE SIN(X) 
 0678  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 067C  E8 0A06 R             C  	CALL	$MOVFR		;MOVE ORIGINAL ARG TO FAC 
 067F  E8 05B3 R             C  	CALL	$COS		;CALCULATE COSINE 
 0682  5B                    C  	POP	BX		;RECALL SIN(X) 
 0683  5A                    C  	POP	DX 
 0684  E9 15DA R             C  	JMP	$FDIVS		;GO DIVIDE TO EFFECT TANGENT 
 0687                        C  ATN: 
 0687                        C  $ATAN:				;(FAC)=ARCTANGENT(FAC) 
 0687  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;WANT ONLY POSITIVE X 
 068A  0A C0                 C  	OR	AL,AL 
 068C  79 09                 C  	JNS	ATN10 
 068E  BF 0B25 R             C  	MOV	DI,OFFSET $NEG	;TAKE ADVANTAGE OF IDENTITY 
 0691  57                    C  	PUSH	DI		;ATAN(X)=-ATAN(-X) 
 0692  24 7F                 C  	AND	AL,LOW 177	;CLEAR SIGN 
 0694  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL 
 0697  80 FC 81              C  ATN10:	CMP	AH,LOW 201	;SEE IF X .GT. TAN(PI/4) 
 069A  72 0C                 C  	JB	ATN20		;IF NOT PROCEED 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-30
$SIN	 SINGLE PRECISION SINE/COSINE/TANGENT/ARCTANGENT       

 069C  BF 06F3 R             C  	MOV	DI,OFFSET ATN100	;WILL WANT TO FORM 
 069F  57                    C  	PUSH	DI		;PI/2-(FAC) AT THE END 
 06A0  33 D2                 C  	XOR	DX,DX		;WILL SET (BXDX)=1.0 
 06A2  BB 8100               C  	MOV	BX,100400 
 06A5  E8 15DA R             C  	CALL	$FDIVS		;THIS PUTS 1/X IN FAC 
 06A8  BA 30A2               C  ATN20:	MOV	DX,30242	;FETCH TAN(PI/12) 
 06AB  BB 7F09               C  	MOV	BX,77411 
 06AE  E8 0A41 R             C  	CALL	$FCOMP		;SEE IF LARGER 
 06B1  78 3A                 C  	JS	ATN30		;IF NOT PROCEED 
 06B3  BF 06FC R             C  	MOV	DI,OFFSET ATN200	;WILL WANT (FAC)=(FAC)+PI/6 
 06B6  57                    C  	PUSH	DI		;AT THE END 
 06B7  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE X 
 06BB  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 06BF  BA B3D7               C  	MOV	DX,131727	;FETCH SQR(3) 
 06C2  BB 815D               C  	MOV	BX,100535 
 06C5  E8 13A3 R             C  	CALL	$FADDS		;(FAC)=X+SQR(3) 
 06C8  5B                    C  	POP	BX 
 06C9  5A                    C  	POP	DX		;FETCH X BACK 
 06CA  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE X+SQR(3) 
 06CE  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 06D2  E8 0A06 R             C  	CALL	$MOVFR		;X TO FAC 
 06D5  BB 0578 R             C  	MOV	BX,OFFSET $ATNC1 
 06D8  E8 1D34 R             C  	CALL	$POLY		;FORM X*SQR(3)-1 
 06DB  5B                    C  	POP	BX 
 06DC  5A                    C  	POP	DX		;RECALL X+SQR(3) 
 06DD  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;PUSH X*SQR(3)-1 ON STACK 
 06E1  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 06E5  E8 0A06 R             C  	CALL	$MOVFR		;X+SQR(3) TO FAC 
 06E8  5B                    C  	POP	BX 
 06E9  5A                    C  	POP	DX		;RECALL X*SQR(3)-1 
 06EA  E8 15DA R             C  	CALL	$FDIVS		;FORM (X+SQR(3)-1)/(X+SQR(3)) 
 06ED  BB 0581 R             C  ATN30:	MOV	BX,OFFSET $ATNC2	;PREPARE FOR HART 4940 
 06F0  E9 1D1B R             C  	JMP	$POLYX 
 06F3  BA 0FDB               C  ATN100: MOV	DX,7733	;FETCH PI/2 
 06F6  BB 8149               C  	MOV	BX,100511 
 06F9  E9 1397 R             C  	JMP	$FSUBS		;(FAC)=PI/2-(FAC) 
                             C   
 06FC  BA 0A92               C  ATN200: MOV	DX,5222	;FETCH PI/6 
 06FF  BB 8006               C  	MOV	BX,100006 
 0702  E9 13A3 R             C  	JMP	$FADDS		;ADD PI/6 TO FAC 
                             C   
                             C  	SUBTTL	 $FINE	 ROUTINE TO ADJUST INPUT NUMBER FOR EXPONENT 
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;       $FINE   THIS ROUTINE MODIFIES THE CURRENT FAC WHICH HAS 
                             C  ;               THE INPUT SIGNIFICANT DIGITS SO THAT THE EXPONENT 
                             C  ;               IS REFLECTED IN THE NUMBER. FOR EXAMPLE, IF THE 
                             C  ;               NUMBER INPUT IS 1.9876E-17 THEN THE FAC CURRENTLY 
                             C  ;               HAS THE NUMBER 19876. IT MUST BE MULTIPLIED BY 
                             C  ;               10^-21 TO CORRECTLY REFLECT THE INPUT NUMBER. 
                             C  ;               IT IS THE JOB OF THIS ROUTINE TO DETERMINE THE 
                             C  ;               CORRECT MULTIPLIER AND PERFORM THE MULTIPLICATION 
                             C  ;       CALLING SEQUENCE        CALL    $FINE 
                             C  ;               WITH (SI) CONTAINING 0 IF POSITIVE EXPONENT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-31
$FINE	 ROUTINE TO ADJUST INPUT NUMBER FOR EXPONENT          

                             C  ;               ALL BITS SET IF NEGATIVE EXPONENT. (DX) CONTAINS 
                             C  ;               THE INPUT EXPONENT(FOR THE EXAMPLE ABOVE =17) 
                             C  ;               AND (DI) CONTAINS THE NUMBER PLACES TO THE RIGHT 
                             C  ;               OF THE DECIMAL POINT. 
                             C  ; 
                             C  ;***************************************************************** 
                             C   
 0705  0B F6                 C  $FINE:	OR	SI,SI		;SEE IF DX SHOULD BE NEGATED 
 0707  79 02                 C  	JNS	FIN05		;IF NOT PROCEED 
 0709  F7 DA                 C  	NEG	DX		;NEGATE 
 070B  2B D7                 C  FIN05:	SUB	DX,DI		;SUBTRACT OUT DIGITS TO RIGHT OF DP. 
 070D  70 44                 C  	JO	FIN80		;UNDERFLOW IF OVERFLOW FLAG SET 
 070F  74 41                 C  	JZ	FIN55		;NUMBER COMPLETE AS IS 
                             C  ;*************************************************************** 
                             C  ;HERE WE HAVE THE EXPONENT IN DX. WE HAVE MULTIPLIERS RANGING 
                             C  ;FROM (10^-38,10^38) TO USE IN DETERMINING THE CORRECT FAC. WE 
                             C  ;MAY NEED TO DO SEVERAL MULTIPLIES TO CORRECTLY FORM THE NUMBER. 
                             C  ;FOR EXAMPLE IF THE NUMBER INPUT WAS 1234567.E-40 DX WOULD 
                             C  ;HAVE -40. IF THIS WERE THE CASE WE NEED TO DO A MULTIPLY BY 10^-38 
                             C  ;THEN A MULTIPLY BY 10^-2 TO GET THE RIGHT NUMBER. 
                             C  ;  All calculations are done in double precision and then converted 
                             C  ;back to the original type.  Integers are converted to single precision. 
                             C  ;**************************************************************** 
 0711                        C  MDPTEN: 
 0711  53                    C  	PUSH	BX		; Preserve text pointer 
 0712  E8 08EF R             C  	CALL	$GETYP		; Get the current type, 
 0715  9C                    C  	PUSHF			; And save, so that we can convert back 
 0716  73 03                 C  	JNB	FIN20		; If already D.P., no conversion necessary 
 0718  E8 17CC R             C  	CALL	FRCDBL		; Force result to be double precision 
 071B  0B D2                 C  FIN20:	OR	DX,DX		; Test sign of exponent 
 071D  78 16                 C  	JS	FIN30		;IF NEGATIVE EXPONENT JUMP 
                             C  ;******************************************************************** 
                             C  ;POSITIVE EXPONENT . IF GREATER THAN D^38 THEN WE HAVE OVERFLOW 
                             C  ; Unless the number is zero, in which case just return zero. 
                             C  ;******************************************************************** 
 071F  F6 06 0000 E FF       C  	TEST	BYTE PTR $FAC,LOW 377O	;Is the number zero? 
 0724  74 2D                 C  	JZ	FIN80		;Yes, just return zero then. 
 0726  83 FA 27              C  	CMP	DX,39D 
 0729  72 1D                 C  	JB	FIN40		;OK PROCEED 
 072B  9D                    C  	POPF			; Get back type flags 
 072C  73 03                 C  	JNB	FIN25		; Already D.P., nothing to convert 
 072E  E8 17AE R             C  	CALL	$CSD		; Convert double to single 
 0731  5B                    C  FIN25:	POP	BX		; Restore text pointer 
 0732  EB 42 90              C  	JMP	$OVFLS		;OVERFLOW 
                             C  ; 
                             C  ; Negative exponent. 
                             C  ; Might require two divisions since highest table entry is 10^38. 
                             C  ; 
 0735  83 FA DA              C  FIN30:	CMP	DX,-38D	;Will one pass be enough? 
 0738  7D 0E                 C  	JGE	FIN40		;Yes. 
 073A  83 C2 26              C  	ADD	DX,38D		;No, will two divisions get it? 
 073D  83 FA DA              C  	CMP	DX,-38D 
 0740  7C 11                 C  	JL	FIN80		;No, underflow - return zero. 
 0742  E8 0758 R             C  	CALL	MDP10		;Yes, do the first one 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-32
$FINE	 ROUTINE TO ADJUST INPUT NUMBER FOR EXPONENT          

 0745  BA FFDA               C  	MOV	DX,-38D	;Then divide by 10^38. 
 0748  E8 0758 R             C  FIN40:	CALL	MDP10		; Do the division 
 074B  9D                    C  FIN45:	POPF			; Get back type flags 
 074C  73 03                 C  	JNB	FIN50		; Already D.P., nothing to convert 
 074E  E8 17AE R             C  	CALL	$CSD		; Convert double to single 
                             C   
                             C  ; At this point the number is restored to its original type, with the 
                             C  ; exception of integers being converted to single precision. 
                             C   
 0751  5B                    C  FIN50:	POP	BX		; Restore text pointer 
 0752  C3                    C  FIN55:	RET 
                             C   
 0753  E8 08B5 R             C  FIN80:	CALL	$ZERO		;UNDERFLOW! 
 0756  EB F3                 C  	JMP	SHORT FIN45	; Restore proper type 
                             C   
                             C  ; 
                             C  ; Multiply or divide by double precision power of ten. 
                             C  ; On entry DX contains the exponent. 
                             C  ; If the exponent is postive, multiply. 
                             C  ; If exponent is negaive, divide. 
                             C  ; 
                             C   
 0758                        C  MDP10: 
 0758  0B D2                 C  	OR	DX,DX		;Is the exponent negative? 
 075A  9C                    C  	PUSHF			;Remember whether to multiply or 
                             C  				;divide. 
 075B  79 02                 C  	JNS	POSEXP		;Positive exponent. 
 075D  F7 DA                 C  	NEG	DX		;Negative exponent, make it positive. 
 075F  B9 0003               C  POSEXP: MOV	CX,3		;DX:=DX*8 to get offset into powers 
 0762  D3 E2                 C  	SHL	DX,CL		;of ten table. 
 0764  81 C2 0361 R          C  	ADD	DX,OFFSET $DP00 ;DX:=pointer to power of ten. 
 0768  87 DA                 C  	XCHG	BX,DX		;Move it to BX. 
 076A  E8 09D0 R             C  	CALL	$MOVAC		;MOVE D.P. NO. TO ARG 
 076D  9D                    C  	POPF			;Divide? 
 076E  78 03                 C  	JS	DBLDIV		;Yes. 
 0770  E9 1877 R             C  	JMP	$FMULD		;No, multiply and return to caller 
 0773  E9 1479 R             C  DBLDIV: JMP	DDIVFA		;Double precision divide; FAC=FAC/ARG, 
                             C  				; Return to caller. 
                             C   
                             C   
                             C  	SUBTTL	 $OVFLS  OVERFLOW CODE 
                             C  ;*********************************************************** 
                             C  ; 
                             C  ;       $OVFLS  PLACES CORRECT INFINITY IN THE FAC AND PRINTS 
                             C  ;               OVERFLOW MESSAGE 
                             C  ; 
                             C  ;       $DIV0S  PLACES CORRECT INFINITY IN THE FAC AND PRINTS 
                             C  ;               DIVIDE-BY-ZERO MESSAGE 
                             C  ; 
                             C  ;*********************************************************** 
                             C   
 0776  53                    C  $OVFLS: PUSH	BX 
 0777  E8 077C R             C  	CALL	OVFLS		;DO THE OVERFLOW CODE 
 077A  5B                    C  	POP	BX		;RESTORE TEXT POINTER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-33
$OVFLS  OVERFLOW CODE                                       

 077B  C3                    C  	RET 
 077C  E8 07B5 R             C  OVFLS:	CALL	DOINF		;PUT IN APPROPRIATE INFINITY 
 077F  B8 0000 E             C  	MOV	AX,OFFSET OVERR ;Error trapping routine adr 
 0782  BB 0000 E             C  	MOV	BX,OFFSET $OVMSG	;ADDRESS APPROPRIATE ERROR MESSAGE 
 0785  EB 0F                 C  	JMP	SHORT DV010	;GO PRINT MESSAGE 
 0787  53                    C  $DIV0S: PUSH	BX		;SAVE TEXT POINTER 
 0788  E8 078D R             C  	CALL	DIV0S		;DO THE DIVIDE OVERFLOW CODE 
 078B  5B                    C  	POP	BX 
 078C  C3                    C  	RET			;RETURN WITH TEXT POINTER SAVED 
 078D  E8 07B5 R             C  DIV0S:	CALL	DOINF		;PUT IN APPROPRIATE INFINITY 
 0790  B8 0000 E             C  	MOV	AX,OFFSET DV0ERR	;Error trapping routine adr 
 0793  BB 0000 E             C  	MOV	BX,OFFSET $DIV0M	;AND ERROR MESSAGE 
 0796  E8 07E2 R             C  DV010:	CALL	TRAPER		;Trap error if error trapping enabled 
 0799  80 3E 0000 E 01       C  	CMP	BYTE PTR $FLGOV,LOW 1	;IF 0,1 PRINT, IF 1 MAKE 2 
 079E  78 07                 C  	JS	DV015		;PRINT IF 0 
 07A0  75 12                 C  	JNZ	DV020		;DON'T PRINT IF 2 
 07A2  C6 06 0000 E 02       C  	MOV	BYTE PTR $FLGOV,LOW 2	;MAKE 2 IF 1 
 07A7  E8 0000 E             C  DV015:	CALL	$STPRN 
 07AA  B0 0D                 C  	MOV	AL,LOW 15	;CARRIAGE RETURN 
 07AC  E8 0000 E             C  	CALL	$CATTY		;SEND IT 
 07AF  B0 0A                 C  	MOV	AL,LOW 12	;LINE FEED 
 07B1  E8 0000 E             C  	CALL	$CATTY		;SEND IT 
 07B4  C3                    C  DV020:	RET 
                             C   
 07B5                        C  DOINF:				;PUT CORRECT INFINITY IN THE FAC 
 07B5  FC                    C  	CLD			;CLEAR THE DIRECTION FLAG "DF" 
 07B6  0A FF                 C  	OR	BH,BH		;SEE IF ZERO TO A NEG POWER 
 07B8  BE 0532 R             C  	MOV	SI,OFFSET $INFPD	;ASSUME POSITIVE 
 07BB  74 0A                 C  	JZ	INF10		;POSITIVE INFINITY FOR ZERO^-X 
 07BD  F6 06 0001 E 80       C  	TEST	BYTE PTR $FAC+1,LOW 200 ;NEGATIVE? 
 07C2  79 03                 C  	JNS	INF10		;IF NOT PROCEED 
 07C4  BE 053A R             C  	MOV	SI,OFFSET $INFMD	;NEGATIVE INFINITY 
 07C7  E8 08EF R             C  INF10:	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 07CA  72 08                 C  	JB	INF20 
                             C  ;*********************************************************** 
                             C  ;IT'S DOUBLE PRECISION 
                             C  ;*********************************************************** 
 07CC  BF 0000 E             C  	MOV	DI,OFFSET $DFACL	;RECEIPIENT 
 07CF  B9 0004               C  	MOV	CX,4		;4 WORDS FOR DOUBLE PRECISION 
 07D2  EB 09                 C  	JMP	SHORT INF30 
 07D4                        C  INF20:				;SINGLE PRECISION 
 07D4  83 C6 04              C  	ADD	SI,4		;SO WE POINT TO SINGLE PRECISION NO. 
 07D7  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 07DA  B9 0002               C  	MOV	CX,2		;2 WORDS FOR SINGLE 
 07DD                        C  INF30:				;MUST FETCH FROM CODE SEGMENT 
 07DD  2E: A5                C  	MOVS	WORD PTR ES:[DI],WORD PTR CS:[SI]	;TO FAC 
 07DF  E2 FC                 C  	LOOP	INF30 
 07E1  C3                    C  	RET 
                             C   
 07E2  50                    C  TRAPER: PUSH	AX		;save Error trapping routine adr 
 07E3  A1 0000 E             C  	MOV	AX,WORD PTR ONELIN 
 07E6  0B C0                 C  	OR	AX,AX		;see if we are trapping errors 
 07E8  75 01                 C  	JNZ	TRAPIT		;branch if errors are being trapped 
 07EA  58                    C  	POP	AX		;discard Error trapping routine adr 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-34
$OVFLS  OVERFLOW CODE                                       

 07EB  C3                    C  TRAPIT: RET			;return to caller or Error trap routine 
                             C   
                             C  	SUBTTL	 $FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC 
                             C  ;************************************************************** 
                             C  ; 
                             C  ;       $FOFMT  FORMAT THE NUMBER IN THE FAC. IF THE NUMBER CAN BE 
                             C  ;               AS ACCURATELY REPRESENTED IN FIXED FORMAT AS 
                             C  ;               SCIENTIFIC THEN USE FIXED OUTPUT. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOFMT 
                             C  ;               WITH (BX) POINTING TO CURRENT OUTPUT POSITION 
                             C  ;               IN THE OUTPUT BUFFER $FBUFF AND CONDITION CODES 
                             C  ;               SET AS IF $GETYP WAS JUST CALLED 
                             C  ; 
                             C  ;***************************************************************** 
                             C   
 07EC  53                    C  $FOFMT: PUSH	BX		;SAVE BUFFER POINTER 
                             C   
                             C   
 07ED  B0 08                 C  	MOV	AL,LOW 8D	;assume single precision - print 7 digits 
                             C   
 07EF  72 02                 C  	JB	FFM10		;JUMP IF SINGLE PRECISION 
 07F1  B0 11                 C  	MOV	AL,LOW 17D	;DOUBLE PRECISION POSSIBLE DIGITS 
 07F3  8A E8                 C  FFM10:	MOV	CH,AL		;WILL SAVE A SECOND COPY FOR LATER 
 07F5  8A C8                 C  	MOV	CL,AL 
 07F7  51                    C  	PUSH	CX		;SAVE FOR LATER 
 07F8  9C                    C  	PUSHF			;SAVE TYPE 
 07F9  E8 1AC4 R             C  	CALL	$FOTNV		;BRACKET THE NUMBER SO THAT SIGNIFICANT 
                             C  				;DIGITS ARE IN THE INTEGER PART AND 
                             C  				;THE NECESSARY EXPONENT IS IN (AL) 
 07FC  0A C0                 C  	OR	AL,AL		;IF POSITIVE DON'T CALL SIGD 
 07FE  74 02                 C  	JZ	FFM11 
 0800  79 0C                 C  	JNS	FFM15 
 0802  9D                    C  FFM11:	POPF			;RECALL TYPE FOR TEST TO SEE IF SIGD 
                             C  				;CALLED. IF S.P. AND (AL) SMALLER THAN 
                             C  				;-7 MUST CALL SIG, IF D.P. AND (AL) 
                             C  				;SMALLER THAN -16 THEN MUST CALL SIGD. 
                             C  				;IF (AL) POSITIVE SIGD WILL NOT BE 
                             C  				;CALLED. PURPOSE OF SIGD IS TO 
                             C  				;DETERMINE WHETHER WE CAN PRINT NO. IN 
                             C  				;FIXED FORMAT W/O LOSING SIGNIFICANT 
                             C  				;DIGITS. 
 0803  59                    C  	POP	CX		;RECALL POSIBLE SIGNIFICANT SIGITS 
 0804  50                    C  	PUSH	AX		;SAVE EXP. 
 0805  7B 0B                 C  	JPO	FFM16		;SINGLE PREC. 
 0807  04 10                 C  	ADD	AL,LOW 16D	;THIS MUST MAKE POSITIVE TO NOT CALL 
 0809  58                    C  	POP	AX 
 080A  79 1A                 C  	JNS	FFM18		;POP AX AND DO FIXED OUTPUT 
 080C  EB 09                 C  	JMP	SHORT FFM17	;MUST CALL SIGD 
 080E                        C  FFM15: 
 080E  9D                    C  	POPF			;RECALL TYPE FLAG 
 080F  59                    C  	POP	CX		;RECALL CX 
 0810  EB 26                 C  	JMP	SHORT FFM20 
 0812                        C  FFM16: 
 0812  04 07                 C  	ADD	AL,LOW 7 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-35
$FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC                

 0814  58                    C  	POP	AX 
 0815  79 0F                 C  	JNS	FFM18 
 0817                        C  FFM17: 
 0817  50                    C  	PUSH	AX		;SAVE NECESSARY EXPONENT IN (AL) 
 0818  E8 2001 R             C  	CALL	$SIGD		;INCREMENT (CL) FOR EACH ZERO DIGIT 
                             C  				;BEGINNING FROM THE RIGHT 
 081B  58                    C  	POP	AX		;RECALL NECESSARY EXPONENT 
 081C  8A E0                 C  	MOV	AH,AL		;WILL PERFORM FIRST TEST ON AH 
 081E  02 E1                 C  	ADD	AH,CL		;IF SF=1 AFTER THIS THEN USE "E" FORMAT 
 0820  7E 16                 C  	JLE	FFM20		;JUMP IF TOO SMALL 
 0822  02 E8                 C  	ADD	CH,AL 
 0824  EB 0C                 C  	JMP	SHORT FFM19 
 0826  02 C5                 C  FFM18:	ADD	AL,CH 
 0828  FE C5                 C  	INC	CH 
 082A  3A E8                 C  	CMP	CH,AL 
 082C  B5 03                 C  	MOV	CH,LOW 3	;TO FLAG "E" FORMAT IF NECESSARY 
 082E  72 0C                 C  	JB	FFM30 
 0830  8A E8                 C  	MOV	CH,AL 
 0832  FE C5                 C  FFM19:	INC	CH		;(CH)= NUMBER DIGITS+2 
 0834  B0 02                 C  	MOV	AL,LOW 2	;THIS WILL CAUSE ZF=1 IN LATER CALC 
                             C  				;AND WILL SIGNAL FIXED OUTPUT 
 0836  EB 04                 C  	JMP	SHORT FFM30 
 0838  02 C5                 C  FFM20:	ADD	AL,CH 
 083A  B5 03                 C  	MOV	CH,LOW 3	;SIGNALS "E" TYPE FORMAT 
 083C  FE C8                 C  FFM30:	DEC	AL		;(AL) 2 TOO LARGE 
 083E  FE C8                 C  	DEC	AL 
 0840  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 0841  50                    C  	PUSH	AX		;SAVE EXPONENT 
 0842  9C                    C  	PUSHF			;SAVE CONDITION CODES 
 0843  32 C9                 C  	XOR	CL,CL		;(CL)=0  (NO COMMAS AFTER EACH 3 DIGITS 
 0845  E8 1991 R             C  	CALL	$FOTAN		;PUT IN DECIMAL POINT AND LEADING 
                             C  				;ZEROS AS NECESSARY 
 0848  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;ZF=1 IF THIS "0" NECESSARY 
 084B  75 01                 C  	JNZ	FFM40 
 084D  43                    C  	INC	BX 
 084E  E8 19C8 R             C  FFM40:	CALL	$FOTCV		;CONVERT THE FAC TO DECIMAL DIGITS 
                             C  				;AND PUT IN DECIMAL POINT AS NECESSARY 
 0851  4B                    C  FFM50:	DEC	BX		;WILL NOW SEE IF THERE ARE TRAILING 
 0852  80 3F 30              C  	CMP	BYTE PTR 0[BX],LOW "0"  ;ZEROS TO SUPPRESS. WE KNOW ZEROS WE 
 0855  74 FA                 C  	JZ	FFM50		;FIND HERE ARE TRAILING BECAUSE $FOTCV 
 0857  80 3F 2E              C  	CMP	BYTE PTR 0[BX],LOW "."  ;PUTS IN DECIMAL POINT 
 085A  74 01                 C  	JZ	FFM60		;CAN WE DELETE THE DECIMAL POINT ALSO? 
 085C  43                    C  	INC	BX		; 
 085D  9D                    C  FFM60:	POPF			;LET'S HAVE A LOOK AT THE POSSIBLE 
                             C  				;EXPONENT 
 085E  58                    C  	POP	AX 
 085F  74 2B                 C  	JZ	FFM100		;IF NO EXPONENT JUST CLEAN-UP AND RET 
 0861  9C                    C  $PUEXP: PUSHF			;SAVE SF( IF =1 NEGATIVE EXPONENT) 
 0862  50                    C  	PUSH	AX		;SAVE EXPONENT 
 0863  E8 08EF R             C  	CALL	$GETYP		;SET COND. CODES FOR TYPE NUMBER 
 0866  B4 45                 C  	MOV	AH,LOW "E"      ;ASSUME SINGLE PRECISION 
 0868  7B 02                 C  	JPO	FFM70		;IF S.P. PROCEED 
 086A  B4 44                 C  	MOV	AH,LOW "D"      ;IT'S DOUBLE PRECISION 
 086C  88 27                 C  FFM70:	MOV	BYTE PTR 0[BX],AH	;PUT IN EXPONENT DESIGNATOR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-36
$FOFMT  FLOATING FORMAT OF NUMBER IN THE FAC                

 086E  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 086F  58                    C  	POP	AX		;RECALL EXPONENT 
 0870  9D                    C  	POPF			;NOW TO SEE IF POSITIVE OR NEGATIVE 
 0871  C6 07 2B              C  	MOV	BYTE PTR 0[BX],LOW "+"  ;ASSUME POSITIVE EXPONENT 
 0874  79 05                 C  	JNS	FFM80		;AND JUMP IF SO 
 0876  C6 07 2D              C  	MOV	BYTE PTR 0[BX],LOW "-" 
 0879  F6 D8                 C  	NEG	AL		;MUST MAKE EXPONENT POSITIVE 
 087B  B4 2F                 C  FFM80:	MOV	AH,LOW OFFSET "0"-1     ;WILL BUILD DIGIT IN (AL) 
 087D  FE C4                 C  FFM90:	INC	AH		;INCREMENT TO NEXT DIGIT 
 087F  2C 0A                 C  	SUB	AL,LOW 10D	; 
 0881  73 FA                 C  	JNB	FFM90 
 0883  04 3A                 C  	ADD	AL,LOW OFFSET "0"+10D   ;ADD TO DETERMINE SECOND DIGIT 
 0885  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 0886  86 C4                 C  	XCHG	AL,AH		;PREPARE FOR WORD STORE 
 0888  89 07                 C  	MOV	WORD PTR 0[BX],AX	;STORE 2 DIGITS OF EXPONENT 
 088A  43                    C  	INC	BX		;INCREMENT TO NEXT BUFFER POSITION 
 088B  43                    C  	INC	BX 
 088C  C6 07 00              C  FFM100: MOV	BYTE PTR 0[BX],LOW 0	;SIGNAL END OF BUFFER DATA 
 088F  87 D9                 C  	XCHG	BX,CX		;END-OF-BUFFER PTR. IN (CX) 
 0891  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1	;START IN (BX) 
 0894  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 UTILS	   UTILITY ROUTINES 
                             C   
                             C   
                             C   
                             C  ;string printer must fetch from code segment 
 0895  E8 0000 E             C  STOULP: CALL	OUTDO		;send char 
 0898  3C 0D                 C  	CMP	AL,LOW 13D	;carriage return? 
 089A  75 03                 C  	JNZ	STROUT		;no 
 089C  E8 0000 E             C  	CALL	CRFIN		;force carriage back to left 
 089F                        C  STROUT:			;fetch from code segment 
 089F  2E: 8A 07             C  	MOV	AL,BYTE PTR CS:0[BX]	;get char 
 08A2  43                    C  	INC	BX		;point at next one 
 08A3  0A C0                 C  	OR	AL,AL		;end of string? 
 08A5  75 EE                 C  	JNZ	STOULP		;no print char until done 
 08A7  C3                    C  	RET 
 08A8                        C  $DZERO:			;DOUBLE PRECISION ZERO 
 08A8  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 08AB  B9 0004               C  	MOV	CX,4 
 08AE  B8 0000               C  	MOV	AX,0 
 08B1  FC                    C  	CLD 
 08B2  F3/ AB                C   REP	STOSW 
 08B4  C3                    C  	RET 
                             C   
 08B5                        C  ZERO: 
 08B5                        C  $ZERO:				;ZERO THE FAC 
 08B5  B8 0000               C  	MOV	AX,0 
 08B8  A3 0000 E             C  	MOV	WORD PTR $FACLO,AX	;ZERO LOWER 2 BYTES 
 08BB  A3 FFFF E             C  	MOV	WORD PTR $FAC-1,AX	;ZERO UPPER TWO BYTES 
 08BE  C3                    C  	RET 
                             C   
 08BF                        C  SIGN: 
 08BF                        C  $SIGNS:			;DETERMINE SIGN OF FAC 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-37
UTILS	   UTILITY ROUTINES                                   

                             C  				;ZF=1 IF ($FAC)=0, SF=1 IF ($FAC) .LT.0, NEITHER OF 
                             C  				;THESE FLAGS SET IF ($FAC).GT.0 
 08BF  E8 08EF R             C  	CALL	$GETYP		;IF NOT INTEGER CAN LOOK AT FAC:FAC-1 
 08C2  75 03                 C  	JNE	SIS01 
 08C4  E9 0000 E             C  	JMP	TMERR		;Strings illegal 9-Mar-82/ngt 
 08C7                        C  SIS01: 
 08C7  79 0E                 C  	JNS	SIS05		;NOT INTEGER PROCEED 
 08C9  A1 0000 E             C  	MOV	AX,WORD PTR $FACLO	;FETCH INTEGER 
 08CC  0B C0                 C  	OR	AX,AX		;DETERMINE SIGN 
 08CE  74 1E                 C  	JZ	SIS10 
 08D0  B0 01                 C  	MOV	AL,LOW 1 
 08D2  79 1A                 C  	JNS	SIS10 
 08D4  F6 D8                 C  	NEG	AL 
 08D6  C3                    C  	RET 
 08D7                        C  SIS05: 
 08D7  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;FIRST CHECK FOR ZERO 
 08DA  0A C0                 C  	OR	AL,AL 
 08DC  74 10                 C  	JZ	SIS10		;IF ZERO JUST RETURN 
 08DE  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1	;FETCH SIGN BYTE 
 08E1  0A C0                 C  SIGNAL: OR	AL,AL		;SIGNSET NOW 
 08E3  74 07                 C  	JZ	SIS07		;MUST MAKE AL=1 AND ZF=0 
 08E5  B0 01                 C  	MOV	AL,LOW 1 
 08E7  79 05                 C  	JNS	SIS10 
 08E9  F6 D8                 C  	NEG	AL 
 08EB  C3                    C  	RET 
 08EC  0C 01                 C  SIS07:	OR	AL,LOW 1	;KNOW POSITIVE NON-ZERO 
 08EE  C3                    C  SIS10:	RET 
                             C   
                             C  ; 
                             C  ; Set cond. codes according to type value. 
                             C  ;   S, C = Integer 
                             C  ;   Z, C = String 
                             C  ;      C = Single Precision 
                             C  ;   None = Double Precision 
                             C  ; 
 08EF                        C  $GETYP: 
 08EF  A0 0000 E             C  	MOV	AL,BYTE PTR $VALTP	;FETCH TYPE VARIABLE 
 08F2  3C 08                 C  	CMP	AL,LOW 10	;CF=1 EXCEPT FOR DOUBLE PREC. 
 08F4  FE C8                 C  	DEC	AL		;WILL SUBTRACT 3 WITH DECBREMENTS 
 08F6  FE C8                 C  	DEC	AL 
 08F8  FE C8                 C  	DEC	AL 
 08FA  C3                    C  	RET			;ZF=1 IF STRING,SF=1 IF INTEGER 
                             C  				;PO=1 IF SINGLE PREC 
                             C   
 08FB                        C  $VADDH:			;ADD .5 ACCORDING TO TYPE 
 08FB  E8 08EF R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 08FE  72 0C                 C  	JB	$FADDH 
 0900                        C  $DADDH:			;DOUBLE PRECISION ADD .5 
 0900  53                    C  	PUSH	BX 
 0901  BB 0499 R             C  	MOV	BX,OFFSET $DHALF 
 0904  E8 09D0 R             C  	CALL	$MOVAC		;MOVE TO ARG 
 0907  E8 12E7 R             C  	CALL	$FADDD		;ADD TO FAC 
 090A  5B                    C  	POP	BX 
 090B  C3                    C  	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-38
UTILS	   UTILITY ROUTINES                                   

 090C                        C  $FADDH:			;SINGLE PRECISION ADD .5 
 090C  33 D2                 C  	XOR	DX,DX		;WILL SET (BXDX)=.5 
 090E  BB 8000               C  	MOV	BX,100000 
 0911  E8 13A3 R             C  	CALL	$FADDS		;ADD .5 TO FAC 
 0914  C3                    C  	RET 
 0915                        C  $DIV10:			;DIVIDE FAC BY 10 
 0915  E8 08EF R             C  	CALL	$GETYP 
 0918  BB 0359 R             C  	MOV	BX,OFFSET $DPM01	;ADDRESS .1 
 091B  72 11                 C  	JB	ML10 
 091D  EB 08                 C  	JMP	SHORT ML05	;MULTIPLY 
                             C   
 091F                        C  $MUL10:			;MULTIPLY THE FAC BY 10 
 091F  E8 08EF R             C  	CALL	$GETYP		;SEE IF SINGLE OR DOUBLE PREC 
 0922  BB 0369 R             C  	MOV	BX,OFFSET $DP01 ;ADDRESS OF DOUBLE PREC 10. 
 0925  72 07                 C  	JB	ML10		;JUMP IF SINGLE 
 0927  E8 09D0 R             C  ML05:	CALL	$MOVAC		;MOVE 10. TO ARG 
 092A  E8 1877 R             C  	CALL	$FMULD		;MULTIPLY 
 092D  C3                    C  	RET 
 092E                        C  ML10:				;MULTIPLY SINGLE PREC. FAC BY NO. POINTED TO BY BX 
 092E                        C  $MLSP: 
 092E  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;PUSH FAC ON THE STACK 
 0932  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0936  C6 06 0000 E 08       C  	MOV	BYTE PTR $VALTP,LOW 10	;SET UP D.P. 
 093B  E8 09D5 R             C  	CALL	$MOVFC		;MOVE DOUBLE PREC. 10 TO FAC 
 093E  E8 17AE R             C  	CALL	$CSD		;CONVERT TO SINGLE PRECISION 
 0941  5A                    C  	POP	DX		;GET LOW MANTISSA BITS 
 0942  5B                    C  	POP	BX		;EXP SIGN AND HIGH MATISSA BITS 
 0943  E8 1921 R             C  	CALL	$FMULS		;MULTIPLY 
 0946  C3                    C  	RET 
                             C   
                             C   
 0947  B9 0004               C  $RDL:	MOV	CX,4		;WILL SHIFT 4 WORDS LEFT 
 094A  D1 17                 C  RDL120: RCL	WORD PTR 0[BX],1	;SHIFT  LEFT 1 BIT SHIFTING IN CF 
 094C  43                    C  	INC	BX 
 094D  43                    C  	INC	BX 
 094E  E2 FA                 C  	LOOP	RDL120 
 0950  C3                    C  	RET 
 0951  B9 0004               C  $SHDR:	MOV	CX,4		;DO DOUBLE PRECISION RIGHT SHIFT 
 0954                        C  $SHRM:				;SHIFT NO. POINTED TO BY (BX) , (CX) WDS RT. 
 0954  D1 1F                 C  	RCR	WORD PTR 0[BX],1	;SHIFT 1 WD. RT. THRU CF 
 0956  4B                    C  	DEC	BX 
 0957  4B                    C  	DEC	BX		;TO NEXT WD. 
 0958  E2 FA                 C  	LOOP	$SHRM		;DO THIS (CX) TIMES 
 095A  C3                    C  	RET 
 095B  80 4F 02 20           C  SHST:	OR	BYTE PTR 2[BX],LOW 40	;"OR" IN ST BIT 
 095F  E2 01                 C  	LOOP	$SHRA 
 0961  C3                    C  	RET 
 0962                        C  $SHRA:				;SHIFT $ARG RIGHT (CX) BITS 
 0962  BB FFFE E             C  	MOV	BX,OFFSET $ARG-2 
 0965  80 F9 08              C  	CMP	CL,LOW 10	;CAN I DO A BYTE MOVE 
 0968  72 24                 C  	JB	SHRA30		;IF NOT PROCEED AS NORMAL 
                             C  ;************************************************************* 
                             C  ;FOR SPEED PURPOSES WE WILL DO A BYTE MOVE TO THE RIGHT 
                             C  ;************************************************************* 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-39
UTILS	   UTILITY ROUTINES                                   

 096A  51                    C  	PUSH	CX		;SAVE BITS TO SHIFT 
 096B  B9 0007               C  	MOV	CX,7		;7 BYTE MOVE 
 096E  BB FFFF E             C  	MOV	BX,OFFSET $ARGLO-1 
 0971  8A 27                 C  	MOV	AH,BYTE PTR 0[BX]	;FETCH OVERFLOW BYTE 
 0973  8A 47 01              C  SHRA11: MOV	AL,BYTE PTR 1[BX] 
 0976  88 07                 C  	MOV	BYTE PTR 0[BX],AL 
 0978  43                    C  	INC	BX 
 0979  E2 F8                 C  	LOOP	SHRA11 
 097B  32 C0                 C  	XOR	AL,AL 
 097D  88 07                 C  	MOV	BYTE PTR 0[BX],AL 
 097F  59                    C  	POP	CX		;RECALL BIT COUNT 
 0980  80 E9 08              C  	SUB	CL,LOW 10 
 0983  80 E4 20              C  	AND	AH,LOW 40	;WILL NEED TO RE-ESTABLISH ST 
 0986  74 DA                 C  	JZ	$SHRA		;NO-ST JUST PROCEED 
 0988  08 26 FFFF E          C  	OR	BYTE PTR $ARGLO-1,AH 
 098C  EB D4                 C  	JMP	$SHRA 
 098E                        C  SHRA30: 
 098E  0A C9                 C  	OR	CL,CL 
 0990  74 0E                 C  	JZ	SHRA40		;JUMP IF DONE 
 0992  51                    C  	PUSH	CX		;SAVE NO. BITS TO SHIFT 
 0993  F8                    C  	CLC			;DON'T WANT THE CARRY SHIFTED IN 
 0994  E8 0951 R             C  	CALL	$SHDR 
 0997  59                    C  	POP	CX 
 0998  F6 47 02 10           C  	TEST	BYTE PTR 2[BX],LOW 20	;SEE IF SHIFTED THRU "ST" 
 099C  75 BD                 C  	JNZ	SHST		;MUST "OR" ST BIT IN IF NON-ZERO 
 099E  E2 C2                 C  	LOOP	$SHRA 
 09A0  C3                    C  SHRA40: RET 
                             C   
                             C   
 09A1  BE 0000 E             C  $XCGAF: MOV	SI,OFFSET $DFACL	;WILL EXCHANGE FAC AND ARG (D.P.) 
 09A4  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 09A7  FC                    C  	CLD			;SO MOVW WILL INCREMENT INDICES 
 09A8  B9 0004               C  	MOV	CX,4		;WILL MOVE 4 WORDS (8 BYTES) 
 09AB  8B 05                 C  XCG10:	MOV	AX,WORD PTR 0[DI]	;FETCH DESTINATION WORD 
 09AD  A5                    C  	MOVSW			;MOVE FAC TO ARG & INCREMENT INDICES 
 09AE  89 44 FE              C  	MOV	WORD PTR -2[SI],AX	;ARG TO FAC 
 09B1  E2 F8                 C  	LOOP	XCG10		;CONTINUE 
 09B3  C3                    C  	RET 
                             C   
                             C  ;********************************************************************* 
                             C  ;       SPECIAL MOVE ROUTINES FOR HANDLING CONSTANTS FROM THE CODE 
                             C  ;       SEGMENT 
                             C  ;********************************************************************* 
 09B4                        C  $MOVBS:			;THIS ROUTINE IS USED TO MOVE A SINGLE PRECISION NO. FROM THE 
                             C  				;CODE SEGMENT TO $DBUFF. THE NO. IS POINTED TO BY (BX) 
 09B4  BF 0004 E             C  	MOV	DI,OFFSET $DBUFF+4 
 09B7  B9 0002               C  	MOV	CX,2 
 09BA  EB 06                 C  	JMP	SHORT MBF10 
 09BC                        C  $MOVBF:			;THIS ROUTINE IS USED TO MOVE A DOUBLE PRECISION NO. FROM THE 
                             C  				;CODE SEGMENT TO $DBUFF. THE NO. IS POINTED TO BY (BX) 
 09BC  BF 0000 E             C  	MOV	DI,OFFSET $DBUFF 
 09BF  B9 0004               C  MBF05:	MOV	CX,4 
 09C2  FC                    C  MBF10:	CLD 
 09C3  8B F3                 C  	MOV	SI,BX		;SO WE CAN USE A LODW 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-40
UTILS	   UTILITY ROUTINES                                   

 09C5                        C  MBF20: 
 09C5  2E: AD                C  	LODS	WORD PTR ?CSLAB ;FETCH FROM CS 
 09C7  AB                    C  	STOSW			;STORE IN DBUFF 
 09C8  E2 FB                 C  	LOOP	MBF20		;CONTINUE WITH MOVE 
 09CA  8B DF                 C  	MOV	BX,DI		;UPDATE (BX) 
 09CC  83 EB 02              C  	SUB	BX,2		;GET POINTER CORRECT 
 09CF  C3                    C  	RET 
                             C   
 09D0                        C  $MOVAC:			;ROUTINE TO MOVE A DOUBLE PRECISION NO. POINTED TO BY (BX) 
                             C  				;FROM THE CODE SEGMENT TO ARG 
 09D0  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 09D3  EB EA                 C  	JMP	SHORT MBF05 
                             C   
 09D5                        C  $MOVFC:			;ROUTINE USED TO MOVE A DOUBLE PRECISION NO. FROM THE CODE 
                             C  				;SEGMENT TO THE FAC. NO. IS POINTED TO BY (BX) 
 09D5  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 09D8  EB E5                 C  	JMP	SHORT MBF05 
                             C   
 09DA                        C  MOVAM:				;MOVE NO. POINTED TO BY BX TO ARG 
 09DA  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO	;LOW ADDRESS OF ARG 
 09DD  B9 0004               C  	MOV	CX,4		;MOVE DOUBLE PREC NO. POINTED TO 
                             C  				;BY (BX) TO DOUBLE PREC NO. POINTED TO 
                             C  				;BY (DI) 
 09E0                        C  MOVEM:				;MOVE NO. POINTED TO BY (BX) TO NO. POINTED TO BY (DI) 
                             C  				;FOR (CX) WORDS 
 09E0  87 DE                 C  	XCHG	BX,SI		;SO MOVW CAN BE USED 
 09E2  FC                    C  	CLD			;SO MOVW WILL INC 
                             C  		     ;DO MOVE (CX) TIMES 
 09E3  F3/ A5                C   REP	MOVSW			;MOVE "FROM" TO "TO" 
 09E5  87 DE                 C  	XCHG	BX,SI		;GET REGISTERS STRAIGHT 
 09E7  C3                    C  	RET 
                             C   
 09E8                        C  $MOVAF:			;MOVE THE $FAC TO $ARG 
 09E8  51                    C  	PUSH	CX		;SAVE CX,BX,DI 
 09E9  53                    C  	PUSH	BX 
 09EA  57                    C  	PUSH	DI 
 09EB  BB 0000 E             C  	MOV	BX,OFFSET $DFACL	;"FROM" ADDRESS 
 09EE  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO	;"TO" ADDRESS 
 09F1  B9 0004               C  MAF05:	MOV	CX,4		;4 16-BIT QUANTITIES TO MOVE 
 09F4  E8 09E0 R             C  	CALL	MOVEM		;DO THE MOVE 
 09F7  5F                    C  	POP	DI 
 09F8  5B                    C  	POP	BX 
 09F9  59                    C  	POP	CX		;REGISTERS RESTORED 
 09FA  C3                    C  	RET 
                             C   
                             C   
                             C   
 09FB                        C  $MOVFA:			;MOVE THE $ARG TO THE FAC 
 09FB  51                    C  	PUSH	CX 
 09FC  53                    C  	PUSH	BX 
 09FD  57                    C  	PUSH	DI		;SAVE REGISTERS 
 09FE  BB 0000 E             C  	MOV	BX,OFFSET $ARGLO	;"FROM" ADDRESS 
 0A01  BF 0000 E             C  	MOV	DI,OFFSET $DFACL	;"TO" ADDRESS 
 0A04  EB EB                 C  	JMP	SHORT MAF05	;GO MOVE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-41
UTILS	   UTILITY ROUTINES                                   

                             C  ;************************************************************** 
                             C  ;SINGLE PRECISION MOVE ROUTINES 
                             C  ;*************************************************************** 
 0A06                        C  $MOVFR:			;MOVE (BXDX) TO FAC 
 0A06  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX 
 0A0A  89 1E FFFF E          C  	MOV	WORD PTR $FAC-1,BX 
 0A0E  C3                    C  	RET 
                             C   
 0A0F                        C  $MOVRF:			;MOVE THE FAC INTO REGISTERS (BXDX) 
 0A0F  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO 
 0A13  8B 1E FFFF E          C  	MOV	BX,WORD PTR $FAC-1 
 0A17  C3                    C  	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-42
UTILS	   UTILITY ROUTINES                                   

                             C  	PAGE 
                             C  ; 
                             C  ; ZCMPCK is called by the comparison routines to handle the 
                             C  ; cases where the exponent of either or both of the numbers 
                             C  ; is zero.  These must be treated as special cases because 
                             C  ; a number whose exponent is zero is zero regardless of the 
                             C  ; garbage that might be in the mantissa. 
                             C  ; 
                             C  ; On entry -    BH=exponent of comperand 
                             C  ;               Bit 7 of BL=sign of comperand 
                             C  ; 
                             C  ; On exit -     Carry clear - caller must continue comparison. 
                             C  ; 
                             C  ;               Carry set - comparison is finished. 
                             C  ;               A=1, Z=0, S=0 for FAC .GT. comperand 
                             C  ;               A=0, Z=1 for FAC .EQ. comperand 
                             C  ;               A=377 octal, Z=0, S=1 for FAC .LT. comperand 
                             C  ; 
                             C   
 0A18  0A FF                 C  ZCMPCK: OR	BH,BH		;Is the comperand zero? 
 0A1A  75 05                 C  	JNZ	NZCOMP		;No. 
 0A1C  E8 08D7 R             C  	CALL	SIS05		;Yes, result is the sign of the FAC. 
 0A1F  F9                    C  	STC			;Set carry to say comparison is done 
 0A20  C3                    C  	RET			;and return. 
                             C   
 0A21  A0 0000 E             C  NZCOMP: MOV	AL,BYTE PTR $FAC	;Is the FAC zero? 
 0A24  0A C0                 C  	OR	AL,AL		;(Also clear carry.) 
 0A26  75 08                 C  	JNZ	ZCMPRT		;No, return with carry clear to tell 
                             C  				;the caller he must continue. 
 0A28  8A C3                 C  	MOV	AL,BL		;Yes, the result is the opposite 
 0A2A  F6 D0                 C  	NOT	AL		;of the sign of the comperand. 
 0A2C  E8 08E1 R             C  	CALL	SIGNAL 
 0A2F  F9                    C  	STC			;Set carry to say comparison is 
 0A30  C3                    C  ZCMPRT: RET			;finished and return. 
                             C   
                             C  ; 
                             C  ; ZCMPBX performs the special zero check for the case where 
                             C  ; BX points to the comperand. 
                             C  ; 
                             C   
 0A31  53                    C  ZCMPBX: PUSH	BX		;Preserve the comperand pointer. 
 0A32  8B 1F                 C  	MOV	BX,WORD PTR 0[BX]	;BH:=exponent, BL bit 7:=sign for 
                             C  				;ZCMPCK. 
 0A34  E8 0A18 R             C  	CALL	ZCMPCK		;Check for the zero cases. 
 0A37  5B                    C  	POP	BX		;Retrieve the comperand pointer 
 0A38  C3                    C  	RET			;and return. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-43
UTILS	   UTILITY ROUTINES                                   

                             C  	PAGE 
                             C   
 0A39                        C  $VCOMP:			;DETERMINE IF SINGLE OR DOUBLE PRECISION AND COMPARE ACCORDINGLY 
 0A39  E8 08EF R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 0A3C  72 43                 C  	JB	$COMPM		;DO S.P. COMPARE 
 0A3E  E9 0AD3 R             C  	JMP	$DCMPM		;GO DO D.P. COMPARE 
                             C   
 0A41                        C  $FCOMP:			;SINGLE PRECISION COMPARE OF ($FAC) AND (BXDX) 
                             C  				;(AL)=1 AND ZF=0,SF=0,CF=0 IF ($FAC).GT.(BXDX) 
                             C  				;(AL)=0 AND ZF=1 IF ($FAC)=(BXDX) 
                             C  				;(AL)=377 AND ZF=0,SF=1,CF=1 IF ($FAC).LT.(BXDX) 
                             C   
 0A41  E8 0A18 R             C  	CALL	ZCMPCK		;Check for zero exponent cases. 
 0A44  72 36                 C  	JB	ZEREXP		;All done if carry set. 
 0A46  53                    C  	PUSH	BX 
 0A47  57                    C  	PUSH	DI		; 
 0A48  8A C3                 C  	MOV	AL,BL		;SIGN OF (BXDX) TO (AL) 
 0A4A  32 06 FFFF E          C  	XOR	AL,BYTE PTR $FAC-1	;SET CODES FOR SIGNS 
 0A4E  78 43                 C  	JS	CPM05 
 0A50  0A DB                 C  	OR	BL,BL 
 0A52  78 10                 C  	JS	UFC10		;NEGATIVE NOS. 
 0A54  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;SIGNS SAME MUST COMPARE 
 0A57  2B C3                 C  	SUB	AX,BX		;SUBTRACT HIGH WORD 
 0A59  72 46                 C  	JB	CPM10		;($FAC) SMALLER 
 0A5B  75 3E                 C  	JNZ	CPM06		;($FAC) LARGER 
 0A5D  A1 0000 E             C  	MOV	AX,WORD PTR $FACLO	;MUST COMPARE LOW WORD 
 0A60  2B C2                 C  	SUB	AX,DX		; 
 0A62  EB 10                 C  	JMP	SHORT TSTFLG	;return comparison result based on flags 
 0A64  8B C3                 C  UFC10:	MOV	AX,BX		;SINCE NEGATIVE LARGER MAGNITUDE IS 
 0A66  2B 06 FFFF E          C  	SUB	AX,WORD PTR $FAC-1	;SMALLER NO. 
 0A6A  72 35                 C  	JB	CPM10 
 0A6C  75 2D                 C  	JNZ	CPM06		;(BXDX) SMALLER 
 0A6E  8B C2                 C  	MOV	AX,DX		;MUST COMPARE LOW WORD 
 0A70  2B 06 0000 E          C  	SUB	AX,WORD PTR $FACLO 
 0A74  72 2B                 C  TSTFLG: JB	CPM10		;branch if FAC is smaller than comperand 
 0A76  75 23                 C  	JNZ	CPM06		;branch if FAC is larger than comperand 
 0A78  32 C0                 C  	XOR	AL,AL		;FAC is equal to comperand 
 0A7A  EB 51                 C  	JMP	SHORT CPM80 
                             C   
                             C  ;One of the exponents was zero (meaning the number=0). 
                             C  ; Set Carry flag if [AL]=377 (if FAC is less than comperand) 
                             C  ; 
 0A7C  FE C0                 C  ZEREXP: INC	AL		;Map AL from (377, 0, 1) to (0, 1, 2) 
 0A7E  2C 01                 C  	SUB	AL,LOW 1	;Map it back, setting Flags appropriately 
 0A80  C3                    C  	RET 
                             C   
 0A81                        C  $COMPM:			;COMPARE FAC TO NUMBER POINTED TO BY (BX) 
                             C  ;       (BX) MUST BE POINTING TO SIGN BYTE OF NO. 
                             C  				;SET (AL)=1,ZF=0,SF=0,CF=0 IF (FAC).GT.[BX] 
                             C  				;    (AL)=0,ZF=1 IF (FAC)=[BX] 
                             C  				;    (AL)=377,ZF=0,SF=1,CF=1 IF (FAC).LT.[BX] 
                             C   
 0A81  E8 0A31 R             C  	CALL	ZCMPBX		;Check for zero exponent cases. 
 0A84  72 F6                 C  	JB	ZEREXP		;All done if carry set. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-44
UTILS	   UTILITY ROUTINES                                   

 0A86  53                    C  	PUSH	BX		;SAVE INITIAL ADDRESS 
 0A87  57                    C  	PUSH	DI		;SAVE DI 
 0A88  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1 
 0A8B  8B 07                 C  	MOV	AX,WORD PTR 0[BX]	;FETCH SIGN BYTE INTO AL 
 0A8D  32 06 FFFF E          C  	XOR	AL,BYTE PTR $FAC-1	;SF=1 IF SIGNS DIFFERENT 
 0A91  79 13                 C  	JNS	CPM20 
                             C  ;***************************************************************** 
                             C  ;SIGNS ARE DIFFERENT , THE ONE WITH POS. SIGN IS BIGGER 
                             C  ;****************************************************************** 
 0A93  8A 26 FFFF E          C  CPM05:	MOV	AH,BYTE PTR $FAC-1	;FETCH FAC SIGN 
 0A97  0A E4                 C  	OR	AH,AH 
 0A99  78 06                 C  	JS	CPM10		;FAC IS SMALLER MUST SET (AL)=377 
 0A9B  B0 01                 C  CPM06:	MOV	AL,LOW 1 
 0A9D  0A C0                 C  	OR	AL,AL		;MIGHT HAVE GOTTEN A ZF=1 ON LAST "OR" 
 0A9F  EB 2C                 C  	JMP	SHORT CPM80 
 0AA1  B0 FF                 C  CPM10:	MOV	AL,LOW 377	;KNOW SF=1 
 0AA3  F9                    C  	STC			;WANT CF=1 IF FAC SMALLER 
 0AA4  EB 27                 C  	JMP	SHORT CPM80 
 0AA6                        C  CPM20: 
                             C  ;****************************************************************** 
                             C  ;SIGNS ARE THE SAME MUST DO ACTUAL COMPARE 
                             C  ;****************************************************************** 
 0AA6  51                    C  	PUSH	CX		;WILL USE (CX) FOR LOOP CONTROL 
 0AA7  B9 0002               C  	MOV	CX,2 
 0AAA  87 DE                 C  CPM22:	XCHG	BX,SI		;SO CMPW CAN BE USED 
 0AAC  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1	;IF NEGATIVE NO. NEED TO REVERSE CMP 
 0AAF  0A C0                 C  	OR	AL,AL 
 0AB1  79 02                 C  	JNS	CPM25 
 0AB3  87 F7                 C  	XCHG	SI,DI		;WILL CAUSE CORRECT COMPARE FOR NEG. 
 0AB5                        C  CPM25: 
 0AB5  FD                    C  	STD			;SO CMPW WILL DECREMENT 
 0AB6  A7                    C  CPM30:	CMPSW			;FORM CODES FOR (.SI)-(.DI) 
 0AB7  75 06                 C  	JNZ	CPM50 
 0AB9  E2 FB                 C  	LOOP	CPM30		;CONTINUE THRU VALUES 
 0ABB  B0 00                 C  	MOV	AL,LOW 0	;ZF=1 ALREADY SET 
 0ABD  EB 0D                 C  	JMP	SHORT CPM70 
 0ABF  73 06                 C  CPM50:	JNB	CPM60		;MEMORY VALUE LARGER 
 0AC1  B0 01                 C  	MOV	AL,LOW 1	;FAC LARGER SF=0,ZF=0 
 0AC3  0A C0                 C  	OR	AL,AL 
 0AC5  EB 05                 C  	JMP	SHORT CPM70 
 0AC7                        C  CPM60:				;MEMORY IS LARGER MUST SET SF=1 AND (AL)=377 
 0AC7  B0 FF                 C  	MOV	AL,LOW 377 
 0AC9  0A C0                 C  	OR	AL,AL 
 0ACB  F9                    C  	STC			;WANT CF=1 IF MEMORY VALUE LARGER 
 0ACC  59                    C  CPM70:	POP	CX		;RESTORE CX REGISTER 
 0ACD                        C  CPM80: 
 0ACD  5F                    C  	POP	DI 
 0ACE  5B                    C  	POP	BX 
 0ACF  C3                    C  	RET 
                             C   
 0AD0                        C  $DCMPA:			;DOUBLE PRECISION COMPARE OF ($FAC) AND ($ARG) 
 0AD0  BB FFFF E             C  	MOV	BX,OFFSET $ARG-1 
                             C   
 0AD3                        C  $DCMPM:			;DOUBLE PRECISION COMPARE OF ($FAC) AND ((BX)) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-45
UTILS	   UTILITY ROUTINES                                   

                             C  				;(AL)=1 AND ZF=0,SF=0,CF=0 IF ($FAC).GT.((BX)) 
                             C  				;(AL)=0 AND ZF=1 IF ($FAC)=((BX)) 
                             C  				;(AL)=377 AND ZF=0,SF=1,CF=1 IF ($FAC).LT.((BX)) 
                             C   
 0AD3  E8 0A31 R             C  	CALL	ZCMPBX		;Check for zero exponent cases. 
 0AD6  72 A4                 C  	JB	ZEREXP		;All done if carry set. 
 0AD8  53                    C  	PUSH	BX 
 0AD9  57                    C  	PUSH	DI		;SAVE REGISTERS 
 0ADA  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1	;D.P. HIGH FAC WORD 
 0ADD  8A 05                 C  	MOV	AL,BYTE PTR 0[DI]	;WILL FIRST SEE IF SIGNS DIFFERENT 
 0ADF  32 07                 C  	XOR	AL,BYTE PTR 0[BX] 
 0AE1  79 02                 C  	JNS	DC10		;PROCEED IF NOT DIFFERENT 
 0AE3  EB AE                 C  	JMP	SHORT CPM05	;SIGNS DIFFERENT SET CODES ACCORDINGLY 
 0AE5  51                    C  DC10:	PUSH	CX 
 0AE6  B9 0004               C  	MOV	CX,4		;FOUR WORDS TO COMPARE 
 0AE9  EB BF                 C  	JMP	SHORT CPM22	;GO COMPARE 
                             C   
                             C   
 0AEB                        C  $CONI2:			;CHECK FAC FOR -32768 SINGLE PRECISION AND IF 
                             C  				;EQUAL CONVERT TO INTEGER 
 0AEB  BB 052E R             C  	MOV	BX,OFFSET $S32KM	;ADDRESS OF S.P. -32768 
 0AEE  E8 09B4 R             C  	CALL	$MOVBS		;MOVE IT OUT TO DBUFF FOR COMPARISON 
 0AF1  E8 0A81 R             C  	CALL	$COMPM		;ONLY INTERESTED IN ZF 
 0AF4  75 0B                 C  	JNZ	CON10		;IF NOT EQUAL JUST RETURN 
 0AF6  C6 06 0000 E 02       C  	MOV	BYTE PTR $VALTP,LOW 2	;TO INDICATE INTEGER 
 0AFB  C7 06 0000 E 8000     C  	MOV	WORD PTR $FACLO,OFFSET 200*400	;-32768 
 0B01  C3                    C  CON10:	RET 
                             C   
                             C   
 0B02                        C  $RSUBM:			;SUBTRACT NO POINTED TO BY (BP) FROM (BLDX) 
                             C  				;NUMBER POINTED TO BY (BP) IS PRESUMED TO BE IN 
                             C  				;THE CODE SEGMENT 
 0B02  2E: 2B 56 00          C  	SUB	DX,WORD PTR CS:0[BP]	;FIRST 16 BITS 
 0B06  2E: 1A 5E 02          C  	SBB	BL,BYTE PTR CS:2[BP] 
 0B0A  C3                    C  	RET			;COND. FLAGS ALL SET 
                             C   
                             C  ;********************************************************* 
                             C  ;THE "V" UTILITIES FOLLOW. THESE UTILITIES HAVE ONE THING IN 
                             C  ;COMMON: THEY MUST FIRST ASCERTAIN WHAT TYPE OF VARIABLE 
                             C  ;THEY ARE TO WORK ON BEFORE PERFORMING THEIR TASK. 
                             C  ;************************************************************ 
 0B0B                        C  ABSFN: 
 0B0B                        C  $VABS:				;ABSOLUTE VALUE ROUTINE 
 0B0B  E8 08EF R             C  	CALL	$GETYP		;SEE WHAT TYPE VARIABLE 
 0B0E  78 08                 C  	JS	$IABS		;IF INTEGER PROCEED 
 0B10  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1 
 0B13  0A C0                 C  	OR	AL,AL		;SEE IF CURRENTLY NEGATIVE 
 0B15  78 0E                 C  	JS	$NEG		;AND IF SO NEGATE 
 0B17  C3                    C  	RET 
 0B18  A1 0000 E             C  $IABS:	MOV	AX,WORD PTR $FACLO	;FETCH INTEGER 
 0B1B  0B C0                 C  	OR	AX,AX		;AND SEE IF ALREADY POS. 
 0B1D  78 0F                 C  	JS	VN15 
 0B1F  C3                    C  	RET			;RETURN IF POSITIVE 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-46
UTILS	   UTILITY ROUTINES                                   

 0B20                        C  VNEG: 
 0B20                        C  $VNEG:				;NEGATE THE VALUE IN THE FAC 
 0B20  E8 08EF R             C  	CALL	$GETYP		;SET COND. CODES ACCORDING TO TYPE 
 0B23  78 06                 C  	JS	$INEG		;IT'S INTEGER MUST COMPLEMENT 
                             C  ;************************************************************ 
                             C  ;IT'S SINGLE OR DOUBLE PRECISION MUST FLIP THE SIGN BIT 
                             C  ;************************************************************ 
 0B25                        C  NEG: 
 0B25                        C  $NEG: 
 0B25  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;FLIP SIGN OF FAC 
 0B2A  C3                    C  	RET 
 0B2B                        C  INEG: 
 0B2B  A1 0000 E             C  $INEG:	MOV	AX,WORD PTR $FACLO	;WILL CHECK FOR -32768 
 0B2E  3D 8000               C  VN15:	CMP	AX,100000	;SEE IF -32768 
 0B31  75 07                 C  	JNZ	VN20		;IF NOT JUST NEGATE 
 0B33  53                    C  	PUSH	BX		;PRESERVE BX 
 0B34  E8 17E9 R             C  	CALL	$CSI		;CONVERT TO SINGLE PRECISION 
 0B37  5B                    C  	POP	BX		;RECALL BX 
 0B38  EB EB                 C  	JMP	$NEG		;GO NEGATE 
 0B3A  F7 1E 0000 E          C  VN20:	NEG	WORD PTR $FACLO ;NEGATE 
 0B3E  C3                    C  	RET 
                             C   
 0B3F                        C  $SETDB:			;MOVE FAC TO DBUFF FOR MULT. AND ZERO FAC 
 0B3F  BB 0001 E             C  	MOV	BX,OFFSET $DBUFF+1	; 
 0B42  E8 0B77 R             C  	CALL	$VMVMF		;MOVE FAC TO DBUFF 
 0B45  BF FFF8 E             C  	MOV	DI,OFFSET $DFACL-10	;WILL NOW ZERO 16 BYTES OF FAC 
 0B48  B9 0008               C  	MOV	CX,10 
 0B4B  B8 0000               C  	MOV	AX,0 
 0B4E  FC                    C  	CLD 
 0B4F  F3/ AB                C   REP	STOSW			;STORES (AX) INTO LOCATIONS 
 0B51  A2 0000 E             C  	MOV	BYTE PTR $DBUFF,AL	;ZERO OVERFLOW BYTE 
 0B54  A2 FFFF E             C  	MOV	BYTE PTR $ARGLO-1,AL	;ZERO OVERFLOW BYTE OF ARG 
 0B57  C3                    C  	RET 
                             C   
 0B58                        C  $VMVAM:			;MOVE THE VALUE POINTED TO BY (BX) TO (BXDX) IF SINGLE 
                             C  				;PRECISION, TO $ARG IF DOUBLE PRECISION 
 0B58  E8 08EF R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 0B5B  72 03                 C  	JB	VM10		;JUMP IF SINGLE PRECISION 
 0B5D  E9 09DA R             C  	JMP	MOVAM		;MOVE THE VALUE TO THE ARG 
 0B60  8B 17                 C  VM10:	MOV	DX,WORD PTR 0[BX]	;FETCH LOW MANTISSA BITS 
 0B62  8B 5F 02              C  	MOV	BX,WORD PTR 2[BX]	;FETCH HIGH MANTISSA AND EXPONENT 
 0B65  C3                    C  	RET 
                             C   
                             C   
 0B66                        C  $VMOVM:			;MOVE THE VARIABLE POINTED TO BY (BX) TO THE ONE POINTED 
                             C  				;TO BY (DI) 
 0B66  B9 0004               C  	MOV	CX,4		;ASSUME DOUBLE PRECISION 
 0B69  E8 08EF R             C  	CALL	$GETYP 
 0B6C  72 03                 C  	JB	VMM10		;IT'S SINGLE PREC JUMP 
 0B6E  E9 09E0 R             C  	JMP	MOVEM		;GO DO MOVE 
 0B71  B9 0002               C  VMM10:	MOV	CX,2 
 0B74  E9 09E0 R             C  	JMP	MOVEM		;GO DO MOVE 
                             C   
 0B77                        C  $VMVMF:			;MOVE THE FAC TO THE NO. POINTED TO BY (BX) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-47
UTILS	   UTILITY ROUTINES                                   

 0B77  B9 0004               C  	MOV	CX,4		;ASSUME DOUBLE PREC. 
 0B7A  87 FB                 C  	XCHG	DI,BX		;(DI)=DESTINATION,(BX)=ORIGIN 
 0B7C  BB 0000 E             C  	MOV	BX,OFFSET $DFACL 
 0B7F  E8 08EF R             C  	CALL	$GETYP		;SET COND. CODES ACCORDING TO $VALTP 
 0B82  72 03                 C  	JB	VMVM1		;JUMP IF S.P. 
 0B84  E9 09E0 R             C  	JMP	MOVEM		;GO DO MOVE 
 0B87  87 DF                 C  VMVM1:	XCHG	BX,DI 
 0B89  B9 0002               C  $MOVMF: MOV	CX,2 
 0B8C  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 0B8F  87 FB                 C  	XCHG	DI,BX 
 0B91  E9 09E0 R             C  	JMP	MOVEM		;GO DO MOVE 
                             C   
 0B94                        C  $VMVFM:			;MOVE TO FAC THE NO POINTED TO BY (BX) 
 0B94  B9 0004               C  	MOV	CX,4		;ASSUME DOUBLE PREC 
 0B97  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 0B9A  E8 08EF R             C  	CALL	$GETYP 
 0B9D  72 03                 C  	JB	$MOVFM 
 0B9F  E9 09E0 R             C  	JMP	MOVEM 
 0BA2  B9 0002               C  $MOVFM: MOV	CX,2 
 0BA5  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 0BA8  E9 09E0 R             C  	JMP	MOVEM		;GO DO MOVE 
                             C   
 0BAB                        C  $VCMPM:			;COMPARE FAC TO NO. POINTED TO BY (BX) 
 0BAB  E8 08EF R             C  	CALL	$GETYP 
 0BAE  72 03                 C  	JB	VCMP10 
 0BB0  E9 0AD3 R             C  	JMP	$DCMPM		;DO DOUBLE PREC COMPARE 
 0BB3  E9 0A81 R             C  VCMP10: JMP	$COMPM		;SINGLE PREC COMPARE 
                             C   
 0BB6                        C  $VPSHF:			;PUSH THE FAC ON THE STACK ACCORDING TO TYPE 
 0BB6  E8 08EF R             C  	CALL	$GETYP		;SET COND CODES ACCORDING TO $VALTP 
 0BB9  B9 0004               C  	MOV	CX,4		;FOR DOUBLE PRECISION 
 0BBC  73 03                 C  	JNB	VPS10		;IF DOUBLE PREC PROCEED 
 0BBE                        C  $PUSHF:			;PUSH SINGLE PRECISION FAC ON THE STACK 
 0BBE  B9 0002               C  	MOV	CX,2 
 0BC1  5D                    C  VPS10:	POP	BP		;GET RETURN ADDRESS OFF STACK 
 0BC2  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1 
 0BC5  FF 35                 C  VPS20:	PUSH	WORD PTR 0[DI] 
 0BC7  4F                    C  	DEC	DI 
 0BC8  4F                    C  	DEC	DI 
 0BC9  E2 FA                 C  	LOOP	VPS20 
 0BCB  55                    C  	PUSH	BP		;GET RETURN ADDRESS RIGHT 
 0BCC  C3                    C  	RET			;AND RETURN 
 0BCD                        C  $POPA:				;POP STACK INTO ARG 
 0BCD  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 0BD0  B9 0004               C  	MOV	CX,4 
 0BD3  EB 11                 C  	JMP	SHORT VPO17 
 0BD5                        C  $VPOPF:			;POP EITHER 4 OR 8 BYTES OFF THE STACK 
 0BD5  E8 08EF R             C  	CALL	$GETYP		;SET CODES ACCORDING TO $VALTP 
 0BD8  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 0BDB  B9 0004               C  	MOV	CX,4 
 0BDE  73 06                 C  	JNB	VPO17		;JUMP IF DOUBLE PRECISION 
 0BE0  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 0BE3  B9 0002               C  	MOV	CX,2 
 0BE6  58                    C  VPO17:	POP	AX		;GET RETURN ADDRESS OFF STACK 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-48
UTILS	   UTILITY ROUTINES                                   

 0BE7  8F 05                 C  VPO20:	POP	WORD PTR 0[DI] 
 0BE9  47                    C  	INC	DI 
 0BEA  47                    C  	INC	DI 
 0BEB  E2 FA                 C  	LOOP	VPO20 
 0BED  50                    C  	PUSH	AX		;PUSH RETURN ADDRESS ON STACK 
 0BEE  C3                    C  	RET 
 0BEF                        C  VINT: 
 0BEF                        C  $VINT:				;DO INT ACCORDING TO TYPE (SINGLE OR DOUBLE PRECISION) 
 0BEF  E8 08EF R             C  	CALL	$GETYP		;SET CODES ACCORDING TO TYPE 
 0BF2  79 01                 C  	JNS	VIN05 
 0BF4  C3                    C  	RET			;RETURN IF INTEGER ALREADY 
 0BF5                        C  VIN05: 
 0BF5  72 03                 C  	JB	VIN10		;JUMP IF SINGLE PRECISION 
 0BF7  E9 1B69 R             C  	JMP	$DINT		;GO DO DOUBLE PRECISION 
 0BFA  E9 1BD8 R             C  VIN10:	JMP	$INT 
                             C   
                             C  	SUBTTL	 $FIN	 NUMERIC INPUT ROUTINE 
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;       $FIN    GIVEN A TEXT POINTER, $FIN WILL BUILD AN INPUT 
                             C  ;               NUMBER IN THE FAC. AS NECESSARY (OR IF FORCED) 
                             C  ;               $FIN WILL GO TO NEXT HIERARCHY OF NUMBERS 
                             C  ;               I.E. TRANSITIONS FROM INTEGER-SINGLE PRECISION- 
                             C  ;               DOUBLE PRECISION CAN EITHER BE FORCED OR DICTATED 
                             C  ;               BY THE INPUT NUMBERS. 
                             C  ;       CALLING         SEQUENCE:       CALL    $FIN 
                             C  ;               WITH (BX) POINTING TO TEXT CONTAINING THE NUMBER 
                             C  ;               TO BE CONVERTED FROM ASCII. 
                             C  ; 
                             C  ;****************************************************************** 
                             C   
                             C   
                             C   
 0BFD                        C  FIN: 
 0BFD  32 C0                 C  $FIN:	XOR	AL,AL		;LET INPUT NUMBER DETERMINE TYPE 
 0BFF  EB 0A                 C  	JMP	SHORT FN20 
 0C01                        C  FINDBL: 
 0C01                        C  $FINDB:			;FORCE DOUBLE PRECISION ENTRY POINT 
                             C  	DBGBRK 
 0C04  B0 01                 C  	MOV	AL,LOW 1	;FLAG TO INDICATE D.P. 
 0C06  C6 06 0000 E 08       C  	MOV	BYTE PTR $VALTP,LOW 10	;SET TO DOUBLE PRECISION 
 0C0B                        C  FN20: 
 0C0B  C6 06 0000 E 01       C  	MOV	BYTE PTR $FLGOV,LOW 1	;SET ONCE-ONLY OVERFLOW MODE 
 0C10  BE 0000 E             C  	MOV	SI,OFFSET $FLGOC	;ADDRESS OF INPUT OVERFLOW CODE 
 0C13  56                    C  	PUSH	SI		;PUSH ON STACK SO RETURN IS HERE 
 0C14  33 FF                 C  	XOR	DI,DI		;DIGITS PAST DECIMAL POINT 
 0C16  8B CF                 C  	MOV	CX,DI		;DECIMAL POINT FLAG 
 0C18  8B F7                 C  	MOV	SI,DI		;(SI) WILL FLAG POS/NEG EXPONENT 
 0C1A  F7 D1                 C  	NOT	CX		;SET ALL BITS 
 0C1C  50                    C  	PUSH	AX 
 0C1D  E8 08B5 R             C  	CALL	$ZERO		;(FAC)=0 
 0C20  58                    C  	POP	AX 
 0C21  0A C0                 C  	OR	AL,AL		;MUST SEE IF $VALTP SHOULD START AT 
 0C23  75 05                 C  	JNZ	FN30		;INTEGER OR NOT. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-49
$FIN	 NUMERIC INPUT ROUTINE                                 

 0C25  C6 06 0000 E 02       C  	MOV	BYTE PTR $VALTP,LOW 2	;SET TO INTEGER 
 0C2A  8A 07                 C  FN30:	MOV	AL,BYTE PTR 0[BX]	;FETCH 1ST CHARACTER FROM TEXT 
 0C2C  3C 26                 C  	CMP	AL,LOW "&"      ;SIGNIFIES SPECIAL INPUT NO. 
 0C2E  75 03                 C  	JNZ	FN40		;IF NOT, PROCEED 
 0C30  E9 0000 E             C  	JMP	$OHCNS		;OTHERWISE GO PROCESS OCT. OR HEX 
 0C33  3C 2D                 C  FN40:	CMP	AL,LOW "-"      ;NEGATIVE NUMBER? 
 0C35  9C                    C  	PUSHF			;WILL SAVE ZF FOR POSSIBLE NEGATION 
 0C36  74 05                 C  	JZ	FN50		;ONCE NUMBER IS FORMED POSITIVE 
 0C38  3C 2B                 C  	CMP	AL,LOW "+"      ;NEED TO ADVANCE TEXT POINTER FOR 
 0C3A  74 01                 C  	JZ	FN50		;LEADING SIGN 
 0C3C  4B                    C  	DEC	BX		; 
 0C3D  E8 0E5F R             C  FN50:	CALL	$CHRGT		;GET NEXT CHARACTER OF NUMBER 
 0C40  73 05                 C  	JNB	FN60		;IF NOT DIGIT GO EXAMINE FURTHER 
 0C42  E8 16B6 R             C  FN55:	CALL	$FIDIG		;MUL FAC BY TEN AND ADD IN THE DIGIT 
 0C45  EB F6                 C  	JMP	SHORT FN50 
 0C47                        C  FN60: 
 0C47  BD 04D2 R             C  	MOV	BP,OFFSET $FINCH+7 
 0C4A  33 D2                 C  	XOR	DX,DX		;MUST SET EXPONENT TO ZERO 
 0C4C  8B F2                 C  	MOV	SI,DX		;FOR SUBSEQUENT CALL TO FINE 
 0C4E                        C  FN70: 
 0C4E  2E: 3A 46 00          C  	CMP	AL,BYTE PTR CS:0[BP]	;CODE SEGMENT 
 0C52  74 09                 C  	JZ	FN80		;FOUND SPEC CH (.,D,D+40,!,#,%,E,E+40) 
 0C54  81 FD 04CB R          C  	CMP	BP,OFFSET $FINCH	;IF EQUAL NONE OF THE SPECIAL CHARS. 
 0C58  74 23                 C  	JZ	FN96		;GO FNISH UP NUMBER NON-RECOG. CHAR. 
 0C5A  4D                    C  	DEC	BP		;PROCEED TO NEXT CHARACTER 
 0C5B  EB F1                 C  	JMP	SHORT FN70	;IF NOT FNISHED LOOK AT NEXT CHAR. 
 0C5D  81 ED 04CB R          C  FN80:	SUB	BP,OFFSET $FINCH	; 
 0C61  D1 E5                 C  	SHL	BP,1		; BRANCH TABLE ENTRIES 2 BYTES EA 
 0C63                        C  FN90: 
                             C  				;CODE SEGMENT OVERRIDE PREFIX 
 0C63  2E: FF A6 0C68 R      C  	JMP	 WORD PTR CS:FN95[BP] 
 0C68                        C  FN95  LABEL WORD 
 0C68  0C82 R                C  	DW	OFFSET FN100 
 0C6A  0C95 R                C  	DW	OFFSET FN200 
 0C6C  0C95 R                C  	DW	OFFSET FN200 
 0C6E  0C9C R                C  	DW	OFFSET FN400 
 0C70  0C9F R                C  	DW	OFFSET FN500 
 0C72  0CA4 R                C  	DW	OFFSET FN600 
 0C74  0C78 R                C  	DW	OFFSET FN92 
 0C76  0C78 R                C  	DW	OFFSET FN92 
 0C78                        C  FN92:				;IT WAS A "D" 
 0C78  32 C0                 C  	XOR	AL,AL		;SET CONDITION CODES CORRECTLY 
 0C7A  E8 172F R             C  FN94:	CALL	$FINEX		;CALCULATE EXPONENT 
 0C7D  E8 0705 R             C  FN96:	CALL	$FINE		;MODIFY NUMBER TO REFLECT EXPONENT 
 0C80  EB 27                 C  	JMP	SHORT FINF	;CLEAN UP, NEGATE AS NECESSARY 
 0C82                        C  FN100:				;IT WAS A "." 
 0C82  41                    C  	INC	CX		;TO DENOTE DECIMAL POINT DETECTED 
 0C83  75 F8                 C  	JNZ	FN96		;GO FINISH UP NO.-2ED DECIMAL PT. SEEN! 
 0C85  E8 08EF R             C  	CALL	$GETYP		;IF SNG OR DOUBLE JUST RETURN 
 0C88  79 B3                 C  	JNS	FN50 
 0C8A  51                    C  	PUSH	CX 
 0C8B  53                    C  	PUSH	BX 
 0C8C  57                    C  	PUSH	DI 
 0C8D  E8 17E9 R             C  	CALL	$CSI		;CONVERT TO SINGLE PRECISION 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-50
$FIN	 NUMERIC INPUT ROUTINE                                 

 0C90  5F                    C  	POP	DI 
 0C91  5B                    C  	POP	BX 
 0C92  59                    C  	POP	CX 
 0C93  EB A8                 C  	JMP	FN50		;GO PROCESS NEXT CHAR. 
 0C95                        C  FN200:				;IT WAS AN "E" OR  "E"+40 (LOWER CASE E) 
 0C95  E8 1258 R             C  	CALL	$CHKEL		;MAKE SURE WE DON'T HAVE AN "ELSE" 
 0C98  74 E3                 C  	JZ	FN96		;IT WAS AN "ELSE" OR "EQV" 
 0C9A  EB DE                 C  	JMP	SHORT FN94	;GO DETERMINE EXPONENT 
 0C9C                        C  FN400:				;IT WAS A "%" (INTEGER) 
 0C9C  43                    C  	INC	BX		;Eat the percent sign. 
 0C9D  EB DE                 C  	JMP	SHORT FN96	;Call $FINE since could be working 
                             C  				;on a floating point. 
                             C   
 0C9F                        C  FN500:				;IT WAS A "#" (DOUBLE PRECISION) 
 0C9F  E8 177A R             C  	CALL	$FIND 
 0CA2  EB 05                 C  	JMP	SHORT FINF	;GO FINISH UP 
 0CA4                        C  FN600:				;IT WAS A "!"    (SINGLE PRECISION) 
 0CA4  32 C0                 C  	XOR	AL,AL		;FLAG AS SINGLE 
 0CA6  E8 177C R             C  	CALL	$FINS		;FORCE TO SINGLE PRECISION 
 0CA9  9D                    C  FINF:	POPF			;RECALL SIGN FLAG 
 0CAA  75 0D                 C  	JNZ	FN990		;RETURN IF NOT NEGATIVE NO. 
 0CAC  E8 0B20 R             C  	CALL	$VNEG		;NEGATE NUMBER 
 0CAF  E8 08EF R             C  	CALL	$GETYP		;SET CONDITION CODES ACCORDING TO TYPE 
 0CB2  7A 05                 C  	JPE	FN990		;IF NOT SINGLE PRECISION RETURN 
 0CB4  53                    C  	PUSH	BX		;SAVE TEXT POINTER 
 0CB5  E8 0AEB R             C  	CALL	$CONI2		;CHECK FOR -32768 AND CONVERT TO INT. 
 0CB8  5B                    C  	POP	BX		;RECALL TEXT POINTER 
                             C  				;IF FOUND 
 0CB9  C3                    C  FN990:	RET 
                             C   
                             C  	SUBTTL	 $FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS. 
                             C  ;*********************************************************** 
                             C  ; 
                             C  ;       $FPWR   CALCULATES X^Y BY X^Y=EXP(Y*LOG(X)) 
                             C  ; 
                             C  ;       CALLING SEQUENCE:       CALL    $FPWR 
                             C  ;               WITH Y IN THE $FAC, X IN (BXDX) 
                             C  ;       $SQR    ENTRY POINT TO PROVIDE SQUARE ROOT FUNCTION 
                             C  ;       CALLING SEQUENCE:       CALL    $SQR 
                             C  ;               WITH ARGUMENT IN $FAC 
                             C  ; 
                             C  ;************************************************************ 
                             C   
                             C  ;SQUARE ROOT FUNCTION (FAC)=SQR(FAC) 
 0CBA                        C  SQR: 
 0CBA                        C  $SQR: 
 0CBA  8B 16 FFFE E          C  	MOV	DX,WORD PTR $FAC-2 
 0CBE  0A F6                 C  	OR	DH,DH		;Test sign bit 
 0CC0  78 68                 C  	JS	NEGNUM 
 0CC2  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;Get exponent 
 0CC5  0A C0                 C  	OR	AL,AL 
 0CC7  74 60                 C  	JZ	DONE		;SQR(0)=0 
 0CC9  8A 3E FFFD E          C  	MOV	BH,BYTE PTR $FAC-3 
 0CCD  B3 00                 C  	MOV	BL,LOW 0 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-51
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0CCF  80 CE 80              C  	OR	DH,LOW 128D	;Set implied bit 
 0CD2  D0 E8                 C  	SHR	AL,1		;Divide exponent by two 
 0CD4  73 05                 C  	JNB	EVENEX		; 
 0CD6  D1 EA                 C  	SHR	DX,1		;HALF MANTISSA IF EXP ODD 
 0CD8  D1 DB                 C  	RCR	BX,1 
 0CDA  F9                    C  	STC			;RESTORE CARRY FOR ROUND UP 
 0CDB                        C  EVENEX: 
 0CDB  14 40                 C  	ADC	AL,LOW 100O	;ADD BACK 1/2 OF BIAS 
 0CDD  A2 0000 E             C  	MOV	BYTE PTR $FAC,AL	;SAVE FINAL EXPONENT 
 0CE0  B9 0019               C  	MOV	CX,25D		;24 BITS PLUS 1 FOR ROUNDING 
 0CE3  33 ED                 C  	XOR	BP,BP		;CLEAR SOME REGISTERS 
 0CE5  8B F5                 C  	MOV	SI,BP 
 0CE7  8B FD                 C  	MOV	DI,BP 
 0CE9  8B C5                 C  	MOV	AX,BP 
 0CEB                        C  RTLP: 
 0CEB  D1 E3                 C  	SHL	BX,1		;64 BIT LEFT SHIFT OF INPUT 
 0CED  D1 D2                 C  	RCL	DX,1 
 0CEF  D1 D7                 C  	RCL	DI,1 
 0CF1  D1 D5                 C  	RCL	BP,1 
 0CF3  D1 E3                 C  	SHL	BX,1		;SHIFT IT TWICE 
 0CF5  D1 D2                 C  	RCL	DX,1 
 0CF7  D1 D7                 C  	RCL	DI,1 
 0CF9  D1 D5                 C  	RCL	BP,1 
 0CFB  F9                    C  	STC			;ROTATE IN TEST BIT 
 0CFC  D1 D6                 C  	RCL	SI,1		;32-BIT SHIFT OF PARTIAL RESULT 
 0CFE  D1 D0                 C  	RCL	AX,1 
 0D00  2B FE                 C  	SUB	DI,SI		;TRY TEST BIT 
 0D02  1B E8                 C  	SBB	BP,AX 
 0D04  73 09                 C  	JNB	ROOTBT		;JUMP OUT IF IT FIT 
 0D06  03 FE                 C  	ADD	DI,SI		;RESTORE IF IT DIDN'T 
 0D08  13 E8                 C  	ADC	BP,AX 
 0D0A  4E                    C  	DEC	SI 
 0D0B  E2 DE                 C  	LOOP	RTLP 
 0D0D  EB 03                 C  	JMP	SHORT FPWRND 
 0D0F                        C  ROOTBT: 
 0D0F  46                    C  	INC	SI		;HERE IF TEST BIT FIT 
 0D10  E2 D9                 C  	LOOP	RTLP		;SET REAL RESULT BIT AND CONTINUE 
 0D12                        C  FPWRND: 
 0D12  D1 E8                 C  	SHR	AX,1		;HALF TO A 25-BIT RESULT 
 0D14  D1 DE                 C  	RCR	SI,1 
 0D16  D1 E8                 C  	SHR	AX,1		;TO A 24-BIT RESULT 
 0D18  D1 DE                 C  	RCR	SI,1 
 0D1A  83 D6 00              C  	ADC	SI,0		;ROUND IF A 1 SHIFTED OUT 
 0D1D  15 0000               C  	ADC	AX,0		;AND PROPAGATE CARRY 
 0D20  89 36 FFFD E          C  	MOV	WORD PTR $FAC-3,SI	;STORE RESULT 
 0D24  24 7F                 C  	AND	AL,LOW 177O	;CLEAR SIGN BIT 
 0D26  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL	;AND STORE 
 0D29  C3                    C  DONE:	RET 
                             C   
 0D2A  E9 0000 E             C  NEGNUM: JMP	$FCERR 
                             C   
 0D2D                        C  $FPWR:				;INVOLUTION ($FAC):=(BXDX)^($FAC) 
                             C  				;OR         (FAC)=X^Y 
 0D2D  BF 0000 E             C  	MOV	DI,OFFSET $CLROV 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-52
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0D30  57                    C  	PUSH	DI 
 0D31  BF 0000 E             C  	MOV	DI,OFFSET $FLGOV 
 0D34  C6 05 01              C  	MOV	BYTE PTR 0[DI],LOW 1	;ONCE-ONLY OVERFLOW MODE 
 0D37  E8 08BF R             C  	CALL	$SIGNS		;SEE IF Y IS ZERO 
 0D3A  75 03                 C  	JNZ	FP10 
 0D3C  E9 126C R             C  	JMP	$EXP		;ANS IS 1 IF Y=0 
 0D3F  79 07                 C  FP10:	JNS	FP20		;IF NEGATIVE POTENTIAL OVERFLOW 
 0D41  0A FF                 C  	OR	BH,BH		;IF X IS ZERO 
 0D43  75 0A                 C  	JNZ	FP25 
 0D45  E9 0787 R             C  	JMP	$DIV0S		;DIVIDE-BY-ZERO CODE 
 0D48  0A FF                 C  FP20:	OR	BH,BH		;SEE IF ZERO TO POWER 
 0D4A  75 03                 C  	JNZ	FP25 
 0D4C  E9 08B5 R             C  	JMP	$ZERO		;ANS IS ZERO 
 0D4F                        C  FP25:				;WE KNOW AT THIS POINT THAT X IS NON-ZERO. IF X IS NEGATIVE 
                             C  				;THEN Y MUST BE AN INTEGRAL POWER OR WE HAVE A FUNCTION 
                             C  				;CALL ERROR 
 0D4F  0A DB                 C  	OR	BL,BL		;IS X NEGATIVE? 
 0D51  79 26                 C  	JNS	FP30		;IF NOT PROCEED 
 0D53  80 3E 0000 E 99       C  	CMP	BYTE PTR $FAC,LOW 231	;SEE IF Y TOO LARGE TO DETERMINE SIGN 
                             C  				;OF INVOLUTION RESULT 
 0D58  72 03                 C  	JB	FP27		;JUMP IF OK TO COMPUTE 
 0D5A  E9 0000 E             C  	JMP	$FCERR 
 0D5D                        C  FP27: 
 0D5D  52                    C  	PUSH	DX		;SAVE X ON THE STACK 
 0D5E  53                    C  	PUSH	BX 
 0D5F  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;PUSH Y ON THE STACK 
 0D63  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 
 0D67  E8 1BD8 R             C  	CALL	$INT		;MAKE Y AN INTEGER 
 0D6A  5B                    C  	POP	BX		;Y TO THE REGISTERS 
 0D6B  5A                    C  	POP	DX 
 0D6C  E8 0A41 R             C  	CALL	$FCOMP		;SEE IF Y IS AN INTEGER 
 0D6F  E8 0A06 R             C  	CALL	$MOVFR		;MOVE ORIGINAL Y BACK TO FAC 
 0D72  5B                    C  	POP	BX		;RECALL X 
 0D73  5A                    C  	POP	DX 
 0D74  74 03                 C  	JZ	FP30		;PROCEED IF Y IS AN INTEGER 
 0D76  E9 0000 E             C  	JMP	$FCERR		;OTHERWISE WE HAVE FCN CALL ERROR 
 0D79  A0 FFFF E             C  FP30:	MOV	AL,BYTE PTR $FAC-1	;NEED TO KNOW IF Y IS NEGATIVE 
 0D7C  0A C0                 C  	OR	AL,AL 
 0D7E  79 3D                 C  	JNS	FP30A		;Y POSITIVE 
 0D80  24 7F                 C  	AND	AL,LOW 177	;Y is negative - will invert when 
 0D82  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL	;finished.  Clear the sign bit of Y. 
 0D85  53                    C  	PUSH	BX		;Save the sign of X. 
 0D86  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;Save Y. 
 0D8A  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0D8E  E8 0DBD R             C  	CALL	FP30A		;FAC:=X^positive Y. 
 0D91  F6 06 0000 E FF       C  	TEST	BYTE PTR $FAC,LOW 377O	;Did it underflow? 
 0D96  75 19                 C  	JNZ	INVERT		;No, go invert it. 
 0D98  8F 06 0000 E          C  	POP	WORD PTR $FACLO ;Yes, pop Y into the FAC. 
 0D9C  8F 06 0000 E          C  	POP	WORD PTR $FACM1 
 0DA0  E8 1C3B R             C  	CALL	$QINT		;Get least significant byte of Y 
                             C  				;into DL. 
 0DA3  5B                    C  	POP	BX		;Get sign of X into BL bit 7. 
 0DA4  D0 CA                 C  	ROR	DL,1		;Set sign bit of FAC if X is negative 
 0DA6  22 DA                 C  	AND	BL,DL		;and Y is odd. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-53
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0DA8  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL 
 0DAC  B7 FF                 C  	MOV	BH,LOW 377O	;Make BH nonzero for DOINF routine 
                             C  				;(which is called by $OVFLS) so it uses 
                             C  				;$FAC+1 to determine the sign of the 
                             C  				;inifinity to use. 
 0DAE  E9 0776 R             C  	JMP	$OVFLS		;Give Overflow error with and return 
                             C  				;appropriate (negative or positive) 
                             C  				;inifinity based on the sign just 
                             C  				;put into the FAC. 
                             C   
 0DB1  83 C4 06              C  INVERT: ADD	SP,6		;Pop off the garbage. 
 0DB4  BA 0000               C  	MOV	DX,0		;BXDX:=1.0. 
 0DB7  BB 8100               C  	MOV	BX,100400 
 0DBA  E9 15DA R             C  	JMP	$FDIVS		;Invert the result and return. 
                             C   
 0DBD                        C  FP30A: 
 0DBD  53                    C  	PUSH	BX		;SAVE X ON THE STACK 
 0DBE  52                    C  	PUSH	DX 
 0DBF  80 CB 7F              C  	OR	BL,LOW 177	;SET CODES TO REFLECT SIGNS OF X 
 0DC2  9C                    C  	PUSHF			;SAVE X POS/NEG INFORMATION 
 0DC3  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;PUSH Y ON THE STACK 
 0DC7  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0DCB  E8 1BD8 R             C  	CALL	$INT		;MUST DETERMINE IF Y IS AN INTEGER 
 0DCE  5A                    C  	POP	DX		;RECALL ORIGINAL Y 
 0DCF  5B                    C  	POP	BX 
 0DD0  E8 0A41 R             C  	CALL	$FCOMP		;ZF=1 IF Y IS AN INTEGER 
 0DD3  75 15                 C  	JNZ	FP34		;IF NOT INTEGER PROCEED AS NORMAL 
 0DD5  52                    C  	PUSH	DX		;SAVE Y 
 0DD6  53                    C  	PUSH	BX 
 0DD7  BA 0000               C  	MOV	DX,0		;WILL MAKE (BXDX) 32768. 
 0DDA  BB 9000               C  	MOV	BX,110000 
 0DDD  E8 0A41 R             C  	CALL	$FCOMP		;SEE IF TOO LARGE 
 0DE0  5B                    C  	POP	BX		;RECALL Y 
 0DE1  5A                    C  	POP	DX 
 0DE2  79 06                 C  	JNS	FP34		;AND IF SO COMPUTE WITH LOG & EXP 
 0DE4  9D                    C  	POPF			;GET X POS/NEG INFO OFF STACK 
 0DE5  5A                    C  	POP	DX		;GET X TO REGISTERS 
 0DE6  5B                    C  	POP	BX 
 0DE7  EB 34 90              C  	JMP	XTON		;AND COMPUTE X^N 
                             C   
 0DEA  9D                    C  FP34:	POPF			;GET X POS/NEG INFORMATION 
 0DEB  79 0E                 C  	JNS	FP40		;NO PROBS IF X IS POSITIVE 
 0DED  53                    C  	PUSH	BX		;SAVE Y ON THE STACK 
 0DEE  52                    C  	PUSH	DX 
 0DEF  E8 1C3B R             C  	CALL	$QINT		;NEED EVEN-ODD INFORMATION 
 0DF2  8A C2                 C  	MOV	AL,DL		;GET LOW BYTE OF INTEGER 
 0DF4  E8 1CE8 R             C  	CALL	$NORMS		;($FAC)=INT(Y) 
 0DF7  5A                    C  	POP	DX		;RECALL Y 
 0DF8  5B                    C  	POP	BX 
 0DF9  D0 D8                 C  	RCR	AL,1		;CF=1 IF ODD 
 0DFB  8F 06 0000 E          C  FP40:	POP	WORD PTR $FACLO ;GET X TO FAC 
 0DFF  8F 06 0002 E          C  	POP	WORD PTR $FACLO+2 
 0E03  9F                    C  	LAHF			;SAVE EVEN/ODD INFO 
 0E04  80 26 0000 E 7F       C  	AND	BYTE PTR $FACM1,LOW 177 ;CLEAR ANY SIGN BIT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-54
$FPWR/$SQR	 INVOLUTION/SQUARE RT. OF SINGLE PRECISION NOS.  

 0E09  9E                    C  	SAHF			;GET EVEN/ODD INFO 
 0E0A  73 04                 C  	JNB	FP60 
 0E0C  BF 0B25 R             C  	MOV	DI,OFFSET $NEG 
 0E0F  57                    C  	PUSH	DI		;WILL NEGATE AT THE END IF CF=1 
 0E10  53                    C  FP60:	PUSH	BX		;SAVE Y AGAIN 
 0E11  52                    C  	PUSH	DX 
 0E12  E8 1C44 R             C  	CALL	$LOG		;LOG(X) 
 0E15  5A                    C  	POP	DX		;RECALL Y 
 0E16  5B                    C  	POP	BX 
 0E17  E8 1921 R             C  	CALL	$FMULS		;($FAC)=Y*LOG(X) 
 0E1A  E9 126C R             C  	JMP	$EXP		;COMPLETE CALCULATION 
                             C  ;************************************************************** 
                             C  ;       ($FAC)=($FAC)^(BXDX) 
                             C  ;WHERE (BXDX) IS AN INTEGER SUCH THAT 0.LT.(BXDX).LE.32767 
                             C  ; 
                             C  ;OR AS IN KNUTH X**N IS AS FOLLOWS 
                             C  ;THE ALGORITHM IS TAKEN FROM KNUTH VOL2 P400 
                             C  ;A1.Y=1, Z=X 
                             C  ;A2.HALVE N AND DETERMINE IF N WAS EVEN OR ODD. IF N WAS EVEN 
                             C  ;   THEN JUMP TO A4. 
                             C  ;A3.Y=Y*Z 
                             C  ;A4.IF N = 0 FINISHED WITH Y THE ANSWER 
                             C  ;A5.Z=Z*Z AND RETURN TO A2 
                             C  ;*************************************************************** 
 0E1D                        C  XTON:				;($FAC):=(BXDX)^($FAC) 
 0E1D  53                    C  	PUSH	BX		;SAVE X ON STACK 
 0E1E  52                    C  	PUSH	DX 
 0E1F  E8 1C3B R             C  	CALL	$QINT		;CONVERT TO INTEGER 
 0E22  89 16 0000 E          C  	MOV	WORD PTR $ARG,DX	;N TO $ARG 
 0E26  C7 06 0000 E 0000     C  	MOV	WORD PTR $FACLO,0	;WILL MOVE 1.0 TO FAC 
 0E2C  C7 06 0000 E 8100     C  	MOV	WORD PTR $FACM1,100400	; 
 0E32  D1 2E 0000 E          C  XTON10: SHR	WORD PTR $ARG,1 ;SHIFT RIGHT 1 BIT 
 0E36  73 07                 C  	JNB	XTON20		;IF NO MULTIPLY THEN Z=Z**2 
 0E38  5A                    C  	POP	DX		;FETCH Z 
 0E39  5B                    C  	POP	BX 
 0E3A  53                    C  	PUSH	BX		;AND PUT IT BACK ON STACK 
 0E3B  52                    C  	PUSH	DX 
 0E3C  E8 1921 R             C  	CALL	$FMULS		;Y=Y*Z 
 0E3F  F7 06 0000 E FFFF     C  XTON20: TEST	WORD PTR $ARG,177777	;SEE IF N HAS GONE TO ZERO 
 0E45  74 15                 C  	JZ	XTON30		;GET OUT IF FINISHED 
 0E47  5A                    C  	POP	DX		;FETCH Z TO REGISTERS 
 0E48  5B                    C  	POP	BX 
 0E49  E8 0BBE R             C  	CALL	$PUSHF		;Y TO STACK 
 0E4C  E8 0A06 R             C  	CALL	$MOVFR		;Z TO FAC 
 0E4F  E8 1921 R             C  	CALL	$FMULS		;Z=Z*Z 
 0E52  5A                    C  	POP	DX		;FETCH Y 
 0E53  5B                    C  	POP	BX 
 0E54  E8 0BBE R             C  	CALL	$PUSHF		;NEW Z TO STACK 
 0E57  E8 0A06 R             C  	CALL	$MOVFR		;Y TO FAC 
 0E5A  EB D6                 C  	JMP	SHORT XTON10	;TRY AGAIN 
 0E5C  5A                    C  XTON30: POP	DX		;GET STACK CLEAR OF Z 
 0E5D  5B                    C  	POP	BX 
 0E5E  C3                    C  	RET 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-55
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

                             C  	SUBTTL	 F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK 
                             C   
                             C   
                             C   
 0E5F  E9 0000 E             C  $CHRGT: JMP	CHRGTR 
 0E62                        C  DSUB: 
 0E62  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;WILL FLIP SIGNS OF EACH ARGUMENT 
 0E67  80 36 FFFF E 80       C  	XOR	BYTE PTR $ARG-1,LOW 200 
 0E6C  E9 12DB R             C  	JMP	$FSUBD 
 0E6F                        C  FADD: 
 0E6F  87 D9                 C  	XCHG	BX,CX 
 0E71  E9 13A3 R             C  	JMP	$FADDS 
 0E74                        C  FSUB: 
 0E74  87 D9                 C  	XCHG	BX,CX 
 0E76  E9 1397 R             C  	JMP	$FSUBS 
 0E79  87 D9                 C  FDIV:	XCHG	BX,CX 
 0E7B  E9 15DA R             C  	JMP	$FDIVS 
 0E7E                        C  CONSIH: 
 0E7E  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0E82  E9 17E9 R             C  	JMP	$CSI 
 0E85                        C  FLOAT: 
 0E85  52                    C  	PUSH	DX 
 0E86  98                    C  	CBW 
 0E87  8B D0                 C  	MOV	DX,AX 
 0E89  E8 1852 R             C  	CALL	$FLT 
 0E8C  5A                    C  	POP	DX 
 0E8D  C3                    C  	RET 
 0E8E                        C  FMULT: 
 0E8E  87 D9                 C  	XCHG	BX,CX 
 0E90  E9 1921 R             C  	JMP	$FMULS 
 0E93                        C  FPWR: 
 0E93  87 D9                 C  	XCHG	BX,CX 
 0E95  E9 0D2D R             C  	JMP	$FPWR 
                             C   
                             C  ;************************************************************* 
                             C  ;INTEGER ARITHMETIC FOLLOWS 
                             C  ;************************************************************* 
 0E98                        C  ISUB:				;(BX)=(DX)-(BX) 
 0E98  81 FB 8000            C  	CMP	BX,100000	;CHECK FOR -32768 
 0E9C  75 11                 C  	JNZ	IS10		;PROCEED IF NOT 
 0E9E  E8 1852 R             C  	CALL	$FLT		;FLOAT DX 
 0EA1  33 D2                 C  	XOR	DX,DX		;WILL SET (BXDX)=-32768.0 
 0EA3  BB 9080               C  	MOV	BX,110200 
 0EA6  E8 1397 R             C  	CALL	$FSUBS		;DO SUBTRACT 
 0EA9  E8 0B25 R             C  	CALL	$NEG		;NEGATE 
 0EAC  E9 17F5 R             C  	JMP	$FI 
 0EAF                        C  IS10: 
 0EAF  F7 DB                 C  	NEG	BX		;NEGATE AND FALL INTO ADD 
                             C   
 0EB1                        C  IADD:				;(BX)=(DX)+(BX) 
 0EB1  53                    C  	PUSH	BX		;SAVE 1ST ARG 
 0EB2  03 DA                 C  	ADD	BX,DX 
 0EB4  70 04                 C  	JO	IAD10		;IF OVERFLOW JUMP 
 0EB6  58                    C  	POP	AX		;CLEAR STACK 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-56
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 0EB7  E9 1062 R             C  	JMP	MAKINT 
 0EBA                        C  IAD10: 
 0EBA  E8 1852 R             C  	CALL	$FLT		;FLOAT 2ED ARG 
 0EBD  5A                    C  	POP	DX		;RECALL FIRST ARG 
 0EBE  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0EC2  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 ;FAC PUSHED ON THE STACK 
 0EC6  E8 1852 R             C  	CALL	$FLT		;FLOAT 2ED ARG 
 0EC9  5B                    C  	POP	BX 
 0ECA  5A                    C  	POP	DX		;GET 2ED ARG TO (BXDX) 
 0ECB  E9 13A3 R             C  	JMP	$FADDS		;GO ADD FLOATING 
                             C   
 0ECE                        C  IMULT:				;(BX)=(BX)*(DX) 
 0ECE  8B C3                 C  	MOV	AX,BX 
 0ED0  52                    C  	PUSH	DX		;SAVE 2ED ARG 
 0ED1  F7 EA                 C  	IMUL	DX		;PERFORM MULTIPLICATION 
 0ED3  5A                    C  	POP	DX		;RECALL 2ED ARG 
 0ED4  72 05                 C  	JB	IM10		;MUST FLOAT ARGS IF CF=1 
 0ED6  8B D8                 C  	MOV	BX,AX 
 0ED8  E9 1062 R             C  	JMP	MAKINT 
 0EDB                        C  IM10: 
 0EDB  53                    C  	PUSH	BX		;SAVE FIRST ARG 
 0EDC  E8 1852 R             C  	CALL	$FLT		;FLOAT 2ED ARG 
 0EDF  5A                    C  	POP	DX		;RECALL 1ST ARG 
 0EE0  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0EE4  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 
 0EE8  E8 1852 R             C  	CALL	$FLT		;FLOAT 1ST ARG 
 0EEB  5B                    C  	POP	BX 
 0EEC  5A                    C  	POP	DX		;GET 2ED ARG TO (BXDX) 
 0EED  E9 1921 R             C  	JMP	$FMULS		;GO MULTIPLY FLOATING 
                             C   
 0EF0                        C  IDIV:				;(BX)=(DX)/(BX) 
 0EF0  0B DB                 C  	OR	BX,BX		;MAKE SURE ITS NON-ZERO 
 0EF2  75 0E                 C  	JNZ	IDIV10 
 0EF4  88 36 0001 E          C  	MOV	BYTE PTR $FAC+1,DH	;FOR CORRECT SIGN 
 0EF8  FE C7                 C  	INC	BH		; Hack for DOINF to work 
 0EFA  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4 
 0EFF  E9 0787 R             C  	JMP	$DIV0S 
 0F02                        C  IDIV10: 
 0F02  81 FA 8000            C  	CMP	DX,100000	;CHECK FOR -32768 
 0F06  75 16                 C  	JNZ	IDIV15		;PROCEED IF NOT 
 0F08  83 FB FF              C  	CMP	BX,177777	;Check for special case of -32768\-1 
 0F0B  75 07                 C  	JNE	IDIV11 
 0F0D  E8 1852 R             C  	CALL	$FLT		;FLOAT DX 
 0F10  E8 0B25 R             C  	CALL	$NEG 
 0F13  C3                    C  	RET 
 0F14                        C  IDIV11: 
 0F14  83 FB 01              C  	CMP	BX,1		;Other special case 
 0F17  75 05                 C  	JNE	IDIV15 
 0F19  8B DA                 C  	MOV	BX,DX		;Put -32768\1 = -32768 in BX so we can ... 
 0F1B  E9 1062 R             C  	JMP	MAKINT		;Return it as an Int. (IDIV doesn't work) 
 0F1E                        C  IDIV15: 
 0F1E  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;WILL PERFORM (DX:AX)/(FAC) 
 0F22  B8 0000               C  	MOV	AX,0 
 0F25  A3 0000 E             C  	MOV	WORD PTR $FACM1,AX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-57
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 0F28  92                    C  	XCHG	AX,DX		;GET NO RT. ADJUSTED IN AX 
 0F29  0B C0                 C  	OR	AX,AX 
 0F2B  79 03                 C  	JNS	IDV20 
 0F2D  BA FFFF               C  	MOV	DX,177777	;SIGN EXTEND INTO DX 
 0F30  0B DB                 C  IDV20:	OR	BX,BX		;SEE IF DENOMINATOR NEEDS SIGN EXT 
 0F32  79 06                 C  	JNS	IDV30 
 0F34  C7 06 0000 E FFFF     C  	MOV	WORD PTR $FACM1,177777 
 0F3A  F7 3E 0000 E          C  IDV30:	IDIV	WORD PTR $FACLO ;16 BIT DIVIDE 
 0F3E  8B D8                 C  	MOV	BX,AX 
 0F40  E9 1062 R             C  	JMP	MAKINT 
                             C   
 0F43  87 D9                 C  MOVFR:	XCHG	BX,CX 
 0F45  E8 0A06 R             C  	CALL	$MOVFR		;MOVE TO FAC 
 0F48  87 D9                 C  	XCHG	BX,CX		;GET REGISTERS RIGHT 
 0F4A  C3                    C  	RET 
 0F4B  53                    C  MOVFM:	PUSH	BX 
 0F4C  E8 0BA2 R             C  	CALL	$MOVFM 
 0F4F  5B                    C  	POP	BX 
 0F50  83 C3 04              C  	ADD	BX,4 
 0F53  C3                    C  	RET 
 0F54  8B 16 0000 E          C  MOVRF:	MOV	DX,WORD PTR $FACLO 
 0F58  8B 0E FFFF E          C  	MOV	CX,WORD PTR $FAC-1 
 0F5C  C3                    C  	RET 
 0F5D  9C                    C  MOVMF:	PUSHF 
 0F5E  53                    C  	PUSH	BX 
 0F5F  E8 0B89 R             C  	CALL	$MOVMF 
 0F62  5B                    C  	POP	BX 
 0F63  83 C3 04              C  	ADD	BX,4 
 0F66  9D                    C  	POPF 
 0F67  C3                    C  	RET 
 0F68  E8 0000 E             C  FOUTO:	CALL	FRQINT 
 0F6B  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0F6F  E9 002E R             C  	JMP	$FOUTO 
 0F72  E8 0000 E             C  FOUTH:	CALL	FRQINT 
 0F75  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0F79  E9 0036 R             C  	JMP	$FOUTH 
 0F7C                        C  FADDS:				;ADD NO. POINTED TO BY (BX) TO (FAC) 
 0F7C  8B 17                 C  	MOV	DX,WORD PTR 0[BX] 
 0F7E  8B 5F 02              C  	MOV	BX,WORD PTR 2[BX] 
 0F81  E9 13A3 R             C  	JMP	$FADDS 
 0F84  5E                    C  PUSHF:	POP	SI		;GET OUR RETURN ADDRESS OFF STACK 
 0F85  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 0F89  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 
 0F8D  FF E6                 C  	JMP	SI 
 0F8F                        C  FCOMP: 
 0F8F  87 D9                 C  	XCHG	BX,CX 
 0F91  E8 0A41 R             C  	CALL	$FCOMP 
 0F94  87 D9                 C  	XCHG	BX,CX 
 0F96  C3                    C  	RET 
 0F97                        C  FRCSTR: 
 0F97  E8 08EF R             C  CHKSTR: CALL	$GETYP		;WANT TO ASSURE STRING 
 0F9A  74 03                 C  	JZ	CH10 
 0F9C  E9 0000 E             C  	JMP	TMERR 
 0F9F  C3                    C  CH10:	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-58
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 0FA0  87 DA                 C  INEG2:	XCHG	BX,DX 
 0FA2  E8 106C R             C  	CALL	VALSNG 
 0FA5  32 C0                 C  	XOR	AL,AL 
 0FA7  B5 98                 C  INEGAD: MOV	CH,LOW 230 
 0FA9                        C  FLOATR: 
 0FA9  BB 0000 E             C  	MOV	BX,OFFSET $FAC 
 0FAC  8A C8                 C  	MOV	CL,AL 
 0FAE  88 2F                 C  	MOV	BYTE PTR 0[BX],CH 
 0FB0  B5 00                 C  	MOV	CH,LOW 0	;ZERO OVERFLOW BYTE 
 0FB2  43                    C  	INC	BX 
 0FB3  88 2F                 C  	MOV	BYTE PTR 0[BX],CH 
 0FB5  D0 D0                 C  	RCL	AL,1 
 0FB7                        C  FADFLT: 
 0FB7  73 03                 C  	JNB	FL10 
 0FB9  E8 10D0 R             C  	CALL	NEGR 
 0FBC  8A E5                 C  FL10:	MOV	AH,CH		;OVERFLOW BYTE TO AH 
 0FBE  8A D9                 C  	MOV	BL,CL		;BL IS HIGH MANTISSA BIT 
 0FC0  E9 1CE8 R             C  	JMP	$NORMS 
 0FC3  E8 0E5F R             C  RNDMON: CALL	$CHRGT 
 0FC6  53                    C  RNDMN2: PUSH	BX 
 0FC7  33 DB                 C  	XOR	BX,BX		;WILL SET FAC TO 1.0 
 0FC9  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 0FCD  B7 81                 C  	MOV	BH,LOW 201 
 0FCF  89 1E 0000 E          C  	MOV	WORD PTR $FACM1,BX 
 0FD3  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4	;SET CORRECT TYPE 
 0FD8  E8 1F07 R             C  	CALL	$RND 
 0FDB  5B                    C  	POP	BX 
 0FDC  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4 
 0FE1  C3                    C  	RET 
 0FE2  8B C1                 C  UMULT:	MOV	AX,CX		;WILL FORM (DX)=(CX)*(DX) 
 0FE4  F7 E2                 C  	MUL	DX 
 0FE6  92                    C  	XCHG	AX,DX 
 0FE7  73 03                 C  	JNB	UM10 
 0FE9  E9 0000 E             C  	JMP	BSERR 
 0FEC  C3                    C  UM10:	RET 
 0FED  BB 0000 E             C  VMOVFA: MOV	BX,OFFSET $ARGLO 
 0FF0  BA 100F R             C  VMOVFM: MOV	DX,OFFSET MOVVFM 
 0FF3  EB 07 90              C  	JMP	VMVVFM 
 0FF6  BB 0000 E             C  VMOVAF: MOV	BX,OFFSET $ARGLO 
 0FF9  BA 1011 R             C  VMOVMF: MOV	DX,OFFSET VMOVE 
 0FFC  52                    C  VMVVFM: PUSH	DX 
 0FFD  BA 0000 E             C  VDFACS: MOV	DX,OFFSET $FACLO 
 1000  E8 08EF R             C  	CALL	$GETYP 
 1003  72 03                 C  	JB	VD15 
 1005  BA 0000 E             C  VD10:	MOV	DX,OFFSET $DFACL 
 1008  C3                    C  VD15:	RET 
 1009  8A CD                 C  MOVE1:	MOV	CL,CH 
 100B  32 ED                 C  	XOR	CH,CH 
 100D  EB 08                 C  	JMP	SHORT F4VM10	;MOVE FOR BASIC INTERPRETER 
 100F  87 DA                 C  MOVVFM: XCHG	BX,DX 
 1011  A0 0000 E             C  VMOVE:	MOV	AL,BYTE PTR $VALTP 
 1014  98                    C  	CBW 
 1015  8B C8                 C  	MOV	CX,AX 
 1017  FC                    C  F4VM10: CLD			;SO WE WILL INCREMENT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-59
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 1018  8B F2                 C  	MOV	SI,DX 
 101A  8B FB                 C  	MOV	DI,BX 
 101C  F3/ A4                C   REP	MOVSB 
 101E  8B D6                 C  	MOV	DX,SI 
 1020  8B DF                 C  	MOV	BX,DI 
 1022  C3                    C  	RET 
                             C   
                             C  ; 
                             C  ; THIS IS THE BLOCK TRANSFER ROUTINE 
                             C  ; IT MAKES SPACE BY SHOVING EVERYTHING FORWARD 
                             C  ; 
                             C  ; BX = DESTINATION OF HIGH ADDRESS 
                             C  ; DX = LOW ADDRESS TO BE TRANSFERRED 
                             C  ; CX = HIGH ADDRESS TO BE TRANSFERRED 
                             C  ; 
                             C  ; A CHECK IS MADE TO MAKE SURE A REASONABLE AMOUNT 
                             C  ; OF SPACE REMAINS BETWEEN THE TOP OF THE STACK AND 
                             C  ; THE HIGHEST LOCATION TRANSFERRED INTO 
                             C  ; 
                             C  ; ON EXIT BX=DX=LOW CX=LOCATION LOW WAS MOVED INTO 
                             C  ; 
 1023  E8 0000 E             C  BLTU:	CALL	REASON		;CHECK DESTINATION TO MAKE SURE 
                             C  				;STRING SPACE WONT BE OVERWRITTEN 
 1026  8B F1                 C  BLTUC:	MOV	SI,CX		;SET UP HIGH ADDRESS 
 1028  8B FB                 C  	MOV	DI,BX		;SET UP DESTINATION OF HIGH ADDRESS 
 102A  FD                    C  	STD			;MOVE DOWN 
 102B  2B CA                 C  	SUB	CX,DX		;GET COUNT OF BYTES TO TRANSFER 
 102D  41                    C  	INC	CX		;ALWAYS MOVE ONE BYTE 
 102E  F3/ A4                C   REP	MOVSB			;MOVE BYTES 
 1030  8B DA                 C  	MOV	BX,DX		;BX=LOW 
 1032  8B CF                 C  	MOV	CX,DI		;CX=DESTINATION OF LOW 
 1034  41                    C  	INC	CX		;CORRECT AS DECREMENTED ONE TOO MANY 
 1035  FC                    C  	CLD			;SET DIRECTION BIT TO UP 
 1036  C3                    C  	RET 
                             C   
 1037  9C                    C  DCXBRT: PUSHF 
 1038  49                    C  	DEC	CX 
 1039  9D                    C  	POPF 
 103A  C3                    C  	RET 
 103B  E8 08EF R             C  VSIGN:	CALL	$GETYP		;DETERMINE TYPE 
 103E  75 03                 C  	JNZ	VS10		;IF NOT STRING PROCEED 
 1040  E9 0000 E             C  	JMP	TMERR 
 1043                        C  VS10: 
 1043  78 03                 C  	JS	ISI10 
 1045  E9 08BF R             C  	JMP	$SIGNS		;SINGLE OR DOUBLE PRECISION 
 1048  A1 0000 E             C  ISI10:	MOV	AX,WORD PTR $FACLO	;GET THE INTEGER 
 104B  0B C0                 C  	OR	AX,AX		;SET SIGNS CORRECTLY 
 104D  74 06                 C  	JZ	ISIGN1 
 104F  B0 01                 C  ISI15:	MOV	AL,LOW 1 
 1051  79 02                 C  	JNS	ISIGN1 
 1053  B0 FF                 C  	MOV	AL,LOW 377 
 1055  C3                    C  ISIGN1: RET 
 1056  33 C0                 C  ISIGN:	XOR	AX,AX		;IN CASE (BX) IS ZERO 
 1058  0B DB                 C  	OR	BX,BX		;NEED SIGN OF (BX) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-60
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 105A  75 F3                 C  	JNZ	ISI15 
 105C  C3                    C  	RET 
 105D  5B                    C  POPHRT: POP	BX 
 105E  C3                    C  	RET 
 105F                        C  CONIA:				;CONVERT NO. IN A TO AN INTEGER 
 105F  98                    C  	CBW 
 1060  8B D8                 C  	MOV	BX,AX 
 1062  C6 06 0000 E 02       C  MAKINT: MOV	BYTE PTR $VALTP,LOW 2	;MAKE INTEGER 
 1067  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;STORE INTEGER IN $FAC 
 106B  C3                    C  	RET 
 106C  C6 06 0000 E 04       C  VALSNG: MOV	BYTE PTR $VALTP,LOW 4 
 1071  C3                    C  	RET 
 1072  E8 103B R             C  SGN:	CALL	VSIGN 
 1075  EB E8                 C  	JMP	CONIA 
 1077                        C  FDIVT: 
 1077  5B                    C  	POP	BX 
 1078  5A                    C  	POP	DX 
 1079  E9 15DA R             C  	JMP	$FDIVS 
 107C  E8 179D R             C  FPWRQ:	CALL	$FS		;FORCE FAC TO SP 
 107F  5B                    C  FPWRT:	POP	BX 
 1080  5A                    C  	POP	DX 
 1081  E9 0D2D R             C  	JMP	$FPWR 
 1084  B9 0004               C  MOVE:	MOV	CX,4 
 1087  EB 8E                 C  	JMP	F4VM10 
 1089  9C                    C  MOVRM:	PUSHF 
 108A  8A 17                 C  	MOV	DL,BYTE PTR 0[BX] 
 108C  43                    C  	INC	BX 
 108D  9D                    C  	POPF 
 108E  9C                    C  GETBCD: PUSHF 
 108F  8A 37                 C  	MOV	DH,BYTE PTR 0[BX] 
 1091  43                    C  	INC	BX 
 1092  8B 0F                 C  	MOV	CX,WORD PTR 0[BX] 
 1094  43                    C  	INC	BX 
 1095  9D                    C  	POPF 
 1096  9C                    C  INXHRT: PUSHF 
 1097  43                    C  	INC	BX 
 1098  9D                    C  	POPF 
 1099  C3                    C  	RET 
 109A  53                    C  INPRT:	PUSH	BX 
 109B  BB 0000 E             C  	MOV	BX,OFFSET INTXT 
 109E  E8 089F R             C  	CALL	STROUT 
 10A1  5B                    C  	POP	BX 
 10A2  B9 0000 E             C  LINPRT: MOV	CX,OFFSET STROUI 
 10A5  51                    C  	PUSH	CX 
 10A6  E8 1062 R             C  LINOUT: CALL	MAKINT 
 10A9  32 C0                 C  	XOR	AL,AL 
 10AB                        C  FOUINI: 
 10AB  A2 0000 E             C  	MOV	BYTE PTR TEMP3,AL 
 10AE  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1 
 10B1  C6 07 20              C  	MOV	BYTE PTR 0[BX],LOW " " 
 10B4  0A 07                 C  	OR	AL,BYTE PTR 0[BX] 
 10B6  43                    C  	INC	BX 
 10B7  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0" 
 10BA  E9 1B4F R             C  	JMP	$FOUT2 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-61
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 10BD                        C  SIGNC: 
 10BD  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1 
 10C0  EB 07                 C  	JMP	SHORT ICOMPS 
 10C2                        C  DCOMP: 
 10C2  E8 0AD0 R             C  	CALL	$DCMPA 
 10C5  74 08                 C  	JZ	SG15 
 10C7  F6 D0                 C  	NOT	AL 
 10C9  D0 E0                 C  ICOMPS: SAL	AL,1 
 10CB  1A C0                 C  SIGNS:	SBB	AL,AL 
 10CD  74 39                 C  	JZ	INRART 
 10CF  C3                    C  SG15:	RET 
 10D0                        C  NEGR: 
 10D0  80 36 0001 E 80       C  	XOR	BYTE PTR $FAC+1,LOW 200 ;FLIP SIGN 
 10D5  33 DB                 C  	XOR	BX,BX		;WILL NEED THIS ZERO REGISTER 
 10D7  F6 DD                 C  	NEG	CH 
 10D9  8B C3                 C  	MOV	AX,BX 
 10DB  1B C2                 C  	SBB	AX,DX		;DO MIDDLE BYTES 
 10DD  8B D0                 C  	MOV	DX,AX		;AND REPLACE 
 10DF  8A C3                 C  	MOV	AL,BL 
 10E1  1A C1                 C  	SBB	AL,CL 
 10E3  8A C8                 C  	MOV	CL,AL 
 10E5  C3                    C  NG10:	RET 
 10E6                        C  FIXER: 
 10E6  E8 08EF R             C  	CALL	$GETYP 
 10E9  78 FA                 C  	JS	NG10 
 10EB  E8 08BF R             C  	CALL	$SIGNS 
 10EE  78 03                 C  	JS	F4FX20 
 10F0  E9 0BEF R             C  	JMP	$VINT 
 10F3  E8 0B25 R             C  F4FX20: CALL	$NEG 
 10F6  E8 0BEF R             C  	CALL	$VINT 
 10F9  E9 0B25 R             C  	JMP	$NEG 
 10FC                        C  ICOMP:				;COMPARE (DX) AND (BX) 
                             C  				;(AL)=1 IF (DX) .LT. (BX) 
                             C  				;(AL)=0 IF (DX) = (BX) 
                             C  				;(AL)=-1 IF (DX) .GT. (BX) 
 10FC  8B C3                 C  	MOV	AX,BX		;SO WE CAN HAVE SEPARATE ENTRY FOR AX 
 10FE  2B C2                 C  ICMPA:	SUB	AX,DX		;COMPARISONS 
 1100  74 0E                 C  	JZ	IC40		;ALL OK , JUST EXIT 
 1102  70 07                 C  	JO	IC20		;IF SF=1 ADDITIONALLY THEN AX LARGER 
 1104  78 07                 C  	JS	IC30		;DX DEFINITELY LARGER 
 1106  32 C0                 C  IC10:	XOR	AL,AL		;(AX) LARGER 
 1108  FE C0                 C  INRART: INC	AL		;(AL)=1 
 110A  C3                    C  IC15:	RET 
 110B  78 F9                 C  IC20:	JS	IC10 
 110D  F9                    C  IC30:	STC 
 110E  1A C0                 C  	SBB	AL,AL		;(AL)=377 
 1110  C3                    C  IC40:	RET 
 1111  3B DA                 C  IMOD:	CMP	BX,DX		;IF EQUAL RETURN ZERO 
 1113  75 05                 C  	JNZ	IMD10 
 1115  33 DB                 C  IMD05:	XOR	BX,BX 
 1117  EB 47 90              C  	JMP	IMD40 
 111A                        C  IMD10:				;(BX)= (DX) MOD (BX) 
 111A  81 FA 8000            C  	CMP	DX,100000	;CHECK FOR -32768 
 111E  75 0A                 C  	JNZ	IMD15		;PROCEED IF NOT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-62
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 1120  83 FB FF              C  	CMP	BX,177777	;Check for special case of -32768 MOD -1 
 1123  74 F0                 C  	JE	IMD05 
 1125  83 FB 01              C  	CMP	BX,1		;Also for -32768 MOD 1 
 1128  74 EB                 C  	JE	IMD05 
 112A                        C  IMD15: 
 112A  8B C2                 C  	MOV	AX,DX 
 112C  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX 
 1130  0B DB                 C  	OR	BX,BX 
 1132  75 0E                 C  	JNZ	IMD17		; Trying to divide by zero? 
 1134  88 36 0001 E          C  	MOV	BYTE PTR $FAC+1,DH	; Yep, set up correct sign 
 1138  FE C7                 C  	INC	BH		; Hack for DOINF to work 
 113A  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4 
 113F  E9 0787 R             C  	JMP	$DIV0S 
 1142                        C  IMD17: 
 1142  C7 06 FFFF E 0000     C  	MOV	WORD PTR $FAC-1,0 
 1148  79 06                 C  	JNS	IMD20 
 114A  C7 06 FFFF E FFFF     C  	MOV	WORD PTR $FAC-1,177777 
 1150  0B C0                 C  IMD20:	OR	AX,AX 
 1152  BA 0000               C  	MOV	DX,0 
 1155  79 03                 C  	JNS	IMD30 
 1157  BA FFFF               C  	MOV	DX,177777 
 115A  F7 3E 0000 E          C  IMD30:	IDIV	WORD PTR $FACLO 
 115E  8B DA                 C  	MOV	BX,DX		;MOVE MOD TO BX 
 1160  89 1E 0000 E          C  IMD40:	MOV	WORD PTR $FACLO,BX 
 1164  C3                    C  	RET 
                             C   
                             C   
                             C  ; THIS IS THE INNER LOOP OF SYMBOL TABLE SEARCHING FOR NON-SUBSCRIPTED 
                             C  ; VARIABLES. 
                             C  ; 
                             C  ; Note 9-Aug-82/MLC - Entry is made at LOPFND, which does a CLD. 
                             C  ; Want this code to be fast so don't only do this one CLD for the 
                             C  ; entire piece of code. 
                             C  ; 
                             C   
 1165  AD                    C  LOPTOP: LODSW			;GET VALTYP IN [AL], 1ST CHAR IN [AH] 
 1166  3A E1                 C  	CMP	AH,CL		;SAME 2ND CHAR? 
 1168  74 11                 C  	JZ	ISIT		;YES MAY BE VAR WERE LOOKING FOR 
 116A  46                    C  NOTIT1: INC	SI		;POINT AT LENGTH OF REST OF VAR CHARS 
 116B  02 04                 C  	ADD	AL,BYTE PTR 0[SI]	;ADD FURTHUR OFFSET 
 116D  FE C0                 C  	INC	AL		;PLUS ONE 
 116F  98                    C  NOTIT0: CBW			;SIGN EXTEND IT 
 1170  03 F0                 C  	ADD	SI,AX		;MOVE TO NEXT VARIABLE 
 1172  3B F5                 C  NOTIT2: CMP	SI,BP		;DONE WITH SYMBOL TABLE SEARCH? 
 1174  75 EF                 C  	JNZ	LOPTOP		;NO, KEEP LOOKING 
 1176  8B D6                 C  	MOV	DX,SI		;POINT AFTER VAR 
 1178  E9 0000 E             C  	JMP	NOTFNS		;SEE IF SEARCHED ALL TABLES 
                             C   
 117B  3A 06 0000 E          C  ISIT:	CMP	AL,BYTE PTR VALTYP	;VALTYP'S THE SAME? 
 117F  75 E9                 C  	JNZ	NOTIT1		;NO, LOOK AT NEXT VAR 
 1181  3A 2C                 C  	CMP	CH,BYTE PTR 0[SI]	;2ND CHAR OF VAR THE SAME? 
 1183  75 E5                 C  	JNZ	NOTIT1		;NO, KEEP LOOKING 
 1185  46                    C  	INC	SI		;POINT TO VALTYP 
 1186  8A D0                 C  	MOV	DL,AL		;GET IN IN [DL] 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-63
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 1188  AC                    C  	LODSB			;GET VALTYP IN [AL] 
 1189  3A 06 0000 E          C  	CMP	AL,BYTE PTR NAMCNT	;SAME AS VAR WERE LOOKING FOR? 
 118D  74 04                 C  	JZ	LENMAT		;LENGTHS MATCH! 
 118F  02 C2                 C  	ADD	AL,DL		;ADD SAVED VALTYP AND LENGTH OF VAR 
 1191  EB DC                 C  	JMP	SHORT NOTIT0	;GO TO NEXT VAR 
                             C   
 1193  0A C0                 C  LENMAT: OR	AL,AL		;LENGTH ZERO? 
 1195  74 10                 C  	JZ	FNDITV		;YES, FOUND IT! 
 1197  98                    C  	CBW			;MAKE LENGTH A WORD 
 1198  91                    C  	XCHG	CX,AX		;SAVE 2 CHARS OF VAR, PUT LENGTH IN CX 
 1199  BF 0000 E             C  	MOV	DI,OFFSET NAMBUF	;POINT TO NAME BUFFER 
                             C  		     ;COMPARE TWO VAR NAMES 
 119C  F3/ A6                C   REP	CMPSB			;WITH SPECIAL INSTR 
 119E  91                    C  	XCHG	AX,CX		;FLIP BACK 
 119F  74 06                 C  	JZ	FNDITV		;FOUND IT 
 11A1  03 F0                 C  	ADD	SI,AX		;ADD CHARS LEFT, CC'S SHOULD BE NON-ZERO 
 11A3  8A C2                 C  	MOV	AL,DL		;GET BACK SAVED VALTYP 
 11A5  EB C8                 C  	JMP	SHORT NOTIT0	;PROCEED WITH FAILED SEARCH 
 11A7  8B D6                 C  FNDITV: MOV	DX,SI		;GET POINTER TO VAR IN [DX] 
 11A9  5B                    C  	POP	BX		;RESTORE TEXT POINTER 
 11AA  C3                    C  	RET			;ALL DONE!!! 
                             C   
 11AB  8B F3                 C  LOPFND: MOV	SI,BX		;START SEARCHING HERE 
 11AD  8B 2E 0000 E          C  	MOV	BP,WORD PTR ARYTA2	;LIMIT OF VARIABLE SEARCH 
 11B1  FC                    C  	CLD			;INCREMENT 
 11B2  EB BE                 C  	JMP	SHORT NOTIT2	;START LOOKING 
                             C   
                             C   
                             C  ; THIS IS THE CORRESPONDING CODE FOR ARRAY SEARCHES 
                             C  ; Note 9-Aug-82/MLC - This code is supposed to be fast so only a 
                             C  ; single CLD is done here for the entire piece of code. 
                             C  ; 
                             C   
 11B4  8B F3                 C  LOPFD1: MOV	SI,BX		;INITIALIZE POINTER TO SYMBOL TABLE 
 11B6  8B 2E 0000 E          C  	MOV	BP,WORD PTR STREND	;GET LIMIT OF SEARCH 
 11BA  FC                    C  	CLD			;SET DIRECTION RIGHT 
 11BB  EB 0E 90              C  	JMP	LOPFDI		;START SEARCHING 
 11BE  AD                    C  LOPFD0: LODSW			;GET VALTYP AND 1ST CHAR OF VAR 
 11BF  3A E1                 C  	CMP	AH,CL		;ARE FIRST CHARS THE SAME? 
 11C1  74 11                 C  	JZ	ISARY		;YES, COULD BE RIGHT ONE 
 11C3  46                    C  NMARY1: INC	SI		;POINT TO LENGTH OF VAR 
 11C4  AC                    C  NMARY2: LODSB			;GET LENGTH OF IT 
 11C5  98                    C  NMARY3: CBW			;EXTEND SIGN 
 11C6  03 F0                 C  	ADD	SI,AX		;ADD OFFSET 
 11C8  AD                    C  NMARY4: LODSW			;GET OFFSET TO ARRAY 
 11C9  03 F0                 C  	ADD	SI,AX		;POINT TO NEXT ARRAY 
 11CB  3B EE                 C  LOPFDI: CMP	BP,SI		;AT END OF ARRAYS? 
 11CD  75 EF                 C  	JNZ	LOPFD0		;NO, KEEP GOING 
 11CF  8B DE                 C  	MOV	BX,SI		;AT END 
 11D1  E9 0000 E             C  	JMP	NOTFDD		;RETURN TO MAIN-LINE CODE IN BIPTRG.MAC 
                             C   
 11D4  3A 06 0000 E          C  ISARY:	CMP	AL,BYTE PTR VALTYP	;TYPE OF VARS THE SAME? 
 11D8  75 E9                 C  	JNZ	NMARY1		;NO, LOOK AT NEXT ONE 
 11DA  3A 2C                 C  	CMP	CH,BYTE PTR 0[SI]	;2ND CHARS THE SAME? 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-64
F4  MAP BETWEEN 8080-8086 CONVERTED F3 TO 8086 MATHPK       

 11DC  75 E5                 C  	JNZ	NMARY1		;NO 
 11DE  46                    C  	INC	SI		;POINT AT EXTRA CHARS 
 11DF  AC                    C  	LODSB			;FETCH NUMBER OF THEM 
 11E0  3A 06 0000 E          C  	CMP	AL,BYTE PTR NAMCNT	;SAME AS WHAT WE WANT? 
 11E4  75 DF                 C  	JNZ	NMARY3		;NO, LOOK AT NEXT VAR 
 11E6  0A C0                 C  	OR	AL,AL		;NO CHARS LEFT? 
 11E8  74 0E                 C  	JZ	CNOMAT		;YES, MATCH, ALL DONE 
 11EA  98                    C  	CBW			;MAKE WORD 
 11EB  91                    C  	XCHG	AX,CX		;PUT CHAR COUNT IN CX, SAVE FIRST TWO VAR CHARS 
 11EC  BF 0000 E             C  	MOV	DI,OFFSET NAMBUF	;POINT AT VAR BUFFER 
                             C  		     ;COMPARE TWO VAR NAMES 
 11EF  F3/ A6                C   REP	CMPSB 
 11F1  91                    C  	XCHG	AX,CX		;GET BACK 2 CHARS TO MATCH IN [CX] 
                             C  				;REMAINING CHARS IN NAME IN [AX] 
 11F2  74 04                 C  	JZ	CNOMAT		;VARS MATCHED 
 11F4  03 F0                 C  	ADD	SI,AX		;ADD REST OF CHARS TO WHERE WE ARE 
 11F6  EB D0                 C  	JMP	SHORT NMARY4	;LOOK AT NEXT VAR 
                             C   
 11F8  AD                    C  CNOMAT: LODSW			;GET OFFSET TO END OF ARRAY 
 11F9  8B D0                 C  	MOV	DX,AX		;PROBOBALLY NOT USED 
 11FB  8B DE                 C  	MOV	BX,SI		;POINT TO NUMBER OF DIMENSIONS 
 11FD  E9 0000 E             C  	JMP	ARYEXT		;GO BACK 
                             C   
                             C   
                             C  	SUBTTL	 $AEXPS  SINGLE AND DOUBLE PRECISION ADD/SUBTRACT OF EXPONENTS 
                             C  ;************************************************************* 
                             C  ; 
                             C  ;       $AEXPS,$SEXPS   WILL PERFORM THE ADDITION/SUBTRACTION 
                             C  ;               OF SINGLE OR DOUBLE PRECISION EXPONENTS. 
                             C  ;       CALLING SEQUENCE:       CALL    $AEXPS 
                             C  ;               OR              CALL    $SEXPS 
                             C  ;               WITH THE SINGLE PRECISION NUMERATOR(MULTIPLIER) 
                             C  ;               IN (BXDX) OR THE DOUBLE PRECISION NUMERATOR 
                             C  ;               (MULTIPLIER) IN ($ARG) AND THE DENOMINATOR 
                             C  ;               (MULTIPLICAND) IN THE ($FAC) 
                             C  ;               FOR DOUBLE PRECISION OPERATIONS THE $ARG  EXPONENT 
                             C  ;               AND HIGH MANTISSA BYTE MUST BE IN BH:BL PRIOR 
                             C  ;               TO A $SEXPS,$AEXPS CALL 
                             C  ; 
                             C  ;************************************************************** 
                             C   
                             C   
 1200  F9                    C  $AEXPS: STC			;CF=1 
 1201  EB 01                 C  	JMP	SHORT SES00 
 1203  F8                    C  $SEXPS: CLC			;CF=0 
 1204  8B F3                 C  SES00:	MOV	SI,BX		;WILL NEED FOR LATER 
 1206  9C                    C  	PUSHF			;SAVE MULTIPLY/DIVIDE FLAG 
 1207  8B 0E FFFF E          C  	MOV	CX,WORD PTR $FAC-1	;(CH)=$FAC:(CL)=$FAC-1 
 120B  8A C3                 C  	MOV	AL,BL		;FETCH (BXDX) SIGN BYTE 
 120D  32 C1                 C  	XOR	AL,CL		;CORRECT SIGN IN AL 
 120F  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;MOVE TO $FAC+1 
 1212  8A C7                 C  	MOV	AL,BH		;GET (BXDX) EXPONENT 
 1214  32 E4                 C  	XOR	AH,AH		;WILL USE 16-BIT ARITHEMETIC 
 1216  8A DD                 C  	MOV	BL,CH		;TO CALCULATE EXPONENTS 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-65
$AEXPS  SINGLE AND DOUBLE PRECISION ADD/SUBTRACT OF EXPONENT

 1218  32 FF                 C  	XOR	BH,BH 
 121A  9D                    C  	POPF			;SEE IF ADD OR SUBTRACT OF EXPONENTS 
 121B  73 07                 C  	JNB	SES05		;JUMP IF SUBTRACT 
 121D  03 C3                 C  	ADD	AX,BX		;HAVE IN TWO BIASES 
 121F  2D 0101               C  	SUB	AX,401		;NOW HAVE RAW SUM LESS 1 
 1222  EB 02                 C  	JMP	SHORT SES07	;GO CHECK FOR OVERFLOW/UNDERFLOW 
 1224  2B C3                 C  SES05:	SUB	AX,BX		;BIASES CANCEL OUT 
 1226  0A E4                 C  SES07:	OR	AH,AH		; 
 1228  78 0D                 C  	JS	SES10		;MUST GO CHECK FOR UNDERFLOW 
 122A  3D 0080               C  	CMP	AX,200		;CF=0 IF OVERFLOW 
 122D  72 15                 C  	JB	SES20		;PROCEED IF OK 
 122F  8B DE                 C  	MOV	BX,SI		;GET (BX) OFF STACK 
 1231  83 C4 02              C  	ADD	SP,2		;GET $SEXPS RETURN ADDRESS OFF STACK 
 1234  E9 0776 R             C  	JMP	$OVFLS		;GO DO OVERFLOW CODE 
 1237                        C  SES10:				;POTENTIAL UNDERFLOW 
 1237  05 0080               C  	ADD	AX,200		;BIAS MUST BRING IT IN POSITIVE 
 123A  79 0B                 C  	JNS	SES30		;IF IT IS POSITIVE PROCEED 
 123C  8B DE                 C  	MOV	BX,SI		;BET (BX) OFF STACK 
 123E  83 C4 02              C  	ADD	SP,2		;GET $SEXPS RETURN ADDRESS OFF STACK 
 1241  E9 08B5 R             C  	JMP	$ZERO		;GO ZERO THE FAC AND RETURN 
 1244  05 0080               C  SES20:	ADD	AX,200		;ADD IN THE BIAS 
 1247  A2 0000 E             C  SES30:	MOV	BYTE PTR $FAC,AL	;PUT CORRECT EXPONENT IN $FAC 
 124A  BB FFFF E             C  	MOV	BX,OFFSET $FAC-1	;ADDRESS OF HIGH MANTISSA BITS 
 124D  80 0F 80              C  	OR	BYTE PTR 0[BX],LOW 200	;OR IN THE HIDDEN "1" 
 1250  8B DE                 C  	MOV	BX,SI		;GET (BXDX) HIGH MANTISSA BITS 
 1252  32 FF                 C  	XOR	BH,BH		;CLEAR SUPERFLUOUS BITS 
 1254  80 CB 80              C  	OR	BL,LOW 200	;RESTORE HIDDEN "1" 
 1257  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $CHKEL  SUBROUTINE TO $FIN FOR CHECKING "ELSE" AND "EQV" 
                             C  ;***************************************************************** 
                             C  ; 
                             C  ;       $CHKEL  CHECKS AN INPUT STREAM FOR POSSIBLE "ELSE" OR "EQV" 
                             C  ;               CONSTRUCTS ONCE AN "E" HAS BEEN DETECTED. IF ONE OF 
                             C  ;               THESE CONSTRUCTS IS DETECTED ZF=1 WILL BE RETURNED 
                             C  ;               OTHERWISE ZF=0 WILL BE RETURNED. 
                             C  ;       CALLING SEQUENCE:       CALL    $CHKEL 
                             C  ;               WITH (BX) POINTING TO THE CURRENT POSITION IN THE 
                             C  ;               INPUT CHARACTER STREAM. 
                             C  ; 
                             C  ;****************************************************************** 
 1258  53                    C  $CHKEL: PUSH	BX		;SAVE TEXT POINTER 
 1259  E8 0E5F R             C  	CALL	$CHRGT		;GET NEXT CHARACTER INTO (AL) 
 125C  3C 6C                 C  	CMP	AL,LOW OFFSET "L"+40    ;LOWER CASE "L"? 
 125E  74 0A                 C  	JZ	CK10		;RETURN WITH ZF=1 
 1260  3C 4C                 C  	CMP	AL,LOW "L"      ;UPPER CASE "L"? 
 1262  74 06                 C  	JZ	CK10		;RETURN WITH ZF=1 
 1264  3C 71                 C  	CMP	AL,LOW OFFSET "Q"+40    ;LOWER CASE "Q"? 
 1266  74 02                 C  	JZ	CK10		;RETURN WITH ZF=1 
 1268  3C 51                 C  	CMP	AL,LOW "Q"      ;UPPER CASE "Q"? 
                             C  ;**************************************************************** 
                             C  ;THAT LAST CMPBI WILL SET ZF APPROPRIATELY SO WE'LL EXIT NOW 
                             C  ;**************************************************************** 
 126A  5B                    C  CK10:	POP	BX		;GET TEXT POINTER BACK 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-66
$CHKEL  SUBROUTINE TO $FIN FOR CHECKING "ELSE" AND "EQV"    

 126B  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $EXP	 SINGLE PRECISION EXPONENTIAL FUNCTION 
                             C  ;************************************************************* 
                             C  ; 
                             C  ;THE FUNCTION EXP(X) CALCULATES e^X WHERE e=2.718282 
                             C  ;       THE TECHNIQUE USED IS TO EMPLOY A COUPLE 
                             C  ;       OF FUNDAMENTAL IDENTITIES THAT ALLOWS US TO 
                             C  ;       USE THE BASE 2 THROUGH THE DIFFICULT PORTIONS OF 
                             C  ;       THE CALCULATION: 
                             C  ; 
                             C  ;               (1)e^X=2^y  WHERE y=X*LOG2(e) [LOG2(e) IS 
                             C  ;                                               LOG BASE 2 
                             C  ;                                               OF e ] 
                             C  ; 
                             C  ;               (2) 2^y=2^[ INT(y)+(y-INT(y)] 
                             C  ;               (3) IF Ny=INT(y) THEN 
                             C  ;                   2^(Ny+y-Ny)=[2^Ny]*[2^(y-Ny)] 
                             C  ; 
                             C  ;       NOW, SINCE 2^Ny IS EASY TO COMPUTE (AN EXPONENT 
                             C  ;       CALCULATION WITH MANTISSA BITS OF ZERO) THE DIFFICULT 
                             C  ;       PORTION IS TO COMPUTE 2^(Y-Ny) WHERE 0.LE.(Y-Ny).LT.1 
                             C  ;       THIS IS ACCOMPLISHED WITH A POLYNOMIAL APPROXIMATION 
                             C  ;       TO 2^Z WHERE 0.LE.Z.LT.1  . ONCE THIS IS COMPUTED WE 
                             C  ;       HAVE TO EFFECT THE MULTIPLY BY 2^Ny . 
                             C  ; 
                             C  ;************************************************************** 
                             C  ;*********************************************************** 
                             C  ;THIS IS EXPONENTIAL EVALUATION BY HART POLYNOMIAL EVALUATION 
                             C  ;USING COEFFICIENTS FROM #1302 
                             C  ;************************************************************ 
 126C                        C  EXP: 
 126C  BA AA3B               C  $EXP:	MOV	DX,125073	;LOG2(e) 
 126F  BB 8138               C  	MOV	BX,100470 
 1272  E8 1921 R             C  	CALL	$FMULS		;y=FAC*LOG2(e) 
 1275  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;MUST SEE IF TOO LARGE 
 1278  3C 88                 C  	CMP	AL,LOW 210	;ABS.GT.128? 
 127A  73 3C                 C  	JNB	EXP110		;Yes, too big.  Go decide between 
                             C  				;overflow and underflow. 
 127C  3C 68                 C  	CMP	AL,LOW 150	;SEE IF TOO SMALL(ANS. OF 1.) 
 127E  72 4B                 C  	JB	EXP200 
 1280  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO ;SAVE y 
 1284  FF 36 0002 E          C  	PUSH	WORD PTR $FACLO+2 
 1288  E8 1C3B R             C  	CALL	$QINT		;Determine integer power of 2. 
 128B  8A E2                 C  	MOV	AH,DL 
 128D  80 C4 81              C  	ADD	AH,LOW 201	;THIS WILL CALCULATE THE EXPONENT 
                             C  				;FOR INTEGER POWER OF 2 FLOATING 
                             C  				;POINT . WE USE 201 BECAUSE WE HAVE 
                             C  				;A BIAS OF 200 AND THE UNDERSTOOD 
                             C  				;1 OF FLOATING POINT NUMBERS IS TO 
                             C  				;THE RIGHT OF THE BINARY POINT 
 1290  74 23                 C  	JZ	EXP100		;JUMP IF OVERFLOW 
 1292  50                    C  	PUSH	AX 
 1293  F6 06 0001 E 80       C  	TEST	BYTE PTR $FAC+1,LOW 200O	;Set SF if negative.  ($QINT saved 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-67
$EXP	 SINGLE PRECISION EXPONENTIAL FUNCTION                 

                             C  				;the sign in $FAC+1.) 
 1298  E8 1C2E R             C  	CALL	NGBLDX		;Negate if necessary. 
 129B  32 E4                 C  	XOR	AH,AH		;Clear overflow for $NORMS. 
 129D  E8 1CE8 R             C  	CALL	$NORMS		;This will make the FAC INT(y). 
 12A0  58                    C  	POP	AX 
 12A1  5B                    C  	POP	BX 
 12A2  5A                    C  	POP	DX		;RECALL y 
 12A3  50                    C  	PUSH	AX		;SAVE EXPONENT 
 12A4  E8 1397 R             C  	CALL	$FSUBS		;WANT THE FRACTIONAL PART SO WE 
                             C  				;CAN USE HART #1302 TO CALCULATE 
                             C  				;2^y OF IT .(WE ALREADY 
                             C  				;KNOW 2^Ny OF THE INTEGER PART 
                             C  				;FROM THE ABOVE) 
 12A7  BB 0546 R             C  	MOV	BX,OFFSET $EXPCN	;POINT TO COEFFICIENTS 
 12AA  E8 1D34 R             C  	CALL	$POLY		;DO THE CALCULATION 
 12AD  5B                    C  	POP	BX		;RECALL EXPONENT OF INTEGER 2^y 
 12AE  33 D2                 C  	XOR	DX,DX		; 
 12B0  8A DA                 C  	MOV	BL,DL		;WE NOW HAVE 2^Ny OF INTEGER 
                             C  				;PART IN (BXDX) AND FRACTIONAL PART 
                             C  				;IN THE $FAC. TO CALCULATE THE ANSWER 
                             C  				;NEED ONLY TO MULTIPLY THESE VALUES 
 12B2  E9 1921 R             C  	JMP	$FMULS 
 12B5                        C  EXP100:			;OVERFLOW WITH VALUES ON THE STACK 
 12B5  83 C4 04              C  	ADD	SP,4 
 12B8  80 26 FFFF E 80       C  EXP110: AND	BYTE PTR $FAC-1,LOW 200O	;Is it positively too big? 
 12BD  74 03                 C  	JZ	EXP115		;Yes, overflow. 
 12BF  E9 08B5 R             C  	JMP	$ZERO		;No, underflow for negative. 
                             C   
 12C2  32 E4                 C  EXP115: XOR	AH,AH		;OVERFLOW WITH STACK CLEAR 
 12C4  88 26 0001 E          C  	MOV	BYTE PTR $FAC+1,AH	;MAKE SURE SIGN IS POSITIVE 
                             C  				;to get postive infinity. 
 12C8  E9 0776 R             C  	JMP	$OVFLS		;GO DO OVERFLOW CODE 
                             C   
 12CB                        C  EXP200:			;WE HAVE DETERMINED THAT THE EXPONENT IS SO SMALL 
                             C  				;THAT WE SHOULD RETURN 1. AS AN ANSWER 
 12CB  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 12CE  33 C0                 C  	XOR	AX,AX		;.0 
 12D0  FC                    C  	CLD			;SO STOW WILL INCREMENT DI 
 12D1  AB                    C  	STOSW			; 
 12D2  C7 05 8100            C  	MOV	WORD PTR 0[DI],100400	;1.0 
 12D6  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FADDD  DOUBLE PRECISION FLOATING POINT ADDITION 
                             C  ;************************************************************ 
                             C  ; 
                             C  ;       $FADDD  THIS ROUTINE PERFORMS DOUBLE PRECISION FLOATING 
                             C  ;               POINT ADDITION/SUBTRACTION,I.E. 
                             C  ;               (FAC)=(FAC)+-(ARG) 
                             C  ;               THE LARGER NO. WILL BE PLACED IN THE FAC, THE SMALLER 
                             C  ;               NO. IN THE ARG WILL BE SHIFTED RIGHT UNTIL THEIR 
                             C  ;               BINARY POINTS ALIGN AND THE TWO WILL BE ADDED/ 
                             C  ;               SUBTRACTED. IF IT TURNS OUT THAT THE EXPONENTS WERE 
                             C  ;               EQUAL AND THE OPERATION WAS A SUBTRACTION THEN 
                             C  ;               A CARRY OUT OF THE HIGH BYTE  CAN OCCUR. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-68
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

                             C  ;               IF THIS IS THE CASE, OUR CHOICE AS TO WHICH WAS THE 
                             C  ;               LARGER NO. WAS INCORRECT AND WE HAVE TO NEGATE 
                             C  ;               OUR MANTISSA AND COMPLEMENT THE SIGN OF THE RESULT. 
                             C  ; 
                             C  ;       CALLING SEQUENCE        CALL    $FADDD 
                             C  ;               WITH THE NOS. TO BE ADDED/SUBTRACTED IN THE DOUBLE 
                             C  ;               PRECISION FAC AND ARG 
                             C  ;THE FORMAT OF DOUBLE PRECISION NUMBERS IS AS FOLLOWS 
                             C  ;; 
                             C  ;BIT: 
                             C  ;66665555 55555544 44444444 33333333 33222222 22221111 11111100 00000000 
                             C  ;32109876 54321098 76543210 98765432 10987654 32109876 54321098 76543210 
                             C  ;AAAAAAAA BCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC CCCCCCCC 
                             C  ;[$FAC  ] [$FAC-1] [$FAC-2] [$FACLO] [$DFACL  [$DFACL  [$DFACL  [$DFACL] 
                             C  ;                                       +3  ]    +2  ]    +1  ] 
                             C  ; 
                             C  ;WHERE A=EXPONENT BIASED 128 
                             C  ;      B=SIGN(1=NEGATIVE,0=POSITIVE) OF NUMBER 
                             C  ;      C=BITS 2-56 OF MANTISSA (BIT 1 IS UNDERSTOOD 1) 
                             C  ;        (ALSO BIT 54 IS HIGH ORDER BIT) 
                             C  ;NOTE:THE BINARY POINT IS TO THE LEFT OF THE UNDERSTOOD 1 
                             C  ; 
                             C  ;**************************************************************** 
                             C   
 12D7  E8 09FB R             C  FADDX1: CALL	$MOVFA		;MOVE DOUBLE PREC ARG TO FAC 
 12DA  C3                    C  FADDX2: RET 
 12DB                        C  $FSUBD:			;($FAC):=($ARG)-($FAC) 
 12DB  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1 
 12DE  0A E4                 C  	OR	AH,AH		;IF ZF=1 ARG IS ANSWER 
 12E0  74 F5                 C  	JZ	FADDX1 
 12E2  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;FLIP SIGN OF FAC 
 12E7                        C  DADD: 
 12E7                        C  $FADDD:			;($FAC):=($ARG)+($FAC) 
 12E7  B0 00                 C  	MOV	AL,LOW 0	;WANT TO ZERO OVERFLOW BYTES 
 12E9  A2 FFFF E             C  	MOV	BYTE PTR $DFACL-1,AL 
 12EC  A2 FFFF E             C  	MOV	BYTE PTR $ARGLO-1,AL 
 12EF  A0 0000 E             C  	MOV	AL,BYTE PTR $ARG	;IF ($ARG)=0 THEN JUST RET 
 12F2  0A C0                 C  	OR	AL,AL		; 
 12F4  74 E4                 C  	JZ	FADDX2		;RETURN 
 12F6  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	; 
 12F9  0A E4                 C  	OR	AH,AH		;IF EXPONENT=0, NO. IS ZERO 
 12FB  74 DA                 C  	JZ	FADDX1		;ARG IS THE ANSWER 
 12FD  8B 1E FFFF E          C  	MOV	BX,WORD PTR $ARG-1	;FETCH SIGN AND EXPONENT 
 1301  80 0E FFFF E 80       C  	OR	BYTE PTR $FAC-1,LOW 200 ;RESTORE HIDDEN 1 MANTISSA BIT 
 1306  80 0E FFFF E 80       C  	OR	BYTE PTR $ARG-1,LOW 200 
 130B  8A CC                 C  	MOV	CL,AH		;WILL FORM SHIFT COUNT IN (CL) 
 130D  2A CF                 C  	SUB	CL,BH		; 
 130F  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;ASSUME SIGN OF FAC 
 1312  74 22                 C  	JZ	FDD25		;PROCEED IF EXPONENTS EQUAL 
 1314  73 12                 C  	JNB	FDD20		;IF FAC LARGER (OR EQUAL) JUMP 
                             C  ;******************************************************************** 
                             C  ; $ARG HAS THE LARGER EXPONENT SO WE MUST EXCHANGE FAC AND ARG AND 
                             C  ;USE SIGN OF THE ARG 
                             C  ;******************************************************************** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-69
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

 1316  86 C3                 C  	XCHG	AL,BL		;HIGH MANTISSA BYTE EXCHANGE 
 1318  F6 D9                 C  	NEG	CL		;NED POS. SHIFT COUNT 
 131A  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;ADAPT ARG SIGN 
 131D  88 3E 0000 E          C  	MOV	BYTE PTR $FAC,BH	;ADAPT ARG EXPONENT 
 1321  50                    C  	PUSH	AX		;SAVE ARG MANTISSA BITS 
 1322  51                    C  	PUSH	CX		;WILL NEED AS COUNT FOR LOOP 
 1323  E8 09A1 R             C  	CALL	$XCGAF		;EXCHANGE ARG AND FAC 
 1326  59                    C  	POP	CX		;RECALL OLD CX 
 1327  58                    C  	POP	AX		;GET MANTISSA BYTES BACK 
 1328                        C  FDD20:				;WE NOW HAVE THE SUSPECTED LARGER NO IN THE FAC, WE NEED 
                             C  				;TO KNOW IF WE ARE TO SUBTRACT (SIGNS ARE DIFFERENT) AND 
                             C  				;WE NEED TO RESTORE THE HIDDEN MANTISSA BIT 
                             C  				;FURTHER, IF THERE IS TO BE MORE THAN 56 BITS SHIFTED 
                             C  				;TO ALIGN THE BINARY POINTS THEN THE LESSOR NO. IS 
                             C  				;INSIGNIFICANT IN COMPARISON TO THE LARGER NO. SO WE 
                             C  				;CAN JUST RETURN AND CALL THE LARGER NO. THE ANSWER. 
 1328  80 F9 39              C  	CMP	CL,LOW 57D	;THIS MUST SET CF TO CONTINUE 
 132B  73 5E                 C  	JNB	FDD95		;RETURN IF CF=0 
 132D  53                    C  	PUSH	BX		;SAVE MANTISSA BITS 
 132E  F8                    C  	CLC			;SO WE DON'T GET CF IN THERE 
 132F  E8 0962 R             C  	CALL	$SHRA		;SHIFT ARG RIGHT (CL) BITS 
 1332  A0 0001 E             C  	MOV	AL,BYTE PTR $FAC+1	;RECALL SIGN (AL DESTROYED 
                             C  				;BY $SHRA) 
 1335  5B                    C  	POP	BX 
 1336  32 C3                 C  FDD25:	XOR	AL,BL		;WILL NOW DETERMINE IF ADD/SUB 
 1338  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1 
 133B  BE FFFF E             C  	MOV	SI,OFFSET $ARGLO-1 
 133E  B9 0004               C  	MOV	CX,4		;4 SIXTEEN BIT OPERATIONS 
 1341  F8                    C  	CLC			;CF=0 
                             C  ;**************************************************************** 
                             C  ;WE ARE NOW STAGED TO DO THE ADD/SUBTRACT. IT WILL BE DONE AS 4 
                             C  ;SIXTEEN BIT OPERATIONS. 
                             C  ;**************************************************************** 
 1342  FC                    C  	CLD			;SO LODW WILL INCB 
                             C  				;Note 9-Aug-82/MLC - This CLD is 
                             C  				;for the LODWs at both FDD30 and 
                             C  				;FDD50. 
 1343  78 1E                 C  	JS	FDD50		;IF SF=1 GO SUBTRACT 
 1345  AD                    C  FDD30:	LODSW			;FETCH NEXT BYTE ARG 
                             C  				;Note 9-Aug-82/MLC - CLD is outside 
                             C  				;loop above. 
 1346  11 07                 C  	ADC	WORD PTR 0[BX],AX	;ADD IT TO FAC 
 1348  43                    C  	INC	BX 
 1349  43                    C  	INC	BX 
 134A  E2 F9                 C  	LOOP	FDD30 
 134C  73 12                 C  	JNB	FDD40		;GO ROUND IF CF=0 
                             C  ;************************************************************* 
                             C  ;WE HAD OVERFLOW OUT OF THE HIGH MANTISSA BIT. WE MUST INCREMENT 
                             C  ;THE EXPONENT AND SHIFT THE OVERFLOW BIT BACK INTO THE FAC BY 
                             C  ;SHIFTING THE FAC RIGHT 1 BIT. 
                             C  ;************************************************************* 
 134E  BB 0000 E             C  FDD35:	MOV	BX,OFFSET $FAC	;FETCH ADDRESS OF EXPONENT 
 1351  FE 07                 C  	INC	BYTE PTR 0[BX]	;INCREMENT THE EXPONENT 
 1353  74 33                 C  	JZ	FDD90		;IF ZF=1 - OVERFLOW 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-70
$FADDD  DOUBLE PRECISION FLOATING POINT ADDITION            

 1355  4B                    C  	DEC	BX 
 1356  4B                    C  	DEC	BX		;BX POINTS TO $FAC-2 
 1357  B9 0004               C  	MOV	CX,4		;4 SIXTEEN BIT SHIFTS 
                             C  ;************************************************************** 
                             C  ;WE ARE NOW SET TO SHIFT THE FAC RIGHT 1 BIT. RECALL WE GOT HERE 
                             C  ;WITH CF=1. THE INSTRUCTIONS SINCE WE GOT HERE HAVEN'T AFFECTED 
                             C  ;CF SO WHEN WE SHIFT RIGHT WE WILL SHIFT CF INTO THE HIGH MANTISSA 
                             C  ;BIT. 
                             C  ;************************************************************* 
 135A  D1 1F                 C  FDD37:	RCR	WORD PTR 0[BX],1 
 135C  4B                    C  	DEC	BX 
 135D  4B                    C  	DEC	BX 
 135E  E2 FA                 C  	LOOP	FDD37 
 1360  E9 1F90 R             C  FDD40:	JMP	$ROUND		;GO ROUND THE RESULT 
 1363                        C  FDD50: 
                             C  ;************************************************************** 
                             C  ;TO GET HERE THE SIGNS OF THE FAC AND ARG WERE DIFFERENT THUS 
                             C  ;IMPLYING A DESIRED SUBTRACT. 
                             C  ;************************************************************** 
 1363  AD                    C  	LODSW			;FETCH NEXT WORD OF ARG 
                             C  				;Note 9-Aug-82/MLC - The CLD is 
                             C  				;just above FDD30. 
 1364  19 07                 C  	SBB	WORD PTR 0[BX],AX	;SUBTRACT FROM FAC 
 1366  43                    C  	INC	BX 
 1367  43                    C  	INC	BX 
 1368  E2 F9                 C  	LOOP	FDD50 
 136A  73 19                 C  	JNB	FDD80		;GO NORMALIZE AND ROUND 
                             C  ;************************************************************ 
                             C  ;TO GET HERE FAC TURNED OUT SMALLER THAN THE ARG. TO CORRECT 
                             C  ;THE ANSWER IN THE FAC WE MUST NEGATE THE MANTISSA BITS 
                             C  ;AND THE SIGN IN $FAC+1 
                             C  ;*********************************************************** 
 136C  F6 57 01              C  	NOT	BYTE PTR 1[BX]	;COMPLEMENT SIGN 
 136F  B9 0004               C  	MOV	CX,4		;4 SIXTEEN BIT COMPLEMENTS 
 1372  4B                    C  FDD60:	DEC	BX 
 1373  4B                    C  	DEC	BX 
 1374  F7 17                 C  	NOT	WORD PTR 0[BX]	;COMPLEMENT FAC 
 1376  E2 FA                 C  	LOOP	FDD60 
                             C  ;*********************************************************** 
                             C  ;MUST NOW ADD 1 FOR 2'S COMPLEMENT ARITH. 
                             C  ;*********************************************************** 
 1378  B9 0004               C  	MOV	CX,4 
 137B  FF 07                 C  FDD70:	INC	WORD PTR 0[BX]	;IF ZF=1 THEN CARRY 
 137D  75 06                 C  	JNZ	FDD80		;SINCE THEY DON'T SET CF 
 137F  43                    C  	INC	BX 
 1380  43                    C  	INC	BX 
 1381  E2 F8                 C  	LOOP	FDD70 
 1383  74 C9                 C  	JZ	FDD35		;IF ZF=1 MUST INCREMENT EXP 
 1385  E9 1C9D R             C  FDD80:	JMP	$NORMD		;GO NORMALIZE 
 1388  E9 0776 R             C  FDD90:	JMP	$OVFLS		;OVERFLOW! 
 138B  E9 1FB8 R             C  FDD95:	JMP	$ROUNX		;PUT IN THE SIGN AND DONE 
                             C   
                             C  	SUBTTL	 $FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB 
                             C  ;********************************************************* 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-71
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

                             C  ; 
                             C  ;       $FADDS  FLOATING POINT ADDITION FOR SINGLE PRECISION 
                             C  ;               $FADDS FORMS THE SUM OF (BXDX) AND ($FAC) AND 
                             C  ;               LEAVES THE RESULT IN THE ($FAC). 
                             C  ; 
                             C  ;       CALLING SEQUENCE:       CALL    $FADDS 
                             C  ;       $FSUBS  FLOATING POINT SUBTRACTION FOR SINGLE PRECISION 
                             C  ;               $FSUBS FORMS THE DIFFERENCE (BXDX)-(FAC) AND 
                             C  ;               LEAVES THE RESULT IN THE (FAC). 
                             C  ;       CALLING SEQUENCE:       CALL    $FSUBS 
                             C  ; 
                             C  ;********************************************************** 
                             C   
 138E  89 1E FFFF E          C  FEXIT1: MOV	WORD PTR $FAC-1,BX	;MOV (BXDX) TO $FAC 
 1392  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX 
 1396  C3                    C  EXIT2:	RET 
 1397  A1 FFFF E             C  $FSUBS: MOV	AX,WORD PTR $FAC-1	;FETCH FAC 
 139A  0A E4                 C  	OR	AH,AH		;IF ZF=1 (BXDX) IS ANSWER 
 139C  74 F0                 C  	JZ	FEXIT1		;(BXDX) IS THE ANSWER 
 139E  80 36 FFFF E 80       C  	XOR	BYTE PTR $FAC-1,LOW 200 ;FLIP SIGN 
 13A3                        C  $FADDS:			;($FAC)=(BXDX)+($FAC) 
 13A3  0A FF                 C  	OR	BH,BH		;WILL FIRST CHECK EXPONENT OF (BXDX) 
 13A5  74 EF                 C  	JZ	EXIT2		;ANS ALREADY IN $FAC 
 13A7  A1 FFFF E             C  	MOV	AX,WORD PTR $FAC-1	;WILL NOW CHECK $FAC AND IF ZERO 
 13AA  0A E4                 C  	OR	AH,AH		;ANSWER IN (BXDX) AND MUST MOVE 
 13AC  74 E0                 C  	JZ	FEXIT1		;MOVE (BXDX) TO FAC 
                             C  				;**************************************************** 
                             C  				;KNOW AT THIS POINT THAT NEITHER (BXDX) NOR THE 
                             C  				;$FAC ARE ZERO. THE SUM WILL BE PERFORMED BY EXAMINATION 
                             C  				;OF THE EXPONENTS, PLACING THE NUMBER WITH THE LARGER 
                             C  				;EXPONENT IN THE $FAC,AND SHIFTING THE SMALLER NUMBER RIGHT 
                             C  				;UNTIL BINARY POINTS ALIGN, THEN ADDING THE MANTISSAS 
                             C  				;IF THE SIGNS ARE THE SAME OR SUBTRACTING THE MANTISSAS 
                             C  				;IF THE SIGNS ARE DIFFERENT. THE EXPONENT OF THE ANSWER 
                             C  				;IS THE EXPONENT OF THE LARGER NUMBER. THE FORMAT OF 
                             C  				;FLOATING POINT NUMBERS IS AS FOLLOWS: 
                             C  				; 
                             C  				;BIT    33222222 22221111 11111100 00000000 
                             C  				;       10987654 32109876 54321098 76543210 
                             C  				;       AAAAAAAA BCCCCCCC CCCCCCCC CCCCCCCC 
                             C  				;BYTE   [ $FAC ] [$FAC-1] [$FAC-2] [$FAC-3] 
                             C  				;                                  [$FACLO] 
                             C  				; 
                             C  				;WHERE  A=BITS OF EXPONENT BIASED BY 128 
                             C  				;       B=0 IF NUMBER IS POSITIVE,1 IF NEGATIVE 
                             C  				;       C=BITS 2-24 OF MANTISSA(BIT 1 IS UNDERSTOOD 1) 
                             C  				;NOTE:THE BINARY POINT IS TO THE LEFT OF THE UNDERSTOOD 1 
                             C  				; 
                             C  				;****************************************************** 
                             C   
 13AE  33 C9                 C  	XOR	CX,CX		;(CX)=0 
 13B0  8B 36 0000 E          C  	MOV	SI,WORD PTR $FACLO	;(SI)=($FAC-2,$FACLO) 
 13B4  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;ASSUME SIGN OF $FAC 
 13B7  8A CC                 C  	MOV	CL,AH		;SINCE ASSUME $FAC LARGER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-72
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

 13B9  2A CF                 C  	SUB	CL,BH		;CL WILL HOLD SHIFT COUNT 
 13BB  73 0D                 C  	JNB	FA20		;JUMP IF $FAC EXP EQUAL OR LARGER 
 13BD  F6 D9                 C  	NEG	CL		;NEED POS. SHIFT COUNT 
 13BF  86 DF                 C  	XCHG	BL,BH 
 13C1  89 1E 0000 E          C  	MOV	WORD PTR $FAC,BX	;SINCE (BXDX) LARGER MAGNITUDE 
 13C5  86 DF                 C  	XCHG	BL,BH		;GET EXP/SGN CORRECT AGAIN 
 13C7  93                    C  	XCHG	BX,AX		;WILL EXCHANGE (BXDX) AND (AXSI) 
 13C8  87 D6                 C  	XCHG	DX,SI		; 
 13CA                        C  FA20:				;******************************************************** 
                             C  				;AT THIS POINT SUSPECTED LARGER NUMBER IS IN (AXSI) WITH 
                             C  				;SMALLER IN (BXDX). THIS WILL BE THE CASE UNLESS THE EXPONENTS 
                             C  				;WERE EQUAL. IF THE EXPONENTS WERE EQUAL AND THIS IS 
                             C  				;TO BE A SUBTRACTION A NEGATIVE MANTISSA COULD RESULT. IF THIS 
                             C  				;HAPPENS, WE MUST COMPLEMENT THE MANTISSA AND THE SIGN OF THE 
                             C  				;RESULT. 
                             C  				;******************************************************** 
 13CA  8A E0                 C  	MOV	AH,AL		;WILL NOW DETERMINE IF ADD OR 
 13CC  32 E3                 C  	XOR	AH,BL		;SUBTRACT 
 13CE  9C                    C  	PUSHF			;SF=1 IF SUBTRACT 
 13CF  B4 80                 C  	MOV	AH,LOW 200	;WILL REPLACE UNDERSTOOD 1 
 13D1  0A C4                 C  	OR	AL,AH 
 13D3  0A DC                 C  	OR	BL,AH 
 13D5  32 E4                 C  	XOR	AH,AH		;(AH) WILL BE OVERFLOW BYTE 
 13D7  8A FC                 C  	MOV	BH,AH		;(AH)=(BH)=0 
 13D9  0B C9                 C  FA22:	OR	CX,CX		;ZF=1 IF EXPONENTS THE SAME 
 13DB  74 51                 C  	JZ	FA40		;IF EXPONENTS SAME JUMP 
 13DD  83 F9 19              C  	CMP	CX,31		;MUST SEE IF WITHIN 24 BITS 
 13E0  72 12                 C  	JB	FA23		;IF SO PROCEED 
                             C  ;************************************************************* 
                             C  ;THE NUMBERS WE ARE TRYING TO ADD/SUBTRACT ARE OF SUCH DIFFERENCE 
                             C  ;IN MAGNITUDE THAT THE SMALLER IS NEGLIGIBLE WITH RESPECT TO THE 
                             C  ;LARGER. OUR ANSWER THEREFORE IS THE NUMBER WITH THE ABSOLUTE 
                             C  ;LARGER MAGNITUDE. THE MANTISSA OF THIS NO. IS IN (AL:SI) 
                             C  ;************************************************************** 
 13E2  9D                    C  	POPF			;CLEAR SUBTRACT/ADD FLAG 
 13E3  89 36 0000 E          C  	MOV	WORD PTR $FACLO,SI	;RESTORE LOWER MANTISSA BITS 
 13E7  8A 26 0001 E          C  	MOV	AH,BYTE PTR $FAC+1	;FETCH SIGN 
 13EB  25 807F               C  	AND	AX,100177	;CLEAR SIGN IN AH, ALL BUT SIGN IN AL 
 13EE  0A C4                 C  	OR	AL,AH		;RESTORE SIGN 
 13F0  A2 FFFF E             C  	MOV	BYTE PTR $FAC-1,AL	;$FAC NOW CORRECTLY BUILT 
 13F3  C3                    C  	RET 
 13F4                        C  FA23: 
                             C  				;WILL TRY FOR BYTE MOVES 
 13F4  80 F9 08              C  	CMP	CL,LOW 10	;NEED AT LEAST 8 BITS 
 13F7  72 27                 C  	JB	FA27		;IF NOT PROCEED AS NORMAL 
 13F9  8B F8                 C  	MOV	DI,AX		;WILL WANT TO CHECK THIS FOR ST 
 13FB  8A E2                 C  	MOV	AH,DL		;SHIFT OVERFLOW BITS 
 13FD  F7 C7 FF00            C  	TEST	DI,177400O	;DID WE SHIFT THROUGH ST? 
 1401  74 03                 C  	JZ	FA24 
 1403  80 CC 20              C  	OR	AH,LOW 40	;PUT ST BACK IN 
 1406                        C  FA24: 
 1406  8A D6                 C  	MOV	DL,DH 
 1408  8A F3                 C  	MOV	DH,BL 
 140A  32 DB                 C  	XOR	BL,BL		;CLEAR UPPER BITS 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-73
$FADDS  SINGLE PRECISION FLOATING POINT ADD/SUB             

 140C  80 E9 08              C  	SUB	CL,LOW 10 
 140F  F6 C4 1F              C  	TEST	AH,LOW 37	;SHIFT THRU ST 
 1412  74 C5                 C  	JZ	FA22		;IF NOT TRY AGAIN 
 1414  80 CC 20              C  	OR	AH,LOW 40 
 1417  EB C0                 C  	JMP	SHORT FA22 
 1419  80 CC 20              C  FA25:	OR	AH,LOW 40	;"OR" IN ST BIT 
 141C  E2 03                 C  	LOOP	FA30		;CONTINUE LOOP 
 141E  EB 0E                 C  	JMP	SHORT FA40	;IF FINISHED JUMP 
 1420  F8                    C  FA27:	CLC			;MAKE SURE CARRY CLEAR BEFORE SHIFT 
 1421  D0 DB                 C  FA30:	RCR	BL,1 
 1423  D1 DA                 C  	RCR	DX,1 
 1425  D0 DC                 C  	RCR	AH,1		;SHIFT (BLDXAH)RIGHT ONE BIT 
 1427  F6 C4 10              C  	TEST	AH,LOW 20	;SEE IF ST SET 
 142A  75 ED                 C  	JNZ	FA25 
                             C  				;CARRY INTO HIGH BIT 
 142C  E2 F3                 C  	LOOP	FA30		;LOOP UNTIL (CX)=0 
 142E  9D                    C  FA40:	POPF			;IF SF=1 WE MUST SUBTRACT MANTISSAS 
 142F  79 25                 C  	JNS	FA50		;IF SF=0 GO ADD MANTISSAS 
 1431  2A CC                 C  	SUB	CL,AH		;SUBTRACT UNDERFLOW BYTE 
 1433  8A E1                 C  	MOV	AH,CL		;MUST GO TO NORMS WITH MANT. IN (BLDXCL) 
 1435  1B F2                 C  	SBB	SI,DX 
 1437  8B D6                 C  	MOV	DX,SI 
 1439  1A C3                 C  	SBB	AL,BL		;IF CARRY (CF) NOT SET THEN 
 143B  8A D8                 C  	MOV	BL,AL 
 143D  73 2F                 C  	JNB	FA90		;ASSUMPTION OF $FAC LARGER VALID 
 143F  F6 16 0001 E          C  	NOT	BYTE PTR $FAC+1 ;MUST USE OTHER SIGN $FAC WASN'T 
 1443  F6 D4                 C  	NOT	AH		;LARGER 
 1445  F7 D2                 C  	NOT	DX 
 1447  F6 D3                 C  	NOT	BL 
 1449  FE C4                 C  	INC	AH		;INCREMENT BY ONE AND SET CARRY 
 144B  75 21                 C  	JNZ	FA90		;IF ZF=0 GO NORMALIZE 
 144D  42                    C  	INC	DX		;INCREMENT BY ONE 
 144E  75 1E                 C  	JNZ	FA90		;IF ZF=0 GO NORMALIZE 
 1450  FE C3                 C  	INC	BL		;INCREMENT BY ONE 
 1452  75 1A                 C  	JNZ	FA90		;IF ZF=0 GO NORMALIZE 
 1454  EB 06                 C  	JMP	SHORT FA60 
 1456                        C  FA50: 
                             C  ;************************************************************ 
                             C  ;SIGNS OF THE NUMBERS WERE THE SAME SO WE ADD MANTISSAS HERE 
                             C  ;************************************************************* 
 1456  03 D6                 C  	ADD	DX,SI		;ADDITION OF LOW BITS 
 1458  12 D8                 C  	ADC	BL,AL		;ADDITION OF HIGH BITS 
 145A  73 0C                 C  	JNB	FA70 
 145C                        C  FA60:				;HERE WHEN WE HAVE OVERFLOWED THE HIGH MANTISSA BYTE 
                             C  				;AND MUST INCREMENT THE EXPONENT 
 145C  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;INCREMENT THE EXPONENT 
 1460  74 09                 C  	JZ	FA80		;OVERFLOW! 
 1462  D0 DB                 C  	RCR	BL,1		;MUST SHIFT RIGHT ONE BIT 
 1464  D1 DA                 C  	RCR	DX,1 
 1466  D0 DC                 C  	RCR	AH,1 
 1468  E9 1FCA R             C  FA70:	JMP	$ROUNS 
 146B  E9 0776 R             C  FA80:	JMP	$OVFLS		;DO OVERFLOW CODE 
 146E  E9 1CE8 R             C  FA90:	JMP	$NORMS		;GO NORMALIZE 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-74
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

                             C  	SUBTTL	 DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC) 
                             C  ;***************************************************************** 
                             C  ; 
                             C  ;       $FDIVD  THIS ROUTINE DIVIDES THE ARG BY THE FAC LEAVING THE 
                             C  ;               QUOTIENT IN THE FAC 
                             C  ;       CALLING SEQUENCE:       CALL    $FDIVD 
                             C  ; 
                             C  ;******************************************************************* 
                             C   
 1471  E9 08A8 R             C  EXIT1:	JMP	$DZERO		;ZERO THE FAC 
 1474  79 FB                 C  DOVCKJ: JNS	EXIT1 
 1476  E9 0776 R             C  	JMP	$OVFLS 
 1479                        C  DDIV: 
 1479  BE 0000 E             C  DDIVFA: MOV	SI,OFFSET $DFACL 
 147C  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 147F  EB 06                 C  	JMP	SHORT $DDIV 
 1481                        C  $FDIVD: 
 1481  BE 0000 E             C  	MOV	SI,OFFSET $ARGLO 
 1484  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 1487                        C  $DDIV: 
 1487  8B 44 06              C  	MOV	AX,WORD PTR 6[SI]	;High half of numerator 
 148A  8B 4D 06              C  	MOV	CX,WORD PTR 6[DI]	;High half of denominator 
 148D  32 C1                 C  	XOR	AL,CL		;Compute sign 
 148F  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;and store in $FAC 
 1492  0A ED                 C  	OR	CH,CH		;Denominator zero? 
 1494  74 63                 C  	JZ	DDIV0 
 1496  0A E4                 C  	OR	AH,AH		;Numerator zero? 
 1498  74 D7                 C  	JZ	EXIT1 
 149A  80 EC 80              C  	SUB	AH,LOW 128D	;Remove bias from exponents 
 149D  80 ED 80              C  	SUB	CH,LOW 128D 
 14A0  2A E5                 C  	SUB	AH,CH		;Compute result exponent 
 14A2  70 D0                 C  	JO	DOVCKJ 
                             C   
                             C  ;AH has the (tentative) true exponent of the result. It is correct if the 
                             C  ;result needs normalizing one bit. If not, 1 will be added to it. A true 
                             C  ;exponent of -128, not normally allowed except to represent zero, is OK 
                             C  ;here because of this possible future incrementing. 
                             C   
 14A4  FC                    C  	CLD			;9-Aug-82/MLC - Good for the LODC, 
                             C  				;LODW, LODW, and LODW which follow. 
 14A5  80 C4 80              C  	ADD	AH,LOW 128D	;Put bias back 
 14A8  50                    C  	PUSH	AX		;SAVE sign and exponent 
 14A9  AC                    C  	LODSB			;Load up dividend 
 14AA  8A E8                 C  	MOV	CH,AL 
 14AC  32 C9                 C  	XOR	CL,CL 
 14AE  AD                    C  	LODSW 
 14AF  93                    C  	XCHG	AX,BX 
 14B0  AD                    C  	LODSW 
 14B1  92                    C  	XCHG	AX,DX 
 14B2  AD                    C  	LODSW 
 14B3  80 CC 80              C  	OR	AH,LOW 200O	;Set implied bit 
 14B6  92                    C  	XCHG	AX,DX		;Divisor in DX:AX:BX:CX 
                             C   
                             C  ;Move divisor to FAC so we can get at it easily. More importantly, get it in 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-75
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

                             C  ;the necessary form - extended to 64 bits with zeros, implied bit set. 
                             C  ;The form we want it in will have the mantissa MSB where the exponent usually 
                             C  ;is, so by moving high to low we will not destroy the divisor even if it is 
                             C  ;already in the FAC. 
                             C   
 14B7  8B F7                 C  	MOV	SI,DI 
 14B9  83 C6 05              C  	ADD	SI,5		;Point to high end of divisor 
 14BC  BF FFFF E             C  	MOV	DI,OFFSET $FAC-1 
 14BF  FD                    C  	STD			;Direction DOWN 
 14C0  A5                    C  	MOVSW			;Move divisor to FAC 
 14C1  A5                    C  	MOVSW 
 14C2  A5                    C  	MOVSW 
 14C3  46                    C  	INC	SI 
 14C4  47                    C  	INC	DI 
 14C5  A4                    C  	MOVSB 
 14C6  FC                    C  	CLD			;DRESTR direction 
 14C7  C6 05 00              C  	MOV	BYTE PTR 0[DI],LOW 0	;Extend to 64 bits with a zero 
 14CA  80 0E 0000 E 80       C  	OR	BYTE PTR $FAC,LOW 200O	;Set implied bit 
                             C   
                             C  ;Now we're all set: 
                             C  ;       DX:AX:BX:CX has dividend 
                             C  ;       FAC has divisor (not in normal format) 
                             C  ;Both are extended to 64 bits with zeros and have implied bit set. 
                             C  ;Top of stack has sign and tentative exponent. 
                             C   
 14CF  D1 EA                 C  	SHR	DX,1		;Make sure dividend is smaller than divisor 
 14D1  D1 D8                 C  	RCR	AX,1		;   by dividing it by two 
 14D3  D1 DB                 C  	RCR	BX,1 
 14D5  D1 D9                 C  	RCR	CX,1 
 14D7  E8 14FF R             C  	CALL	DDIV16		;Get a quotient digit 
 14DA  57                    C  	PUSH	DI 
 14DB  E8 14FF R             C  	CALL	DDIV16 
 14DE  57                    C  	PUSH	DI 
 14DF  E8 14FF R             C  	CALL	DDIV16 
 14E2  57                    C  	PUSH	DI 
 14E3  E8 14FF R             C  	CALL	DDIV16 
 14E6  0B C3                 C  	OR	AX,BX		;Remainder zero? 
 14E8  0B C1                 C  	OR	AX,CX 
 14EA  0B C2                 C  	OR	AX,DX 
 14EC  8B D7                 C  	MOV	DX,DI		;Get lowest word in position 
 14EE  74 03                 C  	JZ	DNSTK1 
 14F0  80 CA 01              C  	OR	DL,LOW 1	;Set sticky bit if not 
 14F3                        C  DNSTK1: 
 14F3  59                    C  	POP	CX		;Recover quotient digits 
 14F4  5B                    C  	POP	BX 
 14F5  5F                    C  	POP	DI 
 14F6  E9 1583 R             C  	JMP	DNRMCHK 
                             C   
 14F9  A2 0001 E             C  DDIV0:	MOV	BYTE PTR $FAC+1,AL 
 14FC  E9 0787 R             C  	JMP	$DIV0S 
                             C   
 14FF                        C  DDIV16: 
 14FF  8B 36 0006 E          C  	MOV	SI,WORD PTR $DFACL+6	;Get high word of divisor 
 1503  33 FF                 C  	XOR	DI,DI		;Initialize quotient digit to zero 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-76
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

 1505  3B D6                 C  	CMP	DX,SI		;Will we overflow? 
 1507  73 5C                 C  	JAE	DMXQUO		;If so, go handle special 
 1509  0B D2                 C  	OR	DX,DX		;Is dividend small? 
 150B  75 04                 C  	JNZ	DODIV 
 150D  3B F0                 C  	CMP	SI,AX		;Will divisor fit at all? 
 150F  77 3B                 C  	JA	ZERQUO		;No - quotient is zero 
 1511                        C  DODIV: 
 1511  F7 F6                 C  	DIV	SI		;AX is our digit "guess" 
 1513  52                    C  	PUSH	DX		;SAVE remainder 
 1514  97                    C  	XCHG	AX,DI		;Quotient digit in DI 
 1515  33 ED                 C  	XOR	BP,BP		;Initialize quotient * divisor 
 1517  8B F5                 C  	MOV	SI,BP 
 1519  A1 0000 E             C  	MOV	AX,WORD PTR $DFACL 
 151C  0B C0                 C  	OR	AX,AX		;If zero, SAVE multiply time 
 151E  74 04                 C  	JZ	REM2 
 1520  F7 E7                 C  	MUL	DI		;Begin computing quotient * divisor 
 1522  8B F2                 C  	MOV	SI,DX 
 1524                        C  REM2: 
 1524  50                    C  	PUSH	AX		;SAVE lowest word of quotient * divisor 
 1525  A1 0002 E             C  	MOV	AX,WORD PTR $DFACL+2 
 1528  0B C0                 C  	OR	AX,AX 
 152A  74 06                 C  	JZ	REM3 
 152C  F7 E7                 C  	MUL	DI 
 152E  03 F0                 C  	ADD	SI,AX 
 1530  13 EA                 C  	ADC	BP,DX 
 1532                        C  REM3: 
 1532  A1 0004 E             C  	MOV	AX,WORD PTR $DFACL+4 
 1535  0B C0                 C  	OR	AX,AX 
 1537  74 08                 C  	JZ	REM4 
 1539  F7 E7                 C  	MUL	DI 
 153B  03 E8                 C  	ADD	BP,AX 
 153D  83 D2 00              C  	ADC	DX,0 
 1540  92                    C  	XCHG	AX,DX 
 1541                        C  REM4:				;Quotient * divisor in AX:BP:SI:[SP] 
 1541  5A                    C  	POP	DX		;Recover lowest word of quotient * divisor 
 1542  F7 DA                 C  	NEG	DX		;Subtract from dividend 
 1544  1B CE                 C  	SBB	CX,SI 
 1546  1B DD                 C  	SBB	BX,BP 
 1548  5D                    C  	POP	BP		;Remainder from DIV 
 1549  1B E8                 C  	SBB	BP,AX 
 154B  95                    C  	XCHG	AX,BP 
 154C                        C  ZERQUO:			;Remainder in AX:BX:CX:DX 
 154C  92                    C  	XCHG	AX,DX 
 154D  91                    C  	XCHG	AX,CX 
 154E  93                    C  	XCHG	AX,BX 
 154F  73 13                 C  	JNB	RETRES		;Remainder in DX:AX:BX:CX 
 1551                        C  DRESTR: 
 1551  4F                    C  	DEC	DI		;Drop quotient since it didn't fit 
 1552  03 0E 0000 E          C  	ADD	CX,WORD PTR $DFACL	;Add divisor back in until remainder goes + 
 1556  13 1E 0002 E          C  	ADC	BX,WORD PTR $DFACL+2 
 155A  13 06 0004 E          C  	ADC	AX,WORD PTR $DFACL+4 
 155E  13 16 0006 E          C  	ADC	DX,WORD PTR $DFACL+6 
 1562  73 ED                 C  	JNB	DRESTR 
 1564  C3                    C  RETRES: RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-77
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

                             C   
 1565                        C  DMXQUO: 
 1565  4F                    C  	DEC	DI		;DI=FFFF=2**16-1 
 1566  2B 0E 0000 E          C  	SUB	CX,WORD PTR $DFACL 
 156A  1B 1E 0002 E          C  	SBB	BX,WORD PTR $DFACL+2 
 156E  1B 06 0004 E          C  	SBB	AX,WORD PTR $DFACL+4 
 1572  03 0E 0002 E          C  	ADD	CX,WORD PTR $DFACL+2 
 1576  13 1E 0004 E          C  	ADC	BX,WORD PTR $DFACL+4 
 157A  13 C2                 C  	ADC	AX,DX 
 157C  8B 16 0000 E          C  	MOV	DX,WORD PTR $DFACL 
 1580  F5                    C  	CMC 
 1581  EB C9                 C  	JMP	SHORT ZERQUO 
 1583                        C  DNRMCHK: 
 1583  58                    C  	POP	AX		;Get exp. and sign back 
 1584  0B FF                 C  	OR	DI,DI		;See if normalized 
 1586  78 0F                 C  	JS	DINCEX		;Yes - increment exponent 
 1588  D1 E2                 C  	SHL	DX,1		;Normalize 
 158A  D1 D1                 C  	RCL	CX,1 
 158C  D1 D3                 C  	RCL	BX,1 
 158E  D1 D7                 C  	RCL	DI,1 
 1590  0A E4                 C  	OR	AH,AH 
 1592  75 07                 C  	JNZ	DDRND 
 1594  E9 08A8 R             C  	JMP	$DZERO 
 1597                        C  DINCEX: 
 1597  FE C4                 C  	INC	AH 
 1599  74 1E                 C  	JZ	DDOVFL 
 159B                        C  $DROUND: 
 159B                        C  DDRND: 
 159B  80 FA 80              C  	CMP	DL,LOW 200O	;Check extended bits 
 159E  77 07                 C  	JA	FPRNDUP 
 15A0  72 1A                 C  	JB	DDSV 
                             C  ;Extended bits equal exactly one-half LSB, so round even 
 15A2  F6 C6 01              C  	TEST	DH,LOW 1	;Already even? 
 15A5  74 15                 C  	JZ	DDSV 
 15A7                        C  FPRNDUP: 
 15A7  80 C6 01              C  	ADD	DH,LOW 1 
 15AA  83 D1 00              C  	ADC	CX,0 
 15AD  83 D3 00              C  	ADC	BX,0		;Propagate carry 
 15B0  83 D7 00              C  	ADC	DI,0 
 15B3  73 07                 C  	JNB	DDSV		;Overflow? 
                             C  ;If we overflowed, DI:BX:CX:DH must now be zero, so we can leave it that way. 
 15B5  FE C4                 C  	INC	AH		;Increment exponent 
 15B7  75 03                 C  	JNZ	DDSV 
 15B9  E9 0776 R             C  DDOVFL: JMP	$OVFLS 
 15BC                        C  DDSV: 
 15BC  24 80                 C  	AND	AL,LOW 200O	;Strip to sign bit 
 15BE  87 DF                 C  	XCHG	BX,DI 
 15C0  80 E7 7F              C  	AND	BH,LOW 177O	;Mask off implied bit 
 15C3  0A C7                 C  	OR	AL,BH		;Combine sign with mantissa 
 15C5  A3 0006 E             C  	MOV	WORD PTR $DFACL+6,AX 
 15C8  88 1E FFFE E          C  	MOV	BYTE PTR $FAC-2,BL 
 15CC  8B DF                 C  	MOV	BX,DI 
 15CE  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 15D1  8A C6                 C  	MOV	AL,DH 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-78
DDIV	 DOUBLE PRECISION DIVIDE (FAC)=(ARG)/(FAC)             

 15D3  FC                    C  	CLD 
 15D4  AA                    C  	STOSB 
 15D5  91                    C  	XCHG	AX,CX 
 15D6  AB                    C  	STOSW 
 15D7  93                    C  	XCHG	AX,BX 
 15D8  AB                    C  	STOSW 
 15D9  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE 
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;       $FDIVS  THIS ROUTINE FORMS THE QUOTIENT (BXDX)/(FAC) 
                             C  ;               AND RETURNS IT TO THE FAC 
                             C  ; 
                             C  ;****************************************************************** 
                             C   
                             C  ;$DIV0S IS THE DIVIDE BY ZERO ENTRY INTO OVERFLOW CODE 
                             C  ;$SIGNS WILL SET THE CONDITION CODES ACCORDING TO THE VALUE OF THE 
                             C  ;       FAC,I.E. ZF=1 IF (FAC)=0, SF=1 IF FAC NEGATIVE, AND NEITHER 
                             C  ;       OF THESE IF (FAC) GREATER THAN 0 
                             C  ;$ZERO CLEARS THE 4 BYTES OF THE FAC 
 15DA  E8 08BF R             C  $FDIVS: CALL	$SIGNS		;MUST BE SURE (FAC) NOT ZERO 
 15DD  75 07                 C  	JNZ	FDS00 
 15DF  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL	;PUT IN FOR CORRECT OVERFLOW SIGN 
 15E3  E9 0787 R             C  	JMP	$DIV0S		;IF SO OVERFLOW! 
 15E6                        C  FDS00: 
 15E6  0A FF                 C  	OR	BH,BH		;IF (BXDX)=0 ANSWER IS ZERO 
 15E8  75 03                 C  	JNZ	FDS10		;PROCEED IF (BXDX) NON-ZERO 
 15EA  E9 08B5 R             C  FDS05:	JMP	$ZERO 
 15ED                        C  FDS10: 
 15ED  89 16 0000 E          C  	MOV	WORD PTR $DFACL,DX	;WILL PUT NUMERATOR IN $DFAC 
 15F1  89 1E 0002 E          C  	MOV	WORD PTR $DFACL+2,BX 
 15F5  BE 0000 E             C  	MOV	SI,OFFSET $DFACL 
 15F8  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
                             C  ;***  $SDIV - Single precision divide 
                             C  ; 
                             C  ; Inputs: 
                             C  ;       SI = Address of Dividend (Numerator) 
                             C  ;       DI = Address of Divisor (Denominator) 
                             C  ; Function: 
                             C  ;       FAC = 0(.SI) / 0(.DI) 
                             C  ; Outputs: 
                             C  ;       Result in FAC. 
                             C  ; Registers: 
                             C  ;       All except BP destroyed. 
                             C   
 15FB                        C  $SDIV: 
 15FB  8B 4D 02              C  	MOV	CX,WORD PTR 2[DI]	;Exponent and sign of denominator 
 15FE  8B 44 02              C  	MOV	AX,WORD PTR 2[SI]	;Exponent and sign of numerator 
 1601  32 C1                 C  	XOR	AL,CL		;Compute sign 
 1603  A2 0001 E             C  	MOV	BYTE PTR $FAC+1,AL	;Save sign in case OVERFLOW 
 1606  80 EC 80              C  	SUB	AH,LOW 128D	;Remove bias from exponents 
 1609  80 ED 80              C  	SUB	CH,LOW 128D 
 160C  2A E5                 C  	SUB	AH,CH		;Compute result exponent 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-79
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 160E  70 33                 C  	JO	OVCHKJ 
                             C   
                             C  ;AH has the (tentative) true exponent of the result. It is correct if the 
                             C  ;result needs normalizing one bit. If not, 1 will be added to it. A true 
                             C  ;exponent of -128, not normally allowed except to represent zero, is OK 
                             C  ;here because of this possible future incrementing. 
                             C   
 1610  80 C4 80              C  	ADD	AH,LOW 128D	;Put bias back 
 1613  50                    C  	PUSH	AX		;Save sign and exponent 
 1614  80 C9 80              C  	OR	CL,LOW 200O	;Set implied bit 
 1617  8B 54 01              C  	MOV	DX,WORD PTR 1[SI]	;Most significant part of numerator mantissa 
 161A  8A 24                 C  	MOV	AH,BYTE PTR 0[SI]	;Least significant part 
 161C  32 C0                 C  	XOR	AL,AL		;Extend with zero 
 161E  80 CE 80              C  	OR	DH,LOW 200O	;And set implied bit 
 1621  8B 5D 01              C  	MOV	BX,WORD PTR 1[DI]	;Load denominator into BX:CX 
 1624  8A 2D                 C  	MOV	CH,BYTE PTR 0[DI] 
 1626  32 C9                 C  	XOR	CL,CL 
 1628  80 CF 80              C  	OR	BH,LOW 200O 
                             C   
                             C  ;Now we have the following configuration: 
                             C  ;       Numerator in DX:AX 
                             C  ;       Denominator in BX:CX 
                             C  ; Both are extended to 32 bits with trailing zeros and have implied bit set 
                             C  ;       Result will go in BX:DX 
                             C  ; 
                             C  ;The algorithm used here is similar to Algorithm D, p.237, Knuth vol. 2. 
                             C  ;It is basically just ordinary long division, except the base is 2^16. This 
                             C  ;means we are dividing two 2-digit numbers, where each "digit" takes a whole 
                             C  ;word. We "guess" at a quotient digit, multiply it by the divisor, and subtract 
                             C  ;from the current dividend to get a remainder. This remainder could be 
                             C  ;negative, so we try a quotient digit one smaller. 
                             C  ; 
                             C  ;The "guess" at the quotient digit simply uses the 8086 DIV instruction. 
                             C  ;Computing the remainder takes advantage of the remainder from this divide. If 
                             C  ;the remainder comes out negative, new quotient digits are tried by repeated 
                             C  ;addition, rather than another multiply. Theorem B on p.237 of Knuth vol. 2 
                             C  ;guarantees that this repeated addition will happen no more than twice. 
                             C   
 162B  D1 EA                 C  	SHR	DX,1 
 162D  D1 D8                 C  	RCR	AX,1		;Ensure DX<BX so divide won't OVERFLOW 
 162F  E8 164F R             C  	CALL	DIV16		;Get first 16 bits of quotient 
 1632  56                    C  	PUSH	SI		;Save high half of quotient on stack 
 1633  E8 164B R             C  	CALL	CDIV16		;Get second 16 bits of quotient 
 1636  0B C2                 C  	OR	AX,DX		;Remainder 0? 
 1638  8B D6                 C  	MOV	DX,SI		;Want low half of result in DX 
 163A  74 03                 C  	JZ	NSTK1 
 163C  80 CA 01              C  	OR	DL,LOW 1	;Set sticky bit if remainder not zero 
 163F                        C  NSTK1: 
 163F  5B                    C  	POP	BX		;Recover high half of result 
 1640  EB 2A 90              C  	JMP	NORMCHK 
                             C   
 1643                        C  OVCHKJ: 
 1643  79 A5                 C  	JNS	FDS05		;ZERO THE FAC 
 1645                        C  SDIVOVFL: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-80
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 1645  E9 0776 R             C  	JMP	$OVFLS		;OVERFLOW 
 1648  E9 0787 R             C  DIV0:	JMP	$DIV0S 
                             C   
 164B                        C  CDIV16: 
 164B  3B D3                 C  	CMP	DX,BX		;Will we OVERFLOW on divide? 
 164D  73 5B                 C  	JAE	MAXQUO		;Special code for maximum quotient 
 164F                        C  DIV16: 
 164F  F7 F3                 C  	DIV	BX		;32 by 16 bit division 
 1651  96                    C  	XCHG	AX,SI		;Put 16-bit quotient in SI 
 1652  33 C0                 C  	XOR	AX,AX		;DX:AX has remainder 
 1654  E3 15                 C  	JCXZ	RETJ		;Is this complete result? 
 1656  8B FA                 C  	MOV	DI,DX		;Save remainder while we multiply 
 1658  8B C6                 C  	MOV	AX,SI 
 165A  F7 E1                 C  	MUL	CX		;Low half of divisor times quotient 
 165C  F7 D8                 C  	NEG	AX		;Subtract from remainder, whose low half is 0 
 165E  1B FA                 C  	SBB	DI,DX 
 1660  8B D7                 C  	MOV	DX,DI		;Remainder again in DX:AX 
 1662  73 07                 C  	JNB	RETJ		;If not negative, divide was good 
 1664                        C  RESTORE: 
 1664  4E                    C  	DEC	SI		;Quotient is too big 
 1665  03 C1                 C  	ADD	AX,CX		;And remainder too small (negative) 
 1667  13 D3                 C  	ADC	DX,BX		;So add divisor back in till positive 
 1669  73 F9                 C  	JNB	RESTORE 
 166B  C3                    C  RETJ:	RET 
 166C                        C  NORMCHK: 
 166C  58                    C  	POP	AX		;Get exp. and sign back 
 166D  0A FF                 C  	OR	BH,BH		;See if normalized 
 166F  78 0B                 C  	JS	INCEXP		;Yes-increment exponent 
 1671  D1 E2                 C  	SHL	DX,1		;Normalize 
 1673  D1 D3                 C  	RCL	BX,1 
 1675  0A E4                 C  	OR	AH,AH		;test exponent 
 1677  75 07                 C  	JNZ	ROUND		;brif exponent not zero 
 1679  E9 08B5 R             C  	JMP	$ZERO		;underflow if exponent zero 
                             C   
 167C                        C  INCEXP: 
 167C  FE C4                 C  	INC	AH 
 167E  74 C5                 C  	JZ	SDIVOVFL 
 1680                        C  $SRND: 
                             C  ;Round single precision and store in $FACLO 
                             C   
 1680                        C  ROUND: 
 1680  80 FA 80              C  	CMP	DL,LOW 200O	;Check extended bits 
 1683  77 07                 C  	JA	ROUNDUP 
 1685  72 11                 C  	JB	SAVE 
                             C  ;Extended bits equal exactly one-half LSB, so round even 
 1687  F6 C6 01              C  	TEST	DH,LOW 1	;Already even? 
 168A  74 0C                 C  	JZ	SAVE 
 168C                        C  ROUNDUP: 
 168C  80 C6 01              C  	ADD	DH,LOW 1 
 168F  83 D3 00              C  	ADC	BX,0		;Propagate carry 
 1692  73 04                 C  	JNB	SAVE		;OVERFLOW? 
                             C  ;If we OVERFLOWed, BX:DH must now be zero, so we can leave it that way. 
 1694  FE C4                 C  	INC	AH		;Increment exponent 
 1696  74 AD                 C  	JZ	SDIVOVFL 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-81
SDIV	 SINGLE PRECISION FLOATING POINT DIVIDE                

 1698                        C  SAVE: 
 1698  24 80                 C  	AND	AL,LOW 200O	;Strip to sign bit 
 169A  80 E7 7F              C  	AND	BH,LOW 177O	;Mask off implied bit 
 169D  0A C7                 C  	OR	AL,BH		;Combine sign with mantissa 
 169F  A3 0002 E             C  	MOV	WORD PTR $FACLO+2,AX 
 16A2  8A E3                 C  	MOV	AH,BL 
 16A4  8A C6                 C  	MOV	AL,DH 
 16A6  A3 0000 E             C  	MOV	WORD PTR $FACLO,AX	;Save lower part of mantissa 
 16A9  C3                    C  	RET 
 16AA                        C  MAXQUO: 
                             C  ;Come here if divide instruction would OVERFLOW. This must mean that DX=BX, 
                             C  ;i.e., the high half of the divisor and dividend are equal. Assume a result 
                             C  ;of (2^16)-1, which will give us a remainder equal to divisor plus (low half 
                             C  ;of dividend minus low half of divisor, times 2^16). 
                             C   
 16AA  BE FFFF               C  	MOV	SI,-1		;Quotient of (2^16)-1 
 16AD  2B C1                 C  	SUB	AX,CX		;Dividend - divisor (always negative) 
 16AF  03 D0                 C  	ADD	DX,AX		;Add to high half of divisor 
 16B1  8B C1                 C  	MOV	AX,CX 
 16B3  73 AF                 C  	JNB	RESTORE	;Carry means it's not negative any more 
 16B5  C3                    C  	RET 
                                 
                             C  	include	math2.asm 
                             C  	SUBTTL	 $FIDIG  ADD TEXT DIGIT TO CURRENT ACCUMULATED NUMBER 
                             C  ;*************************************************************** 
                             C  ; 
                             C  ;       $FIDIG  CONVERTS DIGIT POINTED TO BY (BX) TO BINARY 
                             C  ;               VALUE AND ADDS TO NUMBER ACCUMULATED. AT THE 
                             C  ;               APPROPRIATE TIMES CONVERSION WILL TAKE 
                             C  ;               PLACE TO THE NEXT HIERARCHY OF NUMBERS,I.E. 
                             C  ;               INTEGER-SINGLE PRECISION-DOUBLE PRECISION. 
                             C  ;       CALLING SEQUENCE:       CALL    $FIDIG 
                             C  ;               WITH (BX) POINTING TO NUMBER IN THE 
                             C  ;               TEXT BUFFER. NUMBER IS ACCUMULATED IN THE FAC. 
                             C  ; 
                             C  ;**************************************************************** 
                             C   
                             C  ;****************************************************************** 
                             C  ;AS $FIDIG IS ENTERED CF=1 AND (DI) WILL HOLD PLACES TO THE RIGHT OF 
                             C  ;DECIMAL POINT (IF DECIMAL POINT HAS OCCURRED).(CX) WILL BE EITHER 
                             C  ;ALL BITS SET OR ALL BITS CLEARED. ALL BITS SET INDICATES A DECIMAL 
                             C  ;POINT HAS NOT BEEN SEEN YET AND (CX)=0 INDICATES D. P. SEEN 
                             C  ;****************************************************************** 
 16B6  13 F9                 C  $FIDIG: ADC	DI,CX		;(DI) INCREMENTED ONLY IF D.P. SEEN 
 16B8  53                    C  	PUSH	BX		;MUST NOW SAVE ALL NECESSARY REGS. 
 16B9  57                    C  	PUSH	DI 
 16BA  51                    C  	PUSH	CX 
 16BB  2C 30                 C  	SUB	AL,LOW "0"      ;SUBTRACT OUT ASCII BIAS 
 16BD  50                    C  	PUSH	AX		;SAVE ON STACK 
 16BE  E8 08EF R             C  	CALL	$GETYP		;SET CONDITION CODES 
 16C1  58                    C  	POP	AX		;RECALL DIGIT 
 16C2  98                    C  	CBW			;ZERO AH 
 16C3  79 1E                 C  	JNS	FI05		;MUST BE S.P. OR D.P. ALREADY 
 16C5  8B 1E 0000 E          C  	MOV	BX,WORD PTR $FACLO	;FETCH THE INTEGER ALREADY ACCUM. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-82
$FIDIG  ADD TEXT DIGIT TO CURRENT ACCUMULATED NUMBER        

 16C9  81 FB 0CCD            C  	CMP	BX,3277D	;IS IT ALREADY TOO BIG TO ADD 
                             C  				;ANOTHER DIGIT TO? 
 16CD  73 19                 C  	JNB	FFI10		;IF SO GO MAKE S.P. FIRST 
 16CF  8B CB                 C  	MOV	CX,BX		;SAVE ORIGINAL (BX) 
 16D1  D1 E3                 C  	SHL	BX,1		;(BX)=(BX)*2 
 16D3  D1 E3                 C  	SHL	BX,1		;(BX)=(BX)*4 
 16D5  03 D9                 C  	ADD	BX,CX		;(BX)=(BX)*5 
 16D7  D1 E3                 C  	SHL	BX,1		;(BX)=(BX)*10 
 16D9  03 D8                 C  	ADD	BX,AX		;ADD IN THE DIGIT 
 16DB  78 0B                 C  	JS	FFI10		;IF SF=1 WE HAVE 32768 OR 32769 
 16DD  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;STORE IN $FAC 
 16E1  EB 48                 C  	JMP	SHORT FI50 
 16E3                        C  FI05:				;TO GET HERE NUMBER WAS ALREADY S.P. OR D.P. 
 16E3  50                    C  	PUSH	AX		;SAVE THE NUMBER 
 16E4  72 08                 C  	JB	FFFI20		;IT'S CURRENTLY SINGLE PRECISION 
 16E6  EB 33                 C  	JMP	SHORT FI40	;DOUBLE PRECISION 
 16E8                        C  FFI10:				;TO GET HERE NUMBER WAS PREVIOUSLY AN INTEGER BUT HAS 
                             C  				;GROWN TOO LARGE - MUST MAKE IT SINGLE PRECISION 
 16E8  50                    C  	PUSH	AX		;SAVE THE NUMBER 
 16E9  E8 17E9 R             C  	CALL	$CSI		;CONVERT INTEGER TO S.P. 
 16EC  EB 14                 C  	JMP	SHORT FI30	;MUL BY 10 AND ADD IN DIGIT 
 16EE                        C  FFFI20:			;TO GET HERE NUMBER WAS ALREADY SINGLE PRECISION 
                             C  				;MUST CHECK TO SEE IF ACCURACY MIGHT BE LOST IF WE 
                             C  				;MULTIPLY OUR FAC BY 10,I.E. FAC MUST BE SMALLER 
                             C  				;THAN 1000000. 
 16EE  C7 06 0004 E 2400     C  	MOV	WORD PTR $DBUFF+4,22000 
 16F4  C7 06 0006 E 9474     C  	MOV	WORD PTR $DBUFF+6,112164 
 16FA  BB 0006 E             C  	MOV	BX,OFFSET $DBUFF+6 
 16FD  E8 0A81 R             C  	CALL	$COMPM		;COMPARE TO $FAC 
 1700  79 16                 C  	JNS	FI35		;GO DO D.P. IF TOO LARGE FOR S.P. 
 1702  E8 091F R             C  FI30:	CALL	$MUL10		;MULTIPLY $FAC BY 10 
 1705  5A                    C  	POP	DX		;RECALL DIGIT 
 1706  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 170A  FF 36 FFFF E          C  	PUSH	WORD PTR $FAC-1 ;FAC PUSHED ON STACK 
 170E  E8 1852 R             C  	CALL	$FLT		;CONVERT INTEGER TO S.P. 
 1711  5B                    C  	POP	BX		;RECALL FAC 
 1712  5A                    C  	POP	DX 
 1713  E8 13A3 R             C  	CALL	$FADDS		;ADD IN THE NEW DIGIT 
 1716  EB 13                 C  	JMP	SHORT FI50	;GET STACK RIGHT AND RETURN 
 1718                        C  FI35:				;TO GET HERE WE ALREADY HAVE 7 DIGITS AND WOULD 
                             C  				;HAVE A LOSS OF ACCURACY IF WE CONTINUED IN S.P. SO WE 
                             C  				;NEED TO CONVERT TO D.P. MULTIPLY BY 10 AND ADD IN THE DIG. 
 1718  E8 17DB R             C  	CALL	$CDS		;CONVERT THE SINGLE TO D.P. 
 171B  E8 091F R             C  FI40:	CALL	$MUL10		;MULTIPLY BY 10 
 171E  E8 09E8 R             C  	CALL	$MOVAF		;MOVE $FAC TO $ARG 
 1721  5A                    C  	POP	DX		;RECALL DIGIT 
 1722  E8 1852 R             C  	CALL	$FLT		;CONVERT TO S.P. 
 1725  E8 17DB R             C  	CALL	$CDS		;CONVERT TO D.P. 
 1728  E8 12E7 R             C  	CALL	$FADDD		;ADD IN THE OLD ACCUMULATED VALUE 
 172B  59                    C  FI50:	POP	CX		;GET DECIMAL POINT FLAG BACK 
 172C  5F                    C  	POP	DI		;GET NO. DIGITS TO RIGHT OF DECIMAL PT. 
 172D  5B                    C  	POP	BX		;GET TEXT POINTER BACK 
 172E  C3                    C  	RET			;COMPLETE 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-83
$FINEX  EXPONENT INPUT ROUTINE                              

                             C  	SUBTTL	 $FINEX  EXPONENT INPUT ROUTINE 
                             C  ;************************************************************* 
                             C  ; 
                             C  ;       $FINEX  THE PURPOSE OF THIS ROUTINE IS TO DETERMINE 
                             C  ;               THE INPUT EXPONENT BASE 10 AND LEAVE IN (DX). 
                             C  ;               ADDITIONALLY IF A MINUS "-" SIGN IS ENCOUNTERED 
                             C  ;               $FINEX WILL SET ALL BITS OF (SI). OTHERWISE ALL 
                             C  ;               BITS OF (SI) WILL BE CLEARED. 
                             C  ;       CALLING SEQUENCE:       CALL    $FINEX 
                             C  ;               WITH THE SIGNIFICANT DIGITS OF THE NUMBER IN 
                             C  ;               THE FAC. 
                             C  ; 
                             C  ;*************************************************************** 
                             C   
 172F  9F                    C  $FINEX: LAHF			;SAVE STATUS 
 1730  80 3E 0000 E 08       C  	CMP	BYTE PTR $VALTP,LOW 10	;SEE IF ALREADY D.P. 
 1735  75 04                 C  	JNZ	EXA 
 1737  9E                    C  	SAHF			;GET STACK RIGHT 
 1738  EB 09 90              C  	JMP	EXB 
 173B  9E                    C  EXA:	SAHF			;RESTORE CODES 
 173C  53                    C  	PUSH	BX		;SAVE IMPORTANT REGISTERS 
 173D  57                    C  	PUSH	DI		;PRECISION ACCORDING TO ZF. IF 
 173E  E8 179B R             C  	CALL	$FINFC		;ZF=1 S.P.:ZF=0 THEN D.P. 
 1741  5F                    C  	POP	DI		;RECALL DIGITS TO RIGHT OF D.P. 
 1742  5B                    C  	POP	BX		;RECALL TEXT POINTER 
 1743  33 F6                 C  EXB:	XOR	SI,SI		;IN CASE EXPONENT IS POSITIVE 
 1745  8B D6                 C  	MOV	DX,SI		;WILL BUILD EXPONENT IN DX 
 1747  E8 0E5F R             C  	CALL	$CHRGT		;GET FIRST CHARACTER OF EXPONENT 
 174A  72 13                 C  	JB	FX20		;NO SIGN SO DEFAULT POS. 
 174C  3C 2D                 C  	CMP	AL,LOW "-"      ;NEGATIVE EXPONENT 
 174E  75 04                 C  	JNZ	FX00		;IF NOT MUST BE POSITIVE 
 1750  F7 D6                 C  	NOT	SI		;NEGATIVE EXPONENT 
 1752  EB 05                 C  	JMP	SHORT FX10	;GO GET NEXT CHARACTER 
 1754  3C 2B                 C  FX00:	CMP	AL,LOW "+" 
 1756  74 01                 C  	JZ	FX10 
                             C  				;ILLEGAL CHARACTER MUST LEAVE 
 1758  C3                    C  	RET			;(BX) POINTING HERE 
 1759  E8 0E5F R             C  FX10:	CALL	$CHRGT		;GET NEXT CHARACTER 
 175C  72 01                 C  	JB	FX20		;IF DIGIT PROCESS AS EXPONENT 
 175E  C3                    C  	RET			;OTHERWISE RETURN 
 175F  81 FA 0CCC            C  FX20:	CMP	DX,3276D	;OVERFLOW IF THIS DOESN'T GET CF=1 
 1763  72 05                 C  	JB	FX30		;NO-USE THIS DIGIT 
 1765  BA 7FFF               C  	MOV	DX,32767D	;TO ASSURE OVERFLOW 
 1768  EB EF                 C  	JMP	SHORT FX10 
 176A  50                    C  FX30:	PUSH	AX		;SAVE NEW DIGIT 
 176B  B8 000A               C  	MOV	AX,10D		;MUST MULTIPLY DX BY 10 
 176E  F7 E2                 C  	MUL	DX		;ANSWER NOW IN AX 
 1770  5A                    C  	POP	DX		;RECALL DIGIT TO DX 
 1771  80 EA 30              C  	SUB	DL,LOW 60	;SUBTRACT OUT ASCII BIAS 
 1774  32 F6                 C  	XOR	DH,DH		;TO BE SURE AX HAS CORRECT NO. 
 1776  03 D0                 C  	ADD	DX,AX		;ADD TO DX 
 1778  EB DF                 C  	JMP	SHORT FX10 
                             C   
                             C  	SUBTTL	 FINFC	 INPUT FORCE ROUTINES FOR "#","%","!" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-84
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

                             C  ;********************************************************* 
                             C  ; 
                             C  ;       FINFC   THIS MODULE CONTAINS THE ROUTINES $FINI, 
                             C  ;               $FIND, AND $FINS FOR FORCING THE INPUT TO 
                             C  ;               INTEGER, DOUBLE PRECISION OR SINGLE PRECISION 
                             C  ;               RESPECTIVELY IN RESPONSE TO AN INPUT "$","#", OR 
                             C  ;               "!". ADDITIONALLY THIS MODULE CONTAINS 
                             C  ;               THE UTILITY ROUTINES $FI,$FS,$FD,$CSI,$CSD,$CDS 
                             C  ;               FOR FORCING INTEGER,SINGLE,DOUBLE,CONVERTING 
                             C  ;               INTEGER TO SINGLE,CONVERTING DOUBLE TO SINGLE, AND 
                             C  ;               CONVERTING SINGLE TO DOUBLE, RESPECTIVELY 
                             C  ;       CALLING SEQUENCE:       CALL    $FINI 
                             C  ;               OR              CALL    $FIND 
                             C  ;               OR              CALL    $FINS 
                             C  ;               OR              CALL    $FS 
                             C  ;               OR              CALL    $FD 
                             C  ;               OR              CALL    $FI 
                             C  ;               OR              CALL    $CSI 
                             C  ;               OR              CALL    $CSD 
                             C  ;               OR              CALL    $CDS 
                             C  ;               WITH THE FAC CONTAINING THE CURRENT ACCUMULATED 
                             C  ;               NUMBER. 
                             C  ; 
                             C  ;*********************************************************** 
                             C   
 177A                        C  $FIND:				;FORCE INPUT TO DOUBLE PRECISION 
 177A  0C 01                 C  	OR	AL,LOW 1	;TO SIGNAL DOUBLE PRECISION 
 177C                        C  $FINS:				;FORCE INPUT TO SINGLE PRECISION (caller has set Z flag) 
 177C  53                    C  	PUSH	BX		;SAVE TEXT POINTER 
 177D  57                    C  	PUSH	DI		;SAVE NO DIGITS AFTER DECIMAL POINT 
 177E  75 05                 C  	JNZ	FC10		;Force to double for $FIND callers. 
 1780  E8 179D R             C  	CALL	$FS		;Force to single for $FINS callers. 
 1783  EB 03                 C  	JMP	SHORT FC20	;Skip over $FD call. 
                             C   
 1785  E8 17CC R             C  FC10:	CALL	$FD		;FORCE FAC TO DOUBLE PREC. 
 1788  5F                    C  FC20:	POP	DI		;RECALL NO DIGITS TO RT. OF DEC PT 
 1789  5B                    C  	POP	BX		;RECALL TEXT POINTER 
 178A  33 F6                 C  	XOR	SI,SI		;SINCE THIS IS A FORCED 
 178C  8B D6                 C  	MOV	DX,SI		;NO. EXPONENT IS ZERO 
 178E  E8 0705 R             C  	CALL	$FINE		;DO IMPLIED EXPONENT FIX-UP 
 1791  43                    C  FC30:	INC	BX		;Point past the force character and 
 1792  C3                    C  	RET			;return. 
                             C   
 1793  E8 08EF R             C  $FINI:	CALL	$GETYP		;SET COND CODES ACCORDING TO TYPE 
 1796  78 F9                 C  	JS	FC30 
 1798  E9 0000 E             C  	JMP	$SNERR		;CAN'T MAKE INTEGER IF NOT ALREADY 
 179B  74 2F                 C  $FINFC: JZ	$FD		;IF ZF=1 THEN DOUBLE PRECISION 
 179D                        C  FRCSNG: 
 179D                        C  $FS:				;FORCE SINGLE PRECISION 
 179D  E8 08EF R             C  	CALL	$GETYP		;SET COND CODES ACC. TO TYPE 
 17A0  7B 52                 C  	JPO	FC200		;IF ALREADY S.P. RETURN 
 17A2  75 03                 C  	JNZ	FS10 
 17A4  E9 0000 E             C  	JMP	$TMERR		;CAN'T FORCE A STRING 
 17A7                        C  FS10: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-85
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

 17A7  79 05                 C  	JNS	$CSD		;IF NOT INTEGER FORCE DOUBLE TO S.P. 
 17A9  E8 17E9 R             C  	CALL	$CSI		;FORCE INTEGER TO SINGLE 
 17AC  EB 46                 C  	JMP	SHORT FC200 
 17AE                        C  $CSD:				;CONVERT DOUBLE TO SINGLE PRECISION 
 17AE  B0 04                 C  	MOV	AL,LOW 4	;SINGLE PREC DESIGNATION 
 17B0  A2 0000 E             C  	MOV	BYTE PTR $VALTP,AL 
 17B3  8A 1E FFFF E          C  	MOV	BL,BYTE PTR $FAC-1	;FETCH HIGH MANTISSA BITS 
 17B7  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL	;MOVE SIGN TO $FAC+1 
 17BB  8B 16 FFFD E          C  	MOV	DX,WORD PTR $FAC-3	;FETCH REST OF MANTISSA 
 17BF  8A 26 FFFC E          C  	MOV	AH,BYTE PTR $FAC-4	;FETCH OVERFLOW BITS 
 17C3  80 CC 40              C  	OR	AH,LOW 100	;WANT ROUND-UP IF HIGH BIT SET 
 17C6  80 CB 80              C  	OR	BL,LOW 200	;PUT IN UNDERSTOOD 1 
 17C9  E9 1FCD R             C  	JMP	$ROUNM		;GO ROUND THE NUMBER 
 17CC                        C  FRCDBL: 
 17CC                        C  $FD:				;FORCE TO DOUBLE PRECISION 
 17CC  E8 08EF R             C  	CALL	$GETYP		;DETERMINE CURRENT TYPE 
 17CF  73 23                 C  	JNB	FC200		;IF ALREADY DOUBLE EXIT 
 17D1  75 03                 C  	JNZ	FD10 
                             C   
 17D3  E9 0000 E             C  	JMP	$TMERR 
 17D6                        C  FD10: 
 17D6  79 03                 C  	JNS	$CDS		;IF NOT INTEGER PROCEED 
 17D8  E8 17E9 R             C  	CALL	$CSI		;CONVERT INTEGER TO SINGLE PREC. 
 17DB  B0 08                 C  $CDS:	MOV	AL,LOW 10	;DOUBLE PREC. INDICATOR 
 17DD  A2 0000 E             C  	MOV	BYTE PTR $VALTP,AL	;SET TYPE TO D.P. 
 17E0  33 C0                 C  	XOR	AX,AX		;MUST ZERO OVERFLOW BYTES 
 17E2  A3 0000 E             C  	MOV	WORD PTR $DFACL,AX 
 17E5  A3 0002 E             C  	MOV	WORD PTR $DFACL+2,AX 
 17E8  C3                    C  	RET 
 17E9  52                    C  $CSI:	PUSH	DX		;SAVE (DX) 
 17EA  56                    C  	PUSH	SI		;SAVE (SI) 
 17EB  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH THE INTEGER 
 17EF  E8 1852 R             C  	CALL	$FLT		;FLOAT THE INTEGER AND STORE IN FAC 
 17F2  5E                    C  	POP	SI		;GET REGISTERS RIGHT 
 17F3  5A                    C  	POP	DX 
 17F4  C3                    C  FC200:	RET 
 17F5                        C  FRCINT: 
 17F5                        C  $FI:				;FORCE INTEGER 
 17F5  E8 08EF R             C  	CALL	$GETYP		;SEE WHAT WE'RE IN FOR 
 17F8  79 05                 C  	JNS	FI10		;IF NOT INTEGER ALREADY - JUMP 
 17FA  8B 1E 0000 E          C  	MOV	BX,WORD PTR $FACLO 
 17FE  C3                    C  	RET 
 17FF                        C  FI10: 
 17FF  75 03                 C  	JNZ	FFI20 
 1801  E9 0000 E             C  	JMP	$TMERR		;IF STRING - ERROR 
 1804                        C  FFI20: 
 1804                        C  $CINC:				;Single precision, operand in FAC 
 1804                        C  $CIND:				;Double precision uses same routine 
 1804  50                    C  	PUSH	AX 
 1805  51                    C  	PUSH	CX 
 1806  A1 0000 E             C  	MOV	AX,WORD PTR $FACM1	;Get exponent 
 1809  8B 0E 0000 E          C  	MOV	CX,WORD PTR $FACLO	;Get mantissa 
 180D                        C  CINT: 
 180D  33 DB                 C  	XOR	BX,BX		;Set up zero result 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-86
FINFC	 INPUT FORCE ROUTINES FOR "#","%","!"                 

 180F  80 EC 80              C  	SUB	AH,LOW 200O	;Take bias out of exponent 
 1812  72 1F                 C  	JB	CXRET		;Return zero if no integer part 
 1814  8A F8                 C  	MOV	BH,AL		;Highest byte of mantissa 
 1816  8A DD                 C  	MOV	BL,CH 
 1818  91                    C  	XCHG	AX,CX 
 1819  B1 10                 C  	MOV	CL,LOW 16D 
 181B  2A CD                 C  	SUB	CL,CH		;Number of bits to shift mantissa right 
 181D  8A E7                 C  	MOV	AH,BH		;Save sign 
 181F  72 2E                 C  	JB	OVERFLOW	;If negative shift, it won't fit in 16 bits 
 1821  74 22                 C  	JZ	OVCHK		;Only -32768 has 16 bits - go check for it 
 1823  80 CF 80              C  	OR	BH,LOW 200O	;Set implied bit 
 1826  D3 EB                 C  	SHR	BX,CL		;Position the integer 
 1828  83 D3 00              C  	ADC	BX,0		;Perform rounding 
 182B  70 12                 C  	JO	POSBOVER 
 182D  0A E4                 C  	OR	AH,AH		;Check sign now 
 182F  79 02                 C  	JNS	CXRET 
 1831  F7 DB                 C  	NEG	BX 
 1833                        C  CXRET: 
 1833  59                    C  	POP	CX 
 1834  58                    C  	POP	AX 
 1835  89 1E 0000 E          C  	MOV	WORD PTR $FACLO,BX	;Result in both FAC and BX 
                             C   
 1839                        C  VALINT: 
 1839  C6 06 0000 E 02       C  $VALNT: MOV	BYTE PTR $VALTP,LOW 2 
 183E  C3                    C  	RET 
 183F                        C  POSBOVER:			;Here for either -32768 or overflow 
 183F  0A E4                 C  	OR	AH,AH		;If signed then -32768 
 1841  78 F0                 C  	JS	CXRET 
 1843  EB 0A                 C  	JMP	SHORT OVERFLOW 
 1845                        C  OVCHK: 
                             C  ;Come here if no shift is needed on the number, i.e., it requires a full 
                             C  ;16 bits. Only -32768 (8000H) is allowed. 
 1845  81 FB 8000            C  	CMP	BX,100000O	;The 1 is sign bit (negative), not implied bit 
 1849  75 04                 C  	JNZ	OVERFLOW 
 184B  A8 80                 C  	TEST	AL,LOW 200O	;Should we be rounding up? 
 184D  74 E4                 C  	JZ	CXRET		;If so, that causes overflow 
 184F                        C  OVERFLOW: 
 184F  E9 0000 E             C  	JMP	$OVERR 
                             C   
                             C  	SUBTTL	 $FLT	 CONVERT INTEGER IN (DX) TO REAL AND STORE IN FAC 
                             C  ;**************************************************************** 
                             C  ;       $FLT    CONVERTS THE SIGNED INTEGER IN (DX) TO A REAL 
                             C  ;               (FLOATING POINT ) NUMBER AND STORES IT IN THE FAC 
                             C  ;               AND SETS $VALTP=4 
                             C  ;***************************************************************** 
 1852  33 DB                 C  $FLT:	XOR	BX,BX		;CLEAR HIGH MANTISSA BYTE (BL) 
 1854  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE 
 1856  BE 0001 E             C  	MOV	SI,OFFSET $FAC+1	;FETCH $FAC ADDRESS TO (SI) 
 1859  C6 44 FF 90           C  	MOV	BYTE PTR -1[SI],LOW 220 ;SET EXPONENT TO 16 
 185D  C6 04 00              C  	MOV	BYTE PTR 0[SI],LOW 0	;SET SIGN POSITIVE 
 1860  0B D2                 C  	OR	DX,DX		;SETS SF=1 IF NEGATIVE NO. 
 1862  79 05                 C  	JNS	FLT10		;IF POSITIVE PROCEED 
 1864  F7 DA                 C  	NEG	DX		;NEED POSTIVE MAGNITUDE 
 1866  C6 04 80              C  	MOV	BYTE PTR 0[SI],LOW 200	;SET SIGN TO NEGATIVE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-87
$FLT	 CONVERT INTEGER IN (DX) TO REAL AND STORE IN FAC      

 1869  8A DE                 C  FLT10:	MOV	BL,DH		;WILL MOVE (DX) TO (BLDH) 
 186B  8A F2                 C  	MOV	DH,DL		; 
 186D  8A D7                 C  	MOV	DL,BH		;SET (DL)=0 
 186F  C6 06 0000 E 04       C  	MOV	BYTE PTR $VALTP,LOW 4	;SET TYPE TO S.P. 
 1874  E9 1CE8 R             C  	JMP	$NORMS		;GO NORMALIZE 
                             C   
                             C  	SUBTTL	 $FMULD  DOUBLE PRECISION MULTIPLICATION 
                             C  ;************************************************************** 
                             C  ; 
                             C  ;       $FMULD  THIS ROUTINE FORMS THE DOUBLE PRECISION PRODUCT 
                             C  ;               ($FAC):=($FAC)*($ARG) 
                             C  ;               THE TECHNIQUE USED IS DESCRIBED IN KNUTH, VOL II 
                             C  ;               P.233 AND IS CALLED ALGORITHM "M" 
                             C  ;       CALLING SEQUENCE:       CALL    $FMULD 
                             C  ;               WITH THE MULTIPLIER AND MULTIPLICAND IN THE 
                             C  ;               $FAC AND $ARG 
                             C  ; 
                             C  ;************************************************************** 
                             C   
 1877                        C  DMULT: 
 1877                        C  $FMULD:			;DOUBLE PRECISION MULT., (FAC)=(FAC)*(ARG) 
 1877  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;WILL FIRST SEE IF FAC IS ZERO 
 187A  0A C0                 C  	OR	AL,AL		;AND IF SO JUST RETURN 
 187C  74 0A                 C  	JZ	FMD10 
 187E  A0 0000 E             C  	MOV	AL,BYTE PTR $ARG	;WILL NOW SEE IF ARG IS ZERO AND 
 1881  0A C0                 C  	OR	AL,AL		;IF SO SET FAC TO ZERO AND RETURN 
 1883  75 04                 C  	JNZ	FMD20		;IF NOT ZERO PROCEED TO MULTIPLY 
 1885  E9 08A8 R             C  	JMP	$DZERO		;ZERO THE FAC 
 1888  C3                    C  FMD10:	RET 
 1889                        C  FMD20: 
 1889  8B 1E FFFF E          C  	MOV	BX,WORD PTR $ARG-1	;FETCH SIGN AND EXP. TO BX 
 188D  E8 1200 R             C  	CALL	$AEXPS		;ADD THE EXPONENTS 
 1890  FF 36 0000 E          C  	PUSH	WORD PTR $FAC	;EXPONENT,SIGN 
 1894  89 1E FFFF E          C  	MOV	WORD PTR $ARG-1,BX	;REPLACE UNPACKED MANTISSA 
                             C  				;PUT THE SIGN OF THE PRODUCT IN 
                             C  				;FAC+1 
 1898  E8 0B3F R             C  	CALL	$SETDB		;MOVE THE FAC TO $DBUFF SO PRODUCT 
                             C  				;CAN BE FORMED IN THE FAC, AND ZERO 
                             C  				;THE FAC AND RETURNS WITH (AX)=0 
 189B  8B F0                 C  	MOV	SI,AX		;J 
 189D  A3 0000 E             C  	MOV	WORD PTR $FAC,AX 
 18A0  BB 0000 E             C  	MOV	BX,OFFSET $DBUFF	; 
 18A3  A3 0000 E             C  	MOV	WORD PTR $ARG,AX 
 18A6  BD 0000 E             C  	MOV	BP,OFFSET $ARGLO	;POINT TO MULTIPLICAND BASE 
 18A9  8B 00                 C  M1:	MOV	AX,WORD PTR 0[BX+SI]	;FETCH MULTIPLIER V(J) 
 18AB  0B C0                 C  	OR	AX,AX		;SEE IF ZERO 
 18AD  74 2C                 C  	JZ	M4D		;IF ZERO W(J)=0 
 18AF  BF 0000               C  	MOV	DI,0		;I 
 18B2  8B CF                 C  	MOV	CX,DI		;K 
 18B4  8B 00                 C  M4:	MOV	AX,WORD PTR 0[BX+SI]	;FETCH MULTIPLIER V(J) 
 18B6  F7 23                 C  	MUL	WORD PTR 0[BP+DI]	;FORM PRODUCT V(J)*U(J) IN (DXAX) 
 18B8  53                    C  	PUSH	BX		;SAVE PTR. TO MULTIPLIER BASE 
 18B9  8B DE                 C  	MOV	BX,SI		; 
 18BB  03 DF                 C  	ADD	BX,DI		;I+J 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-88
$FMULD  DOUBLE PRECISION MULTIPLICATION                     

 18BD  81 C3 FFF8 E          C  	ADD	BX,OFFSET $DFACL-10	;W(I+J) ADDRESS IN BX 
 18C1  03 07                 C  	ADD	AX,WORD PTR 0[BX]	;(DXAX)=U(I)*V(J)+W(I+J) 
 18C3  73 01                 C  	JNB	M4A 
 18C5  42                    C  	INC	DX 
 18C6  03 C1                 C  M4A:	ADD	AX,CX		;T=U(I)*V(J)+W(I+J)+K 
 18C8  73 01                 C  	JNB	M4B 
 18CA  42                    C  	INC	DX 
 18CB  89 07                 C  M4B:	MOV	WORD PTR 0[BX],AX	;W(I+J)= T MOD 2^16 
 18CD  8B CA                 C  	MOV	CX,DX		;K=INT(T/2^16) 
 18CF  5B                    C  	POP	BX		;RECALL PTR TO MULTIPLIER BASE 
 18D0  83 FF 06              C  	CMP	DI,6		;FINISHED INNER LOOP? 
 18D3  74 04                 C  	JZ	M4C		;IF SO JUMP AND SET W(J) 
 18D5  47                    C  	INC	DI 
 18D6  47                    C  	INC	DI 
 18D7  EB DB                 C  	JMP	SHORT M4 
 18D9  8B C1                 C  M4C:	MOV	AX,CX		;(AX)=K 
 18DB  53                    C  M4D:	PUSH	BX		;SAVE PTR TO MULTIPLIER BASE 
 18DC  BB 0000 E             C  	MOV	BX,OFFSET $DFACL 
 18DF  89 00                 C  	MOV	WORD PTR 0[BX+SI],AX	;W(J)=K OR 0 (0 IF V(J) WERE 0) 
 18E1  5B                    C  	POP	BX		;RECALL PTR TO MULTIPLIER BASE 
 18E2  83 FE 06              C  	CMP	SI,6		;FINISHED OUTER LOOP? 
 18E5  74 04                 C  	JZ	M5 
 18E7  46                    C  	INC	SI 
 18E8  46                    C  	INC	SI 
 18E9  EB BE                 C  	JMP	SHORT M1 
 18EB                        C  M5:				;MULTIPLICATION COMPLETE AND IN FAC 
 18EB  BE FFFE E             C  	MOV	SI,OFFSET $DFACL-2	;WILL NOW SET ST 
 18EE  FD                    C  	STD			;WANT NON-ZERO BYTE ASAP SO PROB. 
                             C  				;SEEMS HIGHER OF GETTING ONE IF 
                             C  				;(SI) IS DECREMENTED 
 18EF  B9 0007               C  	MOV	CX,7		;7-BYTE CHECK 
 18F2  AC                    C  M5AA:	LODSB			;FETCH NEXT BYTE 
 18F3  0A C0                 C  	OR	AL,AL 
 18F5  E1 FB                 C  	LOOPZ	M5AA 
 18F7  74 05                 C  	JZ	M5AB		;DON'T NEED TO SET ST 
 18F9  80 0E FFFF E 20       C  	OR	BYTE PTR $DFACL-1,LOW 40	;"OR" IN ST BIT 
 18FE                        C  M5AB: 
 18FE  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1	;SEE IF WE NEED TO INC EXPONENT 
 1901  0A C0                 C  	OR	AL,AL 
 1903  8F 06 0000 E          C  	POP	WORD PTR $FAC	;RESTORE EXPONENT,SIGN 
 1907  78 0F                 C  	JS	M6 
 1909  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1	;MUST SHIFT 1 BIT LEFT 
 190C  B9 0004               C  	MOV	CX,4 
 190F  D1 17                 C  M5A:	RCL	WORD PTR 0[BX],1 
 1911  43                    C  	INC	BX 
 1912  43                    C  	INC	BX 
 1913  E2 FA                 C  	LOOP	M5A 
 1915  E9 1F90 R             C  M5B:	JMP	$ROUND		;NOW ROUND 
 1918  FE 06 0000 E          C  M6:	INC	BYTE PTR $FAC	;INCREMENT EXPONENT 
 191C  75 F7                 C  	JNZ	M5B 
 191E  E9 0776 R             C  	JMP	$OVFLS		;OVERFLOW! 
                             C   
                             C  	SUBTTL	 $FMULS  SINGLE PRECISION 8086 MULTIPLICATION 
                             C  ;********************************************************** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-89
$FMULS  SINGLE PRECISION 8086 MULTIPLICATION                

                             C  ;       $FMULS  FMULS MULTIPLIES THE SINGLE PRECISION 
                             C  ;               FLOATING POINT QUANTITIES (BXDX) AND (FAC) 
                             C  ;               AND RETURNS THE PRODUCT IN THE (FAC). ONLY 
                             C  ;               SEGMENT REGISTERS ARE PRESERVED. 
                             C  ;*********************************************************** 
                             C   
 1921                        C  $FMULS:			;(FAC)=(BXDX)*(FAC) 
 1921  E8 08BF R             C  	CALL	$SIGNS		;ZF=1 WILL BE SET IF (FAC)=0 
 1924  74 04                 C  	JZ	FMS00		;JUST RETURN IF (FAC)=0 
 1926  0A FF                 C  	OR	BH,BH		;IF EXPONENT OF (BXDX) IS ZERO 
 1928  75 03                 C  	JNZ	FMS05		;PROCEED IF NON-ZERO 
 192A  E9 08B5 R             C  FMS00:	JMP	$ZERO		;THE NUMBER IS ZERO. 
 192D                        C  FMS05: 
 192D  E8 1200 R             C  	CALL	$AEXPS		;ADD THE S.P. EXPONENTS 
                             C  ;*************************************************************** 
                             C  ;WILL NOW PROCEED TO MULTIPLY THE MANTISSAS. THE MULTIPLICATION 
                             C  ;WILL UTILIZE THE 16 BIT MUL INSTRUCTION AND THUS WILL TAKE 
                             C  ;PLACE AS PARTIAL PRODUCTS SINCE WE HAVE 24 BIT MANTISSAS TO 
                             C  ;MULTIPLY. 
                             C  ;*************************************************************** 
 1930  8B 0E FFFF E          C  	MOV	CX,WORD PTR $FAC-1	;(CH)=($FAC):(CL)=($FAC-1) 
 1934  32 ED                 C  	XOR	CH,CH		;(CX) CONTAINS HIGH MANTISSA BITS 
 1936  A1 FFFD E             C  	MOV	AX,WORD PTR $FAC-3	;(AX) CONTAINS LOW MANTISSA BITS OF FAC 
 1939  8A FD                 C  	MOV	BH,CH		;SET (BH)=0 AS WELL 
                             C  ;************************************************************* 
                             C  ;AT THIS POINT WE HAVE THE FAC MANTISSA IN (CLAX) AND THE 
                             C  ;(BXDX) MANTISSA IN (BLDX). THE UNDERSTOOD LEADING MANTISSA 
                             C  ;BIT WAS INSTALLED BY $AEXPS AND THE SIGN OF THE PRODUCT 
                             C  ;WAS STORED IN FAC+1 
                             C  ;THE PRODUCT WILL BE FORMED IN (BXCX) BY PARTIAL PRODUCTS. 
                             C  ;FIRST THE NECESSARY ELEMENTS WILL BE PUSHED ON THE STACK 
                             C  ;THEN UTILIZED IN REVERSE ORDER(THAT'S THE BEST WAY TO 
                             C  ;GET THE THEM OFF THE LIFO STACK -TURKEY!) 
                             C  ;************************************************************ 
 193B  8B F3                 C  	MOV	SI,BX 
 193D  8B F9                 C  	MOV	DI,CX 
 193F  8B EA                 C  	MOV	BP,DX 
 1941  51                    C  	PUSH	CX		;HIGH FAC MANTISSA BITS 
 1942  50                    C  	PUSH	AX		;LOW FAC MANTISSA BITS 
 1943  F7 E2                 C  	MUL	DX		;32 BIT PRODUCT FORMED(ONLY NEED 
 1945  8B CA                 C  	MOV	CX,DX		;MOST 16 SIGNIFICANT BITS) 
 1947  58                    C  	POP	AX		;LOW FAC MANTISSA BITS 
 1948  F7 E3                 C  	MUL	BX		;TIMES HIGH MANTISSA BITS OF (BLDX) 
 194A  03 C8                 C  	ADD	CX,AX		;ADD TO PREVIOUS CALCULATION 
 194C  73 01                 C  	JNB	FMS10		;IF CARRY NOT PRODUCED PROCEED 
 194E  42                    C  	INC	DX 
 194F  8B DA                 C  FMS10:	MOV	BX,DX		;PROBABLY ONLY 8 BITS HERE 
 1951  5A                    C  	POP	DX		;HIGH FAC MANTISSA BITS 
 1952  8B C5                 C  	MOV	AX,BP		;LOW 16 MANTISSA BITS OF (BLDX) 
 1954  F7 E2                 C  	MUL	DX		; 
 1956  03 C8                 C  	ADD	CX,AX		;ADD IN LOW ORDER BITS 
 1958  73 01                 C  	JNB	FMS20		;JUMP IF CARRY NOT PRODUCED 
 195A  42                    C  	INC	DX		; 
 195B  03 DA                 C  FMS20:	ADD	BX,DX		;CAN'T PRODUCE CARRY HERE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-90
$FMULS  SINGLE PRECISION 8086 MULTIPLICATION                

 195D  8B D7                 C  	MOV	DX,DI		;HIGH FAC MANTISSA BITS 
 195F  8B C6                 C  	MOV	AX,SI		;HIGH FAC MANTISSA BITS 
 1961  F6 E2                 C  	MUL	DL		;(AX) HAS ENTIRE PRODUCT 
 1963  03 D8                 C  	ADD	BX,AX		;ADD IT IN 
 1965  73 0D                 C  	JNB	FMS30		;IF NO CARRY PROCEED 
 1967  D1 DB                 C  	RCR	BX,1		;MOVE EVERYTHING RIGHT 
 1969  D1 D9                 C  	RCR	CX,1		; 
 196B  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;MUST NOW CHECK FOR OVERFLOW 
 196F  75 03                 C  	JNZ	FMS30		;PROCEED IF NON-ZERO 
 1971  E9 0776 R             C  	JMP	$OVFLS 
 1974                        C  FMS30:				;PRODUCT FORMED, MUST NOW GET MANTISSA IN (BLDXAH) FOR ROUNS 
                             C  				;PRODUCT IS CURRENTLY IN (BXCX) 
 1974  0A FF                 C  	OR	BH,BH		;MUST BE SURE PRODUCT LEFT JUSTIFIED 
 1976  79 09                 C  	JNS	FMS35		;IN (BXCX) 
 1978  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;NEED TO INCREMENT EXP. 
 197C  75 07                 C  	JNZ	FMS37		;IF NOT OVERFLOW PROCEED 
 197E  E9 0776 R             C  	JMP	$OVFLS		;OVERFLOW JUMP 
 1981                        C  FMS35: 
 1981  D1 D1                 C  	RCL	CX,1 
 1983  D1 D3                 C  	RCL	BX,1 
 1985                        C  FMS37: 
 1985  8A D5                 C  	MOV	DL,CH 
 1987  8A F3                 C  	MOV	DH,BL 
 1989  8A DF                 C  	MOV	BL,BH 
 198B  8A E1                 C  	MOV	AH,CL		;OVERFLOW BYTE 
 198D  E9 1FCA R             C  	JMP	$ROUNS		;GO ROUND 
 1990  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FOTAN  ROUTINE TO PUT IN DECIMAL POINT AND LEADING ZEROS 
                             C  ;***************************************************************** 
                             C  ; 
                             C  ;       $FOTAN  THIS ROUTINE IS CALLED BY THE FREE FORMAT OUTPUT 
                             C  ;               CODE TO OUTPUT DECIMAL POINT AND LEADING ZEROS. 
                             C  ;       $FOTED  THIS ROUTINE IS CALLED BY BOTH THE FREE FORMAT 
                             C  ;               OUTPUT ROUTINE AND THE PRINT USING CODE TO OUTPUT 
                             C  ;               THE DECIMAL POINT WHEN NECESSARY AND TO PUT IN 
                             C  ;               COMMAS "," AFTER EACH THREE DIGITS IF THIS OPTION 
                             C  ;               IS INVOKED. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTAN 
                             C  ;                               CALL    $FOTED 
                             C  ;               WITH $FMTCX CONTAINING NUMBER PLACES PRIOR TO 
                             C  ;               DECIMAL POINT(NEGATIVELY) IN UPPER BYTE AND 
                             C  ;               NO PLACES BEFORE NEXT COMMA IN LOW BYTE 
                             C  ; 
                             C  ;******************************************************************* 
                             C   
 1991                        C  $FOTAN: 
 1991  FE CD                 C  	DEC	CH		;IF NEGATIVE THEN LEADING ZEROS 
 1993  79 16                 C  	JNS	FTD05		; 
 1995  89 1E 0000 E          C  	MOV	WORD PTR $DPADR,BX	;SAVE DECIMAL POINT COUNT 
 1999  C6 07 2E              C  	MOV	BYTE PTR 0[BX],LOW "."  ;MOVE IN DECIMAL POINT 
 199C  43                    C  FTN10:	INC	BX		;POINT TO NEXT OUTPUT POSITION 
 199D  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN LEADING ZERO 
 19A0  FE C5                 C  	INC	CH		;WILL INCREMENT CH UNTIL ZERO 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-91
$FOTAN  ROUTINE TO PUT IN DECIMAL POINT AND LEADING ZEROS   

 19A2  75 F8                 C  	JNZ	FTN10		;PUT IN LEADING ZEROS UNTIL CH ZERO 
 19A4  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 19A5  33 C9                 C  	XOR	CX,CX		;ZERO OUT DECIMAL POINT AND COMMA CTS. 
 19A7  EB 1A                 C  	JMP	SHORT FTD20	;GET STACK RIGHT AND RETURN 
 19A9                        C  $FOTED: 
 19A9  FE CD                 C  	DEC	CH		;SEE IF TIME FOR D.P. 
 19AB  75 0C                 C  FTD05:	JNZ	FTD10		;IF NOT D.P. TIME SEE IF COMMA TIME 
 19AD  C6 07 2E              C  	MOV	BYTE PTR 0[BX],LOW "."  ;PUT IN D.P. 
 19B0  89 1E 0000 E          C  	MOV	WORD PTR $DPADR,BX	;SAVE ADDR OF DECIMAL POINT 
 19B4  43                    C  	INC	BX		;INCREMENT PAST D.P. 
 19B5  33 C9                 C  	XOR	CX,CX		;ZERO COUNTS & SET ZF=1 
 19B7  EB 0A                 C  	JMP	SHORT FTD20	;GET STACK RIGHT AND RETURN 
 19B9  FE C9                 C  FTD10:	DEC	CL		;IF ZERO TIME FOR COMMA 
 19BB  75 06                 C  	JNZ	FTD20 
 19BD  C6 07 2C              C  	MOV	BYTE PTR 0[BX],LOW 54O	;COMMA 
 19C0  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 19C1  B1 03                 C  	MOV	CL,LOW 3	; 
 19C3  89 0E 0000 E          C  FTD20:	MOV	WORD PTR $FMTCX,CX	;UPDATE D.P.&COMMA COUNTS 
 19C7  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FOTCV  CONVERT FAC TO ASCII DIGITS 
                             C  ;************************************************************ 
                             C  ; 
                             C  ;       $FOTCV  CONVERSION OF SINGLE OR DOUBLE PRECISION 
                             C  ;               NUMBER TO ASCII DIGITS.IF DOUBLE PRECISION 
                             C  ;               10 DIGITS WILL BE CONVERTED WITH DOUBLE 
                             C  ;               PRECISION POWER OF TEN INTEGERS, 3 DIGITS 
                             C  ;               WITH SINGLE PRECISION POWER OF TEN INTEGERS 
                             C  ;               AND 3 DIGITS WITH INTEGER POWERS OF TEN 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTCV 
                             C  ;               WITH THE NUMBER TO BE CONVERTED HAVING PREVIOUSLY 
                             C  ;               BEEN OPERATED ON BY $FOTNV TO BRACKET THE 
                             C  ;               NUMBER AND HAVE ALL DIGITS IN THE INTEGER PORTION 
                             C  ;               OF THE FAC. AND THE CORRESPONDING EXPONENT WILL 
                             C  ;               BE SAVED ON THE STACK AND CONVERTED LATER. 
                             C  ; 
                             C  ;************************************************************** 
                             C   
 19C8  E8 08EF R             C  $FOTCV: CALL	$GETYP		;SET CONDITION CODES FOR VALTYP 
 19CB  7B 6A                 C  	JPO	FCV40		;IF SINGLE PRECISION GO PROCESS 
 19CD  51                    C  	PUSH	CX		;SAVE DIGIT AND COMMA COUNT 
 19CE  53                    C  	PUSH	BX		;SAVE BUFFR PTR. 
 19CF  BE 0000 E             C  	MOV	SI,OFFSET $DFACL	;WILL MOVE FAC TO ARG 
 19D2  BF 0000 E             C  	MOV	DI,OFFSET $ARGLO 
 19D5  B9 0004               C  	MOV	CX,4 
 19D8  FC                    C  	CLD 
 19D9  F3/ A5                C   REP	MOVSW 
 19DB  E8 1B69 R             C  	CALL	$DINT		;WILL SEE IF FAC ALREADY INTEGER 
 19DE  53                    C  	PUSH	BX		;NEED TO CALL VCOMP WITH BX=ARG-1 
 19DF  BB FFFF E             C  	MOV	BX,OFFSET $ARG-1 
 19E2  E8 0A39 R             C  	CALL	$VCOMP		;DO COMPARE 
 19E5  5B                    C  	POP	BX		;GET BUFFER POINTER BACK 
 19E6  BE 0000 E             C  	MOV	SI,OFFSET $ARGLO	;WILL MOVIE ARG TO FAC 
 19E9  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-92
$FOTCV  CONVERT FAC TO ASCII DIGITS                         

 19EC  B9 0004               C  	MOV	CX,4 
 19EF  FC                    C  	CLD 
 19F0  F3/ A5                C   REP	MOVSW 
 19F2  74 03                 C  	JZ	FCV05		;DON'T ADD .5 IF NO DIFF. 
 19F4  E8 0900 R             C  	CALL	$DADDH		;ADD .5 TO NUMBER 
 19F7  8A 0E 0000 E          C  FCV05:	MOV	CL,BYTE PTR $FAC	;SHIFT COUNT IN (CL) 
 19FB  80 E9 B8              C  	SUB	CL,LOW 270 
 19FE  F6 D9                 C  	NEG	CL		;MAKE SHIFT COUNT POSITIVE 
 1A00  F8                    C  	CLC			;TO TELL DINT NOT TO NORMALIZE 
 1A01  E8 1B74 R             C  	CALL	$FTDNT		;MAKE SURE ITS STILL INTEGER 
 1A04  5B                    C  	POP	BX		;RECALL BUFFER PTR. 
 1A05  59                    C  	POP	CX		;RECALL DIGIT AND COMMA COUNT 
 1A06  BE 04D5 R             C  	MOV	SI,OFFSET $FODTB	;DOUBLE PRECISION OUTPUT INTEGERS 
 1A09  B0 09                 C  	MOV	AL,LOW 9D	;9 DIGITS TO BE CONVERTED WITH D.P. 
 1A0B  E8 19A9 R             C  FCV10:	CALL	$FOTED		;SEE IF DECIMAL POINT NEEDED 
 1A0E  50                    C  	PUSH	AX		;SAVE DIGIT COUNT 
 1A0F  B0 2F                 C  	MOV	AL,LOW OFFSET "0"-1     ;WILL FORM DIGIT IN (AL) 
 1A11  50                    C  	PUSH	AX 
 1A12  58                    C  FCV20:	POP	AX		;RECALL DIGIT 
 1A13  FE C0                 C  	INC	AL		;INCREMENT TO NEXT DIGIT 
 1A15  50                    C  	PUSH	AX		;SAVE DIGIT 
 1A16  E8 1A9E R             C  	CALL	DSUBI		;SUBTRACT POWER OF TEN 
 1A19  73 F7                 C  	JNB	FCV20 
 1A1B  E8 1AB2 R             C  	CALL	DADDI		;ADD POWER 10 BACK IN 
                             C  				;AND ADVANCE SI TO NEXT POWER 10 
 1A1E  58                    C  	POP	AX		;GET DIGIT BACK 
 1A1F  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;PUT IN ASCII DIGIT 
 1A21  43                    C  	INC	BX		;POINT TO NEXT BUFFER POSITION 
 1A22  58                    C  	POP	AX		;GET DIGIT COUNT 
 1A23  FE C8                 C  	DEC	AL		;SEE IF 10 DIGITS FORMED 
 1A25  75 E4                 C  	JNZ	FCV10		;IF NOT CONTINUE THE ALGORITHM 
 1A27  51                    C  	PUSH	CX		;SAVE DECIMAL POINT COUNT 
 1A28  BE 0000 E             C  	MOV	SI,OFFSET $DFACL	;WILL MOVE INTO FAC 
 1A2B  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
 1A2E  B9 0002               C  	MOV	CX,2 
 1A31  FC                    C  	CLD 
 1A32  F3/ A5                C   REP	MOVSW 
 1A34  59                    C  	POP	CX		;RECALL DECIMAL POINT COUNT 
 1A35  EB 29                 C  	JMP	SHORT FCV50	;GO DO THE REST OF THE DIGITS 
 1A37                        C  FCV40: 
                             C  ;************************************************************** 
                             C  ;CODE BELOW WORKS WITH SINGLE PRECISION NUMBERS 
                             C  ;*************************************************************** 
 1A37  53                    C  	PUSH	BX		;SAVE BUFFER PTR 
 1A38  51                    C  	PUSH	CX		;SAVE DIGIT AND COMMA COUNTS 
 1A39  E8 0BBE R             C  	CALL	$PUSHF		;SAVE $FAC ON STACK 
 1A3C  E8 1BD8 R             C  	CALL	$INT		;WILL SEE IF INTEGER CURRENTLY 
 1A3F  5A                    C  	POP	DX		;RECALL FAC 
 1A40  5B                    C  	POP	BX 
 1A41  E8 0A41 R             C  	CALL	$FCOMP		;COMPARE IF EQUAL DON'T ADD .5 
 1A44  74 0B                 C  	JZ	FCV45 
 1A46  89 1E FFFF E          C  	MOV	WORD PTR $FAC-1,BX	;MOVE BACK TO FAC 
 1A4A  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX 
 1A4E  E8 090C R             C  	CALL	$FADDH		;ADD .5 TO NUMBER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-93
$FOTCV  CONVERT FAC TO ASCII DIGITS                         

 1A51  B0 01                 C  FCV45:	MOV	AL,LOW 1	;FLAG TO QINT WE HAVE A POS. NO. 
 1A53  E8 1C3B R             C  	CALL	$QINT		;GET INTEGER INTO (BLDX) 
 1A56  89 1E FFFF E          C  	MOV	WORD PTR $FAC-1,BX 
 1A5A  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX	;MOVE TO FAC 
 1A5E  59                    C  	POP	CX		;RECALL DIGIT AND COMMA COUNTS 
 1A5F  5B                    C  	POP	BX		;RECALL BUFFER PTR 
                             C   
                             C   
 1A60                        C  FCV50: 
 1A60  B0 03                 C  	MOV	AL,LOW 3	;WILL CONVERT 3 DIGITS IN THIS CODE 
 1A62  BA 051B R             C  	MOV	DX,OFFSET $FOSTB	;Print S.P. numbers with 7 digits 
 1A65  E8 19A9 R             C  FCV60:	CALL	$FOTED		;SEE IF NEED A DECIMAL POINT OR COMMA 
 1A68  50                    C  	PUSH	AX		;SAVE DIGIT COUNT 
 1A69  53                    C  	PUSH	BX		;SAVE BUFFER POINTER 
 1A6A  52                    C  	PUSH	DX		;SAVE POWER OF TEN POINTER 
 1A6B  E8 0A0F R             C  	CALL	$MOVRF		;FETCH INTEGER 
 1A6E  5D                    C  	POP	BP		;FETCH POWER TEN POINTER 
 1A6F  B0 2F                 C  	MOV	AL,LOW OFFSET "0"-1     ;WILL BUILD DIGIT IN (AL) 
 1A71  50                    C  	PUSH	AX		;SAVE DIGIT 
 1A72  58                    C  FCV70:	POP	AX		;RECALL DIGIT 
 1A73  FE C0                 C  	INC	AL		;GO TO NEXT DIGIT 
 1A75  50                    C  	PUSH	AX 
 1A76  E8 0B02 R             C  	CALL	$RSUBM		;SUBTRACT NO. POINTED TO BY (BP) 
                             C  				;FROM (BLDX) 
 1A79  73 F7                 C  	JNB	FCV70		;CONTINUE UNTIL CF=1 
                             C  				;POWER TEN TABLE IN CODE SEGMENT 
 1A7B  2E: 03 56 00          C  	ADD	DX,WORD PTR CS:0[BP]	;ADD WORD PORTION 
 1A7F  2E: 12 5E 02          C  	ADC	BL,BYTE PTR CS:2[BP] 
                             C  				;SINCE WE SUBTRACTED ONE TOO MANY 
 1A83  45                    C  	INC	BP		;INCREMENT TO NEXT POWER OF TEN 
 1A84  45                    C  	INC	BP 
 1A85  45                    C  	INC	BP 
 1A86  E8 0A06 R             C  	CALL	$MOVFR		;SAVE (BLDX) IN FAC 
 1A89  58                    C  	POP	AX		;RECALL DIGIT 
 1A8A  87 D5                 C  	XCHG	DX,BP		;SAVE POWER TEN PTR. IN DX 
 1A8C  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 1A8D  88 07                 C  	MOV	BYTE PTR 0[BX],AL	;SEND OUT DIGIT 
 1A8F  43                    C  	INC	BX		;INCREMENT TO NEXT BUFFER POSITION 
 1A90  58                    C  	POP	AX		;RECALL DIGIT COUNT 
 1A91  FE C8                 C  	DEC	AL		;SEE IF FINISHED 
 1A93  75 D0                 C  	JNZ	FCV60		;IF NOT CONTINUE 
 1A95  42                    C  	INC	DX		;NEED TO INCREMENT PAST 1ST 
 1A96  42                    C  	INC	DX		;INTEGER SO THAT FOTCI WILL 
 1A97  8B EA                 C  	MOV	BP,DX		;FOTCI IS EXPECTING POINTER IN BP 
 1A99  B4 04                 C  	MOV	AH,LOW 4	;CONVERT ONLY 4 DIGITS 
 1A9B  E9 0005 R             C  	JMP	$FCI4 
                             C  				;INTEGER ARITHMETIC 
 1A9E                        C  DSUBI:				;SUBTRACT 7 BYTE INTEGER POINTED TO BY (SI) FROM $DFACL 
 1A9E  51                    C  	PUSH	CX		;FIRST SAVE CX,SI,DI 
 1A9F  56                    C  	PUSH	SI 
 1AA0  B9 0007               C  	MOV	CX,7		;7 BYTES 
 1AA3  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 1AA6  F8                    C  	CLC			;CF=0 
 1AA7  FC                    C  	CLD			;SO LODC WILL INCREMENT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-94
$FOTCV  CONVERT FAC TO ASCII DIGITS                         

 1AA8                        C  DSUBI1:			;NEED NO. FROM CODE SEGMENT 
 1AA8  2E: AC                C  	LODS	BYTE PTR ?CSLAB ;FETCH BYTE TO AL 
 1AAA  18 05                 C  	SBB	BYTE PTR 0[DI],AL	;SUBTRACT 
 1AAC  47                    C  	INC	DI 
 1AAD  E2 F9                 C  	LOOP	DSUBI1 
 1AAF  5E                    C  	POP	SI 
 1AB0  59                    C  	POP	CX 
 1AB1  C3                    C  	RET 
 1AB2                        C  DADDI:				;ADD 7 BYTE INTEGER POINTED TO BY (SI) FROM $DFACL 
 1AB2  51                    C  	PUSH	CX		;SAVE CX,SI,DI 
 1AB3  B9 0007               C  	MOV	CX,7 
 1AB6  BF 0000 E             C  	MOV	DI,OFFSET $DFACL 
 1AB9  F8                    C  	CLC 
 1ABA  FC                    C  	CLD			;SO LODC WILL INCREMENT SI 
 1ABB                        C  DADDI1:			;WANT NO. FETCHED FROM CODE SEGMENT 
 1ABB  2E: AC                C  	LODS	BYTE PTR ?CSLAB ;FETCH NEXT BYTE TO ADD 
 1ABD  10 05                 C  	ADC	BYTE PTR 0[DI],AL	;ADD IT IN 
 1ABF  47                    C  	INC	DI 
 1AC0  E2 F9                 C  	LOOP	DADDI1 
 1AC2  59                    C  	POP	CX 
 1AC3  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $FOTNV  BRACKET FAC SO PRINTABLE DIGITS IN INTEGER PART 
                             C  ;**************************************************************** 
                             C  ; 
                             C  ;       $FOTNV  THIS ROUTINE MULTIPLIES THE FAC BY APPROPRIATE 
                             C  ;               VALUES SO THAT THE PRINTABLE DIGITS (7 FOR SINGLE 
                             C  ;               PRECISION, 16 FOR DOUBLE PRECISION) ARE IN THE 
                             C  ;               INTEGER PART OF THE FAC . IT RETURNS THE COMPLEMENT- 
                             C  ;               ING EXPONENT IN (AL). 
                             C  ;       CALLING SEQUENCE:       CALL    $FOTNV 
                             C  ;               WITH THE FAC CONTAINING THE DESIRED VALUE TO PRINT 
                             C  ;               REGISTERS (BX) AND (CX) WILL RETAIN THEIR VALUES 
                             C  ; 
                             C  ;***************************************************************** 
                             C   
 1AC4                        C  $FOTNV: 
 1AC4  53                    C  	PUSH	BX		;WON'T ALTER (BX) OR (CX) 
 1AC5  51                    C  	PUSH	CX 
 1AC6  33 FF                 C  	XOR	DI,DI		;INITIALIZE EXPONENT 
 1AC8  57                    C  	PUSH	DI		;SAVE EXPONENT 
 1AC9  BB 0259 R             C  FNV10:	MOV	BX,OFFSET $FOTB ;ADDRESS OF BRACKET CONTROL TABLE 
 1ACC  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;FETCH THE EXPONENT 
                             C  				;MUST FETCH FROM CODE SEGMENT 
 1ACF  2E: D7                C  	XLAT	BYTE PTR ?CSLAB ;GET MULTIPLIER 
 1AD1  0A C0                 C  	OR	AL,AL		;IF ZERO - DONE 
 1AD3  74 0C                 C  	JZ	FNV20 
 1AD5  5F                    C  	POP	DI		;RECALL EXPONENT 
 1AD6  98                    C  	CBW			;CONVERT AL TO WORD 
 1AD7  2B F8                 C  	SUB	DI,AX		;GET EXPONENT CORRECT 
 1AD9  57                    C  	PUSH	DI		;SAVE EXPONENT 
 1ADA  8B D0                 C  	MOV	DX,AX		;DX:=exponent for MDPTEN. 
 1ADC  E8 0711 R             C  	CALL	MDPTEN		;Multiply or divide by power of ten. 
 1ADF  EB E8                 C  	JMP	SHORT FNV10	;See if need to do it again. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-95
$FOTNV  BRACKET FAC SO PRINTABLE DIGITS IN INTEGER PART     

                             C   
 1AE1  BB 0395 R             C  FNV20:	MOV	BX,OFFSET $DP06+4	;LOWER BOUND 
 1AE4  E8 09B4 R             C  	CALL	$MOVBS		;MOVE OUT TO "DS" AREA 
 1AE7  E8 0A81 R             C  	CALL	$COMPM		;ONE MORE MULT. POSSIBLE 
                             C  				;$COMPM WILL SET CF=1 IF $DP06 
                             C  				;IS LARGER, CF=0 FOR EQ OR GT 
 1AEA  73 06                 C  	JNB	FNV30		;JUMP IF NOT NEEDED 
 1AEC  E8 091F R             C  	CALL	$MUL10		;MULTIPLY BY TEN 
 1AEF  5F                    C  	POP	DI		;RECALL EXPONENT 
 1AF0  4F                    C  	DEC	DI		;ACCOUNT FOR MULTIPLY BY 10. 
 1AF1  57                    C  	PUSH	DI 
 1AF2  E8 08EF R             C  FNV30:	CALL	$GETYP		;SET CONDITION CODES FOR TYPE 
                             C   
                             C   
 1AF5  72 1F                 C  	JB	FNV40		;done if single precision 
                             C   
 1AF7  BB 03A9 R             C  	MOV	BX,OFFSET $DP09 ;MUST MULTIPLY BY 10^9 
 1AFA  E8 09D0 R             C  	CALL	$MOVAC		;MOVE 10^9 TO $ARG 
 1AFD  E8 1877 R             C  	CALL	$FMULD		;PERFORM MULTIPLICATION 
 1B00  58                    C  	POP	AX		;RECALL EXPONENT 
 1B01  2C 09                 C  	SUB	AL,LOW 11	;SUBTRACT 9 
 1B03  50                    C  	PUSH	AX		;Resave the exponent. 
 1B04  BB 1B1C R             C  	MOV	BX,OFFSET HIDBL ;Is the number too big?  (Will it 
 1B07  E8 09BC R             C  	CALL	$MOVBF		;overflow when $FOTCV adds .5 to it?) 
 1B0A  E8 0AD3 R             C  	CALL	$DCMPM 
 1B0D  76 07                 C  	JNA	FNV40		;No. 
 1B0F  E8 0915 R             C  FNV44:	CALL	$DIV10		;Yes, divide by ten and fix up the 
                             C  				;the decimal exponent. 
 1B12  58                    C  	POP	AX		;restore the exponent 
 1B13  FE C0                 C  	INC	AL		;adjust for $DIV10 
 1B15  50                    C  	PUSH	AX 
 1B16  58                    C  FNV40:	POP	AX		;recall exponent 
 1B17  59                    C  FNV50:	POP	CX		;restore registers 
 1B18  5B                    C  	POP	BX 
 1B19  0A C0                 C  	OR	AL,AL		;SET CONDITION CODES ACCORDING TO EXP 
 1B1B  C3                    C  	RET 
                             C   
                             C  ; 
                             C  ; The largest double precision value that .5 can be added to without 
                             C  ; overflow occuring. 
                             C  ; 
                             C   
 1B1C  FD FF 03 BF C9 1B 0E  C  HIDBL:	DB	375,377,3,277,311,33,16,266	;9999999999999999. 
       B6                    C  
                             C   
                             C   
                             C   
                             C  	SUBTTL	 $FOUT	 CONTROL OUTPUT CONVERSION 
                             C  ;*************************************************************** 
                             C  ; 
                             C  ;       $FOUT   THIS ROUTINE PROVIDES TOP-LEVEL CONTROL OF THE 
                             C  ;               FREE FORMAT OUTPUT FUNCTION. 
                             C  ;       CALLING SEQUENCE:       CALL    $FOUT 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-96
$FOUT	 CONTROL OUTPUT CONVERSION                            

                             C  ;**************************************************************** 
                             C   
 1B24  BB 0001 E             C  S:	MOV	BX,OFFSET $FBUFF+1	;FETCH BUFFER POINTER 
 1B27  C6 07 20              C  	MOV	BYTE PTR 0[BX],LOW " "  ;MOVE IN SPACE FOR POSSIBLE SIGN 
 1B2A  53                    C  	PUSH	BX		;SAVE BUFFER POINTER 
 1B2B  E8 08BF R             C  	CALL	$SIGNS		;DETERMINE SIGN OF NUMBER 
 1B2E  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 1B2F  9C                    C  	PUSHF			;SAVE FLAGS FOR LATER 
 1B30  79 0A                 C  	JNS	FO20		;JUMP IF POSITIVE 
 1B32  C6 07 2D              C  	MOV	BYTE PTR 0[BX],LOW "-"  ;PUT IN MINUS SGN 
 1B35  53                    C  	PUSH	BX		;SAVE TEXT POINTER 
 1B36  E8 0B20 R             C  	CALL	$VNEG		;NEGATE NO. SO WE WORK ONLY WITH 
 1B39  5B                    C  	POP	BX		;RECALL TEXT POINTER 
 1B3A  0C 01                 C  	OR	AL,LOW 1	;POS. NOS. AND SET ZF=0 
 1B3C  43                    C  FO20:	INC	BX		;POINT TO NEXT BUFFER POSITION 
 1B3D  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN ZERO IN CASE NO IS ZERO 
 1B40  9D                    C  	POPF			;RECALL FLAGS 
 1B41  C3                    C  	RET 
 1B42                        C  FOUT: 
 1B42                        C  $FOUT:				;FREE-FORMAT ENTRY POINT 
 1B42  E8 1B24 R             C  	CALL	S		;DO SIGN FIX-UP 
 1B45  75 08                 C  	JNZ	$FOUT2		;IF NON-ZERO PROCEED 
 1B47  43                    C  	INC	BX		;POINT TO NEXT OUTPUT BUFFER POS. 
 1B48  C6 07 00              C  	MOV	BYTE PTR 0[BX],LOW 0	;INDICATE END OF NUMBER 
 1B4B  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1	;POINT (BX) TO START POSITION 
 1B4E  C3                    C  	RET 
 1B4F  E8 08EF R             C  $FOUT2: CALL	$GETYP		;GET TYPE NO. 
 1B52  79 12                 C  	JNS	FO50		;GO FORMAT SINGLE OR DOUBLE PREC. 
 1B54  B9 0700               C  	MOV	CX,OFFSET 7*400 ;default 7 digits prior to dp. 
 1B57  33 C0                 C  	XOR	AX,AX		;CLEAR COMMA COUNT 
 1B59  A3 0000 E             C  	MOV	WORD PTR $FMTAX,AX 
 1B5C  89 0E 0000 E          C  	MOV	WORD PTR $FMTCX,CX 
 1B60  E8 0000 R             C  	CALL	$FOTCI		;CONVERT INTEGER TO ASCII 
 1B63  E9 00D4 R             C  	JMP	$FOTZS		;DO LEADING ZERO SUPPRESSION 
 1B66  E9 07EC R             C  FO50:	JMP	$FOFMT		;SINGLE OR DOUBLE PREC. OUTPUT 
                             C   
                             C  	SUBTTL	 $INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION 
                             C  ;*********************************************************** 
                             C  ; 
                             C  ;       $INT    SINGLE PRECISION INT ROUTINE 
                             C  ;       $DINT   DOUBLE PRECISION INT ROUTINE 
                             C  ;       $QINT   CONVERT TO INT AND LEAVE IN (BLDX) 
                             C  ;       $FTDNT  FOUT ENTRY TO CONVERT TO INT AND LEAVE RT.ADJUSTED 
                             C  ;       $SHRD   SHIFT DOUBLE PRECISION MANTISSA RIGHT 
                             C  ; 
                             C  ;********************************************************** 
                             C  ;********************************************************** 
                             C  ;THE INT TECHNIQUE IS PRETTY STRAIGHT FORWARD EXCEPT 
                             C  ;FOR NEGATIVE NON-INTEGERS. THE RUB WITH THESE NOS. IS THAT 
                             C  ;IF THEY HAVE ANY FRACTIONAL BITS THE ANSWER IS TO 
                             C  ;BE THE NEXT LOWER VALUE INTEGER. FOR EXAMPLE : INT(-1.1) SHOULD 
                             C  ;RETURN -2 WHEREAS INT(1.1) SHOULD RETURN 1. THE TRICK USED TO 
                             C  ;EFFECT THIS IS TO SUBTRACT 1 FROM NEGATIVE NON-INTEGER MANTISSAS 
                             C  ;PRIOR TO SHIFTING OUT FRACTIONAL BITS THEN ADD 1 BACK TO THE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-97
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

                             C  ;MANTISSA ONCE FRACTIONAL BITS HAVE BEEN SHIFTED OUT. WITH THE 
                             C  ;FOLLOWING EXAMPLE (IN BINARY) WATCH HOW THIS TECHNIQUE WORKS: 
                             C  ;FIND INT(10011.011) 
                             C  ;       (1)     SINCE THIS IS A POSITIVE NO WE JUST SHIFT OUT 
                             C  ;               THE FRACTIONAL BITS AND NORMALIZE 
                             C  ;FIND INT(-10011.011) 
                             C  ;       (1)     SUBTRACT ONE FROM THE MANTISSA YIELDING -10011.010 
                             C  ;       (2)     SHIFT OUT THE FRACTIONAL BITS YIELDING -10011. 
                             C  ;       (3)     ADD 1 TO MANTISSA YIELDING -10100 THE CORRECT VALUE 
                             C  ;FIND INT(-10011.000) 
                             C  ;       (1)     SUBTRACT ONE FROM MANTISSA YIELDING -10010.111 
                             C  ;       (2)     SHIFT OUT THE FRACTIONAL BITS YIELDING -10010. 
                             C  ;       (3)     ADD 1 TO MANTISSA YIELDING -10011. THE CORRECT VALUE 
                             C  ;****************************************************************** 
 1B69                        C  $DINT:				;DOUBLE PRECISION INT FUNCTION 
 1B69  8A 0E 0000 E          C  	MOV	CL,BYTE PTR $FAC	;CL:=exponent. 
 1B6D  80 E9 B8              C  	SUB	CL,LOW 270	;Is there a fractional part? 
 1B70  73 3E                 C  	JNB	DNT20		;RETURN IF NO FRACTIONAL BITS 
 1B72  F6 D9                 C  	NEG	CL		;CL NOW POSITIVE 
 1B74  9C                    C  $FTDNT: PUSHF			;FOUT ENTRY POINT. THIS IS SEPARATE 
                             C  				;ENTRY POINT BECAUSE FOUT WISHES 
                             C  				;TO HAVE INTEGER RIGHT ADJUSTED 
                             C  				;IN THE MANTISSA BITS. WE WILL DO 
                             C  				;THE NECESSARY SHIFTS AND RETURN 
                             C  				;PRIOR TO NORMALIZATION IF CALLED 
                             C  				;BY FOUT (SIGNIFIED BY CF=0) 
 1B75  F6 06 0000 E FF       C  	TEST	BYTE PTR $FAC,LOW 377O	;Is the exponent zero? 
 1B7A  75 02                 C  	JNE	DINTNZ		;No, proceed. 
 1B7C  9D                    C  	POPF			;Yes, if the exponent is zero the 
 1B7D  C3                    C  	RET			;number is zero.  Don't operate on 
                             C  				;the possible garbage in the mantissa. 
 1B7E  BB FFFE E             C  DINTNZ: MOV	BX,OFFSET $FAC-2 
 1B81  8A 47 01              C  	MOV	AL,BYTE PTR 1[BX]	;FETCH SIGN BYTE 
 1B84  88 47 03              C  	MOV	BYTE PTR 3[BX],AL	;AND PUT IN $FAC+1  FOR $NORMD 
 1B87  0A C0                 C  	OR	AL,AL		;SEE IF NEGATIVE 
 1B89  9C                    C  	PUSHF 
 1B8A  0C 80                 C  	OR	AL,LOW 200	;RESTORE HIDDEN 1 
 1B8C  88 47 01              C  	MOV	BYTE PTR 1[BX],AL	;AND REPLACE 
 1B8F  C6 47 02 B8           C  	MOV	BYTE PTR 2[BX],LOW 270	;SET EXPONENT FOR POST SHIFT VALUE 
 1B93  9D                    C  	POPF			;RECALL SF 
 1B94  9C                    C  	PUSHF 
 1B95  79 03                 C  	JNS	DNT10		;IF POSITIVE PROCEED 
                             C  ;***************************************************************** 
                             C  ;NEGATIVE NO. MUST DO THE FANCY FOOTWORK DESCRIBED ABOVE 
                             C  ;***************************************************************** 
 1B97  E8 1BBC R             C  	CALL	DINTA		;SUBTRACT 1 FROM MANTISSA BITS 
 1B9A  32 ED                 C  DNT10:	XOR	CH,CH		;(CX)=SHIFT COUNT 
 1B9C  E8 1BB1 R             C  	CALL	$SHRD		;DOUBLE PRECISION SHIFT RIGHT 
 1B9F  9D                    C  	POPF			;RECALL SF 
 1BA0  79 03                 C  	JNS	DNT15		;IF POSITIVE PROCEED 
 1BA2  E8 1BCB R             C  	CALL	ADD1D		;ADD 1 TO MANTISSA BITS 
 1BA5  C6 06 FFFF E 00       C  DNT15:	MOV	BYTE PTR $DFACL-1,LOW 0 ;ZERO THE OVERFLOW BYTE 
 1BAA  9D                    C  	POPF			;SEE IF CALLED BY FOUT (CF=0) 
 1BAB  73 03                 C  	JNB	DNT20		;IF SO JUST RETURN 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-98
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

 1BAD  E9 1C9D R             C  	JMP	$NORMD		;OTHERWISE NORMALIZE 
 1BB0  C3                    C  DNT20:	RET 
                             C   
 1BB1                        C  $SHRD:				;SHIFT RIGHT DOUBLE PRECISION 
                             C   
 1BB1  51                    C  SHRD10: PUSH	CX		;SAVE OUTER LOOP VARIABLE (BITS TO 
                             C  				;BE SHIFTED RIGHT) 
 1BB2  53                    C  	PUSH	BX		;SAVE POINTER TO HIGH BYTE TO SHIFT 
 1BB3  F8                    C  	CLC			;CF=0 
 1BB4  E8 0951 R             C  	CALL	$SHDR		;SHIFT 1 BIT RIGHT 
 1BB7  5B                    C  	POP	BX 
 1BB8  59                    C  	POP	CX		;GET OUTER LOOP VARIABLE 
 1BB9  E2 F6                 C  	LOOP	SHRD10 
 1BBB  C3                    C  	RET 
                             C   
 1BBC  53                    C  DINTA:	PUSH	BX 
 1BBD  BB 0000 E             C  	MOV	BX,OFFSET $DFACL	;BEGINNING ADDRESS FOR SUBTRACT 
 1BC0  83 2F 01              C  DINA10: SUB	WORD PTR 0[BX],1	;NEED CF SO CAN'T USE DEC 
 1BC3  73 04                 C  	JNB	DINA20 
 1BC5  43                    C  	INC	BX 
 1BC6  43                    C  	INC	BX		;CAN DO WORD SUBTRACTS SINCE HIGH BIT 
                             C  				;OF MANTISSA IS SET (THUS PROTECTING 
                             C  				;THE EXPONENT FROM THE SUBTRACT) 
 1BC7  EB F7                 C  	JMP	SHORT DINA10 
 1BC9  5B                    C  DINA20: POP	BX 
 1BCA  C3                    C  	RET 
                             C   
 1BCB                        C  ADD1D:				;ADD 1 TO DOUBLE PRECISION MANTISSA BITS 
 1BCB  53                    C  	PUSH	BX		; 
 1BCC  BB 0000 E             C  	MOV	BX,OFFSET $DFACL 
 1BCF  FE 07                 C  ADD10:	INC	BYTE PTR 0[BX] 
 1BD1  75 03                 C  	JNZ	ADD20 
 1BD3  43                    C  	INC	BX		;POINT TO NEXT BYTE THERE WAS A CARRY 
 1BD4  EB F9                 C  	JMP	SHORT ADD10 
 1BD6  5B                    C  ADD20:	POP	BX 
 1BD7  C3                    C  	RET 
                             C   
 1BD8                        C  INT: 
 1BD8                        C  $INT:				;SINGLE PRECISION INT FUNCTION 
 1BD8  8A 0E 0000 E          C  	MOV	CL,BYTE PTR $FAC	;FETCH EXPONENT 
 1BDC  80 E9 98              C  	SUB	CL,LOW 230	;CALCULATE SHIFT COUNT 
 1BDF  73 4C                 C  	JNB	INT20		;ALREADY INTEGER PROCEED 
 1BE1  F6 D9                 C  	NEG	CL		;GET POSITIVE SHIFT COUNT 
                             C  ; 
                             C  ; Note - At this point the carry is set.  This will be used 
                             C  ; to indicate that this is not a QINT call.  Also note that 
                             C  ; if the exponent is zero the above subtraction did set the 
                             C  ; carry so the check for the zero exponent case below is 
                             C  ; guaranteed to be executed. 
                             C  ; 
 1BE3                        C  QINTX:				; $QINTX'S ENTRY POINT 
 1BE3  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH LOW MANTISSA BITS 
 1BE7  8B 1E FFFF E          C  	MOV	BX,WORD PTR $FAC-1	;FETCH EXP,SIGN,HIGH MANTISSA BITS 
 1BEB  FE C7                 C  	INC	BH		;Is the exponent zero?  (Test for zero 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-99
$INT	 CONVERT PRESENT NO. TO INTEGER BY TRUNCATION          

 1BED  FE CF                 C  	DEC	BH		;without affecting the carry.) 
 1BEF  75 05                 C  	JNE	QINTNZ		;No, proceed. 
 1BF1  32 DB                 C  	XOR	BL,BL		;Yes, put zero into BL,DX for QINT 
 1BF3  33 D2                 C  	XOR	DX,DX		;rather than work with the possible 
 1BF5  C3                    C  	RET			;garbage in the mantissa (an exponent 
                             C  				;of zero means the number is zero). 
 1BF6  9C                    C  QINTNZ: PUSHF			;Save carry which if clear indicates 
                             C  				;this is a QINT call. 
 1BF7  0A DB                 C  	OR	BL,BL		;SEE IF NEGATIVE 
 1BF9  9C                    C  	PUSHF			;SAVE 
 1BFA  88 1E 0001 E          C  	MOV	BYTE PTR $FAC+1,BL	;SAVE SIGN FOR NORMS 
 1BFE  C6 06 0000 E 98       C  	MOV	BYTE PTR $FAC,LOW 230	;SET EXP FOR POST SHIFT 
 1C03  80 CB 80              C  	OR	BL,LOW 200	;RESTORE HIDDEN 1 
 1C06  9D                    C  	POPF 
 1C07  9C                    C  	PUSHF			;SAVE SIGN 
 1C08  79 06                 C  	JNS	INT10		; 
 1C0A  83 EA 01              C  	SUB	DX,1		;CAN'T DO A 'DEC' BECAUSE NEED CF 
 1C0D  80 DB 00              C  	SBB	BL,LOW 0	;DO APPROPRIATE SUBTRACT TO HIGH BYTE 
 1C10  32 ED                 C  INT10:	XOR	CH,CH		;CX HAS LOOP COUNT 
 1C12  0A C9                 C  	OR	CL,CL		;IF SHIFT COUNT ZERO MUST JUMP OVER 
 1C14  74 06                 C  	JZ	INT12		;RIGHT SHIFTS 
 1C16  D0 EB                 C  INT11:	SHR	BL,1		;SHIFT RIGHT INTO CF 
 1C18  D1 DA                 C  	RCR	DX,1		;ROTATE RIGHT 
 1C1A  E2 FA                 C  	LOOP	INT11		;WILL DO (CX) RIGHT SHIFTS 
 1C1C  9D                    C  INT12:	POPF			;RECALL SIGN OF NO. 
 1C1D  9F                    C  	LAHF			;STORE FLAGS TEMPORARILY 
 1C1E  79 05                 C  	JNS	INT15		;PROCEED IF POSITIVE 
 1C20  42                    C  	INC	DX 
 1C21  75 02                 C  	JNZ	INT15 
 1C23  FE C3                 C  	INC	BL 
 1C25                        C  INT15: 
 1C25  9D                    C  	POPF			;CF=0 IF CALLED BY QINT 
 1C26  73 05                 C  	JNB	INT20		;JUST RETURN IF QINT CALL 
 1C28  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE 
 1C2A  E9 1CE8 R             C  	JMP	$NORMS		;NORMALIZE AND RETURN 
 1C2D  9E                    C  INT20:	SAHF			;MUST SEE IF NEGATIVE 
 1C2E  79 0A                 C  NGBLDX: JNS	INT30		;IF NOT PROCEED AS NORMAL 
 1C30  F7 D2                 C  	NOT	DX		;COMPLEMENT DX 
 1C32  F6 D3                 C  	NOT	BL		;AND BL 
 1C34  83 C2 01              C  	ADD	DX,1		;NEED CF SET IF DX OVERFLOWS 
 1C37  80 D3 00              C  	ADC	BL,LOW 0	;2's COMPLEMENT NOW FORMED 
 1C3A  C3                    C  INT30:	RET 
 1C3B                        C  QINT: 
 1C3B                        C  $QINT:				;DO INT(FAC) AND LEAVE IN (BLDX) 
 1C3B  B1 98                 C  	MOV	CL,LOW 230 
 1C3D  2A 0E 0000 E          C  	SUB	CL,BYTE PTR $FAC	;GET SHIFT COUNT TO CL 
 1C41  F8                    C  	CLC			;CF=0 
 1C42  EB 9F                 C  	JMP	SHORT QINTX	;LEAVE RIGHT ADJUSTED 
                             C   
                             C  	SUBTTL	 $LOG	 SINGLE PRECISION NATURAL LOG FUNCTION 
                             C  ;********************************************************** 
                             C  ; 
                             C  ;       $LOG    COMPUTE THE NATURAL LOG OF THE VALUE IN THE FAC 
                             C  ;       CALLING SEQUENCE:       CALL    $LOG 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-100
$LOG	 SINGLE PRECISION NATURAL LOG FUNCTION                 

                             C  ;               WITH INPUT ARGUMENT IN THE FAC 
                             C  ;       MLLN2   IF THIS ENTRY POINT IS USED THE FAC WILL BE 
                             C  ;               MULTIPLIED BY LN(2) 
                             C  ; 
                             C  ;************************************************************ 
                             C   
 1C44                        C  LOG: 
 1C44  E8 08BF R             C  $LOG:	CALL	$SIGNS		;ERROR IF ($FAC).LE..0 
 1C47  7E 51                 C  	JLE	LG100 
                             C  ;**************************************************************** 
                             C  ;       WILL NOW PERFORM SPECIAL TEST FOR ARGUMENT OF 1.0 AND IF 
                             C  ;       FOUND EQUAL ANSWER IS 0 
                             C  ;***************************************************************** 
 1C49  BA 0000               C  	MOV	DX,0		;FETCH 1.0 TO (BXDX) 
 1C4C  BB 8100               C  	MOV	BX,100400 
 1C4F  E8 0A41 R             C  	CALL	$FCOMP 
 1C52  75 09                 C  	JNZ	LOG10		;PROCEED IF NOT 1.0 
 1C54  89 16 0000 E          C  	MOV	WORD PTR $FACLO,DX	;WILL ZERO $FAC AND RETURN 
 1C58  89 16 0000 E          C  	MOV	WORD PTR $FACM1,DX 
 1C5C  C3                    C  	RET 
 1C5D                        C  LOG10: 
 1C5D  A0 0000 E             C  	MOV	AL,BYTE PTR $FAC	;FETCH EXPONENT 
 1C60  2C 80                 C  	SUB	AL,LOW 200	;TAKE OUT BIAS 
 1C62  98                    C  	CBW			;CONVERT BYTE TO WORD 
 1C63  50                    C  	PUSH	AX		;AND SAVE 
 1C64  C6 06 0000 E 80       C  	MOV	BYTE PTR $FAC,LOW 200	;ZERO THE EXPONENT 
 1C69  E8 0BBE R             C  	CALL	$PUSHF		;SAVE ARG FOR Q(X) CALCULATION 
 1C6C  BB 04A5 R             C  	MOV	BX,OFFSET $LOGP ;NOW TO USE HART APPROX FOR P(X) 
 1C6F  E8 1D34 R             C  	CALL	$POLY 
 1C72  5A                    C  	POP	DX		;GET X OFF THE STACK 
 1C73  5B                    C  	POP	BX 
 1C74  E8 0BBE R             C  	CALL	$PUSHF		;SAVE P(X) 
 1C77  E8 0A06 R             C  	CALL	$MOVFR		;MOVE X TO FAC 
 1C7A  BB 04B6 R             C  	MOV	BX,OFFSET $LOGQ 
 1C7D  E8 1D34 R             C  	CALL	$POLY		;CALCULATE Q(X) 
 1C80  5A                    C  	POP	DX		;RECALL P(X) 
 1C81  5B                    C  	POP	BX 
 1C82  E8 15DA R             C  	CALL	$FDIVS		;CALCULATE P(X)/Q(X) 
 1C85  5A                    C  	POP	DX		;FETCH RAW EXPONENT 
 1C86  E8 0BBE R             C  	CALL	$PUSHF		;SAVE FAC ON THE STACK 
 1C89  E8 1852 R             C  	CALL	$FLT		;FLOAT THE VALUE INTO THE $FAC 
 1C8C  5A                    C  	POP	DX		;RECALL LOG2 VALUE 
 1C8D  5B                    C  	POP	BX 
 1C8E  E8 13A3 R             C  	CALL	$FADDS		;ADD 
 1C91  BB 8031               C  MLLN2:	MOV	BX,100061	;FETCH LN(2) TO (BXDX) 
 1C94  BA 7218               C  	MOV	DX,71030 
 1C97  E9 1921 R             C  	JMP	$FMULS		;MULTIPLY TO COMPLETE 
 1C9A  E9 0000 E             C  LG100:	JMP	$FCERR 
                             C   
                             C  	SUBTTL	 $NORMD  DOUBLE PRECISION NORMALIZATION ROUTINE 
                             C  ;****************************************************************** 
                             C  ; 
                             C  ;       $NORMD  NORMALIZES THE NUMBER IN $FAC+1 THRU $DFACL-1 
                             C  ;               AND JUMPS TO $ROUND 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-101
$NORMD  DOUBLE PRECISION NORMALIZATION ROUTINE              

                             C  ;       CALLING SEQUENCE:       CALL    $NORMD 
                             C  ;               OR              JMP     $NORMD 
                             C  ;               WILL RESULT IN NORMALIZATION FOLLOWED BY ROUNDING 
                             C  ;               AND PACKING THE $FAC. 
                             C  ; 
                             C  ;******************************************************************* 
                             C   
 1C9D  B2 39                 C  $NORMD: MOV	DL,LOW 71	;MAX BITS TO SHIFT LEFT 
 1C9F  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1 
 1CA2  BF FFFF E             C  NORD5:	MOV	DI,OFFSET $FAC-1 
 1CA5  BE 0000 E             C  	MOV	SI,OFFSET $FAC 
 1CA8  EB 15                 C  	JMP	SHORT NORD30 
 1CAA                        C  NORD10: 
 1CAA  B9 0004               C  	MOV	CX,4 
 1CAD  F8                    C  	CLC			;CF=0 
 1CAE  D1 17                 C  NORD20: RCL	WORD PTR 0[BX],1 
 1CB0  43                    C  	INC	BX 
 1CB1  43                    C  	INC	BX		;POINT TO NEXT WORD 
 1CB2  E2 FA                 C  	LOOP	NORD20 
 1CB4  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1	;POINT BACK TO END OF NUMBER 
 1CB7                        C  NORD25: 
 1CB7  FE 0C                 C  	DEC	BYTE PTR 0[SI]	;DECREMENT EXPONENT 
 1CB9  74 25                 C  	JZ	NORD40		;DO CLEAN-UP IF UNDERFLOW 
 1CBB  FE CA                 C  	DEC	DL		;SEE IF MAX BITS SHIFTED 
 1CBD  74 21                 C  	JZ	NORD40		;IF SO TERMINATE SHIFTS 
 1CBF  F6 05 FF              C  NORD30: TEST	BYTE PTR 0[DI],LOW 377	;SF=1 IF NOW NORMALIZED 
 1CC2  78 1C                 C  	JS	NORD40		;NORMALIZED 
                             C   
 1CC4  75 E4                 C  	JNZ	NORD10		;MUST SHIFT BIT AT A TIME 
                             C  ;*************************************************************** 
                             C  ;CAN DO AT 1 BYTE MOVE LEFT 
                             C  ;*************************************************************** 
 1CC6  80 2C 08              C  	SUB	BYTE PTR 0[SI],LOW 10	;SUBTRACT 8 
 1CC9  76 15                 C  	JBE	NORD40		;UNDERFLOW 
 1CCB  80 EA 08              C  	SUB	DL,LOW 10	;SEE IF MAX BITS SHIFTED 
 1CCE  76 10                 C  	JBE	NORD40		;AND IF SO QUIT 
 1CD0  BE FFFE E             C  	MOV	SI,OFFSET $FAC-2 
 1CD3  B9 0007               C  	MOV	CX,7		;7 BYTES TO MOVE 
 1CD6  FD                    C  	STD			;SO FOLLOWING MOVB WILL DECREMENT 
                             C  		     ;REPEAT CX TIMES (THE MOVB) 
 1CD7  F3/ A4                C   REP	MOVSB			;MOVE 
 1CD9  C6 06 FFFF E 00       C  	MOV	BYTE PTR $DFACL-1,LOW 0 ;ZERO OVERFLOW 
 1CDE  EB C2                 C  	JMP	SHORT NORD5	;SEE IF MORE CASES 
 1CE0  76 03                 C  NORD40: JBE	NORD50		;UNDERFLOW JUMP 
 1CE2  E9 1F90 R             C  	JMP	$ROUND 
 1CE5                        C  NORD50: 
 1CE5  E9 08A8 R             C  	JMP	$DZERO 
                             C   
                             C  	SUBTTL	 $NORMS  SINGLE PRECISION NORMALIZATION ROUTINE 
                             C  ;************************************************************ 
                             C  ; 
                             C  ;       $NORMS  SINGLE PRECISION NORMALIZATION ROUTINE 
                             C  ;               $NORMS SHIFTS (BLDXAH) LEFT UNTIL THE SIGN 
                             C  ;               BIT OF (BL)IS 1. FOR EACH LEFT SHIFT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-102
$NORMS  SINGLE PRECISION NORMALIZATION ROUTINE              

                             C  ;               $NORMS WILL DECREMENT THE FAC 
                             C  ;               ONCE THIS PROCESS IS COMPLETE, $NORMS WILL 
                             C  ;               JUMP TO $ROUNS TO ROUND THE NUMBER AND 
                             C  ;               PACK IT INTO THE FAC BYTES. 
                             C  ; 
                             C  ;************************************************************* 
                             C   
 1CE8                        C  $NORMS: 
 1CE8  8A 3E 0000 E          C  	MOV	BH,BYTE PTR $FAC	;EXPONENT TO BH 
 1CEC  B9 0004               C  	MOV	CX,4 
 1CEF  0A DB                 C  NOR10:	OR	BL,BL		;SEE IF SIGN BIT SET 
 1CF1  78 21                 C  	JS	NOR20		;IF SO NORMALIZATION COMPLETE 
 1CF3  75 11                 C  	JNZ	NOR15		;UPPER BYTE NON-ZERO 
 1CF5  80 EF 08              C  	SUB	BH,LOW 10	;CAN WE SUBTRACT 8 W/O UNDERFLOW? 
 1CF8  76 17                 C  	JBE	NOR17 
 1CFA  8A DE                 C  	MOV	BL,DH 
 1CFC  8A F2                 C  	MOV	DH,DL 
 1CFE  8A D4                 C  	MOV	DL,AH 
 1D00  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE 
 1D02  E2 EB                 C  	LOOP	NOR10 
 1D04  74 0B                 C  	JZ	NOR17		;UNDERFLOW! 
 1D06                        C  NOR15: 
 1D06  F8                    C  	CLC			;CLEAR CARRY FLAG [CF] 
 1D07  D0 D4                 C  	RCL	AH,1		;SHIFT OVERFLOW BYTE LEFT. 
 1D09  D1 D2                 C  	RCL	DX,1		;SHIFT LOWER MANTISSA WORD LEFT 
 1D0B  D0 D3                 C  	RCL	BL,1		;SHIFT HIGH MANTISSA BYTE LEFT 
 1D0D  FE CF                 C  NOR16:	DEC	BH		;DECREMENT EXPONENT 
 1D0F  75 DE                 C  	JNZ	NOR10		;CONTINUE UNLESS UNDERFLOW 
 1D11  E9 08B5 R             C  NOR17:	JMP	$ZERO		;ZERO THE FAC AND RETURN 
 1D14  88 3E 0000 E          C  NOR20:	MOV	BYTE PTR $FAC,BH	;UPDATE EXPONENT 
 1D18  E9 1FCA R             C  	JMP	$ROUNS 
                             C   
                             C  	SUBTTL $POLY	 SINGLE PRECISION POLYNOMIAL EVALUATOR 
                             C  ;********************************************************* 
                             C  ; 
                             C  ;       $POLY   EVALUATES THE POLYNOMIAL: 
                             C  ;                       P(X)=C0+C1X+C2X2+...+CNXN 
                             C  ;               THE EVALUATION IS ACCOMPLISHED VIA HORNER'S 
                             C  ;               RULE (SEE "THE ART OF COMPUTER PROGRAMMING" 
                             C  ;               VOL.2 PP423, BY KNUTH) 
                             C  ;       $POLYX  PERFORMS THE EVALUATION X(P(X**2)) ON THE 
                             C  ;               POLYNOMIAL MENTIONED ABOVE 
                             C  ;       CALLING SEQUENCE:       CALL $POLY 
                             C  ;               OR              CALL    $POLYX 
                             C  ;               WITH X STORED IN THE $FAC AND (BX) 
                             C  ;               POINTING TO THE FOLLOWING: 
                             C  ;                                       N+1 
                             C  ;                                       CN 
                             C  ;                                       CN-1 
                             C  ;                                       . 
                             C  ;                                       . 
                             C  ;                                       . 
                             C  ;                                       C0 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-103
$POLY	 SINGLE PRECISION POLYNOMIAL EVALUATOR                

                             C  ;*********************************************************** 
                             C   
 1D1B                        C  $POLYX: 
 1D1B  8B 16 0000 E          C  	MOV	DX,WORD PTR $FACLO	;FETCH LOW BYTES 
 1D1F  8B 2E 0000 E          C  	MOV	BP,WORD PTR $FACM1	;AND HIGH BYTES 
 1D23  52                    C  	PUSH	DX		;SAVE X ON THE STACK 
 1D24  55                    C  	PUSH	BP		; 
 1D25  53                    C  	PUSH	BX		;SAVE COEFFICIENT POINTER 
 1D26  8B DD                 C  	MOV	BX,BP		;(BXDX)=X 
 1D28  E8 1921 R             C  	CALL	$FMULS		;FORM X**2 
 1D2B  5B                    C  	POP	BX		;RECALL COEFFICIENT POINTER 
 1D2C  E8 1D34 R             C  	CALL	$POLY		;FORM P(X**2) 
 1D2F  5B                    C  	POP	BX		;FETCH X TO REGISTERS 
 1D30  5A                    C  	POP	DX 
 1D31  E9 1921 R             C  	JMP	$FMULS 
                             C   
 1D34  FC                    C  $POLY:	CLD			;9-Aug-82/MLC - Good for LODC, MOVW, 
                             C  				;and MOVW down to POL10. 
 1D35  8B F3                 C  	MOV	SI,BX		;SO WE CAN USE STRING MOVES 
                             C  				;MUST FETCH FROM THE CODE SEG 
 1D37  2E: AC                C  	LODS	BYTE PTR ?CSLAB ;FETCH NUMBER OF COEFFICIENTS 
 1D39  98                    C  	CBW			;(AH)=0 
 1D3A  50                    C  	PUSH	AX		;PUSH NUMBER ELEMENTS ON STACK 
 1D3B  FF 36 0000 E          C  	PUSH	WORD PTR $FACM1 ;SAVE THE FAC ON THE STACK 
 1D3F  FF 36 0000 E          C  	PUSH	WORD PTR $FACLO 
 1D43  BF 0000 E             C  	MOV	DI,OFFSET $FACLO 
                             C  				;WANT TO FETCH COEFF FROM 
 1D46  2E: A5                C  	MOVS	WORD PTR ES:[DI],WORD PTR CS:[SI] 
                             C  				;FETCH FROM CODE SEGMENT 
 1D48  2E: A5                C  	MOVS	WORD PTR ES:[DI],WORD PTR CS:[SI] 
 1D4A                        C  POL10: 
 1D4A  5A                    C  	POP	DX		;FETCH LOW X 
 1D4B  5B                    C  	POP	BX		;FETCH HIGH X 
 1D4C  58                    C  	POP	AX		;RECALL COEFFICIENT COUNTER 
 1D4D  48                    C  	DEC	AX		;DECREMENT 
 1D4E  74 16                 C  	JZ	POL30		;JUMP WHEN COMPLETE 
 1D50  50                    C  	PUSH	AX		;SAVE COUNTER 
 1D51  53                    C  	PUSH	BX		;SAVE X ON THE STACK 
 1D52  52                    C  	PUSH	DX 
 1D53  56                    C  	PUSH	SI		;SAVE POINTER TO COEFFICIENTS 
 1D54  E8 1921 R             C  	CALL	$FMULS		;MULTIPLY BY X 
 1D57  5E                    C  	POP	SI		;FETCH COEFFICIENT POINTER 
 1D58  FC                    C  	CLD			;9-Aug-82/MLC - Good for next two 
                             C  				;LODWs. 
                             C  				;MUST FETCH FROM CODE SEGMENT 
 1D59  2E: AD                C  	LODS	WORD PTR ?CSLAB ;FETCH LOW WORD 
 1D5B  92                    C  	XCHG	AX,DX 
                             C  				;MUST FETCH FROM CODE SEGMENT 
 1D5C  2E: AD                C  	LODS	WORD PTR ?CSLAB ;FETCH HIGH WORD 
 1D5E  93                    C  	XCHG	AX,BX 
 1D5F  56                    C  	PUSH	SI		;SAVE COEFFICIENT POINTER 
 1D60  E8 13A3 R             C  	CALL	$FADDS		;ADD IT IN 
 1D63  5E                    C  	POP	SI		;GET POINTER BACK 
 1D64  EB E4                 C  	JMP	SHORT POL10 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-104
$POLY	 SINGLE PRECISION POLYNOMIAL EVALUATOR                

 1D66                        C  POL30:				;CLEAR THE STACK 
 1D66  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $PUF	 PRINT-USING FOR FLOATING POINT NUMBERS 
                             C  ;************************************************************** 
                             C  ; 
                             C  ;       $PUF    THIS ROUTINE ACCEPTS EITHER SINGLE OR DOUBLE 
                             C  ;               PRECISION FLOATING VALUES AND FORMATS THEM 
                             C  ;               ACCORDING TO INPUT FORMATS. BOTH FIXED AND 
                             C  ;               "E" TYPE FORMATS ARE PRODUCED BY THIS CODE 
                             C  ;       CALLING SEQUENCE:       CALL    $PUF 
                             C  ;               WITH FLOATING POINT VALUE IN THE FAC, (BX) POINTING 
                             C  ;               TO THE NEXT PRINT POSITION IN THE OUTPUT BUFFER 
                             C  ;               AND FORMAT SPECIFICATIONS IN AX, AND CX. 
                             C  ;               $FMTAX LOADED INTO (AX) WILL CONTAIN COMMA COUNT 
                             C  ;               IN (AH) AND THE FOLLOWING FORMAT IN (AL): 
                             C  ;               BIT     7       =0 FREE FORMAT OUTPUT, NUMBER DICTATES 
                             C  ;                               OUTPUT FORMAT 
                             C  ;                               =1 PRINT USING OUTPUT. THE REMAINDER OF 
                             C  ;                               (AL) AND (CX) DICTATE HOW THE NUMBER IS 
                             C  ;                               TO BE PRINTED 
                             C  ;                       6       IF =1 GROUP THE DIGITS IN THE INTEGER 
                             C  ;                               PART IN GROUPS OF THREE AND SEPARATE 
                             C  ;                               WITH COMMAS. 
                             C  ;                       5       IF =1 FILL THE LEADING SPACES IN THE 
                             C  ;                               FIELD WITH ASTERISKS "*" 
                             C  ;                       4       IF =1 OUTPUT THE NUMBER WITH A FLOATING 
                             C  ;                               DOLLAR SIGN "$" 
                             C  ;                       3       IF =1 PRINT THE SIGN OF THE NUMBER WITH 
                             C  ;                               A PLUS "+" IF POSITIVE INSTEAD OF A SPC 
                             C  ;                       2       IF =1 PRINT THE SIGN AFTER THE NUMBER 
                             C  ;                       1       UNUSED 
                             C  ;                       0       IF =1 PRINT THE NUMBER IN SCIENTIFIC 
                             C  ;                               NOTATION AND IGNORE BIT 6. 
                             C  ;                               IF =0 USE FIXED POINT NOTATION. 
                             C  ;               $FMTCX WILL HAVE THE FOLLOWING FORMAT LOADED IN (CX) 
                             C  ;               (CH)    NUMBER PLACES IN FIELD TO LEFT OF DECIMAL POINT 
                             C  ;                       (DOES NOT INCLUDE THE DECIMAL POINT) 
                             C  ;               (CL)    NUMBER PLACES IN THE FIELD TO THE RIGHT OF THE 
                             C  ;                       DECIMAL POINT (INCLUDES DECIMAL POINT) 
                             C  ; 
                             C  ;**************************************************************** 
                             C   
 1D67                        C  $PUF: 
 1D67  53                    C  	PUSH	BX		;SAVE OUTPUT BUFFER POINTER 
 1D68  D0 E8                 C  	SHR	AL,1		;CF=1 IF "E" FORMAT DESIRED 
 1D6A  73 03                 C  	JNB	PUF10		;IF FIXED PROCEED 
 1D6C  E9 015E R             C  	JMP	$PUFE		;GO DO IT 
 1D6F                        C  PUF10: 
                             C  ;****************************************************************** 
                             C  ;KNOW THAT A FIXED FORMAT IS DESIRED. THE FOLLOWING ANALYSIS WILL 
                             C  ;BE PERFORMED:  (1) SEE IF NO. IS .GE. 10^16 , AND IF SO 
                             C  ;GO PRINT WITH $FOUT AND INSERT A LEADING "%". (2) BRACKET THE 
                             C  ;PRINTABLE DIGITS IN THE INTEGER PART OF THE NUMBER WITH $FOTNV 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-105
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

                             C  ;(3) SEE IF LEADING ZEROS ARE REQUIRED(THE POSITIONS SPECIFIED 
                             C  ;TO THE LEFT OF THE DECIMAL POINT ARE MORE THAN THE AVAILABLE 
                             C  ;DIGITS TO LEFT OF DECIMAL POINT). (4) SEE IF THE SUM OF THE DIGITS 
                             C  ;ON THE LEFT PLUS THOSE ON THE RIGHT ARE LESS THAN THE AVAILABLE 
                             C  ;DIGITS,I.E. WE HAVE MORE PRINTABLE DIGITS THAN REQUIRED. IF THIS 
                             C  ;IS THE CASE WE MUST SHIFT THE NUMBER RIGHT SO THAT WE CAN ROUND IT 
                             C  ;AT THE CORRECT POSITION. (5) PUT IN THE PRINTABLE DIGITS. (6) SEE 
                             C  ;IF TRAILING ZEROS ARE REQUIRED(SPECIFIED DIGITS TO THE RIGHT 
                             C  ;WERE IN EXCESS OF DIGITS AVAILABLE) 
                             C  ;******************************************************************** 
 1D6F  BB 03E1 R             C  	MOV	BX,OFFSET $DP16 ;WILL FIRST SEE IF NO. TOO LARGE 
 1D72  E8 09BC R             C  	CALL	$MOVBF		;NO. MOVED TO DBUFF FOR COMPARISON 
                             C  				;(IT WAS PREVIOUSLY IN CODE SEGMENT) 
 1D75  E8 0A39 R             C  	CALL	$VCOMP		;(FAC)-10^16(CF=1 IF OK) 
 1D78  72 09                 C  	JB	PUF30		;JUMP IF SMALL ENOUGH TO PROCESS 
                             C  ;****************************************************************** 
                             C  ;NO. WAS TOO LARGE TO PRINT WITH FIXED FORMAT. MUST PRINT IN FREE- 
                             C  ;FORMAT WITH $FOUT AND INSERT A LEADING "%" TO INDICATE IT OVERFLOWED 
                             C  ;THE SPECIFIED PRINT FIELD 
                             C  ;******************************************************************* 
 1D7A  5B                    C  	POP	BX		;RECALL PRINT BUFFER POINTER 
 1D7B  E8 1B42 R             C  	CALL	$FOUT		;PRINT IN FREE-FORMAT 
 1D7E  4B                    C  	DEC	BX		;POINT TO POSITION 1 
 1D7F  C6 07 25              C  	MOV	BYTE PTR 0[BX],LOW "%"  ;PUT IN OVERFLOW INDICATOR 
 1D82  C3                    C  	RET			;DONE 
 1D83                        C  PUF30: 
                             C  ;******************************************************************** 
                             C  ;ALL WE KNOW AT THIS POINT IS THAT IT IS POSSIBLE TO PRINT THE 
                             C  ;NUMBER WITH A FIXED FORMAT, DO NOT KNOW THE SPECIFIED FIXED FORMAT 
                             C  ;IS SUFFICIENT. WHAT WE WILL DO IS FORMAT THE NUMBER IN FIXED FORMAT 
                             C  ;AND THEN JUMP TO $PUFXE AND LET HIM DETERMINE IF THE NUMBER WAS 
                             C  ;WITHIN THE SPECIFIED FORMAT. 
                             C  ;******************************************************************** 
 1D83  E8 08EF R             C  	CALL	$GETYP		;DETERMINE TYPE 
 1D86  B5 10                 C  	MOV	CH,LOW 20	;ASSUME DOUBLE PREC. (16 PRINTABLE POS) 
 1D88  73 02                 C  	JNB	PUF40 
                             C   
                             C   
 1D8A  B5 07                 C  	MOV	CH,LOW 7	;7 print positions if single precision 
                             C   
 1D8C  E8 08BF R             C  PUF40:	CALL	$SIGNS		;SEE IF NO. IS ZERO 
 1D8F  74 03                 C  	JZ	PUF50		;IF SO DON'T CALL $FOTNV 
 1D91  E8 1AC4 R             C  	CALL	$FOTNV		;BRACKET NO. SO ALL PRINTABLE DIGITS 
                             C  				;IN THE INTEGER PART OF THE NUMBER AND 
                             C  				;RETURN COMPLEMENTING EXPONENT IN (AL) 
                             C  				;AND SF=1 IF THIS EXPONENT IS NEG. 
                             C  				;(THERE ARE DIGITS TO RIGHT OF D.P) 
 1D94  5B                    C  PUF50:	POP	BX		;GET OUTPUT BUFFER POINTER BACK 
 1D95  78 3F                 C  	JS	PUF80		;GO PRINT NO. WITH DIGITS TO RIGHT 
                             C  				;OF DECIMAL POINT 
                             C  ;********************************************************************* 
                             C  ;KNOW AT THIS POINT WE HAVE A NUMBER LESS THAN 10^16 THAT HAS NO 
                             C  ;PRINTABLE DIGITS TO RIGHT OF THE DECIMAL POINT. THEREFORE WE HAVE 
                             C  ;TO PUT IN LEADING ZEROS IF THE SPECIFIED PRINT POSITIONS TO THE LEFT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-106
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

                             C  ;OF THE DECIMAL POINT ARE MORE THAN THE PRINTABLE POSITIONS (CH) 
                             C  ;AND THE POSITIVE EXPONENT IN (AL) 
                             C  ;******************************************************************** 
 1D97  8A D0                 C  	MOV	DL,AL		;SAVE THIS POSITIVE EXP. FOR LATER 
 1D99  02 C5                 C  	ADD	AL,CH		;THIS IS NECESSARY PRINT POSITIONS 
                             C  				;TO ACCOMODATE THIS NUMBER. 
 1D9B  2A 06 0001 E          C  	SUB	AL,BYTE PTR $FMTCX+1	;SUBTRACT DIGITS TO LEFT 
 1D9F  79 05                 C  	JNS	PUF60		;NO LEADING ZEROS REQUIRED 
 1DA1  F6 D8                 C  	NEG	AL		;MUST MAKE (AL) POSITIVE FOR $FOTZ 
 1DA3  E8 0145 R             C  	CALL	$FOTZ		;PUT IN (AL) LEADING ZEROS 
 1DA6  32 C9                 C  PUF60:	XOR	CL,CL		;ZERO CREATED ZEROS 
 1DA8  E8 1E65 R             C  	CALL	DPCOM		;SET-UP DECIMAL POINT AND COMMA CT. 
 1DAB  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE DECIMAL POINT INFO. 
 1DAF  52                    C  	PUSH	DX		;SAVE EXPONENT 
 1DB0  E8 19C8 R             C  	CALL	$FOTCV		;CONVERT THE BINARY NO. TO ASCII DIGITS 
                             C  				;NOTE THAT $FOTCV WILL ONLY CONVERT 
                             C  				;THE PRINTABLE DIGITS. IF THERE WAS A 
                             C  				;NON-ZERO EXPONENT AS WELL WE MUST 
                             C  				;INSERT SOME ZEROS PRIOR TO THE DECIMAL 
                             C  				;POINT. FURTHER WE MUST PAY ATTENTION 
                             C  				;TO OUR COMMA COUNT WHILE INSERTING 
                             C  				;THESE ZEROS. 
 1DB3  5A                    C  	POP	DX		;RECALL EXPONENT 
 1DB4  8F 06 0000 E          C  	POP	WORD PTR $FMTCX ;RECALL DECIMAL POINT INFO. 
 1DB8  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE DESIRED POSITIONS LEFT/RT. 
 1DBC  32 C0                 C  	XOR	AL,AL		;WANT DL IN AL WITH APPROPRIATE SIGNS 
 1DBE  0A C2                 C  	OR	AL,DL		;DL=EXPONENT 
 1DC0  74 06                 C  	JZ	PUF70		;IF NO ZEROS PRIOR TO D.P. JUMP 
 1DC2  E8 0155 R             C  	CALL	$FOTZC		;PUT IN ZEROS AND PAY ATTENTION TO 
                             C  				;COMMA COUNT. 
 1DC5  E8 19A9 R             C  	CALL	$FOTED		;PUT IN DECIMAL POINT 
 1DC8  8F 06 0000 E          C  PUF70:	POP	WORD PTR $FMTCX ;RECALL DESIRED POSITIONS LEFT/RT. 
 1DCC  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;AND SAVE AGAIN 
 1DD0  A0 0000 E             C  	MOV	AL,BYTE PTR $FMTCX	;FETCH NO. POSITIONS TO RT. OF D.P. 
 1DD3  E9 1EF1 R             C  	JMP	$PUIZ		;GO PUT IN ANY REQUIRED TRAILING ZEROS 
                             C  				;AND CHECK TO ASSURE FIELD SPECS. MET 
 1DD6                        C  PUF80: 
                             C  ;******************************************************************** 
                             C  ;AT THIS POINT WE KNOW WE HAVE PRINTABLE DIGITS TO THE RIGHT OF THE 
                             C  ;DECIMAL POINT . WE KNOW THIS BECAUSE $FOTNV WAS CALLED TO BRACKET 
                             C  ;THE NO. SUCH THAT THE PRINTABLE DIGITS WERE IN THE INTEGER PART 
                             C  ;OF THE NUMBER AND THE COMPLEMENTING EXPONENT WAS IN (AL). FURTHER 
                             C  ;SF=1 WAS SET TO INDICATE (AL) WAS NEGATIVE. 
                             C  ;WE FURTHER NEED TO DETERMINE IF WE NEED TO ROUND SOMEWHERE 
                             C  ;WITHIN THE PRINTABLE DIGITS. THIS WILL BE THE CASE IF THE 
                             C  ;DIGITS TO BE PRINTED TO THE RIGHT IS LESS THAN THOSE AVAILABLE 
                             C  ;TO THE RIGHT. (AL) HAS THOSE AVAILABLE TO THE RIGHT, $FMTCX HAS 
                             C  ;THOSE DESIRED. 
                             C  ;*************************************************************** 
 1DD6  8A D0                 C  	MOV	DL,AL		;SAVE THE COMPLEMENTING EXPONENT 
 1DD8  A0 0000 E             C  	MOV	AL,BYTE PTR $FMTCX	;FETCH DIGITS DESIRED TO RIGHT 
 1DDB  0A C0                 C  	OR	AL,AL		;IF NON-ZERO MUST SUBTRACT 1 
                             C  				;BECAUSE DECIMAL POINT INCLUDED 
 1DDD  74 02                 C  	JZ	PUF90		;PROCEED IF NO DIG. TO RT. DESIRED 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-107
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

 1DDF  FE C8                 C  	DEC	AL		;TAKE OUT FOR DECIMAL POINT COUNT 
 1DE1  8A F0                 C  PUF90:	MOV	DH,AL		;SAVE DESIRED DIGITS TO RIGHT COUNT 
 1DE3  02 C2                 C  	ADD	AL,DL		;SUBTRACT DIGITS AVAILABLE TO RT. 
                             C  				;(THIS IS A SUBTRACT BECAUSE (DL) IS 
                             C  				;THE NEGATIVE TO DIGITS TO RT.) 
 1DE5  8A C8                 C  	MOV	CL,AL		;WILL NEED THIS FOR LATER. IT 
                             C  				;IS THE NEGATIVE OF THE NUMBER 
                             C  				;OF DIGITS WE ARE ABOUT TO SHIFT 
                             C  				;OFF TO THE RIGHT 
 1DE7  78 06                 C  	JS	PUF100		;JUMP IF INTERNAL ROUNDING NECESSARY 
 1DE9  32 C0                 C  	XOR	AL,AL		;WILL NEED ALL PRINTABLE DIGITS 
 1DEB  8A C8                 C  	MOV	CL,AL		;NO DIGITS SHIFTED OFF 
 1DED  EB 11                 C  	JMP	SHORT PUF110	;DO NOT NEED TO DIVIDE IF POSITIVE 
 1DEF  50                    C  PUF100: PUSH	AX 
 1DF0  51                    C  	PUSH	CX		;SAVE GENERATED LEADING ZEROS 
 1DF1  52                    C  	PUSH	DX		; 
 1DF2  53                    C  	PUSH	BX 
 1DF3  E8 0915 R             C  	CALL	$DIV10		;NEED TO ELIMINATE EXCESS PRINTABLE 
 1DF6  5B                    C  	POP	BX 
 1DF7  5A                    C  	POP	DX 
 1DF8  59                    C  	POP	CX		;RECALL GENERATED LEADING ZEROS 
 1DF9  58                    C  	POP	AX		;RECALL EXCESS DIGITS 
 1DFA  FE C0                 C  	INC	AL		;BECAUSE AL WAS ORIGINALLY NEGATIVE 
 1DFC  78 F1                 C  	JS	PUF100		;CONTINUE FOR INTERNAL ROUNDING 
 1DFE  8A E1                 C  	MOV	AH,CL		;WILL NEED CREATED LEADING ZEROS 
                             C  				;LATER 
 1E00                        C  PUF110: 
 1E00  8A C2                 C  	MOV	AL,DL		;GET NEGATIVE EXPONENT 
 1E02  2A C1                 C  	SUB	AL,CL		;ADD CREATED ZEROS 
 1E04  02 C5                 C  	ADD	AL,CH		;IF SF=1 THEN NO DIGITS TO LEFT 
 1E06  79 20                 C  	JNS	PUF120		;JUMP IF DIGITS TO LEFT OF DECIMAL PT 
                             C  ;****************************************************************** 
                             C  ;WE KNOW HERE THAT THE ENTIRE PRINTABLE DIGITS GO TO THE RIGHT OF 
                             C  ;THE DECIMAL POINT. IF DIGITS WERE REQUESTED TO THE LEFT THEN WE 
                             C  ;NEED TO INSERT LEADING ZEROS 
                             C  ;******************************************************************** 
 1E08  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;DESIRED LEADING DIGITS 
 1E0B  E8 0145 R             C  	CALL	$FOTZ		;INSERT (AL) LEADING ZEROS 
 1E0E  C6 07 2E              C  	MOV	BYTE PTR 0[BX],LOW "."  ;PUT IN DECIMAL POINT 
 1E11  89 1E 0000 E          C  	MOV	WORD PTR $DPADR,BX	;*** Save DP position for $FOTED, etc. *** 
 1E15  43                    C  	INC	BX		;NEXT BUFFER POSITION 
 1E16  32 C9                 C  	XOR	CL,CL		;COMMA COUNT TO ZERO 
                             C  ;********************************************************** 
                             C  ;OK WE'VE PUT IN THE REQUIRED LEADING ZEROS PRIOR 
                             C  ;TO THE DECIMAL POINT. WE MAY FURTHER NEED TO PUT IN A FEW 
                             C  ;AFTER THE DECIMAL POINT. WE KNOW THAT THE EXPONENT IS 
                             C  ;GREATER IN ABSOLUTE VALUE THAN THE NO. OF PRINTABLE DIGITS. 
                             C  ;THE NUMBER OF LEADING ZEROS REQUIRE HERE THEN IS ABS. 
                             C  ;VALUE OF THE EXPONENT LESS PRINTABLE DIGITS 
                             C  ;********************************************************** 
 1E18  8A C6                 C  	MOV	AL,DH		;Get number of digits after decimal point 
 1E1A  2A C5                 C  	SUB	AL,CH		;Subtract number that will be printed by $FOTCV 
 1E1C  E8 0145 R             C  	CALL	$FOTZ		;PUT IN (AL) LEADING ZEROS 
 1E1F  33 C9                 C  	XOR	CX,CX		;*** No longer need comma & decimal info *** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-108
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

 1E21  52                    C  	PUSH	DX		;*** 8-Mar-82/ngt Fix                    *** 
 1E22  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;*** Balance number of PUSHes and POPs   *** 
 1E26  EB 16                 C  	JMP	SHORT PUF140	;GO PUT IN THE DIGITS 
 1E28                        C  PUF120: 
                             C  ;******************************************************************* 
                             C  ;WE KNOW HERE THAT THERE ARE DIGITS TO THE LEFT OF THE DEC.PT. 
                             C  ;WE NEED TO DETERMINE IF LEADING ZEROS ARE REQUIRED. THEY WILL BE 
                             C  ;REQUIRED IF THE SPECIFIED DIGITS TO THE LEFT IS GREATER THAN 
                             C  ;THE NUMBER OF PRINTABLE DIGITS LESS THOSE TO THE RIGHT. RECALL THAT 
                             C  ;EARLIER WE PUT THE NUMBER OF PRINTABLE DIGITS IN (CH). DUE TO THE 
                             C  ;ABOVE CODE WE MAY HAVE INCREASED THE NUMBER OF DIGITS AVAILABLE TO 
                             C  ;THE LEFT BECAUSE WE SHIFTED THE NUMBER RIGHT BRINGING IN LEADING 
                             C  ;ZEROS. FOR EXAMPLE: IF WE GOT HERE WITH THE NUMBER 12.78575 $FOTNV 
                             C  ;WOULD HAVE 1278575. IN THE FAC AND -5 IN (AL), IF FURTHER THE INPUT 
                             C  ;FORMAT HAD BEEN ########.## WE WOULD HAVE SHIFTED THE NUMBER 3 DIGITS 
                             C  ;RIGHT FOR ROUNDING PURPOSES LEAVING 1278.575 IN THE FAC AND -3 IN 
                             C  ;(CL). ONCE WE GO TO $FOTCV , HE SHALL PRODUCE THE DIGITS 
                             C  ;00012.79 SO THE FORMULA FOR LEADING ZEROS IS: 
                             C  ;LEADING ZEROS=DESIRED DIGITS-[(CH)+(DL)-(CL)] 
                             C  ;               =DESIRED DIGITS-(CH)-(DL)+(CL) 
                             C  ;OR AS IN THIS EXAMPLE,LEADING ZEROS=8-[7+(-5)-(-3)]=3 
                             C  ;********************************************************************* 
 1E28  A0 0001 E             C  	MOV	AL,BYTE PTR $FMTCX+1	;FETCH DESIRED DIGITS 
 1E2B  52                    C  	PUSH	DX		;SAVE DIGITS TO RIGHT 
 1E2C  FF 36 0000 E          C  	PUSH	WORD PTR $FMTCX ;SAVE DIGITS TO LEFT/RIGHT 
 1E30  2A C5                 C  	SUB	AL,CH		;SUBTRACT PRINTABLE DIGITS 
 1E32  2A C2                 C  	SUB	AL,DL		;ADD DIGITS TO RIGHT 
 1E34  02 C1                 C  	ADD	AL,CL		;SUBTRACT CREATED LEADING ZEROS 
 1E36  78 03                 C  	JS	PUF130		;IF NO LEADING ZEROS REQUIRED JUMP 
 1E38  E8 0145 R             C  	CALL	$FOTZ		;PUT IN REQUIRED LEADING ZEROS 
 1E3B  E8 1E65 R             C  PUF130: CALL	DPCOM		;SET UP DECIMAL POINT AND COMMA CTS. 
 1E3E  FF 36 0000 E          C  PUF140: PUSH	WORD PTR $FMTCX ;SAVE DECIMAL POINT INFO. 
 1E42  E8 19C8 R             C  	CALL	$FOTCV		;CONVERT FAC TO ASCII DIGITS AND 
                             C  				;INSERT INTO OUTPUT BUFFER. DECIMAL 
                             C  				;POINT AND COMMA COUNTS ARE IN 
                             C  				;(CH)&(CL) RESPECTIVELY 
 1E45  8F 06 0000 E          C  	POP	WORD PTR $FMTCX ;Retrieve the right and left counts. 
                             C  				;($FMTCX:=digits to right of decimal 
                             C  				;point plus one for the decimal point, 
                             C  				;$FMTCX+1:=digits to left of decimal 
                             C  				;point.) 
 1E49  58                    C  	POP	AX		;RECALL DIGITS TO LEFT 
 1E4A  5A                    C  	POP	DX		;RECALL DIGITS TO RIGHT 
 1E4B  F6 06 0000 E FF       C  	TEST	BYTE PTR $FMTCX,LOW 377O	;Is the right side count zero? 
                             C  				;(This count includes the point 
                             C  				;point itself.) 
 1E50  75 07                 C  	JNZ	PUF150		;No, retain the decimal point. 
                             C  				;Go see if trailing zeroes are needed. 
 1E52  8B 1E 0000 E          C  	MOV	BX,WORD PTR $DPADR	;Yes, get rid of the decimal point 
                             C  				;by backing up the pointer so the 
 1E56  E9 006C R             C  	JMP	$PUFXE		;GO DO FIX-UP 
 1E59                        C  PUF150: 
                             C  ;***************************************************************** 
                             C  ;WE NEED TO NOW DETERMINE IF TRAILING ZEROS ARE TO BE PRINTED 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-109
$PUF	 PRINT-USING FOR FLOATING POINT NUMBERS                

                             C  ;THIS WILL BE THE CASE IF NO. DIGITS TO THE RIGHT (DL) IS LESS 
                             C  ;THAN THOSE REQUESTED (AL). 
                             C  ;**************************************************************** 
 1E59  02 C2                 C  	ADD	AL,DL		;SUBTRACT DIGITS TO THE RIGHT 
 1E5B  FE C8                 C  	DEC	AL		;BECAUSE DECIMAL POINT WAS INCLUDED 
 1E5D  78 03                 C  	JS	PUF160		;GO DO FIX-UP 
 1E5F  E8 0145 R             C  	CALL	$FOTZ		;PUT IN TRAILING ZEROS 
 1E62  E9 006C R             C  PUF160: JMP	$PUFXE		;GO DO FIX-UP 
                             C   
                             C   
                             C   
 1E65                        C  DPCOM:				;ROUTINE TO SET UP DECIMAL POINT AND COMMA COUNTS 
 1E65  8A C5                 C  	MOV	AL,CH		;FETCH PRINTABLE DIGITS 
 1E67  02 C2                 C  	ADD	AL,DL		;SUBTRACT DIGITS TO RIGHT 
 1E69  2A C1                 C  	SUB	AL,CL		;ADD CREATED ZEROS 
 1E6B  FE C0                 C  	INC	AL		;FOR SIGN 
 1E6D  8A E8                 C  	MOV	CH,AL 
 1E6F  2C 03                 C  DPC10:	SUB	AL,LOW 3	;SUBTRACT OUT AL MULTIPLES OF 3 
 1E71  7F FC                 C  	JG	DPC10 
 1E73  04 03                 C  	ADD	AL,LOW 3 
 1E75  8A C8                 C  	MOV	CL,AL		;COMMA COUNT NOW SET 
 1E77  A0 0000 E             C  	MOV	AL,BYTE PTR $FMTAX	;FETCH FORMAT FLAGS 
 1E7A  24 40                 C  	AND	AL,LOW 100	;SEE IF COMMAS DESIRED 
 1E7C  75 02                 C  	JNZ	DPC20 
 1E7E  8A C8                 C  	MOV	CL,AL		;ZERO COMMA COUNT 
 1E80  C3                    C  DPC20:	RET 
                             C   
                             C  	SUBTTL	 $PUFOT  PRINT USING OUTPUT ROUTINE 
                             C  ;*************************************************************** 
                             C  ; 
                             C  ;       $PUFOT  THIS ROUTINE PROVIDES TOP-LEVEL CONTROL OF THE 
                             C  ;               PRINT USING OUTPUT FUNCTION. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUFOT 
                             C  ;               WITH NUMBER TO BE OUTPUT IN THE FAC AND FORMAT 
                             C  ;               SPECIFICATIONS IN (AL), AND (CX).(AL) IS SET AS 
                             C  ;               FOLLOWS: 
                             C  ;               BIT     7       =0 FREE FORMAT OUTPUT, NUMBER DICTATES 
                             C  ;                               OUTPUT FORMAT 
                             C  ;                               =1 PRINT USING OUTPUT. THE REMAINDER OF 
                             C  ;                               (AL) AND (CX) DICTATE HOW THE NUMBER IS 
                             C  ;                               TO BE PRINTED 
                             C  ;                       6       IF =1 GROUP THE DIGITS IN THE INTEGER 
                             C  ;                               PART IN GROUPS OF THREE AND SEPARATE 
                             C  ;                               WITH COMMAS. 
                             C  ;                       5       IF =1 FILL THE LEADING SPACES IN THE 
                             C  ;                               FIELD WITH ASTERISKS "*" 
                             C  ;                       4       IF =1 OUTPUT THE NUMBER WITH A FLOATING 
                             C  ;                               DOLLAR SIGN "$" 
                             C  ;                       3       IF =1 PRINT THE SIGN OF THE NUMBER WITH 
                             C  ;                               A PLUS "+" IF POSITIVE INSTEAD OF A SPC 
                             C  ;                       2       IF =1 PRINT THE SIGN AFTER THE NUMBER 
                             C  ;                       1       UNUSED 
                             C  ;                       0       IF =1 PRINT THE NUMBER IN SCIENTIFIC 
                             C  ;                               NOTATION AND IGNORE BIT 6. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-110
$PUFOT  PRINT USING OUTPUT ROUTINE                          

                             C  ;                               IF =0 USE FIXED POINT NOTATION. 
                             C  ;               (CH)    NUMBER PLACES IN FIELD TO LEFT OF DECIMAL POINT 
                             C  ;                       (DOES NOT INCLUDE THE DECIMAL POINT) 
                             C  ;               (CL)    NUMBER PLACES IN THE FIELD TO THE RIGHT OF THE 
                             C  ;                       DECIMAL POINT (INCLUDES DECIMAL POINT) 
                             C  ; 
                             C  ;**************************************************************** 
                             C   
 1E81                        C  PUFOUT: 
 1E81                        C  $PUFOT: 
 1E81  8A E0                 C  	MOV	AH,AL		;FETCH FORMAT SPECS. 
 1E83  F6 C4 40              C  	TEST	AH,LOW 100	;ZF=0 IF COMMAS DESIRED 
 1E86  B4 03                 C  	MOV	AH,LOW 3	;IF COMMAS DESIRED 
 1E88  75 02                 C  	JNZ	PFO05		;JUMP IF COMMAS DESIRED 
 1E8A  32 E4                 C  	XOR	AH,AH		;COMMAS NOT DESIRED 
 1E8C  A3 0000 E             C  PFO05:	MOV	WORD PTR $FMTAX,AX	;SAVE COMMA COUNT AND PFORMAT SPECS 
 1E8F  89 0E 0000 E          C  	MOV	WORD PTR $FMTCX,CX	;SAVE POSITIONS TO RT./LEFT 
                             C  				;OF DECIMAL POINT 
 1E93  8A E0                 C  	MOV	AH,AL		;FOR TESTING 
 1E95  BB 0001 E             C  	MOV	BX,OFFSET $FBUFF+1	;FETCH BUFFER POINTER 
 1E98  C6 07 20              C  	MOV	BYTE PTR 0[BX],LOW " "  ;MOVE IN SPACE FOR POSSIBLE SIGN 
 1E9B  F6 C4 08              C  	TEST	AH,LOW 10	;SEE IF "+" DESIRED 
 1E9E  74 03                 C  	JZ	PFO10		;JUMP IF NOT 
 1EA0  C6 07 2B              C  	MOV	BYTE PTR 0[BX],LOW "+"  ;MOVE IN PLUS 
 1EA3  53                    C  PFO10:	PUSH	BX		;SAVE BUFFER POINTER 
 1EA4  E8 08BF R             C  	CALL	$SIGNS		;DETERMINE SIGN OF NUMBER 
 1EA7  5B                    C  	POP	BX		;RECALL BUFFER POINTER 
 1EA8  79 08                 C  	JNS	PFO20		;JUMP IF POSITIVE 
 1EAA  C6 07 2D              C  	MOV	BYTE PTR 0[BX],LOW "-"  ;PUT IN MINUS SGN 
 1EAD  53                    C  	PUSH	BX		;SAVE BUFFER PTR. 
 1EAE  E8 0B20 R             C  	CALL	$VNEG		;NEGATE NO. SO WE WORK ONLY WITH 
 1EB1  5B                    C  	POP	BX		;RECALL BUFFER PTR. 
 1EB2  43                    C  PFO20:	INC	BX		;POINT TO NEXT BUFFER POSITION 
 1EB3  C6 07 30              C  	MOV	BYTE PTR 0[BX],LOW "0"  ;PUT IN ZERO IN CASE NO IS ZERO 
 1EB6  E8 08EF R             C  	CALL	$GETYP		;SET COND CODES ACCORDING TO TYPE 
 1EB9  A1 0000 E             C  	MOV	AX,WORD PTR $FMTAX	;FETCH FORMAT SPECS 
 1EBC  8B 0E 0000 E          C  	MOV	CX,WORD PTR $FMTCX 
 1EC0  78 03                 C  	JS	PFO40		;IF INTEGER JUMP 
 1EC2  E9 1D67 R             C  	JMP	$PUF		;DO FLOATING POINT FORMATTING 
 1EC5  EB 01 90              C  PFO40:	JMP	$PUI		;PROCESS INTEGER 
                             C   
                             C  	SUBTTL	 $PUI	 PRINT USING FOR INTEGERS 
                             C  ;************************************************************ 
                             C  ; 
                             C  ;       $PUI    PRINT THE INTEGER ACCORDING TO THE FORMATS IN 
                             C  ;               $FMTCX (NO PLACES TO LEFT/RIGHT OF DECIMAL POINT) 
                             C  ;               $FMTAX (AH)=0 OR 3 FOR COMMA INSERTION AND (AL) 
                             C  ;               HAS THE FOLLOWING MEANING: 
                             C  ;               BIT     7       =0 FREE FORMAT OUTPUT, NUMBER DICTATES 
                             C  ;                               OUTPUT FORMAT 
                             C  ;                               =1 PRINT USING OUTPUT. THE REMAINDER OF 
                             C  ;                               (AL) AND (CX) DICTATE HOW THE NUMBER IS 
                             C  ;                               TO BE PRINTED 
                             C  ;                       6       IF =1 GROUP THE DIGITS IN THE INTEGER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-111
$PUI	 PRINT USING FOR INTEGERS                              

                             C  ;                               PART IN GROUPS OF THREE AND SEPARATE 
                             C  ;                               WITH COMMAS. 
                             C  ;                       5       IF =1 FILL THE LEADING SPACES IN THE 
                             C  ;                               FIELD WITH ASTERISKS "*" 
                             C  ;                       4       IF =1 OUTPUT THE NUMBER WITH A FLOATING 
                             C  ;                               DOLLAR SIGN "$" 
                             C  ;                       3       IF =1 PRINT THE SIGN OF THE NUMBER WITH 
                             C  ;                               A PLUS "+" IF POSITIVE INSTEAD OF A SPC 
                             C  ;                       2       IF =1 PRINT THE SIGN AFTER THE NUMBER 
                             C  ;                       1       UNUSED 
                             C  ;                       0       IF =1 PRINT THE NUMBER IN SCIENTIFIC 
                             C  ;                               NOTATION AND IGNORE BIT 6. 
                             C  ;                               IF =0 USE FIXED POINT NOTATION. 
                             C  ;       CALLING SEQUENCE:       CALL    $PUI 
                             C  ;               WITH THE AFOREMENTIONED INFORMATION AVAILABLE 
                             C  ; 
                             C  ;****************************************************************** 
                             C   
 1EC8  A1 0000 E             C  $PUI:	MOV	AX,WORD PTR $FMTAX	;FETCH PRINT DESCRIPTION DATA 
 1ECB  8A CC                 C  	MOV	CL,AH		;$FOTCI WILL NEED COMMA INFO 
                             C  				;IN (CL) 
 1ECD  B5 06                 C  	MOV	CH,LOW 6	;AT MOST 6 PLACES PRIOR TO DECIMAL PT 
 1ECF  D0 E8                 C  	SHR	AL,1		;SETS CF=1 IF "E" TYPE PRINT DESIRED 
 1ED1  8B 16 0000 E          C  	MOV	DX,WORD PTR $FMTCX	;FETCH PLACES TO LEFT/RIGHT OF DEC. PT 
 1ED5  73 0B                 C  	JNB	PI10		;IF NOT "E" FORMAT JUMP 
 1ED7  53                    C  	PUSH	BX		;SAVE BUFFER POINTER 
 1ED8  52                    C  	PUSH	DX		;SAVE PLACES TO LEFT/RIGHT OF DEC. PT 
 1ED9  E8 17E9 R             C  	CALL	$CSI		;CONVERT THE INTEGER TO S.P. 
 1EDC  32 C0                 C  	XOR	AL,AL		;MUST SET ZF=1 FOR $PUFE 
 1EDE  5A                    C  	POP	DX		;FETCH PLACES TO LEFT /RIGHT OF D.P. 
 1EDF  E9 015E R             C  	JMP	$PUFE		;GO FORMAT THE SINGLE PRECISION NO. 
 1EE2  8A C6                 C  PI10:	MOV	AL,DH		;FETCH PLACES TO LEFT OF D.P. 
 1EE4  2C 05                 C  	SUB	AL,LOW 5	;LET'S SEE IF LEADING ZEROS NEEDED 
                             C  ;******************************************************************* 
                             C  ;AT MOST 5 PRINT POSITIONS NEEDED FOR INTEGER (-32768,32767) SO IF 
                             C  ;DESIRED NO. PLACES ON LEFT IS MORE THAN 5 WE NEED TO FILL THESE 
                             C  ;POSITIONS WITH ASCII SPACES. 
                             C  ;****************************************************************** 
 1EE6  78 03                 C  	JS	PI20		;JUMP IF LESS THAN 5 
 1EE8  E8 0145 R             C  	CALL	$FOTZ		;ZERO FILL (AL) POSITIONS 
 1EEB  52                    C  PI20:	PUSH	DX		;SAVE POSITIONS TO LEFT/RIGHT OF D.P. 
 1EEC  E8 0000 R             C  	CALL	$FOTCI		;CONVERT THE INTEGER TO ASCII DIGITS 
                             C  				;AND INSERT DECIMAL POINT AND COMMAS 
                             C  				;AS DESIRED 
 1EEF  58                    C  	POP	AX		;RECALL NO. PLACESTO LEFT/RIGHT OF D.P. 
 1EF0  50                    C  	PUSH	AX		;AND SAVE AGAIN 
 1EF1  0A C0                 C  $PUIZ:	OR	AL,AL		;IF 0 THEN NO DECIMAL POINT DESIRED 
 1EF3  75 01                 C  	JNZ	PI30		;IF DESIRED PROCEED 
 1EF5  4B                    C  	DEC	BX		;THIS WILL ELIMINATE DECIMAL POINT 
 1EF6  FE C8                 C  PI30:	DEC	AL		;MAY NEED TO INSERT ZEROS TO RIGHT 
                             C  				;OF DECIMAL POINT. 
 1EF8  78 06                 C  	JS	PI40		;JUMP IF NOT DESIRED 
 1EFA  E8 0145 R             C  	CALL	$FOTZ		;PUT (AL) ASCII ZEROS IN BUFFER 
 1EFD  C6 07 00              C  	MOV	BYTE PTR 0[BX],LOW 0	;RE-ESTABLISH END-OF-PRINT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-112
$PUI	 PRINT USING FOR INTEGERS                              

 1F00  8F 06 0000 E          C  PI40:	POP	WORD PTR $FMTCX ;MAINTAIN DIGITS LEFT/RT. OF DP. 
 1F04  E9 006C R             C  	JMP	$PUFXE		;BE SURE FORMAT SPECS MET 
                             C   
                             C  	SUBTTL	 $RND	 PSEUDO-RANDOM NUMBER GENERATOR 
                             C  ;****************************************************************** 
                             C  ; 
                             C  ;       $RND    GENERATE THE NEXT RANDOM NUMBER IN THE 
                             C  ;               SEQUENCE. 
                             C  ; 
                             C  ;       CALLING SEQUENCE:       CALL    $RND 
                             C  ;               WITH THE PREVIOUS RANDOM NUMBER IN $RNDX 
                             C  ;               AND DATA ITEMS $RNDA AND $RNDC SET PROPERLY 
                             C  ;       METHOD: LINEAR CONGRUENTIAL FROM VOL. 2 CHAPTER 3 OF 
                             C  ;               KNUTH - THE ART OF COMPUTER PROGRAMMING. 
                             C  ;               M=16,777,216 OR 2^24; [ A MOD 8 ]=5 AND 
                             C  ;               [ C MOD 8 ]=3 
                             C  ;               RND(N+1)=(RND(N)*A+C)MOD M 
                             C  ; 
                             C  ;               THE DATA ITEMS A AND C CORRESPOND TO $RNDA 
                             C  ;               AND $RNDC RESPECTIVELY AND WERE CAREFULLY 
                             C  ;               CHOSEN TO MEET THE RECIPE IN KNUTH. 
                             C  ; 
                             C  ;************************************************************** 
                             C   
 1F07                        C  RND: 
 1F07  E8 08BF R             C  $RND:	CALL	$SIGNS		;FIND WHICH MODE REQUESTED 
 1F0A  74 6E                 C  	JZ	OLDRN		;RETURN PREVIOUS NO.? 
 1F0C  79 0C                 C  	JNS	RND10		;GO DO NEW SEED 
 1F0E  A1 0000 E             C  	MOV	AX,WORD PTR $FACLO	;FETCH NUMBER 
 1F11  A3 0000 E             C  	MOV	WORD PTR $RNDX,AX	;AND INITIALIZE LAST RANDOM # 
 1F14  A0 FFFF E             C  	MOV	AL,BYTE PTR $FAC-1 
 1F17  A2 0002 E             C  	MOV	BYTE PTR $RNDX+2,AL	;SO SEQUENCE STARTS AGAIN 
 1F1A  A1 0000 E             C  RND10:	MOV	AX,WORD PTR $RNDX	;FETCH LOW 16 BITS OF RNDX 
 1F1D  2E: F7 26 059A R      C  	MUL	WORD PTR $RNDA	;MULTIPLY BY LOW BITS OF A 
 1F22  8B F8                 C  	MOV	DI,AX		;SAVE LOW 16 BITS 
 1F24  8A CA                 C  	MOV	CL,DL		;SAVE UPPER 8 BITS 
 1F26  2E: A0 059C R         C  	MOV	AL,BYTE PTR $RNDA+2	;FETCH UPPER 8 BITS OF A 
 1F2A  32 E4                 C  	XOR	AH,AH		;CLEAR UPPER AX 
 1F2C  F7 26 0000 E          C  	MUL	WORD PTR $RNDX	;MULTIPLY BY LOW RNDX 
 1F30  02 C8                 C  	ADD	CL,AL		;ADD TO UPPER 8 BITS 
 1F32  32 E4                 C  	XOR	AH,AH		;CLEAR UPPER AX 
 1F34  A0 0002 E             C  	MOV	AL,BYTE PTR $RNDX+2	;FETCH HIGH 8 BITS OF RNDX 
 1F37  2E: F7 26 059A R      C  	MUL	WORD PTR $RNDA	;MULTIPLY BY LOW 16 OF A 
 1F3C  02 C8                 C  	ADD	CL,AL		;ADD IN TO UPPER 8 
 1F3E  32 E4                 C  	XOR	AH,AH		;CLEAR OVERFLOW BYTE FOR NORM 
 1F40  2E: 8B 16 059D R      C  	MOV	DX,WORD PTR $RNDC	;FETCH LOW 16 OF C 
 1F45  03 D7                 C  	ADD	DX,DI		;ADD IN LOW OF RND(N)*A 
 1F47  2E: 8A 1E 059F R      C  	MOV	BL,BYTE PTR $RNDC+2	;FETCH HIGH OF C 
 1F4C  12 D9                 C  	ADC	BL,CL		;ADD WITH CARRY HIGH RND(N)*A 
 1F4E  88 26 0001 E          C  	MOV	BYTE PTR $FAC+1,AH	;SIGN IS POSITIVE 
 1F52  B0 80                 C  	MOV	AL,LOW 200	;SO NORM WILL PRODUCE NO. 
                             C  				;LESS THAN 1 
 1F54  A2 0000 E             C  	MOV	BYTE PTR $FAC,AL 
 1F57  89 16 0000 E          C  	MOV	WORD PTR $RNDX,DX	;SAVE NEW RND(N+1) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-113
$RND	 PSEUDO-RANDOM NUMBER GENERATOR                        

 1F5B  88 1E 0002 E          C  	MOV	BYTE PTR $RNDX+2,BL 
 1F5F  B0 04                 C  	MOV	AL,LOW 4	;MUST SET VALTP TO SINGLE PREC. 
 1F61  A2 0000 E             C  	MOV	BYTE PTR $VALTP,AL 
 1F64  E9 1CE8 R             C  	JMP	$NORMS 
 1F67                        C  NEWSD:				;DETERMINE NEW RANDOM NO. SEED 
 1F67  BB 0000 E             C  	MOV	BX,OFFSET $FBUFF	;WILL SUM THE FIRST 32 WDS OF 
 1F6A  B9 0020               C  	MOV	CX,40		;RAM 
 1F6D  03 07                 C  NEW10:	ADD	AX,WORD PTR 0[BX] 
 1F6F  43                    C  	INC	BX 
 1F70  43                    C  	INC	BX 
 1F71  E2 FA                 C  	LOOP	NEW10 
 1F73  24 FE                 C  	AND	AL,LOW 376	;BE SURE BIT 0=0 SO AS TO NOT 
                             C  				;MATCH RND0 
 1F75  A3 0000 E             C  	MOV	WORD PTR $RNDX,AX 
 1F78  EB A0                 C  	JMP	SHORT RND10	;GO PROCEED AS USUAL 
 1F7A                        C  OLDRN:				;RETURN THE PREVIOUS RANDOM NO. 
 1F7A  8B 16 0000 E          C  	MOV	DX,WORD PTR $RNDX	;FETCH LOW 16 BITS 
 1F7E  8A 1E 0002 E          C  	MOV	BL,BYTE PTR $RNDX+2	;FETCH HIGH 8 BITS 
 1F82  33 C0                 C  	XOR	AX,AX		;CLEAR OVERFLOW BYTE (AH) 
 1F84  B0 80                 C  	MOV	AL,LOW 200	;EXPONENT OF 0 
 1F86  A2 0000 E             C  	MOV	BYTE PTR $FAC,AL 
 1F89  88 26 0001 E          C  	MOV	BYTE PTR $FAC+1,AH	;POSITIVE SIGN 
 1F8D  E9 1CE8 R             C  	JMP	$NORMS		;GO NORMALIZE 
                             C   
                             C  	SUBTTL	 $ROUND  DOUBLE PRECISION ROUND ROUTINE 
                             C  ;***************************************************************** 
                             C  ; 
                             C  ;       $ROUND  ROUND THE DOUBLE PRECISION FLOATING POINT NUMBER IN 
                             C  ;               $FAC+1 THRU $DFACL-1. 
                             C  ;       CALLING SEQUENCE:       CALL    $ROUND 
                             C  ;               WITH NUMBER IN $FAC TO BE ROUNDED 
                             C  ; 
                             C  ;****************************************************************** 
                             C   
 1F90                        C  $ROUND:			;DOUBLE PRECISION ROUND AND PACK 
 1F90  BB FFFF E             C  	MOV	BX,OFFSET $DFACL-1 
 1F93  81 07 0080            C  	ADD	WORD PTR 0[BX],200	;ADD TO HIGH BIT OV OVERFLOW BYTE 
 1F97  B9 0003               C  	MOV	CX,3		;3 MORE BYTES TO LOOK AT POTENTIALLY 
 1F9A  73 0E                 C  	JNB	RDD20		;IF CF=0 WE ARE DONE 
 1F9C  43                    C  RDD10:	INC	BX 
 1F9D  43                    C  	INC	BX 
 1F9E  FF 07                 C  	INC	WORD PTR 0[BX]	;IF THIS GETS ZF=1 THEN CARRY 
 1FA0  75 08                 C  	JNZ	RDD20		;FINISHED WHEN ZF=0 
 1FA2  E2 F8                 C  	LOOP	RDD10 
 1FA4  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;MUST INCREMENT EXPONENT 
 1FA8  D1 1F                 C  	RCR	WORD PTR 0[BX],1	;SET HIGH BYTE TO 200 
 1FAA                        C  RDD20: 
 1FAA  74 1B                 C  	JZ	RDD30		;OVERFLOW HOOK 
 1FAC  F6 06 FFFF E FF       C  	TEST	BYTE PTR $DFACL-1,LOW 377	;SEE IF OVERFLOW BYTE ZERO 
 1FB1  75 05                 C  	JNZ	$ROUNX 
 1FB3  80 26 0000 E FE       C  	AND	BYTE PTR $DFACL,LOW 376 ;MAKE ANSWER EVEN 
 1FB8                        C  $ROUNX: 
 1FB8  80 26 FFFF E 7F       C  	AND	BYTE PTR $FAC-1,LOW 177 ;CLEAR SIGN BIT 
 1FBD  A0 0001 E             C  	MOV	AL,BYTE PTR $FAC+1	;FETCH SIGN BYTE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-114
$ROUND  DOUBLE PRECISION ROUND ROUTINE                      

 1FC0  24 80                 C  	AND	AL,LOW 200	;CLEAR ALL BUT SIGN 
 1FC2  08 06 FFFF E          C  	OR	BYTE PTR $FAC-1,AL	;AND SET SIGN APPROPRIATELY 
 1FC6  C3                    C  	RET 
 1FC7  E9 0776 R             C  RDD30:	JMP	$OVFLS 
                             C   
                             C  	SUBTTL	 $ROUNS  INTEL 8086 ROUNDING SUBROUTINE 
                             C  ;*********************************************************** 
                             C  ; 
                             C  ;       $ROUNS  SINGLE PRECISION ROUNDING SUBROUTINE 
                             C  ;       CALLING SEQUENCE:       CALL    $ROUNS 
                             C  ;       ASSUMPTIONS:    (BLDXAH)WILL BE ROUNDED BY ADDING 
                             C  ;                       128 TO (AH) . IF CF (CARRY) IS SET 
                             C  ;                       AND (AH) IS NON-ZERO AFTER THIS 
                             C  ;                       ADDITION (BLDX) WILL BE INCREMENTED 
                             C  ;                       ONCE ROUNDING IS COMPLETE, LOGIC WILL 
                             C  ;                       CONTINUE INTO PAKSP FOR PACKING THE MANTISSA 
                             C  ;                       AND SIGN INTO THE FAC. 
                             C  ; 
                             C  ;************************************************************** 
                             C   
 1FCA  80 E4 E0              C  $ROUNS: AND	AH,LOW 340	;CLEAR SUPERFLUOUS BITS 
 1FCD  80 C4 80              C  $ROUNM: ADD	AH,LOW 200	;ADD TO MOST SIG. BIT OF AH 
 1FD0  73 1B                 C  	JNB	PAKSP		;IF NO CARRY RETURN 
 1FD2  9C                    C  	PUSHF			;IF ZF=1 WANT TO ROUND TO EVEN 
 1FD3  42                    C  	INC	DX		;IF ZF=1 MUST INCREMENT BL 
 1FD4  75 11                 C  	JNZ	TSTEVN 
 1FD6  9D                    C  	POPF			;KNOW RESULT WILL BE EVEN 
 1FD7  FE C3                 C  	INC	BL		;IF ZF=1 MUST INCREMENT EXPONENT 
 1FD9  75 12                 C  	JNZ	PAKSP 
 1FDB  F9                    C  	STC			;CF=1 
 1FDC  D0 DB                 C  	RCR	BL,1		;THIS WILL SET HIGH BIT OF BL 
 1FDE  FE 06 0000 E          C  	INC	BYTE PTR $FAC	;IF THIS CAUSES ($FAC)=0 WE HAVE 
                             C  				;OVERFLOW IN ROUNDING 
 1FE2  75 09                 C  	JNZ	PAKSP 
 1FE4  E9 0776 R             C  	JMP	$OVFLS 
 1FE7  9D                    C  TSTEVN: POPF			;IF ZF=1 MUST CLEAR LOW BIT OF DL 
 1FE8  75 03                 C  	JNZ	PAKSP		;GO PACK THE FAC 
 1FEA  80 E2 FE              C  	AND	DL,LOW 376	;CLEAR LOW BIT 
 1FED                        C  PAKSP:				;PAK SINGLE PRECISION FAC. EXPONENT IS IN FAC,SIGN IN FAC+1 
                             C  				;THE MANTISSA IS IN (BLDX) 
 1FED  BE FFFD E             C  	MOV	SI,OFFSET $FAC-3	;LOAD ADDRESS OF $FAC IN SI 
 1FF0  89 14                 C  	MOV	WORD PTR 0[SI],DX	;MOVE LOWER MANTISSA WORD IN 
 1FF2  46                    C  	INC	SI		;INCREMENT TO HIGH MANTISSA BYTE 
 1FF3  46                    C  	INC	SI		; 
 1FF4  8A 3E 0001 E          C  	MOV	BH,BYTE PTR $FAC+1	;FETCH SIGN 
 1FF8  81 E3 807F            C  	AND	BX,100177	;CLEAR ALL BUT SIGN IN BH SIGN IN BL 
 1FFC  0A DF                 C  	OR	BL,BH		;(BL) NOW IN CORRECT FORMAT 
 1FFE  88 1C                 C  	MOV	BYTE PTR 0[SI],BL	;PUT INTO FAC-1 
 2000  C3                    C  	RET 
                             C   
                             C  	SUBTTL	 $SIGD	 CALCULATE SIGNIFICANT DIGITS FOR $FOUT 
                             C  ;************************************************************** 
                             C  ; 
                             C  ;       $SIGD   WHEN $FOUT IS DETERMINING WHETHER TO PRINT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-115
$SIGD	 CALCULATE SIGNIFICANT DIGITS FOR $FOUT               

                             C  ;               A NUMBER IN SCIENTIFIC NOTATION OR FIXED POINT 
                             C  ;               IT NEEDS TO KNOW THE NUMBER OF SIGNIFICANT DIGITS 
                             C  ;               IF THE NUMBER IS LESS THAN .01 . 
                             C  ;               PRIOR TO CALLING $SIGD, $FOUT HAS BRACKETED THE 
                             C  ;               SIGNIFICANT DIGITS VIA $FOUNV. THE NUMBER IN THE 
                             C  ;               FAC WILL BE AXXXXXX OR AXXXXXXXXXXXXXXX WHERE A IS 
                             C  ;               NON-ZERO. $SIGD'S JOB IS TO DETERMINE HOW MANY OF 
                             C  ;               THESE X'S STARTING FROM THE RIGHT ARE ZERO 
                             C  ;               PRIOR TO A NON-ZERO X. FOR EACH ZERO X, $SIGD WILL 
                             C  ;               INCREMENT (CL). 
                             C  ;       CALLING SEQUENCE:       CALL    $SIGD 
                             C  ; 
                             C  ;******************************************************************* 
                             C   
 2001                        C  $SIGD:				;(CL)=(CL)+1 FOR EACH ZERO DIGIT STARTING FROM 
                             C  				;THE RIGHT . ASSUMES $FOUNV HAS PREVIOUSLY OPERATED. 
 2001  8B F1                 C  	MOV	SI,CX		;SAVE CX 
 2003  E8 0BB6 R             C  	CALL	$VPSHF		;PUSH EITHER 4 OR 8 BYTES OF $FAC 
                             C  				;ON THE STACK ACCORDING TO $VALTP 
 2006  8B CE                 C  	MOV	CX,SI		;MUSU MAINTAIN (CL) 
 2008  51                    C  	PUSH	CX 
                             C  ;************************************************************** 
                             C  ;FIRST THING WE'LL DO IS ROUND THE FAC AND MAKE SURE WE 
                             C  ;STILL HAVE AN INTEGER. 
                             C  ;*************************************************************** 
                             C  ;***************************************************************** 
                             C  ;IF WE ALREADY HAVE AN EXACT INTEGER DON'T WANT TO ADD .5 HERE 
                             C  ;***************************************************************** 
 2009  E8 08EF R             C  	CALL	$GETYP 
 200C  72 09                 C  	JB	SI31		;JUMP IF SINGLE PREC 
 200E  80 3E 0000 E B8       C  	CMP	BYTE PTR $FAC,LOW 270	;IF EQUAL OR SF=0 THEN INTEGER ALREADY 
 2013  79 0F                 C  	JNS	SI20		;DON'T ADD .5 
 2015  EB 07                 C  	JMP	SHORT SI32	;PROCESS FAC NORMALLY 
 2017  80 3E 0000 E 98       C  SI31:	CMP	BYTE PTR $FAC,LOW 230	;IF SF=0 THEN INTEGER ALREADY 
 201C  79 06                 C  	JNS	SI20 
 201E  E8 08FB R             C  SI32:	CALL	$VADDH		;ADD .5 TO FAC 
 2021  E8 0BEF R             C  	CALL	$VINT		;MAKE SURE WE STILL HAVE AN INTEGER 
 2024                        C  SI20: 
 2024  BB 0000 E             C  	MOV	BX,OFFSET $ZLO	;FETCH ADDRESS OF Z INTO (BX) 
 2027  E8 0B77 R             C  	CALL	$VMVMF		;MOVE FAC TO Z , Z=INT(FAC+.5) 
 202A  59                    C  	POP	CX		;GET (CL) BACK 
 202B  51                    C  SI30:	PUSH	CX		;SAVE CX FOR LATER 
 202C  BF 0000 E             C  	MOV	DI,OFFSET $Z1LO ;GET ADDRESS OF Z1 
 202F  BB 0000 E             C  	MOV	BX,OFFSET $ZLO	;GET ADDRESS OF Z 
 2032  E8 0B66 R             C  	CALL	$VMOVM		;Z1=Z 
 2035  BB 0000 E             C  	MOV	BX,OFFSET $ZLO	;FETCH ADDRESS OF Z 
 2038  E8 0B94 R             C  	CALL	$VMVFM		;MOVE Z TO FAC 
 203B  E8 0915 R             C  	CALL	$DIV10		;FAC=Z/10 
 203E  E8 0BEF R             C  	CALL	$VINT		;FAC=INT(Z/10) 
 2041  BB 0000 E             C  	MOV	BX,OFFSET $ZLO 
 2044  E8 0B77 R             C  	CALL	$VMVMF		;Z=INT(Z/10) 
 2047  E8 091F R             C  	CALL	$MUL10		;FAC=INT(Z/10)*10 
 204A  BB FFFF E             C  	MOV	BX,OFFSET $Z1-1 ;ADDRESS OF Z1-1 
 204D  E8 08EF R             C  	CALL	$GETYP		;NEED TO DECREMENT BX IF S.P. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Page     1-116
$SIGD	 CALCULATE SIGNIFICANT DIGITS FOR $FOUT               

 2050  73 03                 C  	JNB	SI35 
 2052  83 EB 04              C  	SUB	BX,4		;NOW (BX) POINTS TO S.P. 
 2055                        C  SI35: 
 2055  E8 0BAB R             C  	CALL	$VCMPM		;COMPARE TO FAC 
 2058  59                    C  	POP	CX		;GET SIGNIFICANT DIGIT COUNT BACK 
 2059  75 04                 C  	JNZ	SI40		;THROUGH WHEN NON-ZERO 
 205B  FE C1                 C  	INC	CL		;(CL)=(CL)+1 
 205D  EB CC                 C  	JMP	SHORT SI30	;LET'S GO SEE IF WE CAN FIND ANOTHER 
 205F  8B E9                 C  SI40:	MOV	BP,CX		;SAVE CX 
 2061  E8 0BD5 R             C  	CALL	$VPOPF		;RESTORE ORIGINAL FAC 
 2064  8B CD                 C  	MOV	CX,BP		;RESTORE CX 
                             C   
                             C   
 2066  C3                    C  	RET 
 2067                        C  CSEG	ENDS 
                             C  	END			;END MATH86.MAC 

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-1
                                                             

Macros:

		N a m e			Lines

ACRLF  . . . . . . . . . . . . .  	   2
ADR  . . . . . . . . . . . . . .  	   1
CALLOS . . . . . . . . . . . . .  	   1
CHRGET . . . . . . . . . . . . .  	   1
COMPAR . . . . . . . . . . . . .  	   2
DBGBRK . . . . . . . . . . . . .  	   1
DC . . . . . . . . . . . . . . .  	   6
DJNZ . . . . . . . . . . . . . .  	   2
FSIGN  . . . . . . . . . . . . .  	   1
GETYPE . . . . . . . . . . . . .  	   1
INS86  . . . . . . . . . . . . .  	  13
INST . . . . . . . . . . . . . .  	   1
LDDR . . . . . . . . . . . . . .  	   8
LDIR . . . . . . . . . . . . . .  	   8
MOVRI  . . . . . . . . . . . . .  	   6
OUTCHR . . . . . . . . . . . . .  	   1
POPR . . . . . . . . . . . . . .  	   2
PUSHM  . . . . . . . . . . . . .  	   5
PUSHR  . . . . . . . . . . . . .  	   2
SYNCHK . . . . . . . . . . . . .  	   2

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CSEG . . . . . . . . . . . . . .  	2067	PARA	PUBLIC	'CODESG'
DSEG . . . . . . . . . . . . . .  	0000	PARA	PUBLIC	'DATASG'

Symbols:            

                N a m e         	Type	Value	Attr         

ABSFN  . . . . . . . . . . . . .  	L NEAR	0B0B	CSEG	Global
ADD10  . . . . . . . . . . . . .  	L NEAR	1BCF	CSEG
ADD1D  . . . . . . . . . . . . .  	L NEAR	1BCB	CSEG
ADD20  . . . . . . . . . . . . .  	L NEAR	1BD6	CSEG
ALTAIR . . . . . . . . . . . . .  	Number	0000	
ANSI . . . . . . . . . . . . . .  	Number	0001	
ARYEXT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ARYTA2 . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ATN  . . . . . . . . . . . . . .  	L NEAR	0687	CSEG	Global
ATN10  . . . . . . . . . . . . .  	L NEAR	0697	CSEG
ATN100 . . . . . . . . . . . . .  	L NEAR	06F3	CSEG
ATN20  . . . . . . . . . . . . .  	L NEAR	06A8	CSEG
ATN200 . . . . . . . . . . . . .  	L NEAR	06FC	CSEG
ATN30  . . . . . . . . . . . . .  	L NEAR	06ED	CSEG

BASDEB . . . . . . . . . . . . .  	Number	0000	
BEEPSW . . . . . . . . . . . . .  	Number	0001	
BINCSW . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-2
                                                             

BLODSW . . . . . . . . . . . . .  	Number	0001	
BLTU . . . . . . . . . . . . . .  	L NEAR	1023	CSEG	Global
BLTUC  . . . . . . . . . . . . .  	L NEAR	1026	CSEG	Global
BSERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
BUFLEN . . . . . . . . . . . . .  	Number	00FF	

CASSW  . . . . . . . . . . . . .  	Number	0000	
CDIV16 . . . . . . . . . . . . .  	L NEAR	164B	CSEG
CH10 . . . . . . . . . . . . . .  	L NEAR	0F9F	CSEG
CHKSTR . . . . . . . . . . . . .  	L NEAR	0F97	CSEG	Global
CHRGTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CHSEAT . . . . . . . . . . . . .  	Number	0001	
CINT . . . . . . . . . . . . . .  	L NEAR	180D	CSEG
CK10 . . . . . . . . . . . . . .  	L NEAR	126A	CSEG
CLMWID . . . . . . . . . . . . .  	Number	000E	
CMPUTN . . . . . . . . . . . . .  	Number	0000	
CNOMAT . . . . . . . . . . . . .  	L NEAR	11F8	CSEG
COMMNT . . . . . . . . . . . . .  	Number	0000	
CON10  . . . . . . . . . . . . .  	L NEAR	0B01	CSEG
CONIA  . . . . . . . . . . . . .  	L NEAR	105F	CSEG	Global
CONSIH . . . . . . . . . . . . .  	L NEAR	0E7E	CSEG	Global
CONSSW . . . . . . . . . . . . .  	Number	0001	
CONTO  . . . . . . . . . . . . .  	Number	000F	
CONTRO . . . . . . . . . . . . .  	Number	0001	
COS  . . . . . . . . . . . . . .  	L NEAR	05B3	CSEG	Global
CPM  . . . . . . . . . . . . . .  	Number	0001	
CPM05  . . . . . . . . . . . . .  	L NEAR	0A93	CSEG
CPM06  . . . . . . . . . . . . .  	L NEAR	0A9B	CSEG
CPM10  . . . . . . . . . . . . .  	L NEAR	0AA1	CSEG
CPM110 . . . . . . . . . . . . .  	Number	0000	
CPM2 . . . . . . . . . . . . . .  	Number	0001	
CPM20  . . . . . . . . . . . . .  	L NEAR	0AA6	CSEG
CPM22  . . . . . . . . . . . . .  	L NEAR	0AAA	CSEG
CPM25  . . . . . . . . . . . . .  	L NEAR	0AB5	CSEG
CPM30  . . . . . . . . . . . . .  	L NEAR	0AB6	CSEG
CPM50  . . . . . . . . . . . . .  	L NEAR	0ABF	CSEG
CPM60  . . . . . . . . . . . . .  	L NEAR	0AC7	CSEG
CPM70  . . . . . . . . . . . . .  	L NEAR	0ACC	CSEG
CPM80  . . . . . . . . . . . . .  	L NEAR	0ACD	CSEG
CPM86  . . . . . . . . . . . . .  	Number	0000	
CPMA75 . . . . . . . . . . . . .  	Number	0000	
CPMADD . . . . . . . . . . . . .  	Number	0000	
CPMCON . . . . . . . . . . . . .  	Number	0000	
CPMLIF . . . . . . . . . . . . .  	Number	0000	
CPMMDS . . . . . . . . . . . . .  	Number	0000	
CPMPER . . . . . . . . . . . . .  	Number	0000	
CPMRSH . . . . . . . . . . . . .  	Number	0000	
CPMSBC . . . . . . . . . . . . .  	Number	0000	
CPMSER . . . . . . . . . . . . .  	Number	0000	
CRFIN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CRONLY . . . . . . . . . . . . .  	Number	0000	
CURNCY . . . . . . . . . . . . .  	Number	0024	
CXRET  . . . . . . . . . . . . .  	L NEAR	1833	CSEG

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-3
                                                             

DADD . . . . . . . . . . . . . .  	L NEAR	12E7	CSEG	Global
DADDI  . . . . . . . . . . . . .  	L NEAR	1AB2	CSEG
DADDI1 . . . . . . . . . . . . .  	L NEAR	1ABB	CSEG
DATPSC . . . . . . . . . . . . .  	Number	0080	
DBLCHR . . . . . . . . . . . . .  	Number	0000	
DBLDIV . . . . . . . . . . . . .  	L NEAR	0773	CSEG
DBLTRN . . . . . . . . . . . . .  	Number	0000	
DC10 . . . . . . . . . . . . . .  	L NEAR	0AE5	CSEG
DCOMP  . . . . . . . . . . . . .  	L NEAR	10C2	CSEG	Global
DCXBRT . . . . . . . . . . . . .  	L NEAR	1037	CSEG	Global
DDIV . . . . . . . . . . . . . .  	L NEAR	1479	CSEG	Global
DDIV0  . . . . . . . . . . . . .  	L NEAR	14F9	CSEG
DDIV16 . . . . . . . . . . . . .  	L NEAR	14FF	CSEG
DDIVFA . . . . . . . . . . . . .  	L NEAR	1479	CSEG
DDOVFL . . . . . . . . . . . . .  	L NEAR	15B9	CSEG
DDRND  . . . . . . . . . . . . .  	L NEAR	159B	CSEG
DDSV . . . . . . . . . . . . . .  	L NEAR	15BC	CSEG
DEBUG  . . . . . . . . . . . . .  	Text  		
DINA10 . . . . . . . . . . . . .  	L NEAR	1BC0	CSEG
DINA20 . . . . . . . . . . . . .  	L NEAR	1BC9	CSEG
DINCEX . . . . . . . . . . . . .  	L NEAR	1597	CSEG
DINTA  . . . . . . . . . . . . .  	L NEAR	1BBC	CSEG
DINTNZ . . . . . . . . . . . . .  	L NEAR	1B7E	CSEG
DISK . . . . . . . . . . . . . .  	Number	0001	
DIV0 . . . . . . . . . . . . . .  	L NEAR	1648	CSEG
DIV0S  . . . . . . . . . . . . .  	L NEAR	078D	CSEG
DIV16  . . . . . . . . . . . . .  	L NEAR	164F	CSEG
DMC  . . . . . . . . . . . . . .  	Number	0000	
DMULT  . . . . . . . . . . . . .  	L NEAR	1877	CSEG	Global
DMXQUO . . . . . . . . . . . . .  	L NEAR	1565	CSEG
DNRMCHK  . . . . . . . . . . . .  	L NEAR	1583	CSEG
DNSTK1 . . . . . . . . . . . . .  	L NEAR	14F3	CSEG
DNT10  . . . . . . . . . . . . .  	L NEAR	1B9A	CSEG
DNT15  . . . . . . . . . . . . .  	L NEAR	1BA5	CSEG
DNT20  . . . . . . . . . . . . .  	L NEAR	1BB0	CSEG
DODIV  . . . . . . . . . . . . .  	L NEAR	1511	CSEG
DOINF  . . . . . . . . . . . . .  	L NEAR	07B5	CSEG
DONE . . . . . . . . . . . . . .  	L NEAR	0D29	CSEG
DOS  . . . . . . . . . . . . . .  	Number	0000	
DOVCKJ . . . . . . . . . . . . .  	L NEAR	1474	CSEG
DPC10  . . . . . . . . . . . . .  	L NEAR	1E6F	CSEG
DPC20  . . . . . . . . . . . . .  	L NEAR	1E80	CSEG
DPCOM  . . . . . . . . . . . . .  	L NEAR	1E65	CSEG
DRESTR . . . . . . . . . . . . .  	L NEAR	1551	CSEG
DRVPOS . . . . . . . . . . . . .  	Number	0000	
DSUB . . . . . . . . . . . . . .  	L NEAR	0E62	CSEG	Global
DSUBI  . . . . . . . . . . . . .  	L NEAR	1A9E	CSEG
DSUBI1 . . . . . . . . . . . . .  	L NEAR	1AA8	CSEG
DUPONT . . . . . . . . . . . . .  	Number	0000	
DV010  . . . . . . . . . . . . .  	L NEAR	0796	CSEG
DV015  . . . . . . . . . . . . .  	L NEAR	07A7	CSEG
DV020  . . . . . . . . . . . . .  	L NEAR	07B4	CSEG
DV0ERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DYNCOM . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-4
                                                             


EDIT80 . . . . . . . . . . . . .  	Number	0000	
ESCCTL . . . . . . . . . . . . .  	Number	0000	
EVENEX . . . . . . . . . . . . .  	L NEAR	0CDB	CSEG
EXA  . . . . . . . . . . . . . .  	L NEAR	173B	CSEG
EXB  . . . . . . . . . . . . . .  	L NEAR	1743	CSEG
EXIDY  . . . . . . . . . . . . .  	Number	0000	
EXIT1  . . . . . . . . . . . . .  	L NEAR	1471	CSEG
EXIT2  . . . . . . . . . . . . .  	L NEAR	1396	CSEG
EXP  . . . . . . . . . . . . . .  	L NEAR	126C	CSEG	Global
EXP100 . . . . . . . . . . . . .  	L NEAR	12B5	CSEG
EXP110 . . . . . . . . . . . . .  	L NEAR	12B8	CSEG
EXP115 . . . . . . . . . . . . .  	L NEAR	12C2	CSEG
EXP200 . . . . . . . . . . . . .  	L NEAR	12CB	CSEG

F4FX20 . . . . . . . . . . . . .  	L NEAR	10F3	CSEG
F4VM10 . . . . . . . . . . . . .  	L NEAR	1017	CSEG
FA20 . . . . . . . . . . . . . .  	L NEAR	13CA	CSEG
FA22 . . . . . . . . . . . . . .  	L NEAR	13D9	CSEG
FA23 . . . . . . . . . . . . . .  	L NEAR	13F4	CSEG
FA24 . . . . . . . . . . . . . .  	L NEAR	1406	CSEG
FA25 . . . . . . . . . . . . . .  	L NEAR	1419	CSEG
FA27 . . . . . . . . . . . . . .  	L NEAR	1420	CSEG
FA30 . . . . . . . . . . . . . .  	L NEAR	1421	CSEG
FA40 . . . . . . . . . . . . . .  	L NEAR	142E	CSEG
FA50 . . . . . . . . . . . . . .  	L NEAR	1456	CSEG
FA60 . . . . . . . . . . . . . .  	L NEAR	145C	CSEG
FA70 . . . . . . . . . . . . . .  	L NEAR	1468	CSEG
FA80 . . . . . . . . . . . . . .  	L NEAR	146B	CSEG
FA90 . . . . . . . . . . . . . .  	L NEAR	146E	CSEG
FADD . . . . . . . . . . . . . .  	L NEAR	0E6F	CSEG	Global
FADDS  . . . . . . . . . . . . .  	L NEAR	0F7C	CSEG	Global
FADDX1 . . . . . . . . . . . . .  	L NEAR	12D7	CSEG
FADDX2 . . . . . . . . . . . . .  	L NEAR	12DA	CSEG
FADFLT . . . . . . . . . . . . .  	L NEAR	0FB7	CSEG
FAST . . . . . . . . . . . . . .  	Number	0001	
FC10 . . . . . . . . . . . . . .  	L NEAR	1785	CSEG
FC20 . . . . . . . . . . . . . .  	L NEAR	1788	CSEG
FC200  . . . . . . . . . . . . .  	L NEAR	17F4	CSEG
FC30 . . . . . . . . . . . . . .  	L NEAR	1791	CSEG
FCI10  . . . . . . . . . . . . .  	L NEAR	0005	CSEG
FCI20  . . . . . . . . . . . . .  	L NEAR	0014	CSEG
FCOMP  . . . . . . . . . . . . .  	L NEAR	0F8F	CSEG	Global
FCV05  . . . . . . . . . . . . .  	L NEAR	19F7	CSEG
FCV10  . . . . . . . . . . . . .  	L NEAR	1A0B	CSEG
FCV20  . . . . . . . . . . . . .  	L NEAR	1A12	CSEG
FCV40  . . . . . . . . . . . . .  	L NEAR	1A37	CSEG
FCV45  . . . . . . . . . . . . .  	L NEAR	1A51	CSEG
FCV50  . . . . . . . . . . . . .  	L NEAR	1A60	CSEG
FCV60  . . . . . . . . . . . . .  	L NEAR	1A65	CSEG
FCV70  . . . . . . . . . . . . .  	L NEAR	1A72	CSEG
FD10 . . . . . . . . . . . . . .  	L NEAR	17D6	CSEG
FDD20  . . . . . . . . . . . . .  	L NEAR	1328	CSEG
FDD25  . . . . . . . . . . . . .  	L NEAR	1336	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-5
                                                             

FDD30  . . . . . . . . . . . . .  	L NEAR	1345	CSEG
FDD35  . . . . . . . . . . . . .  	L NEAR	134E	CSEG
FDD37  . . . . . . . . . . . . .  	L NEAR	135A	CSEG
FDD40  . . . . . . . . . . . . .  	L NEAR	1360	CSEG
FDD50  . . . . . . . . . . . . .  	L NEAR	1363	CSEG
FDD60  . . . . . . . . . . . . .  	L NEAR	1372	CSEG
FDD70  . . . . . . . . . . . . .  	L NEAR	137B	CSEG
FDD80  . . . . . . . . . . . . .  	L NEAR	1385	CSEG
FDD90  . . . . . . . . . . . . .  	L NEAR	1388	CSEG
FDD95  . . . . . . . . . . . . .  	L NEAR	138B	CSEG
FDIV . . . . . . . . . . . . . .  	L NEAR	0E79	CSEG	Global
FDIVT  . . . . . . . . . . . . .  	L NEAR	1077	CSEG	Global
FDS00  . . . . . . . . . . . . .  	L NEAR	15E6	CSEG
FDS05  . . . . . . . . . . . . .  	L NEAR	15EA	CSEG
FDS10  . . . . . . . . . . . . .  	L NEAR	15ED	CSEG
FEXIT1 . . . . . . . . . . . . .  	L NEAR	138E	CSEG
FFFI20 . . . . . . . . . . . . .  	L NEAR	16EE	CSEG
FFI10  . . . . . . . . . . . . .  	L NEAR	16E8	CSEG
FFI20  . . . . . . . . . . . . .  	L NEAR	1804	CSEG
FFM10  . . . . . . . . . . . . .  	L NEAR	07F3	CSEG
FFM100 . . . . . . . . . . . . .  	L NEAR	088C	CSEG
FFM11  . . . . . . . . . . . . .  	L NEAR	0802	CSEG
FFM15  . . . . . . . . . . . . .  	L NEAR	080E	CSEG
FFM16  . . . . . . . . . . . . .  	L NEAR	0812	CSEG
FFM17  . . . . . . . . . . . . .  	L NEAR	0817	CSEG
FFM18  . . . . . . . . . . . . .  	L NEAR	0826	CSEG
FFM19  . . . . . . . . . . . . .  	L NEAR	0832	CSEG
FFM20  . . . . . . . . . . . . .  	L NEAR	0838	CSEG
FFM30  . . . . . . . . . . . . .  	L NEAR	083C	CSEG
FFM40  . . . . . . . . . . . . .  	L NEAR	084E	CSEG
FFM50  . . . . . . . . . . . . .  	L NEAR	0851	CSEG
FFM60  . . . . . . . . . . . . .  	L NEAR	085D	CSEG
FFM70  . . . . . . . . . . . . .  	L NEAR	086C	CSEG
FFM80  . . . . . . . . . . . . .  	L NEAR	087B	CSEG
FFM90  . . . . . . . . . . . . .  	L NEAR	087D	CSEG
FI05 . . . . . . . . . . . . . .  	L NEAR	16E3	CSEG
FI10 . . . . . . . . . . . . . .  	L NEAR	17FF	CSEG
FI30 . . . . . . . . . . . . . .  	L NEAR	1702	CSEG
FI35 . . . . . . . . . . . . . .  	L NEAR	1718	CSEG
FI40 . . . . . . . . . . . . . .  	L NEAR	171B	CSEG
FI50 . . . . . . . . . . . . . .  	L NEAR	172B	CSEG
FIN  . . . . . . . . . . . . . .  	L NEAR	0BFD	CSEG	Global
FIN05  . . . . . . . . . . . . .  	L NEAR	070B	CSEG
FIN20  . . . . . . . . . . . . .  	L NEAR	071B	CSEG
FIN25  . . . . . . . . . . . . .  	L NEAR	0731	CSEG
FIN30  . . . . . . . . . . . . .  	L NEAR	0735	CSEG
FIN40  . . . . . . . . . . . . .  	L NEAR	0748	CSEG
FIN45  . . . . . . . . . . . . .  	L NEAR	074B	CSEG
FIN50  . . . . . . . . . . . . .  	L NEAR	0751	CSEG
FIN55  . . . . . . . . . . . . .  	L NEAR	0752	CSEG
FIN80  . . . . . . . . . . . . .  	L NEAR	0753	CSEG
FINDBL . . . . . . . . . . . . .  	L NEAR	0C01	CSEG	Global
FINF . . . . . . . . . . . . . .  	L NEAR	0CA9	CSEG
FIVDSK . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-6
                                                             

FIVEO  . . . . . . . . . . . . .  	Number	0001	
FIVLPT . . . . . . . . . . . . .  	Number	0001	
FIVMEM . . . . . . . . . . . . .  	Number	0001	
FIXER  . . . . . . . . . . . . .  	L NEAR	10E6	CSEG	Global
FKEYON . . . . . . . . . . . . .  	Number	0001	
FL10 . . . . . . . . . . . . . .  	L NEAR	0FBC	CSEG
FLOAT  . . . . . . . . . . . . .  	L NEAR	0E85	CSEG
FLOATR . . . . . . . . . . . . .  	L NEAR	0FA9	CSEG
FLT10  . . . . . . . . . . . . .  	L NEAR	1869	CSEG
FMD10  . . . . . . . . . . . . .  	L NEAR	1888	CSEG
FMD20  . . . . . . . . . . . . .  	L NEAR	1889	CSEG
FMS00  . . . . . . . . . . . . .  	L NEAR	192A	CSEG
FMS05  . . . . . . . . . . . . .  	L NEAR	192D	CSEG
FMS10  . . . . . . . . . . . . .  	L NEAR	194F	CSEG
FMS20  . . . . . . . . . . . . .  	L NEAR	195B	CSEG
FMS30  . . . . . . . . . . . . .  	L NEAR	1974	CSEG
FMS35  . . . . . . . . . . . . .  	L NEAR	1981	CSEG
FMS37  . . . . . . . . . . . . .  	L NEAR	1985	CSEG
FMULT  . . . . . . . . . . . . .  	L NEAR	0E8E	CSEG	Global
FN100  . . . . . . . . . . . . .  	L NEAR	0C82	CSEG
FN20 . . . . . . . . . . . . . .  	L NEAR	0C0B	CSEG
FN200  . . . . . . . . . . . . .  	L NEAR	0C95	CSEG
FN30 . . . . . . . . . . . . . .  	L NEAR	0C2A	CSEG
FN40 . . . . . . . . . . . . . .  	L NEAR	0C33	CSEG
FN400  . . . . . . . . . . . . .  	L NEAR	0C9C	CSEG
FN50 . . . . . . . . . . . . . .  	L NEAR	0C3D	CSEG
FN500  . . . . . . . . . . . . .  	L NEAR	0C9F	CSEG
FN55 . . . . . . . . . . . . . .  	L NEAR	0C42	CSEG
FN60 . . . . . . . . . . . . . .  	L NEAR	0C47	CSEG
FN600  . . . . . . . . . . . . .  	L NEAR	0CA4	CSEG
FN70 . . . . . . . . . . . . . .  	L NEAR	0C4E	CSEG
FN80 . . . . . . . . . . . . . .  	L NEAR	0C5D	CSEG
FN90 . . . . . . . . . . . . . .  	L NEAR	0C63	CSEG
FN92 . . . . . . . . . . . . . .  	L NEAR	0C78	CSEG
FN94 . . . . . . . . . . . . . .  	L NEAR	0C7A	CSEG
FN95 . . . . . . . . . . . . . .  	L WORD 	0C68	CSEG
FN96 . . . . . . . . . . . . . .  	L NEAR	0C7D	CSEG
FN990  . . . . . . . . . . . . .  	L NEAR	0CB9	CSEG
FNDITV . . . . . . . . . . . . .  	L NEAR	11A7	CSEG
FNV10  . . . . . . . . . . . . .  	L NEAR	1AC9	CSEG
FNV20  . . . . . . . . . . . . .  	L NEAR	1AE1	CSEG
FNV30  . . . . . . . . . . . . .  	L NEAR	1AF2	CSEG
FNV40  . . . . . . . . . . . . .  	L NEAR	1B16	CSEG
FNV44  . . . . . . . . . . . . .  	L NEAR	1B0F	CSEG
FNV50  . . . . . . . . . . . . .  	L NEAR	1B17	CSEG
FO20 . . . . . . . . . . . . . .  	L NEAR	1B3C	CSEG
FO50 . . . . . . . . . . . . . .  	L NEAR	1B66	CSEG
FOUINI . . . . . . . . . . . . .  	L NEAR	10AB	CSEG
FOUT . . . . . . . . . . . . . .  	L NEAR	1B42	CSEG	Global
FOUTH  . . . . . . . . . . . . .  	L NEAR	0F72	CSEG	Global
FOUTO  . . . . . . . . . . . . .  	L NEAR	0F68	CSEG	Global
FP10 . . . . . . . . . . . . . .  	L NEAR	0D3F	CSEG
FP20 . . . . . . . . . . . . . .  	L NEAR	0D48	CSEG
FP25 . . . . . . . . . . . . . .  	L NEAR	0D4F	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-7
                                                             

FP27 . . . . . . . . . . . . . .  	L NEAR	0D5D	CSEG
FP30 . . . . . . . . . . . . . .  	L NEAR	0D79	CSEG
FP30A  . . . . . . . . . . . . .  	L NEAR	0DBD	CSEG
FP34 . . . . . . . . . . . . . .  	L NEAR	0DEA	CSEG
FP40 . . . . . . . . . . . . . .  	L NEAR	0DFB	CSEG
FP60 . . . . . . . . . . . . . .  	L NEAR	0E10	CSEG
FPRNDUP  . . . . . . . . . . . .  	L NEAR	15A7	CSEG
FPWR . . . . . . . . . . . . . .  	L NEAR	0E93	CSEG
FPWRND . . . . . . . . . . . . .  	L NEAR	0D12	CSEG
FPWRQ  . . . . . . . . . . . . .  	L NEAR	107C	CSEG	Global
FPWRT  . . . . . . . . . . . . .  	L NEAR	107F	CSEG
FRCDBL . . . . . . . . . . . . .  	L NEAR	17CC	CSEG	Global
FRCINT . . . . . . . . . . . . .  	L NEAR	17F5	CSEG	Global
FRCSNG . . . . . . . . . . . . .  	L NEAR	179D	CSEG	Global
FRCSTR . . . . . . . . . . . . .  	L NEAR	0F97	CSEG	Global
FRQINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FS10 . . . . . . . . . . . . . .  	L NEAR	17A7	CSEG
FSUB . . . . . . . . . . . . . .  	L NEAR	0E74	CSEG	Global
FTD05  . . . . . . . . . . . . .  	L NEAR	19AB	CSEG
FTD10  . . . . . . . . . . . . .  	L NEAR	19B9	CSEG
FTD20  . . . . . . . . . . . . .  	L NEAR	19C3	CSEG
FTH10  . . . . . . . . . . . . .  	L NEAR	003C	CSEG
FTH20  . . . . . . . . . . . . .  	L NEAR	0048	CSEG
FTH40  . . . . . . . . . . . . .  	L NEAR	0063	CSEG
FTH50  . . . . . . . . . . . . .  	L NEAR	006B	CSEG
FTN10  . . . . . . . . . . . . .  	L NEAR	199C	CSEG
FTZ10  . . . . . . . . . . . . .  	L NEAR	0149	CSEG
FTZ15  . . . . . . . . . . . . .  	L NEAR	014F	CSEG
FTZC10 . . . . . . . . . . . . .  	L NEAR	0152	CSEG
FX00 . . . . . . . . . . . . . .  	L NEAR	1754	CSEG
FX10 . . . . . . . . . . . . . .  	L NEAR	1759	CSEG
FX20 . . . . . . . . . . . . . .  	L NEAR	175F	CSEG
FX30 . . . . . . . . . . . . . .  	L NEAR	176A	CSEG
FZ10 . . . . . . . . . . . . . .  	L NEAR	00F1	CSEG
FZ20 . . . . . . . . . . . . . .  	L NEAR	00FB	CSEG
FZ30 . . . . . . . . . . . . . .  	L NEAR	010A	CSEG
FZ40 . . . . . . . . . . . . . .  	L NEAR	0110	CSEG
FZ45 . . . . . . . . . . . . . .  	L WORD 	0115	CSEG
FZ50 . . . . . . . . . . . . . .  	L NEAR	0129	CSEG
FZ60 . . . . . . . . . . . . . .  	L NEAR	012D	CSEG
FZ70 . . . . . . . . . . . . . .  	L NEAR	013A	CSEG
FZ90 . . . . . . . . . . . . . .  	L NEAR	0144	CSEG

GENBIN . . . . . . . . . . . . .  	Number	0001	
GENDSK . . . . . . . . . . . . .  	Number	0000	
GENIO  . . . . . . . . . . . . .  	Number	0001	
GESBC  . . . . . . . . . . . . .  	Number	0000	
GETBCD . . . . . . . . . . . . .  	L NEAR	108E	CSEG	Global
GIO86  . . . . . . . . . . . . .  	Number	0001	
GW . . . . . . . . . . . . . . .  	Number	0001	
GWCASS . . . . . . . . . . . . .  	Number	0000	
GWDBUG . . . . . . . . . . . . .  	Number	0000	

HEATH  . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-8
                                                             

HEXOCT . . . . . . . . . . . . .  	Number	0001	
HGHBIT . . . . . . . . . . . . .  	Number	0001	
HIDBL  . . . . . . . . . . . . .  	L NEAR	1B1C	CSEG

I8086  . . . . . . . . . . . . .  	Number	0001	
I8251  . . . . . . . . . . . . .  	Number	0000	
IAD10  . . . . . . . . . . . . .  	L NEAR	0EBA	CSEG
IADD . . . . . . . . . . . . . .  	L NEAR	0EB1	CSEG	Global
IBMLIK . . . . . . . . . . . . .  	Number	0001	
IBMTOK . . . . . . . . . . . . .  	Number	0001	
IC10 . . . . . . . . . . . . . .  	L NEAR	1106	CSEG
IC15 . . . . . . . . . . . . . .  	L NEAR	110A	CSEG
IC20 . . . . . . . . . . . . . .  	L NEAR	110B	CSEG
IC30 . . . . . . . . . . . . . .  	L NEAR	110D	CSEG
IC40 . . . . . . . . . . . . . .  	L NEAR	1110	CSEG
ICMPA  . . . . . . . . . . . . .  	L NEAR	10FE	CSEG	Global
ICOMP  . . . . . . . . . . . . .  	L NEAR	10FC	CSEG	Global
ICOMPS . . . . . . . . . . . . .  	L NEAR	10C9	CSEG
IDIV . . . . . . . . . . . . . .  	L NEAR	0EF0	CSEG	Global
IDIV10 . . . . . . . . . . . . .  	L NEAR	0F02	CSEG
IDIV11 . . . . . . . . . . . . .  	L NEAR	0F14	CSEG
IDIV15 . . . . . . . . . . . . .  	L NEAR	0F1E	CSEG
IDV20  . . . . . . . . . . . . .  	L NEAR	0F30	CSEG
IDV30  . . . . . . . . . . . . .  	L NEAR	0F3A	CSEG
IM10 . . . . . . . . . . . . . .  	L NEAR	0EDB	CSEG
IMD05  . . . . . . . . . . . . .  	L NEAR	1115	CSEG
IMD10  . . . . . . . . . . . . .  	L NEAR	111A	CSEG
IMD15  . . . . . . . . . . . . .  	L NEAR	112A	CSEG
IMD17  . . . . . . . . . . . . .  	L NEAR	1142	CSEG
IMD20  . . . . . . . . . . . . .  	L NEAR	1150	CSEG
IMD30  . . . . . . . . . . . . .  	L NEAR	115A	CSEG
IMD40  . . . . . . . . . . . . .  	L NEAR	1160	CSEG
IMOD . . . . . . . . . . . . . .  	L NEAR	1111	CSEG	Global
IMULT  . . . . . . . . . . . . .  	L NEAR	0ECE	CSEG	Global
INCEXP . . . . . . . . . . . . .  	L NEAR	167C	CSEG
INEG . . . . . . . . . . . . . .  	L NEAR	0B2B	CSEG	Global
INEG2  . . . . . . . . . . . . .  	L NEAR	0FA0	CSEG	Global
INEGAD . . . . . . . . . . . . .  	L NEAR	0FA7	CSEG
INF10  . . . . . . . . . . . . .  	L NEAR	07C7	CSEG
INF20  . . . . . . . . . . . . .  	L NEAR	07D4	CSEG
INF30  . . . . . . . . . . . . .  	L NEAR	07DD	CSEG
INKEYF . . . . . . . . . . . . .  	Number	0001	
INLADD . . . . . . . . . . . . .  	Number	0000	
INPRT  . . . . . . . . . . . . .  	L NEAR	109A	CSEG	Global
INRART . . . . . . . . . . . . .  	L NEAR	1108	CSEG	Global
INSTSW . . . . . . . . . . . . .  	Number	0000	
INT  . . . . . . . . . . . . . .  	L NEAR	1BD8	CSEG	Global
INT10  . . . . . . . . . . . . .  	L NEAR	1C10	CSEG
INT11  . . . . . . . . . . . . .  	L NEAR	1C16	CSEG
INT12  . . . . . . . . . . . . .  	L NEAR	1C1C	CSEG
INT15  . . . . . . . . . . . . .  	L NEAR	1C25	CSEG
INT20  . . . . . . . . . . . . .  	L NEAR	1C2D	CSEG
INT30  . . . . . . . . . . . . .  	L NEAR	1C3A	CSEG
INTEL  . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-9
                                                             

INTFHW . . . . . . . . . . . . .  	Number	0000	
INTFSW . . . . . . . . . . . . .  	Number	0000	
INTLEC . . . . . . . . . . . . .  	Number	0000	
INTROM . . . . . . . . . . . . .  	Number	0000	
INTXT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INVERT . . . . . . . . . . . . .  	L NEAR	0DB1	CSEG
INXHRT . . . . . . . . . . . . .  	L NEAR	1096	CSEG	Global
IS10 . . . . . . . . . . . . . .  	L NEAR	0EAF	CSEG
ISARY  . . . . . . . . . . . . .  	L NEAR	11D4	CSEG
ISC  . . . . . . . . . . . . . .  	Number	0000	
ISI10  . . . . . . . . . . . . .  	L NEAR	1048	CSEG
ISI15  . . . . . . . . . . . . .  	L NEAR	104F	CSEG
ISIGN  . . . . . . . . . . . . .  	L NEAR	1056	CSEG	Global
ISIGN1 . . . . . . . . . . . . .  	L NEAR	1055	CSEG
ISIS . . . . . . . . . . . . . .  	Number	0000	
ISIT . . . . . . . . . . . . . .  	L NEAR	117B	CSEG
ISUB . . . . . . . . . . . . . .  	L NEAR	0E98	CSEG	Global

JISKTN . . . . . . . . . . . . .  	Number	0000	

KANABS . . . . . . . . . . . . .  	Number	0000	
KANJFN . . . . . . . . . . . . .  	Number	0000	
KEYSTA . . . . . . . . . . . . .  	Number	0000	
KILLER . . . . . . . . . . . . .  	Number	0000	

LABKEY . . . . . . . . . . . . .  	Number	0001	
LEN2 . . . . . . . . . . . . . .  	Number	0001	
LEN3 . . . . . . . . . . . . . .  	Number	0001	
LENGTH . . . . . . . . . . . . .  	Number	0002	
LENMAT . . . . . . . . . . . . .  	L NEAR	1193	CSEG
LG100  . . . . . . . . . . . . .  	L NEAR	1C9A	CSEG
LINLN  . . . . . . . . . . . . .  	Number	0050	
LINOUT . . . . . . . . . . . . .  	L NEAR	10A6	CSEG
LINPRT . . . . . . . . . . . . .  	L NEAR	10A2	CSEG	Global
LISTEN . . . . . . . . . . . . .  	Number	0001	
LNGVAR . . . . . . . . . . . . .  	Number	0001	
LOG  . . . . . . . . . . . . . .  	L NEAR	1C44	CSEG	Global
LOG10  . . . . . . . . . . . . .  	L NEAR	1C5D	CSEG
LOKHED . . . . . . . . . . . . .  	Number	0000	
LONGI  . . . . . . . . . . . . .  	Number	0000	
LOPFD0 . . . . . . . . . . . . .  	L NEAR	11BE	CSEG
LOPFD1 . . . . . . . . . . . . .  	L NEAR	11B4	CSEG	Global
LOPFDI . . . . . . . . . . . . .  	L NEAR	11CB	CSEG
LOPFND . . . . . . . . . . . . .  	L NEAR	11AB	CSEG	Global
LOPTOP . . . . . . . . . . . . .  	L NEAR	1165	CSEG
LPT3 . . . . . . . . . . . . . .  	Number	0000	
LPTLEN . . . . . . . . . . . . .  	Number	0084	
LPTSW  . . . . . . . . . . . . .  	Number	0001	

M1 . . . . . . . . . . . . . . .  	L NEAR	18A9	CSEG
M4 . . . . . . . . . . . . . . .  	L NEAR	18B4	CSEG
M4A  . . . . . . . . . . . . . .  	L NEAR	18C6	CSEG
M4B  . . . . . . . . . . . . . .  	L NEAR	18CB	CSEG
M4C  . . . . . . . . . . . . . .  	L NEAR	18D9	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-10
                                                             

M4D  . . . . . . . . . . . . . .  	L NEAR	18DB	CSEG
M5 . . . . . . . . . . . . . . .  	L NEAR	18EB	CSEG
M5A  . . . . . . . . . . . . . .  	L NEAR	190F	CSEG
M5AA . . . . . . . . . . . . . .  	L NEAR	18F2	CSEG
M5AB . . . . . . . . . . . . . .  	L NEAR	18FE	CSEG
M5B  . . . . . . . . . . . . . .  	L NEAR	1915	CSEG
M6 . . . . . . . . . . . . . . .  	L NEAR	1918	CSEG
MAF05  . . . . . . . . . . . . .  	L NEAR	09F1	CSEG
MAKINT . . . . . . . . . . . . .  	L NEAR	1062	CSEG	Global
MAXQUO . . . . . . . . . . . . .  	L NEAR	16AA	CSEG
MBF05  . . . . . . . . . . . . .  	L NEAR	09BF	CSEG
MBF10  . . . . . . . . . . . . .  	L NEAR	09C2	CSEG
MBF20  . . . . . . . . . . . . .  	L NEAR	09C5	CSEG
MDP10  . . . . . . . . . . . . .  	L NEAR	0758	CSEG
MDPTEN . . . . . . . . . . . . .  	L NEAR	0711	CSEG
MDS  . . . . . . . . . . . . . .  	Number	0000	
MDSISS . . . . . . . . . . . . .  	Number	0000	
MEMIMG . . . . . . . . . . . . .  	Number	0001	
ML05 . . . . . . . . . . . . . .  	L NEAR	0927	CSEG
ML10 . . . . . . . . . . . . . .  	L NEAR	092E	CSEG
MLLN2  . . . . . . . . . . . . .  	L NEAR	1C91	CSEG
MOSTEK . . . . . . . . . . . . .  	Number	0000	
MOVAM  . . . . . . . . . . . . .  	L NEAR	09DA	CSEG
MOVE . . . . . . . . . . . . . .  	L NEAR	1084	CSEG	Global
MOVE1  . . . . . . . . . . . . .  	L NEAR	1009	CSEG	Global
MOVEM  . . . . . . . . . . . . .  	L NEAR	09E0	CSEG
MOVFM  . . . . . . . . . . . . .  	L NEAR	0F4B	CSEG	Global
MOVFR  . . . . . . . . . . . . .  	L NEAR	0F43	CSEG	Global
MOVMF  . . . . . . . . . . . . .  	L NEAR	0F5D	CSEG	Global
MOVRF  . . . . . . . . . . . . .  	L NEAR	0F54	CSEG	Global
MOVRM  . . . . . . . . . . . . .  	L NEAR	1089	CSEG	Global
MOVVFM . . . . . . . . . . . . .  	L NEAR	100F	CSEG
MULSEG . . . . . . . . . . . . .  	Number	0001	

NAMBUF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NAMCNT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NAMLEN . . . . . . . . . . . . .  	Number	0028	
NASCOM . . . . . . . . . . . . .  	Number	0000	
NATROM . . . . . . . . . . . . .  	Number	0000	
NBANKS . . . . . . . . . . . . .  	Number	0001	
NCRBAS . . . . . . . . . . . . .  	Number	0000	
NCRCAS . . . . . . . . . . . . .  	Number	0000	
NCRDEB . . . . . . . . . . . . .  	Number	0000	
NCRELS . . . . . . . . . . . . .  	Number	0000	
NCRLPT . . . . . . . . . . . . .  	Number	0001	
NECBAS . . . . . . . . . . . . .  	Number	0000	
NEG  . . . . . . . . . . . . . .  	L NEAR	0B25	CSEG	Global
NEGNUM . . . . . . . . . . . . .  	L NEAR	0D2A	CSEG
NEGR . . . . . . . . . . . . . .  	L NEAR	10D0	CSEG
NEW10  . . . . . . . . . . . . .  	L NEAR	1F6D	CSEG
NEWSD  . . . . . . . . . . . . .  	L NEAR	1F67	CSEG
NG10 . . . . . . . . . . . . . .  	L NEAR	10E5	CSEG
NGBLDX . . . . . . . . . . . . .  	L NEAR	1C2E	CSEG
NMARY1 . . . . . . . . . . . . .  	L NEAR	11C3	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-11
                                                             

NMARY2 . . . . . . . . . . . . .  	L NEAR	11C4	CSEG
NMARY3 . . . . . . . . . . . . .  	L NEAR	11C5	CSEG
NMARY4 . . . . . . . . . . . . .  	L NEAR	11C8	CSEG
NMCOMT . . . . . . . . . . . . .  	Number	0002	
NMKEYF . . . . . . . . . . . . .  	Number	000A	
NMKEYT . . . . . . . . . . . . .  	Number	000E	
NMLINE . . . . . . . . . . . . .  	Number	0019	
NMLPT  . . . . . . . . . . . . .  	Number	0003	
NMPENT . . . . . . . . . . . . .  	Number	0001	
NMSTRT . . . . . . . . . . . . .  	Number	0004	
NOATDL . . . . . . . . . . . . .  	Number	0000	
NOCTLA . . . . . . . . . . . . .  	Number	0000	
NODOT  . . . . . . . . . . . . .  	Number	0000	
NOEDIT . . . . . . . . . . . . .  	Number	0000	
NOIOS  . . . . . . . . . . . . .  	Number	0000	
NONULL . . . . . . . . . . . . .  	Number	0000	
NOPEKS . . . . . . . . . . . . .  	Number	0000	
NOR10  . . . . . . . . . . . . .  	L NEAR	1CEF	CSEG
NOR15  . . . . . . . . . . . . .  	L NEAR	1D06	CSEG
NOR16  . . . . . . . . . . . . .  	L NEAR	1D0D	CSEG
NOR17  . . . . . . . . . . . . .  	L NEAR	1D11	CSEG
NOR20  . . . . . . . . . . . . .  	L NEAR	1D14	CSEG
NORD10 . . . . . . . . . . . . .  	L NEAR	1CAA	CSEG
NORD20 . . . . . . . . . . . . .  	L NEAR	1CAE	CSEG
NORD25 . . . . . . . . . . . . .  	L NEAR	1CB7	CSEG
NORD30 . . . . . . . . . . . . .  	L NEAR	1CBF	CSEG
NORD40 . . . . . . . . . . . . .  	L NEAR	1CE0	CSEG
NORD5  . . . . . . . . . . . . .  	L NEAR	1CA2	CSEG
NORD50 . . . . . . . . . . . . .  	L NEAR	1CE5	CSEG
NORMCHK  . . . . . . . . . . . .  	L NEAR	166C	CSEG
NOROMP . . . . . . . . . . . . .  	Number	0000	
NORUBT . . . . . . . . . . . . .  	Number	0000	
NOTFDD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NOTFNS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NOTIT0 . . . . . . . . . . . . .  	L NEAR	116F	CSEG
NOTIT1 . . . . . . . . . . . . .  	L NEAR	116A	CSEG
NOTIT2 . . . . . . . . . . . . .  	L NEAR	1172	CSEG
NOUSR  . . . . . . . . . . . . .  	Number	0000	
NOVARP . . . . . . . . . . . . .  	Number	0000	
NSTK1  . . . . . . . . . . . . .  	L NEAR	163F	CSEG
NUMLEV . . . . . . . . . . . . .  	Number	006E	
NUMTMP . . . . . . . . . . . . .  	Number	000A	
NUMTRP . . . . . . . . . . . . .  	Number	0015	
NZCOMP . . . . . . . . . . . . .  	L NEAR	0A21	CSEG

OEMRAM . . . . . . . . . . . . .  	Number	0000	
OLDRN  . . . . . . . . . . . . .  	L NEAR	1F7A	CSEG
ONEARG . . . . . . . . . . . . .  	L NEAR	0661	CSEG
ONELIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ONTEL  . . . . . . . . . . . . .  	Number	0000	
OUTDO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
OVCHK  . . . . . . . . . . . . .  	L NEAR	1845	CSEG
OVCHKJ . . . . . . . . . . . . .  	L NEAR	1643	CSEG
OVERFLOW . . . . . . . . . . . .  	L NEAR	184F	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-12
                                                             

OVERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
OVFLS  . . . . . . . . . . . . .  	L NEAR	077C	CSEG

PAKSP  . . . . . . . . . . . . .  	L NEAR	1FED	CSEG
PALSIZ . . . . . . . . . . . . .  	Number	0000	
PANBAS . . . . . . . . . . . . .  	Number	0000	
PCS  . . . . . . . . . . . . . .  	Number	0000	
PFE10  . . . . . . . . . . . . .  	L NEAR	0167	CSEG
PFE100 . . . . . . . . . . . . .  	L NEAR	0236	CSEG
PFE110 . . . . . . . . . . . . .  	L NEAR	024F	CSEG
PFE20  . . . . . . . . . . . . .  	L NEAR	0177	CSEG
PFE30  . . . . . . . . . . . . .  	L NEAR	0186	CSEG
PFE40  . . . . . . . . . . . . .  	L NEAR	0194	CSEG
PFE45  . . . . . . . . . . . . .  	L NEAR	019E	CSEG
PFE50  . . . . . . . . . . . . .  	L NEAR	01A0	CSEG
PFE55  . . . . . . . . . . . . .  	L NEAR	01CB	CSEG
PFE57  . . . . . . . . . . . . .  	L NEAR	01D9	CSEG
PFE65  . . . . . . . . . . . . .  	L NEAR	01EC	CSEG
PFE66  . . . . . . . . . . . . .  	L NEAR	01EE	CSEG
PFE70  . . . . . . . . . . . . .  	L NEAR	0204	CSEG
PFE80  . . . . . . . . . . . . .  	L NEAR	0222	CSEG
PFE90  . . . . . . . . . . . . .  	L NEAR	0232	CSEG
PFO05  . . . . . . . . . . . . .  	L NEAR	1E8C	CSEG
PFO10  . . . . . . . . . . . . .  	L NEAR	1EA3	CSEG
PFO20  . . . . . . . . . . . . .  	L NEAR	1EB2	CSEG
PFO40  . . . . . . . . . . . . .  	L NEAR	1EC5	CSEG
PFX10  . . . . . . . . . . . . .  	L NEAR	0076	CSEG
PFX20  . . . . . . . . . . . . .  	L NEAR	007C	CSEG
PFX30  . . . . . . . . . . . . .  	L NEAR	007D	CSEG
PFX40  . . . . . . . . . . . . .  	L NEAR	009E	CSEG
PFX50  . . . . . . . . . . . . .  	L NEAR	00BD	CSEG
PFX60  . . . . . . . . . . . . .  	L NEAR	00C0	CSEG
PFX70  . . . . . . . . . . . . .  	L NEAR	00CA	CSEG
PFX90  . . . . . . . . . . . . .  	L NEAR	00D3	CSEG
PI10 . . . . . . . . . . . . . .  	L NEAR	1EE2	CSEG
PI20 . . . . . . . . . . . . . .  	L NEAR	1EEB	CSEG
PI30 . . . . . . . . . . . . . .  	L NEAR	1EF6	CSEG
PI40 . . . . . . . . . . . . . .  	L NEAR	1F00	CSEG
PLAYSW . . . . . . . . . . . . .  	Number	0001	
POL10  . . . . . . . . . . . . .  	L NEAR	1D4A	CSEG
POL30  . . . . . . . . . . . . .  	L NEAR	1D66	CSEG
POPHRT . . . . . . . . . . . . .  	L NEAR	105D	CSEG	Global
POSBOVER . . . . . . . . . . . .  	L NEAR	183F	CSEG
POSEXP . . . . . . . . . . . . .  	L NEAR	075F	CSEG
PUF10  . . . . . . . . . . . . .  	L NEAR	1D6F	CSEG
PUF100 . . . . . . . . . . . . .  	L NEAR	1DEF	CSEG
PUF110 . . . . . . . . . . . . .  	L NEAR	1E00	CSEG
PUF120 . . . . . . . . . . . . .  	L NEAR	1E28	CSEG
PUF130 . . . . . . . . . . . . .  	L NEAR	1E3B	CSEG
PUF140 . . . . . . . . . . . . .  	L NEAR	1E3E	CSEG
PUF150 . . . . . . . . . . . . .  	L NEAR	1E59	CSEG
PUF160 . . . . . . . . . . . . .  	L NEAR	1E62	CSEG
PUF30  . . . . . . . . . . . . .  	L NEAR	1D83	CSEG
PUF40  . . . . . . . . . . . . .  	L NEAR	1D8C	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-13
                                                             

PUF50  . . . . . . . . . . . . .  	L NEAR	1D94	CSEG
PUF60  . . . . . . . . . . . . .  	L NEAR	1DA6	CSEG
PUF70  . . . . . . . . . . . . .  	L NEAR	1DC8	CSEG
PUF80  . . . . . . . . . . . . .  	L NEAR	1DD6	CSEG
PUF90  . . . . . . . . . . . . .  	L NEAR	1DE1	CSEG
PUFOUT . . . . . . . . . . . . .  	L NEAR	1E81	CSEG	Global
PURE . . . . . . . . . . . . . .  	Number	0001	
PUSHF  . . . . . . . . . . . . .  	L NEAR	0F84	CSEG	Global

QINT . . . . . . . . . . . . . .  	L NEAR	1C3B	CSEG
QINTNZ . . . . . . . . . . . . .  	L NEAR	1BF6	CSEG
QINTX  . . . . . . . . . . . . .  	L NEAR	1BE3	CSEG
QUEUE  . . . . . . . . . . . . .  	Number	0001	

RDD10  . . . . . . . . . . . . .  	L NEAR	1F9C	CSEG
RDD20  . . . . . . . . . . . . .  	L NEAR	1FAA	CSEG
RDD30  . . . . . . . . . . . . .  	L NEAR	1FC7	CSEG
RDL120 . . . . . . . . . . . . .  	L NEAR	094A	CSEG
REALIO . . . . . . . . . . . . .  	Number	0001	
REASON . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
REM2 . . . . . . . . . . . . . .  	L NEAR	1524	CSEG
REM3 . . . . . . . . . . . . . .  	L NEAR	1532	CSEG
REM4 . . . . . . . . . . . . . .  	L NEAR	1541	CSEG
RESTORE  . . . . . . . . . . . .  	L NEAR	1664	CSEG
RETJ . . . . . . . . . . . . . .  	L NEAR	166B	CSEG
RETRES . . . . . . . . . . . . .  	L NEAR	1564	CSEG
RMX  . . . . . . . . . . . . . .  	Number	0000	
RND  . . . . . . . . . . . . . .  	L NEAR	1F07	CSEG	Global
RND10  . . . . . . . . . . . . .  	L NEAR	1F1A	CSEG
RNDMN2 . . . . . . . . . . . . .  	L NEAR	0FC6	CSEG	Global
RNDMON . . . . . . . . . . . . .  	L NEAR	0FC3	CSEG	Global
ROOTBT . . . . . . . . . . . . .  	L NEAR	0D0F	CSEG
ROUND  . . . . . . . . . . . . .  	L NEAR	1680	CSEG
ROUNDUP  . . . . . . . . . . . .  	L NEAR	168C	CSEG
RR . . . . . . . . . . . . . . .  	L NEAR	063F	CSEG
RR1  . . . . . . . . . . . . . .  	L NEAR	064B	CSEG
RR2  . . . . . . . . . . . . . .  	L NEAR	064E	CSEG
RR3  . . . . . . . . . . . . . .  	L NEAR	0654	CSEG
RSHACK . . . . . . . . . . . . .  	Number	0000	
RSTLES . . . . . . . . . . . . .  	Number	0001	
RTLP . . . . . . . . . . . . . .  	L NEAR	0CEB	CSEG

S  . . . . . . . . . . . . . . .  	L NEAR	1B24	CSEG
SAVE . . . . . . . . . . . . . .  	L NEAR	1698	CSEG
SBC  . . . . . . . . . . . . . .  	Number	0000	
SBC86  . . . . . . . . . . . . .  	Number	0000	
SCP  . . . . . . . . . . . . . .  	Number	0001	
SCRN86 . . . . . . . . . . . . .  	Number	0001	
SCRNIO . . . . . . . . . . . . .  	Number	0001	
SCROLT . . . . . . . . . . . . .  	Number	0001	
SDIVOVFL . . . . . . . . . . . .  	L NEAR	1645	CSEG
SES00  . . . . . . . . . . . . .  	L NEAR	1204	CSEG
SES05  . . . . . . . . . . . . .  	L NEAR	1224	CSEG
SES07  . . . . . . . . . . . . .  	L NEAR	1226	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-14
                                                             

SES10  . . . . . . . . . . . . .  	L NEAR	1237	CSEG
SES20  . . . . . . . . . . . . .  	L NEAR	1244	CSEG
SES30  . . . . . . . . . . . . .  	L NEAR	1247	CSEG
SG15 . . . . . . . . . . . . . .  	L NEAR	10CF	CSEG
SGN  . . . . . . . . . . . . . .  	L NEAR	1072	CSEG	Global
SGSATS . . . . . . . . . . . . .  	Number	0000	
SHORTJ . . . . . . . . . . . . .  	Number	0001	
SHRA11 . . . . . . . . . . . . .  	L NEAR	0973	CSEG
SHRA30 . . . . . . . . . . . . .  	L NEAR	098E	CSEG
SHRA40 . . . . . . . . . . . . .  	L NEAR	09A0	CSEG
SHRD10 . . . . . . . . . . . . .  	L NEAR	1BB1	CSEG
SHST . . . . . . . . . . . . . .  	L NEAR	095B	CSEG
SHTCHN . . . . . . . . . . . . .  	Number	0000	
SHTERR . . . . . . . . . . . . .  	Number	0000	
SHTINS . . . . . . . . . . . . .  	Number	0000	
SHTLHM . . . . . . . . . . . . .  	Number	0000	
SHTLIN . . . . . . . . . . . . .  	Number	0000	
SHTPRO . . . . . . . . . . . . .  	Number	0000	
SHTREN . . . . . . . . . . . . .  	Number	0000	
SI20 . . . . . . . . . . . . . .  	L NEAR	2024	CSEG
SI30 . . . . . . . . . . . . . .  	L NEAR	202B	CSEG
SI31 . . . . . . . . . . . . . .  	L NEAR	2017	CSEG
SI32 . . . . . . . . . . . . . .  	L NEAR	201E	CSEG
SI35 . . . . . . . . . . . . . .  	L NEAR	2055	CSEG
SI40 . . . . . . . . . . . . . .  	L NEAR	205F	CSEG
SIGN . . . . . . . . . . . . . .  	L NEAR	08BF	CSEG	Global
SIGNAL . . . . . . . . . . . . .  	L NEAR	08E1	CSEG
SIGNC  . . . . . . . . . . . . .  	L NEAR	10BD	CSEG	Global
SIGNS  . . . . . . . . . . . . .  	L NEAR	10CB	CSEG	Global
SIN  . . . . . . . . . . . . . .  	L NEAR	05CB	CSEG	Global
SIN10  . . . . . . . . . . . . .  	L NEAR	05D4	CSEG
SIN20  . . . . . . . . . . . . .  	L NEAR	05E1	CSEG
SIN30  . . . . . . . . . . . . .  	L NEAR	05E4	CSEG
SIN31  . . . . . . . . . . . . .  	L NEAR	05F0	CSEG
SIN40  . . . . . . . . . . . . .  	L NEAR	0601	CSEG
SIN50  . . . . . . . . . . . . .  	L NEAR	0611	CSEG
SIN51  . . . . . . . . . . . . .  	L NEAR	061B	CSEG
SIN60  . . . . . . . . . . . . .  	L NEAR	0630	CSEG
SIN65  . . . . . . . . . . . . .  	L NEAR	0636	CSEG
SIN70  . . . . . . . . . . . . .  	L NEAR	063E	CSEG
SIS01  . . . . . . . . . . . . .  	L NEAR	08C7	CSEG
SIS05  . . . . . . . . . . . . .  	L NEAR	08D7	CSEG
SIS07  . . . . . . . . . . . . .  	L NEAR	08EC	CSEG
SIS10  . . . . . . . . . . . . .  	L NEAR	08EE	CSEG
SIXDIG . . . . . . . . . . . . .  	Number	0000	
SMALL  . . . . . . . . . . . . .  	Number	0000	
SPCDSK . . . . . . . . . . . . .  	Number	0000	
SPCNDS . . . . . . . . . . . . .  	Number	0000	
SQR  . . . . . . . . . . . . . .  	L NEAR	0CBA	CSEG	Global
STOULP . . . . . . . . . . . . .  	L NEAR	0895	CSEG
STREND . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
STRING . . . . . . . . . . . . .  	Number	0001	
STROUI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STROUT . . . . . . . . . . . . .  	L NEAR	089F	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-15
                                                             

STRSIZ . . . . . . . . . . . . .  	Number	0003	
SUPRSH . . . . . . . . . . . . .  	Number	0001	
SWAPSW . . . . . . . . . . . . .  	Number	0001	

TAN  . . . . . . . . . . . . . .  	L NEAR	0667	CSEG	Global
TEK  . . . . . . . . . . . . . .  	Number	0000	
TEMP3  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TIMSHR . . . . . . . . . . . . .  	Number	0000	
TMERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TRAPER . . . . . . . . . . . . .  	L NEAR	07E2	CSEG
TRAPIT . . . . . . . . . . . . .  	L NEAR	07EB	CSEG
TRNCHR . . . . . . . . . . . . .  	Number	0000	
TRSER2 . . . . . . . . . . . . .  	Number	0000	
TRUANS . . . . . . . . . . . . .  	Number	0000	
TRUROM . . . . . . . . . . . . .  	Number	0001	
TSDISK . . . . . . . . . . . . .  	Number	0000	
TSLPT  . . . . . . . . . . . . .  	Number	0000	
TSTEVN . . . . . . . . . . . . .  	L NEAR	1FE7	CSEG
TSTFLG . . . . . . . . . . . . .  	L NEAR	0A74	CSEG

UFC10  . . . . . . . . . . . . .  	L NEAR	0A64	CSEG
UM10 . . . . . . . . . . . . . .  	L NEAR	0FEC	CSEG
UMULT  . . . . . . . . . . . . .  	L NEAR	0FE2	CSEG	Global

VALINT . . . . . . . . . . . . .  	L NEAR	1839	CSEG	Global
VALSNG . . . . . . . . . . . . .  	L NEAR	106C	CSEG	Global
VALTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
VCMP10 . . . . . . . . . . . . .  	L NEAR	0BB3	CSEG
VD10 . . . . . . . . . . . . . .  	L NEAR	1005	CSEG
VD15 . . . . . . . . . . . . . .  	L NEAR	1008	CSEG
VDFACS . . . . . . . . . . . . .  	L NEAR	0FFD	CSEG	Global
VIN05  . . . . . . . . . . . . .  	L NEAR	0BF5	CSEG
VIN10  . . . . . . . . . . . . .  	L NEAR	0BFA	CSEG
VINT . . . . . . . . . . . . . .  	L NEAR	0BEF	CSEG	Global
VM10 . . . . . . . . . . . . . .  	L NEAR	0B60	CSEG
VMM10  . . . . . . . . . . . . .  	L NEAR	0B71	CSEG
VMOVAF . . . . . . . . . . . . .  	L NEAR	0FF6	CSEG	Global
VMOVE  . . . . . . . . . . . . .  	L NEAR	1011	CSEG	Global
VMOVFA . . . . . . . . . . . . .  	L NEAR	0FED	CSEG	Global
VMOVFM . . . . . . . . . . . . .  	L NEAR	0FF0	CSEG	Global
VMOVMF . . . . . . . . . . . . .  	L NEAR	0FF9	CSEG	Global
VMVM1  . . . . . . . . . . . . .  	L NEAR	0B87	CSEG
VMVVFM . . . . . . . . . . . . .  	L NEAR	0FFC	CSEG
VN15 . . . . . . . . . . . . . .  	L NEAR	0B2E	CSEG
VN20 . . . . . . . . . . . . . .  	L NEAR	0B3A	CSEG
VNEG . . . . . . . . . . . . . .  	L NEAR	0B20	CSEG	Global
VPO17  . . . . . . . . . . . . .  	L NEAR	0BE6	CSEG
VPO20  . . . . . . . . . . . . .  	L NEAR	0BE7	CSEG
VPS10  . . . . . . . . . . . . .  	L NEAR	0BC1	CSEG
VPS20  . . . . . . . . . . . . .  	L NEAR	0BC5	CSEG
VS10 . . . . . . . . . . . . . .  	L NEAR	1043	CSEG
VSIGN  . . . . . . . . . . . . .  	L NEAR	103B	CSEG	Global

XCG10  . . . . . . . . . . . . .  	L NEAR	09AB	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-16
                                                             

XTNSYS . . . . . . . . . . . . .  	Number	0000	
XTON . . . . . . . . . . . . . .  	L NEAR	0E1D	CSEG
XTON10 . . . . . . . . . . . . .  	L NEAR	0E32	CSEG
XTON20 . . . . . . . . . . . . .  	L NEAR	0E3F	CSEG
XTON30 . . . . . . . . . . . . .  	L NEAR	0E5C	CSEG

Z80  . . . . . . . . . . . . . .  	Number	0001	
Z80MAC . . . . . . . . . . . . .  	Number	0001	
ZCMPBX . . . . . . . . . . . . .  	L NEAR	0A31	CSEG
ZCMPCK . . . . . . . . . . . . .  	L NEAR	0A18	CSEG
ZCMPRT . . . . . . . . . . . . .  	L NEAR	0A30	CSEG
ZEREXP . . . . . . . . . . . . .  	L NEAR	0A7C	CSEG
ZERO . . . . . . . . . . . . . .  	L NEAR	08B5	CSEG	Global
ZERQUO . . . . . . . . . . . . .  	L NEAR	154C	CSEG

$AEXPS . . . . . . . . . . . . .  	L NEAR	1200	CSEG
$ARG . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ARGLO . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ATAN  . . . . . . . . . . . . .  	L NEAR	0687	CSEG
$ATNC1 . . . . . . . . . . . . .  	L NEAR	0578	CSEG
$ATNC2 . . . . . . . . . . . . .  	L NEAR	0581	CSEG
$CATTY . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$CDS . . . . . . . . . . . . . .  	L NEAR	17DB	CSEG	Global
$CHKEL . . . . . . . . . . . . .  	L NEAR	1258	CSEG
$CHRGT . . . . . . . . . . . . .  	L NEAR	0E5F	CSEG
$CINC  . . . . . . . . . . . . .  	L NEAR	1804	CSEG
$CIND  . . . . . . . . . . . . .  	L NEAR	1804	CSEG
$CLROV . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$COMPM . . . . . . . . . . . . .  	L NEAR	0A81	CSEG
$CONI2 . . . . . . . . . . . . .  	L NEAR	0AEB	CSEG
$COS . . . . . . . . . . . . . .  	L NEAR	05B3	CSEG
$CSD . . . . . . . . . . . . . .  	L NEAR	17AE	CSEG	Global
$CSI . . . . . . . . . . . . . .  	L NEAR	17E9	CSEG	Global
$DADDH . . . . . . . . . . . . .  	L NEAR	0900	CSEG
$DBUFF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$DCMPA . . . . . . . . . . . . .  	L NEAR	0AD0	CSEG	Global
$DCMPM . . . . . . . . . . . . .  	L NEAR	0AD3	CSEG
$DDIV  . . . . . . . . . . . . .  	L NEAR	1487	CSEG
$DFACL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$DHALF . . . . . . . . . . . . .  	L NEAR	0499	CSEG
$DINT  . . . . . . . . . . . . .  	L NEAR	1B69	CSEG
$DIV0M . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$DIV0S . . . . . . . . . . . . .  	L NEAR	0787	CSEG	Global
$DIV10 . . . . . . . . . . . . .  	L NEAR	0915	CSEG
$DP00  . . . . . . . . . . . . .  	L NEAR	0361	CSEG
$DP01  . . . . . . . . . . . . .  	L NEAR	0369	CSEG
$DP06  . . . . . . . . . . . . .  	L NEAR	0391	CSEG
$DP07  . . . . . . . . . . . . .  	L NEAR	0399	CSEG
$DP09  . . . . . . . . . . . . .  	L NEAR	03A9	CSEG
$DP16  . . . . . . . . . . . . .  	L NEAR	03E1	CSEG
$DPADR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$DPM01 . . . . . . . . . . . . .  	L NEAR	0359	CSEG
$DROUND  . . . . . . . . . . . .  	L NEAR	159B	CSEG
$DZERO . . . . . . . . . . . . .  	L NEAR	08A8	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-17
                                                             

$EXP . . . . . . . . . . . . . .  	L NEAR	126C	CSEG
$EXPCN . . . . . . . . . . . . .  	L NEAR	0546	CSEG	Global
$FAC . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FACLO . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FACM1 . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FADDD . . . . . . . . . . . . .  	L NEAR	12E7	CSEG
$FADDH . . . . . . . . . . . . .  	L NEAR	090C	CSEG
$FADDS . . . . . . . . . . . . .  	L NEAR	13A3	CSEG	Global
$FBUFF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FCERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$FCI4  . . . . . . . . . . . . .  	L NEAR	0005	CSEG
$FCOMP . . . . . . . . . . . . .  	L NEAR	0A41	CSEG	Global
$FD  . . . . . . . . . . . . . .  	L NEAR	17CC	CSEG
$FDIVD . . . . . . . . . . . . .  	L NEAR	1481	CSEG
$FDIVS . . . . . . . . . . . . .  	L NEAR	15DA	CSEG	Global
$FI  . . . . . . . . . . . . . .  	L NEAR	17F5	CSEG	Global
$FIDIG . . . . . . . . . . . . .  	L NEAR	16B6	CSEG
$FIN . . . . . . . . . . . . . .  	L NEAR	0BFD	CSEG
$FINCH . . . . . . . . . . . . .  	L NEAR	04CB	CSEG
$FIND  . . . . . . . . . . . . .  	L NEAR	177A	CSEG
$FINDB . . . . . . . . . . . . .  	L NEAR	0C01	CSEG
$FINE  . . . . . . . . . . . . .  	L NEAR	0705	CSEG
$FINEX . . . . . . . . . . . . .  	L NEAR	172F	CSEG
$FINFC . . . . . . . . . . . . .  	L NEAR	179B	CSEG
$FINI  . . . . . . . . . . . . .  	L NEAR	1793	CSEG
$FINS  . . . . . . . . . . . . .  	L NEAR	177C	CSEG
$FLGOC . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$FLGOV . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FLT . . . . . . . . . . . . . .  	L NEAR	1852	CSEG	Global
$FMTAL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FMTAX . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FMTCX . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$FMULD . . . . . . . . . . . . .  	L NEAR	1877	CSEG
$FMULS . . . . . . . . . . . . .  	L NEAR	1921	CSEG	Global
$FODTB . . . . . . . . . . . . .  	L NEAR	04D5	CSEG
$FOFMT . . . . . . . . . . . . .  	L NEAR	07EC	CSEG
$FOITB . . . . . . . . . . . . .  	L NEAR	0524	CSEG
$FOSTB . . . . . . . . . . . . .  	L NEAR	051B	CSEG
$FOTAN . . . . . . . . . . . . .  	L NEAR	1991	CSEG
$FOTB  . . . . . . . . . . . . .  	L NEAR	0259	CSEG
$FOTCI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	Global
$FOTCV . . . . . . . . . . . . .  	L NEAR	19C8	CSEG
$FOTED . . . . . . . . . . . . .  	L NEAR	19A9	CSEG
$FOTNV . . . . . . . . . . . . .  	L NEAR	1AC4	CSEG
$FOTZ  . . . . . . . . . . . . .  	L NEAR	0145	CSEG
$FOTZC . . . . . . . . . . . . .  	L NEAR	0155	CSEG
$FOTZS . . . . . . . . . . . . .  	L NEAR	00D4	CSEG
$FOUT  . . . . . . . . . . . . .  	L NEAR	1B42	CSEG
$FOUT2 . . . . . . . . . . . . .  	L NEAR	1B4F	CSEG	Global
$FOUTH . . . . . . . . . . . . .  	L NEAR	0036	CSEG	Global
$FOUTO . . . . . . . . . . . . .  	L NEAR	002E	CSEG	Global
$FPWR  . . . . . . . . . . . . .  	L NEAR	0D2D	CSEG	Global
$FS  . . . . . . . . . . . . . .  	L NEAR	179D	CSEG	Global
$FSUBD . . . . . . . . . . . . .  	L NEAR	12DB	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-18
                                                             

$FSUBS . . . . . . . . . . . . .  	L NEAR	1397	CSEG	Global
$FTDNT . . . . . . . . . . . . .  	L NEAR	1B74	CSEG
$GETYP . . . . . . . . . . . . .  	L NEAR	08EF	CSEG	Global
$IABS  . . . . . . . . . . . . .  	L NEAR	0B18	CSEG
$IN2PI . . . . . . . . . . . . .  	L NEAR	0592	CSEG
$INEG  . . . . . . . . . . . . .  	L NEAR	0B2B	CSEG
$INFMD . . . . . . . . . . . . .  	L NEAR	053A	CSEG
$INFPD . . . . . . . . . . . . .  	L NEAR	0532	CSEG
$INT . . . . . . . . . . . . . .  	L NEAR	1BD8	CSEG
$LG2E  . . . . . . . . . . . . .  	L NEAR	0542	CSEG
$LN2 . . . . . . . . . . . . . .  	L NEAR	04C7	CSEG
$LOG . . . . . . . . . . . . . .  	L NEAR	1C44	CSEG
$LOGP  . . . . . . . . . . . . .  	L NEAR	04A5	CSEG	Global
$LOGQ  . . . . . . . . . . . . .  	L NEAR	04B6	CSEG
$MLSP  . . . . . . . . . . . . .  	L NEAR	092E	CSEG
$MOVAC . . . . . . . . . . . . .  	L NEAR	09D0	CSEG
$MOVAF . . . . . . . . . . . . .  	L NEAR	09E8	CSEG
$MOVBF . . . . . . . . . . . . .  	L NEAR	09BC	CSEG
$MOVBS . . . . . . . . . . . . .  	L NEAR	09B4	CSEG
$MOVFA . . . . . . . . . . . . .  	L NEAR	09FB	CSEG	Global
$MOVFC . . . . . . . . . . . . .  	L NEAR	09D5	CSEG
$MOVFM . . . . . . . . . . . . .  	L NEAR	0BA2	CSEG	Global
$MOVFR . . . . . . . . . . . . .  	L NEAR	0A06	CSEG	Global
$MOVMF . . . . . . . . . . . . .  	L NEAR	0B89	CSEG	Global
$MOVRF . . . . . . . . . . . . .  	L NEAR	0A0F	CSEG	Global
$MUL10 . . . . . . . . . . . . .  	L NEAR	091F	CSEG
$NEG . . . . . . . . . . . . . .  	L NEAR	0B25	CSEG	Global
$NORMD . . . . . . . . . . . . .  	L NEAR	1C9D	CSEG	Global
$NORMS . . . . . . . . . . . . .  	L NEAR	1CE8	CSEG	Global
$NUMB  . . . . . . . . . . . . .  	L NEAR	05A3	CSEG
$OHCNS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$OVERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$OVFLS . . . . . . . . . . . . .  	L NEAR	0776	CSEG
$OVMSG . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$POLY  . . . . . . . . . . . . .  	L NEAR	1D34	CSEG
$POLYX . . . . . . . . . . . . .  	L NEAR	1D1B	CSEG
$POPA  . . . . . . . . . . . . .  	L NEAR	0BCD	CSEG	Global
$PUEXP . . . . . . . . . . . . .  	L NEAR	0861	CSEG
$PUF . . . . . . . . . . . . . .  	L NEAR	1D67	CSEG
$PUFE  . . . . . . . . . . . . .  	L NEAR	015E	CSEG
$PUFOT . . . . . . . . . . . . .  	L NEAR	1E81	CSEG
$PUFXE . . . . . . . . . . . . .  	L NEAR	006C	CSEG
$PUI . . . . . . . . . . . . . .  	L NEAR	1EC8	CSEG
$PUIZ  . . . . . . . . . . . . .  	L NEAR	1EF1	CSEG
$PUSHF . . . . . . . . . . . . .  	L NEAR	0BBE	CSEG
$QINT  . . . . . . . . . . . . .  	L NEAR	1C3B	CSEG
$RDL . . . . . . . . . . . . . .  	L NEAR	0947	CSEG
$RND . . . . . . . . . . . . . .  	L NEAR	1F07	CSEG
$RND0  . . . . . . . . . . . . .  	L NEAR	05A0	CSEG
$RNDA  . . . . . . . . . . . . .  	L NEAR	059A	CSEG
$RNDC  . . . . . . . . . . . . .  	L NEAR	059D	CSEG
$RNDX  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ROUND . . . . . . . . . . . . .  	L NEAR	1F90	CSEG
$ROUNM . . . . . . . . . . . . .  	L NEAR	1FCD	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:47:07
 
MATH86 8086 MATH PACK                                       Symbols-19
                                                             

$ROUNS . . . . . . . . . . . . .  	L NEAR	1FCA	CSEG
$ROUNX . . . . . . . . . . . . .  	L NEAR	1FB8	CSEG
$RSUBM . . . . . . . . . . . . .  	L NEAR	0B02	CSEG
$S32KM . . . . . . . . . . . . .  	L NEAR	052E	CSEG
$SDIV  . . . . . . . . . . . . .  	L NEAR	15FB	CSEG
$SETDB . . . . . . . . . . . . .  	L NEAR	0B3F	CSEG
$SEXPS . . . . . . . . . . . . .  	L NEAR	1203	CSEG
$SHALF . . . . . . . . . . . . .  	L NEAR	049D	CSEG
$SHDR  . . . . . . . . . . . . .  	L NEAR	0951	CSEG
$SHRA  . . . . . . . . . . . . .  	L NEAR	0962	CSEG
$SHRD  . . . . . . . . . . . . .  	L NEAR	1BB1	CSEG
$SHRM  . . . . . . . . . . . . .  	L NEAR	0954	CSEG
$SIGD  . . . . . . . . . . . . .  	L NEAR	2001	CSEG
$SIGNS . . . . . . . . . . . . .  	L NEAR	08BF	CSEG	Global
$SIN . . . . . . . . . . . . . .  	L NEAR	05CB	CSEG
$SINCN . . . . . . . . . . . . .  	L NEAR	0563	CSEG
$SNERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$SQR . . . . . . . . . . . . . .  	L NEAR	0CBA	CSEG
$SQRH  . . . . . . . . . . . . .  	L NEAR	04A1	CSEG
$SRND  . . . . . . . . . . . . .  	L NEAR	1680	CSEG
$STPRN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$TAN . . . . . . . . . . . . . .  	L NEAR	0667	CSEG
$TMERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$VABS  . . . . . . . . . . . . .  	L NEAR	0B0B	CSEG
$VADDH . . . . . . . . . . . . .  	L NEAR	08FB	CSEG
$VALNT . . . . . . . . . . . . .  	L NEAR	1839	CSEG
$VALTP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$VCMPM . . . . . . . . . . . . .  	L NEAR	0BAB	CSEG
$VCOMP . . . . . . . . . . . . .  	L NEAR	0A39	CSEG
$VINT  . . . . . . . . . . . . .  	L NEAR	0BEF	CSEG	Global
$VMOVM . . . . . . . . . . . . .  	L NEAR	0B66	CSEG
$VMVAM . . . . . . . . . . . . .  	L NEAR	0B58	CSEG
$VMVFM . . . . . . . . . . . . .  	L NEAR	0B94	CSEG
$VMVMF . . . . . . . . . . . . .  	L NEAR	0B77	CSEG
$VNEG  . . . . . . . . . . . . .  	L NEAR	0B20	CSEG
$VPOPF . . . . . . . . . . . . .  	L NEAR	0BD5	CSEG
$VPSHF . . . . . . . . . . . . .  	L NEAR	0BB6	CSEG	Global
$XCGAF . . . . . . . . . . . . .  	L NEAR	09A1	CSEG
$Z1  . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$Z1LO  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
$ZERO  . . . . . . . . . . . . .  	L NEAR	08B5	CSEG
$ZLO . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
?CSLAB . . . . . . . . . . . . .  	L NEAR	0050	CSEG


   6089 Source  Lines
   6092 Total   Lines
   1000 Symbols

  17160 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
