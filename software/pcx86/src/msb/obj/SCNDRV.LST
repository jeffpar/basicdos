Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-1
                                                            

                                ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                                 
 0008                           	.RADIX  8		; To be safe 
                                 
 0000                           CSEG	SEGMENT PUBLIC 'CODESG' 
                                	ASSUME  CS:CSEG 
                                 
                             C  INCLUDE	OEM.INC 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
                             C  	PAGE	,132D 
                             C  	SUBTTL  Common file to produce 2-segment 8086 GW-CPM BASIC 
                             C   
                             C  	.SALL 
                             C   
 000A                        C  	.RADIX	10 
 = 0000                      C  	OEMRAM=0D 
                             C  ;Pascal program HFILE searches for the following line - DO NOT MODIFY 
                             C  ;** (VERSION SPECIFIC VALUES) ************************************************ 
 = 0019                      C  	NMLINE=25		;Max screen display text lines 
 = 0001                      C  	NBANKS=1		;Number of graphic planes 
 = 0000                      C  	PALSIZ=0		;Size of OEM color palette 
 = 0000                      C  	DBLCHR=0		;Editor support for KANJI chars 
 = 0000                      C  	KANABS=0		;Kana BASIC (Japanese JIS codes) 
 = 0000                      C  	KANJFN=0		;KANJI String Functions KPOS, KLEN .. 
 = 0000                      C  	JISKTN=0		;&K, &J constants (KANJI) 
 = 0001                      C  	SUPRSH=1		;1=super shift key feature 
 = 000A                      C  	NMKEYF=10		;number of function keys 
 = 000E                      C  	NMKEYT=14		;number of function key traps 
 = 0001                      C  	FKEYON=1		;yes=display function keys 
 = 0001                      C  	SCROLT=1		;Line 25 allocated for status only 
 = 0001                      C  	PLAYSW=1		;for PLAY statement 
 = 0001                      C  	BEEPSW=1		;for SOUND, BEEP statements 
 = 0003                      C  	NMLPT=3			;number of line printers 
 = 0001                      C  	CONSSW=1		;Device CONS: 
 = 0002                      C  	NMCOMT=2		;number of COMmunications ports 
 = 0001                      C  	NMPENT=1		;number of light pens 
 = 0004                      C  	NMSTRT=4		;number of joysticks 
 = 0000                      C  	GWCASS=0		;Cassette switch (CSAVE,CLOAD,MOTOR) 
 = 0001                      C  	IBMLIK=1		;IBM compatibility package 
 = 0001                      C  	IBMTOK=1		;IBM token compatibility 
 = 0001                      C  	DYNCOM=1		;Dynamic communication buffers 
                             C  ;** (END OF VERSION SPECIFIC VALUES) ***************************************** 
                             C  ;Pascal program HFILE searches for the previous line - DO NOT MODIFY 
                             C  ; 
 = 0015                      C  	NUMTRP=NMKEYT+NMCOMT+NMPENT+NMSTRT 
 = 0001                      C  	GW=1			;GW BASIC 
 = 0000                      C  	ESCCTL=0		;Escape Sequence processing in SCROUT 
 = 0000                      C  	GWDBUG=0		;DEBUG statement (TEST VERSIONS ONLY) 
                             C  				; Support is in BINTRP.MAC and GWSTS.MAC 
 = 0000                      C  	SIXDIG=0		;# of digits of accuracy assumed when formatting 
                             C  				;single precision numbers for output. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-2
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  				; 0 := 7 digits 
                             C  				; 1 := 6 digits 
 = 0000                      C  	CASSW=0			;CASSETTE SWITCH 
 = 0001                      C  	LABKEY=1		;^T (LABEL) key capability 
 = 0001                      C  	HGHBIT=1		;8-bit characters (ASCII & Graphics) 
 = 0001                      C  	QUEUE=1			;Queued painting algorithm (vs. stack) 
 = 0001                      C  	GIO86=1			;BASIC-86 Generalized I/O 
 = 0001                      C  	SCRNIO=1		;Screen editor 
 = 0001                      C  	SCRN86=1		;8086 Screen editor 
 = 0001                      C  	I8086=1			;CROSS ASSEMBLING FOR 8086 
 = 0001                      C  	MULSEG=1		;MULTI-SEGMENT 8086 BASIC 
 = 0000                      C  	SMALL=0			;"SMALL" VERSION OF 8086 BASIC IF SET 
 = 0001                      C  	TRUROM=1 
 = 0000                      C  	SBC86=0			;SBC 86/02 BOARD? 
 = 0001                      C  	SHORTJ=1		;USE INTRA-SEGMENT SHORT JUMPS 
                             C  				;IN 8086 CODE 
 = 0001                      C  	LNGVAR=1		;LONG VARIABLE NAME SUPPORT (EXTENDED ONLY) 
 = 0000                      C  	SHTERR=0		;SHORT (2 CHAR) ERROR MESSAGES 
 = 0000                      C  	SHTINS=0		;INSTR IN NON-FAST LEN2 VERSIONS 
 = 0000                      C  	SHTLHM=0		;LEFT HAND SIDE MID IN NON FAST LEN2 VERSIONS 
 = 0000                      C  	SHTCHN=0		;ALLOW CHAIN IN NON-5.0 
 = 0000                      C  	SHTPRO=0		;ALLOW PROTECTED FILES IN NON-FIVDSK 
 = 0000                      C  	SHTLIN=0		;ALLOW LINE INPUT IN NON-EXTENDED NON-FAST 
 = 0000                      C  	SHTREN=0		;ALLOW RENUM IN NON-FST VERSIONS 
 = 0001                      C  	INKEYF=1		;ADDS INKEY$ FUNCTION 
 = 0000                      C  	NOIOS=0			;NO I/O STATMENTS (INP,OUT, WAIT) 
 = 0000                      C  	NOPEKS=0		;NO PEEK, POKE 
 = 0000                      C  	NOUSR=0			;NO USR 
 = 0000                      C  	NOCTLA=0		;NO CONTROL-A IN EXTENDED 
 = 0000                      C  	NORUBT=0		;NO RUBOUT 
 = 0000                      C  	NOROMP=0		;NO ROM PROGRAM FEATURE 
 = 0000                      C  	NOATDL=0		;NO AUTO DELETE IN NON-FAST EXTENDED 
 = 0000                      C  	NODOT=0			;NO DOT IN LEN2 
 = 0000                      C  	NOEDIT=0		;NO EDIT COMMAND 
 = 0000                      C  	CRONLY=0		;ONLY PUT OUT CR, NOT CRLF TO TERMINAL 
                             C  				;AND FILES 
 = 0000                      C  	NONULL=0		;NO NULL COMMAND, PUT OUT NULLS IN CRDO & OUTCH1 
 = 0000                      C  	NOVARP=0		;NO VARPTR FUNCTION 
 = 0001                      C  	FIVEO=1			;GENERATE VERSION WITH RELEASE 5.0 FEATURES 
 = 0001                      C  	FIVMEM=1 
 = 0001                      C  	ANSI=1 
 = 0001                      C  	FIVDSK=1		;5.0 NEW DSK CODE 
 = 0001                      C  	FIVLPT=1		;WIDTH LPRINT AND 255 FEATURE 
 = 0001                      C  	HEXOCT=1		;&H..., HEX$, &O..., OCT$ 
 = 0000                      C  	BINCSW=0		;&B..., BIN$ 
 = 0001                      C  	BLODSW=1		;BLOAD, BSAVE COMMANDS 
 = 0001                      C  	MEMIMG=1		;MEMORY IMAGE FILES 
 = 0001                      C  	GENBIN=1 
                             C   
 = 0000                      C  	TRUANS=0		;TRUE ANSI VERSION (STATIC SCAN, ON ERROR) 
 = 0000                      C  	COMMNT=0		;DONT WANT BIG COMMENT 
 = 0000                      C  	INTEL=0			;INTEL PROPRIETARY 
 = 0000                      C  	INTFSW=0		;INTEL FLOATING POINT 
 = 0000                      C  	INTFHW=0 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-3
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	RMX=0			;INTEL RMX VERSION 
 = 0000                      C  	EDIT80=0		;FOR EDIT80 I/O ROUTINES 
 = 0000                      C  	RSHACK=0 
 = 0000                      C  	INTLEC=0 
 = 0002                      C  	LENGTH=2		;  1 MEANS 8K, 2 MEANS 12K 
 = 0000                      C  	BASDEB=0		;WHETHER DBG WILL BE LOADED WITH BASIC 
 = 0001                      C  	RSTLES=1		;WHETHER BASIC WILL USE RST LOCATIONS 
                             C  				;TO MAKE ITSELF SMALLER & QUICKER 
 = 0001                      C  	REALIO=1		;WHETHER SIMULATE (=0) OR ON MACHINE (=1) 
 = 0001                      C  	GENIO=1			;USE G/P ROUTINES 
 = 0001                      C  	CHSEAT=1		;CHSNS eats chars 
 = 0000                      C  	GENDSK=0		;USE G/P DSK CODE 
 = 0000                      C  	LONGI=0			;WHETHER WE ASK "TERMINAL WIDTH?" 
                             C  				;AND WANT SIN-TAN-COS-ATN? 
 = 0000                      C  	INSTSW=0		;FOR INSTR INSTRUCTION 
 = 0001                      C  	SWAPSW=1		;FOR SWAP STATEMENT 
 = 0000                      C  	MDS=0			;FOR INTEL MDS SYSTEMS 
 = 0000                      C  	SBC=0			;FOR INTEL SINGLE BOARD COMPUTER 
                             C  				;1=SBC 80/10, 2=SBC 80/20 
 = 0001                      C  	PURE=1			;ON FOR PURE CODE 
 = 0000                      C  	KILLER=0		;FOR ROM VERSION THAT WONT RUN IN RAM 
 = 0000                      C  	INTROM=0 
 = 0001                      C  	LPTSW=1 
 = 0001                      C  	NCRLPT=1 
 = 0000                      C  	NCRCAS=0 
 = 0000                      C  	ISC=0			;FOR ISC VERSION 
 = 0000                      C  	LPT3=0			;THREE LPT DRIVER VERSION(QUME,OKIA,CENT) 
 = 0000                      C  	TSLPT=0 
                             C   
 = 0000                      C  	DOS=0			;ON TO GEN ROUTINES FOR DOS 
 = 0001                      C  	DISK=1			;FILE I/O FEATURES 
 = 0000                      C  	TIMSHR=0		;NO TIME-SHARING DISK 
 = 0000                      C  	TSDISK=0		;NO TIME-SHARING DISK FOR US 
 = 0000                      C  	SPCDSK=0		;MAY HAVE MM'S DISK CODE 
 = 0000                      C  	SPCNDS=0 
 = 0001                      C  	FAST=1			;CONSTANT COMPRESSION, RENUM & FRIENDS 
 = 0000                      C  	KEYSTA=0 
 = 0000                      C  	ISIS=0			;FOR VERSION TO RUN UNDER INTEL'S ISIS II DOS 
 = 0000                      C  	MDSISS=0		;FOR MDS VERSION THAT RUNS UNDER ISIS-II 
 = 0001                      C  	CPM=1			;FOR CPM compatible operating systems 
 = 0001                      C  	CPM2=1			;VERSION 2. CPM 
 = 0000                      C  	CPM86=0			;FOR CP/M-86 operating system 
 = 0001                      C  	SCP=1			;MS-DOS operating system 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	CPMSER=0		;CHECK CPM SERIAL #'S 
 = 0000                      C  	CPMADD=0		;FOR VERSION TO RUN ON ADDS CPM 
 = 0000                      C  	CPMA75=0		;FOR VERSION TO RUN ON ADDS SYSTEM 75 
                             C  				;CP/M 
 = 0000                      C  	CPMRSH=0		;FOR RADIO SHACK CPM/M 
 = 0000                      C  	CPM110=0		;FOR CP/M @1100 HEX (INTERALIA) 
 = 0000                      C  	CPMSBC=0		;FOR VERSION TO RUN ON SBC CP/M AT 4100H 
 = 0000                      C  	CPMPER=0		;FOR PERTEC VERSION OF CPM 
 = 0000                      C  	CPMLIF=0		;LIFEBOAT CP/M AT 4200H 
 = 0000                      C  	CPMMDS=0		;MOHAWK DATA SYSTEMS CP/M 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-4
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	CPMCON=0 
 = 0000                      C  	Z80=0 
 = 0001                      C  	DISK=1 
 = 0001                      C  	NCRLPT=1 
 = 0001                      C  	RSTLES=1 
 = 0000                      C  	DRVPOS=CPMADD 
 = 0000                      C  	TRNCHR=CPMADD 
 = 0000                      C  	INLADD=CPMADD 
 = 0001                      C  	LISTEN=1		;ON MEANS LISTEN FOR ^C 
 = 0001                      C  	LISTEN=1 
 = 0000                      C  	LEN2=0 
 = 0001                      C  	LEN2=1 
 = 0001                      C  	HEXOCT=1 
 = 0002                      C  	LENGTH=2 
 = 0001                      C  	RSTLES=1 
 = 0001                      C  	FIVLPT=1 
 = 0000                      C  	I8251=0			;THIS SWITCH IS USED FOR ROSEMOUNT VERSION 
 = 0001                      C  	CONTRO=1		;ALLOW ^O 
 = 0001                      C  	LEN3=LEN2 OR CASSW 
                             C   
                             C   
                             C   
 = 0001                      C  	STRING=1 
 = 0001                      C  	NCRLPT=1 
                             C   
                             C  ; *** OEM Switches which need to be defaulted to 0 
                             C  ; 
 = 0000                      C  	CMPUTN=0 
 = 0000                      C  	DUPONT=0 
 = 0000                      C  	EXIDY=0 
 = 0000                      C  	GESBC=0 
 = 0000                      C  	HEATH=0 
 = 0000                      C  	LOKHED=0 
 = 0000                      C  	MOSTEK=0 
 = 0000                      C  	TEK=0 
 = 0000                      C  	TRSER2=0 
 = 0000                      C  	NASCOM=0 
 = 0000                      C  	NATROM=0 
 = 0000                      C  	NCRBAS=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRELS=0 
 = 0000                      C  	ONTEL=0 
 = 0000                      C  	PCS=0 
 = 0000                      C  	SGSATS=0 
 = 0000                      C  	ALTAIR=0 
 = 0000                      C  	DMC=0 
 = 0000                      C  	PANBAS=0 
 = 0000                      C  	XTNSYS=0 
 = 0000                      C  	NECBAS=0 
                             C  ;******************************************************************* 
                             C  ; Z80 related macros 
                             C  ;******************************************************************* 
 = 0001                      C  	Z80=1			;FOR VERSION THAT RUNS ON BOTH 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-5
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  				;8080'S AND ZILOG Z-80'S 
 = 0001                      C  	Z80MAC=1		;USE 8080 MACROS INSTEAD OF Z80 INSTRUCTIONS 
 = 0000                      C  	Z80=0 
 = 0001                      C  	Z80=1 
                             C  LDIR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	INXF	H 
                             C  	INXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  LDDR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	DCXF	H 
                             C  	DCXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  DJNZ	MACRO	    DEST 
                             C  	DCR	B 
                             C  	JNZ	DEST 
                             C  ENDM 
                             C  ;******************************************************************* 
                             C  ; Define reset routines. 
                             C  ;******************************************************************* 
                             C  FSIGN	MACRO 
                             C  	CALL	SIGN 
                             C  ENDM 
                             C  PUSHM	MACRO 
                             C  	MOV	WORD PTR C,WORD PTR M 
                             C  	INX	H 
                             C  	MOV	WORD PTR B,WORD PTR M 
                             C  	INX	H 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  SYNCHK	MACRO	X 
                             C  	CALL	SYNCHR 
                             C  	DB	OFFSET X 
                             C  ENDM 
                             C  OUTCHR	MACRO 
                             C  	CALL	OUTDO 
                             C  ENDM 
                             C  CHRGET	MACRO 
                             C  	CALL	CHRGTR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	CALL	DCOMPR 
                             C  ENDM 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-6
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  GETYPE	MACRO 
                             C  	CALL	GETYPR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	DB	73O 
                             C  	DB	332O 
                             C   ENDM 
                             C  ACRLF	MACRO 
                             C  	DB	13D 
                             C  	DB	10D 
                             C  ENDM 
                             C  PUSHR	MACRO 
                             C  	PUSH	WORD PTR D 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  POPR	MACRO 
                             C  	POP	WORD PTR B 
                             C  	POP	WORD PTR D 
                             C  ENDM 
                             C  MOVRI	MACRO	B,C,D,E 
                             C  	DB	1O		; "LXI  B" 
                             C  	DB	OFFSET C 
                             C  	DB	OFFSET B 
                             C  	DB	21O		; "LXI  D" 
                             C  	DB	OFFSET E 
                             C  	DB	OFFSET D 
                             C  ENDM 
                             C  INST	MACRO	X 
                             C  	DB	OX 
                             C  ENDM 
                             C   
                             C   
 = 000F                      C  	CONTO=15		;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O) 
 = 0000                      C  	DBLTRN=0		;FOR DOUBLE PRECISION TRANSCENDENTALS 
                             C   
 = 000E                      C  	CLMWID=14D		;MAKE COMMA COLUMNS FOURTEEN CHARACTERS 
 = 0080                      C  	DATPSC=128D		;NUMBER OF DATA BYTES IN DISK SECTOR 
 = 0050                      C  	LINLN=80D		;TERMINAL LINE LENGTH 
 = 0084                      C  	LPTLEN=132D 
 = 00FF                      C  	BUFLEN=255		;LONG LINES 
 = 0028                      C  	NAMLEN=40D		;MAXIMUM LENGTH NAME -- 3 TO 127 
                             C   
 = 006E                      C  	NUMLEV=110D		;NUMBER OF STACK LEVELS RESERVED 
                             C  				;BY AN EXPLICIT CALL TO GETSTK 
 = 0004                      C  	STRSIZ=4 
 = 0003                      C  	STRSIZ=3 
 = 0003                      C  	NUMTMP=3		;NUMBER OF STRING TEMPORARIES 
 = 000A                      C  	NUMTMP=10 
                             C   
 0008                        C  	.RADIX	8 
                             C  ; 
                             C  ; Useful macros 
                             C  ; 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-7
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  ACRLF   MACRO 
                             C          DB      13D 
                             C          DB      10D 
                             C  ENDM 
                             C   
                             C  INS86   MACRO   A,B,C,D 
                             C          DB      A&O 
                             C  IFNB    <B> 
                             C          DB      B&O 
                             C  ENDIF 
                             C  IFNB    <D> 
                             C          DB      C&O 
                             C          DB      D&O 
                             C  ENDIF 
                             C  IFB     <D> 
                             C   IFNB   <C> 
                             C          DW      C 
                             C    ENDIF 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  CALLOS  MACRO 
                             C          CALL    CPMENT 
                             C  ENDM 
                             C   
                             C  POPR    MACRO 
                             C          POP     CX 
                             C          POP     DX 
                             C  ENDM 
                             C   
                             C  ADR     MACRO   X 
                             C          DW      X 
                             C  ENDM 
                             C   
                             C  DC      MACRO   ARG 
                             C          IRPC    ZZ,<ARG> 
                             C              IFDIF       <ZZ>,<">
                             C                  DB      "&ZZ&" 
                             C                  _A="&ZZ&" 
                             C              ENDIF 
                             C          ENDM 
                             C  ENDM 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-8
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C          PAGE 
                             C   
                             C  DBGBRK	MACRO 
                             C  	DB	0CDh,06h,0CCh 
                             C  	ENDM 
                                 
                                 
                                	TITLE   SCNDRV  This is the OS independent Screen Driver for GW BASIC 
                                	SUBTTL  DATA DEFINITIONS - Miscellaneous 
                                 
                                COMMENT	* 
                                	--------- --- ---- -- --------- 
                                	COPYRIGHT (C) 1982 BY MICROSOFT 
                                	--------- --- ---- -- --------- 
                                 
                                	PROGRAMMER: MARC WILSON 
                                 
                                	* 
                             C  	INCLUDE	GIO86U.INC 
                             C  ; [ This translation created 12-Jan-83 by Version 4.3 ] 
                             C   
                             C  	SUBTTL GIO86U - Device Independent I/O Constants and Macros 
                             C   
                             C  COMMENT	* 
                             C   
                             C  --------- --- ---- -- --------- 
                             C  COPYRIGHT (C) 1982 BY MICROSOFT 
                             C  --------- --- ---- -- --------- 
                             C   
                             C          Programmer: Tom Corbett,  Microsoft Inc. 
                             C   
                             C          * 
                             C   
                             C  ROFFST	MACRO	NAME,SIZE	;define record macro 
                             C  	NAME=_OFFST 
                             C  	_OFFST=_OFFST+SIZE 
                             C  ENDM  
                             C   
                             C   
                             C  ;ASCII character definitions 
                             C  ; 
 = 0003                      C  	ASCCTC=3D		;CTL-C 
 = 0008                      C  	ASCBS=8D		;backspace 
 = 0009                      C  	ASCTAB=9D		;Tab 
 = 000A                      C  	ASCLF=10D		;Line Feed 
 = 000D                      C  	ASCCR=13D		;Carriage Return 
 = 0013                      C  	ASCCTS=19D		;CTL-S 
 = 001A                      C  	ASCCTZ=26D		;Control Z (End-of-file for some devices) 
 = 001B                      C  	ASCESC=27D		;Escape 
 = 0020                      C  	ASCSPC=32D		;Space 
                             C   
                             C  ;Special File ID's (identified by 1st byte of file) 
                             C  ; 
 = 00FF                      C  	BINFID=255D		;files created by SAVE "fn" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-9
GIO86U - Device Independent I/O Constants and Macros        

 = 00FE                      C  	PROFID=254D		;files created by SAVE "fn",P 
 = 00FD                      C  	BSVFID=253D		;files created by BSAVE "fn" 
                             C   
                             C  ;Generalized I/O Function Codes: 
                             C  ; 
 = 0000                      C  	_OFFST=0		;initialize count 
                             C  	ROFFST	G_EOF,2		;test EOF for file opened to this device 
                             C  	ROFFST	G_LOC,2		;LOC 
                             C  	ROFFST	G_LOF,2		;LOF 
                             C  	ROFFST	G_CLS,2		;perform special CLOSE functions for this device 
                             C  	ROFFST	G_SWD,2		;set device width 
                             C  	ROFFST	G_RND,2		;GET/PUT random record from/to this device 
                             C  	ROFFST	G_OPN,2		;perform special OPEN functions for this device 
                             C  	ROFFST	G_SIN,2		;input 1 byte from file opened on this device 
                             C  	ROFFST	G_SOT,2		;output 1 byte to file opened on this device 
                             C  	ROFFST	G_GPS,2		;POS 
                             C  	ROFFST	G_GWD,2		;get device width 
                             C  	ROFFST	G_SCW,2		;set device column width 
                             C  	ROFFST	G_GCW,2		;get device column width 
                             C  	ROFFST	G_BIN,2		;block input from file opened on this device 
                             C  	ROFFST	G_BOT,2		;block output to file opened on this device 
                             C   
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-10
GIO86U - Device Independent I/O Constants and Macros        

                             C          PAGE 
                                 
                                	.SALL 
 0008                           	.RADIX	8 
                                 
                                ;OEM IFNDEFs 
 = 0000                         MELCO=0 
 = 0000                         CANON=0 
                                 
                                ;GENERIC IFNDEF'S: 
 = 0000                         TERMSW=0 
 = 0000                         HLPEDT=0 
 = 0001                         NMPAGE=1			;Number of pages 
 = 0001                         NEWCHP=1			;New change page routine 
 = 0001                         IBMEOL=IBMLIK			;Clear to EOL for COMPATIBILITY 
 = 0001                         IBMCSR=IBMLIK			;IBM COMPATIBILITY for cursor 
                                 
                                ;Definition of scroll types 
                                ; Choice of scroll type is by switch SCROLT. 
                                ; Switches defined here are used to implement a specific SCROLT type. 
                                ; If other scroll types are needed then additional SCROLT types should be 
                                ;   defined here. 
 = 0001                         	INVLIN=SCROLT		;Invisible (function key) Line 
 = 0000                         	FKFSRL=(SCROLT-1) AND 1	;Clear fkeys/full scroll/rewrite fkeys 
                                 
                                 
                                ;OTHER GENERIC SWITCHES(OEM SPECIFIC) 
 = 0000                         	TXTWDO=0		;list of OEM's which have window setting capability 
                                 
                                	SUBTTL  DATA DEFINITIONS - Internal routines(with usage description) 
                                 
                                 
                                ;Entry points 
                                	PUBLIC	SCNSWI		; Set CRT physical line width 
                                				;on entry:  AL=width, CL=height 
                                 
                                	PUBLIC	SCNCLR		; Clear CRT, Refresh Function Key Display, 
                                				; Home Graphics and Text Cursors 
                                				;on entry:  none 
                                 
                                	PUBLIC	SCNLOC		; Locate cursor on physical screen(1,1 = HOME) 
                                				;on entry:  AH=column(x), AL=line(y) 
                                 
                                	PUBLIC	SCNOUT		; Character output at current position 
                                				;on entry:  AX=character 
                                 
                                	PUBLIC	SCNRDL		; Read a physical line at current position 
                                				;on entry:  DI=address of where to put string, CX=max count 
                                				;on exit:   CX=CX-number of characters read 
                                				;           DI=DI+number of characters read 
                                 
                                 
                                	PUBLIC	SCNPOS		; Return current cursor location 
                                				;on exit:   DL=cursor line, DH=cursor column 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-11
DATA DEFINITIONS - Internal routines(with usage description)

                                 
                                	PUBLIC	SCNRDT		; Read terminator for physical line 
                                				;on entry:  DL=line number 
                                				;on exit:   AH= terminator column, AL=terminator value 
                                				;           Flags indicate terminator value: 
                                				;           CF=EOL, ZF=Linefeed 
                                 
                                	PUBLIC	SCNGWI		; Read logical width of lines 
                                				;on exit:   AH=logical width of lines 
                                 
                                	PUBLIC	SCNMRK		; Mark position as current FSTPOS, LSTPOS 
                                				;on entry:  ZF set indicates use WDOLFT as column 
                                				;           ZF clear indicates use CSRX as column 
                                 
                                	PUBLIC	SCNIPL		; Initialize - called during IPL 
                                 
                                	PUBLIC	SCNBRK		; Initialize - called when BREAK received by POLKEY 
                                	SUBTTL  DATA DEFINITIONS - External routines and data 
                                 
                                 
                                 
                                ;EXTERNAL ROUTINES 
                                	EXTRN	SCROLL:NEAR	; OEM supplied SCROLL routine 
                                	EXTRN	SCROUT:NEAR	; OEM supplied character output 
                                	EXTRN	SCRINP:NEAR	; OEM supplied screen input(read character) 
                                	EXTRN	CLREOL:NEAR	; OEM supplied screen clear to end of line 
                                 
                                ;THE FOLLOWING IS DATA UNIQUE TO THE SCNDRV MODULE 
                                ;       ALL DATA IS ONE BYTE LONG UNLESS STATED OTHERWISE 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	ASSUME DS:DSEG 
                                	EXTRN	LINCNT:WORD	; Number of lines 
                                	EXTRN	CRTWID:WORD	; Characters per line 
                                	EXTRN	WDOTOP:WORD	; Top line in window(1-[LINCNT]) 
                                	EXTRN	WDOBOT:WORD	; Bottom line in window([WDOTOP]-[LINCNT]) 
                                	EXTRN	WDOLFT:WORD	; Leftmost column in window(1-[CRTWID]) 
                                	EXTRN	WDORGT:WORD	; Rightmost column plus one([WDOLFT]-[LINCNT]) 
                                	EXTRN	LINLEN:WORD	; Line max width(1 to CRTWID) 
                                	EXTRN	LINTTB:WORD	; Line terminator table((# lines * 2) bytes long) 
                                				; Two items per entry: 
                                				;   Terminator, last column 
                                	EXTRN	TRMCUR:WORD	; Address of current terminator entry(2 bytes) 
                                	EXTRN	FSTLIN:WORD	; Line number saved by SCNSTM call 
                                	EXTRN	FSTCOL:WORD	; Column saved as above and decreases to WDOLFT 
                                	EXTRN	LSTLIN:WORD	; Line number saved by SCNSTM and grows as the 
                                				;   logical line grows. 
                                	EXTRN	LSTCOL:WORD	; Column saved as above which grows as the logical 
                                				;   line grows(always reflects last col on LSTLIN). 
                                	EXTRN	F_CRET:WORD	; Zero indicates last character output was CR 
                                	EXTRN	CSRY:WORD	; Current line(1-[LINCNT]) 
                                	EXTRN	CSRX:WORD	; Current column(1-[CRTWID]) 
                                	EXTRN	KEYSW:WORD	; ^O377=Function Keys displayed on bottom line 
                                 
                                ;THE FOLLOWING DATA IS ACCESSED BY SCNDRV BUT SET ELSEWHERE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-12
DATA DEFINITIONS - External routines and data               

                                	EXTRN	F_EDIT:WORD	; Set to non-zero by INLIN when editing 
                                	EXTRN	F_INST:WORD	; Set to non-zero by INLIN for insert mode 
 0000                           DSEG	ENDS 
                                	SUBTTL  DATA DEFINITIONS - Literals 
                                 
                                 
                                 
                                ;CHARACTER DEFINITIONS 
                                ; 
 = 0001                         	CHREDT=1		; EDiT 
 = 0002                         	CHRBKW=2		; BacK Word 
 = 0003                         	CHRCAN=3		; CANcel 
 = 0004                         	CHRHCN=4		; Hard CaNcel 
 = 0005                         	CHRCLE=5		; CLear to End of line 
 = 0006                         	CHRFDW=6		; ForwarD Word 
 = 0007                         	CHRBEL=7		; BELl 
 = 0008                         	CHRBAK=8D		; BAcKspace 
 = 0009                         	CHRTAB=9D		; TAB 
 = 000A                         	CHRLNF=10D		; LiNeFeed 
 = 000B                         	CHRHOM=11D		; HOMe 
 = 000C                         	CHRERA=12D		; ERAse 
 = 000D                         	CHRRET=13D		; RETurn 
 = 000E                         	CHRAPP=14D		; APPend 
 = 0012                         	CHRINS=18D		; INSert 
 = 0014                         	CHRFKD=20D		; Function Key Display key 
 = 0015                         	CHRLDL=21D		; Line DeLete 
 = 001C                         	CHRADV=28D		; cursor RiGhT 
 = 001D                         	CHRREG=29D		; cursor LeFT 
 = 001E                         	CHRUP=30D		; cursor UP 
 = 001F                         	CHRDWN=31D		; cursor DoWN 
 = 007F                         	CHRDEL=127D		; DELete 
                                 
                                ;TERMINATOR TABLE LITERALS 
                                PUBLIC	TRMLNF 
 = 000A                         	TRMLNF=10D		; LINEFEED terminator 
                                PUBLIC	TRMEOL 
 = 007F                         	TRMEOL=177O		; EOL terminator 
                                PUBLIC	TRMWRP 
 = 0000                         	TRMWRP=0		; WRAP terminator 
                                PUBLIC	TRMNWP 
 = 0001                         	TRMNWP=1		; NULL WRAP terminator 
                                PUBLIC	TRMNUL 
 = 0080                         	TRMNUL=200O		; Sign bit indicates initialize line 
                                 
                                ;DEFAULT SCREEN SIZE 
                                PUBLIC	SCNSIZ 
 = 2814                         	SCNSIZ=20D+(40D*400O)	; Height = 20, Width = 40 
                                 
                                	SUBTTL  SCNIPL, SCNSWI AND SCNWDO   The parameter setting routines 
                                 
                                 
                                 
                                ;SUBROUTINE SCNIPL():           ; Initialize 
                                ;** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-13
SCNIPL, SCNSWI AND SCNWDO   The parameter setting routines  

 0000                           SCNIPL: 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	ESCFLG:WORD 
 0000                           DSEG	ENDS 
 0000  C6 06 0000 E 00          	MOV	BYTE PTR ESCFLG,LOW 0 
 0005  C3                       	RET 
                                ;** END SUBROUTINE SCNIPL 
                                 
                                ;BREAK - reset flags etc. when ^C typed. 
                                ; 
 0006  C6 06 0000 E 00          SCNBRK:	MOV	BYTE PTR FSTLIN,LOW 0 
 000B  C6 06 0000 E FF          	MOV	BYTE PTR LSTLIN,LOW 377O	; Set FSTPOS, LSTPOS to impossible values 
 0010  C6 06 0000 E FF          	MOV	BYTE PTR F_CRET,LOW 377O	; Clear "last char was CR" flag 
 0015  C3                       	RET 
                                 
                                ;SUBROUTINE SCNSWI(WIDTH,HEIGHT):       ; Set screen width(logical/physical) and height 
                                ;**                     on entry:   AL=width, CL=height 
                                ;** 
 0016  A2 0000 E                SCNSWI:	MOV	BYTE PTR CRTWID,AL	; Save physical width 
 0019  A2 0000 E                	MOV	BYTE PTR LINLEN,AL	; Set logical line length 
 001C  88 0E 0000 E             	MOV	BYTE PTR LINCNT,CL	; Save physical height 
 0020  C6 06 0000 E 01          	MOV	BYTE PTR WDOTOP,LOW 1	; Init window top 
 0025  51                       	PUSH	CX 
 0026  FE C9                    	DEC	CL		; Reserve status line 
 0028  88 0E 0000 E             	MOV	BYTE PTR WDOBOT,CL	; Set window bottom 
 002C  59                       	POP	CX 
 002D  C6 06 0000 E 01          	MOV	BYTE PTR WDOLFT,LOW 1	; Set window left 
 0032  A2 0000 E                	MOV	BYTE PTR WDORGT,AL	; Set window right 
 0035  C3                       	RET 
                                ;** *** END 
                                ;** END SUBROUTINE SCNSWI 
                                 
                                 
                                ;SUBROUTINE SCNWDO(POSN,COUNT): ; Set text window 
                                ;** 
                                ;**                             on entry:   AH=column posn, AL=line posn 
                                ;**                                         CH=width, CL=height 
                                ;**                             on exit:    AX,CX=values actually set 
                                ;**                                         CF indicates posn outside screen 
                                ;** 
                                ;**                             NOTE: This routine truncates width and height. 
                                ;** 
                                ;** IF POSN IS CONTAINED WITHIN PHYSICAL SCREEN BEGIN 
                                	SUBTTL CURSOR READ/WRITE 
                                 
                                 
                                 
                                ;SUBROUTINE SCNLOC(X,Y):        ; Locate cursor on physical screen 
                                ;**                         on entry:   AH=column, AL=line(1,1 is home) 
                                ;** 
 0036  88 26 0000 E             SCNLOC:	MOV	BYTE PTR CSRX,AH 
 003A  A2 0000 E                	MOV	BYTE PTR CSRY,AL 
 003D  C3                       	RET 
                                ;** END SUBROUTINE SCNLOC 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-14
CURSOR READ/WRITE                                           

                                 
                                ;SUBROUTINE SCNCLR(X,Y):        ; Clear Screen, Home Text & Graphics Cursor, 
                                ;                               ; Refresh Function Key Display 
                                ;**                         on entry: 
                                ; 
                                	EXTRN	KEYDSP:NEAR,GRPINI:NEAR 
 003E                           SCNCLR: 
 003E  E8 009E R                	CALL	TTBINI		;Clear the terminator table 
 0041  E8 0000 E                	CALL	GRPINI		;Home the graphics cursor 
 0044  E8 0752 R                	CALL	WHOME		;DX=cursor home 
 0047  8B C2                    	MOV	AX,DX 
 0049  E8 0036 R                	CALL	SCNLOC		;set cursor position 
 004C  E9 0000 E                	JMP	KEYDSP		;Conditionally display softkeys and return 
                                ;** END SUBROUTINE SCNCLR 
                                 
                                ;SUBROUTINE SCNPOS              ; Read current cursor location 
 004F  8A 36 0000 E             SCNPOS:	MOV	DH,BYTE PTR CSRX 
 0053  8A 16 0000 E             	MOV	DL,BYTE PTR CSRY 
 0057  9C                       	PUSHF 
 0058  3A 36 0000 E             	CMP	DH,BYTE PTR LINLEN 
 005C  76 04                    	JBE	SCNPS1		;BRIF not beyond edge of screen 
 005E  8A 36 0000 E             	MOV	DH,BYTE PTR LINLEN	;Force posn within screen 
 0062  9D                       SCNPS1:	POPF 
 0063  C3                       	RET 
                                ;** END SUBROUTINE SCNPOS 
                                 
                                ;SUBROUTINE SCNGWI              ; Read current logical width 
                                ;**                         on exit:    AH=width 
                                ;** 
 0064  8A 26 0000 E             SCNGWI:	MOV	AH,BYTE PTR LINLEN 
 0068  C3                       	RET 
                                ;** END SUBROUTINE SCNGWI 
                                	SUBTTL  TERMINATOR TABLE READ/WRITE/INITIALIZE 
                                 
                                 
                                ;SUBROUTINE SCNRDT(Y):          ; Read terminator value and column 
                                ;**                         on entry:   DL=line number 
                                ;**                         on exit:    AH=terminator posn, AL=terminator value 
                                ;**                                     If CF=1; EOL 
                                ;**                                     If CF=0 and ZF=1; LF terminated 
                                ;** 
 0069  53                       SCNRDT:	PUSH	BX 
 006A  8A DA                    	MOV	BL,DL		; BX = Displacement into table 
 006C  02 DB                    	ADD	BL,BL 
 006E  B7 00                    	MOV	BH,LOW 0 
 0070  89 1E 0000 E             	MOV	WORD PTR TRMCUR,BX	; Save address of terminator reading(for set term) 
 0074  8A A7 FFFE E             	MOV	AH,BYTE PTR LINTTB-2[BX]	; Get terminator posn 
 0078  8A 87 FFFF E             	MOV	AL,BYTE PTR LINTTB-1[BX]	; Get terminator value 
 007C  24 7F                    	AND	AL,LOW OFFSET 377O-TRMNUL	; Get rid of initialize line status bit 
 007E  3C 7F                    	CMP	AL,LOW OFFSET TRMEOL 
 0080  F9                       	STC 
 0081  74 05                    	JZ	SCNRTX		; BRIF EOL terminator(CF=1) 
 0083  3C 0A                    	CMP	AL,LOW OFFSET TRMLNF	; CF=0, set ZF if linefeed terminated 
 0085  73 01                    	JNB	SCNRTX		; BRIF carry not set 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-15
TERMINATOR TABLE READ/WRITE/INITIALIZE                      

 0087  F5                       	CMC			; clear carry 
 0088  5B                       SCNRTX:	POP	BX 
 0089  C3                       	RET 
                                ;** END SUBROUTINE SCNRDT 
                                 
                                 
                                ;SUBROUTINE SCNWTT(TERM)        ; Set new value for terminator last read 
                                ;**                     on entry:   AH=column where physical line ends 
                                ;**                                 AL=terminator type(one of: TRMEOL, TRMLNF 
                                ;**                                     TRMWRP, TRMNWP) 
                                ;** 
 008A  53                       SCNWTT:	PUSH	BX 
 008B  8B 1E 0000 E             	MOV	BX,WORD PTR TRMCUR	; Get address of terminator last read 
 008F  88 A7 FFFE E             	MOV	BYTE PTR LINTTB-2[BX],AH 
 0093  80 A7 FFFF E 80          	AND	BYTE PTR LINTTB-1[BX],LOW OFFSET TRMNUL 
 0098  08 87 FFFF E             	OR	BYTE PTR LINTTB-1[BX],AL	; Write new terminator, leaving NULL bit 
 009C  5B                       	POP	BX 
 009D  C3                       	RET 
                                ;** END SUBROUTINE SCNWTT 
                                 
                                ;TERMINATOR TABLE INIT 
                                ; 
 009E  B9 001A                  TTBINI:	MOV	CX,OFFSET NMLINE+1	; CX=count of line term table entries 
 00A1  BB 0000 E                	MOV	BX,OFFSET LINTTB	; BX=addr of line term table 
 00A4  C6 07 00                 TTBIN0:	MOV	BYTE PTR 0[BX],LOW 0	; Clear column number 
 00A7  C6 47 01 7F              	MOV	BYTE PTR 1[BX],LOW OFFSET TRMEOL	; Set terminator to <CR> 
 00AB  43                       	INC	BX 
 00AC  43                       	INC	BX 
 00AD  E2 F5                    	LOOP	TTBIN0		; Init entire line terminator table 
 00AF  C3                       	RET 
                                	SUBTTL  CHARACTER OUTPUT 
                                 
                                 
                                 
                                ;SUBROUTINE SCNOUT(CHAR):       ; Output character 
                                ;**                         on entry:   AX= character 
                                ;** 
                                 
 00B0  52                       SCNOUT:	PUSH	DX 
 00B1  51                       	PUSH	CX 
 00B2  53                       	PUSH	BX 
 00B3  E8 0542 R                	CALL	CTLDSP		; If control char or ESC sequence, do operation 
 00B6  72 13                    	JB	SCNOTX		; No char to output 
 00B8  E8 00EB R                	CALL	CHWRAP		; Do wrap for char in AX, return DX=posn for output 
                                	EXTRN	SETCSR:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	CSRTYP:WORD 
 0000                           DSEG	ENDS 
 00BB  C6 06 0000 E 00          	MOV	BYTE PTR CSRTYP,LOW 0D	; Set next cursor type to off 
 00C0  E8 0000 E                	CALL	SETCSR		; Insure that the cursor is off 
                                 
 00C3  E8 0000 E                	CALL	SCROUT		; Send char in AX to BIOS at DX posn 
 00C6  C6 06 0000 E FF          	MOV	BYTE PTR F_CRET,LOW 377O	; Clear last char was Carriage return flag 
 00CB  5B                       SCNOTX:	POP	BX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-16
CHARACTER OUTPUT                                            

 00CC  59                       	POP	CX 
 00CD  5A                       	POP	DX 
 00CE  C3                       	RET 
                                ;** END SUBROUTINE SCNOUT 
                                 
                                ;SUBROUTINE MKRMCI              ; Open up sapce for char if insert mode 
                                ; 
 00CF  9C                       MKRMCI:	PUSHF 
 00D0  F6 06 0000 E FF          	TEST	BYTE PTR F_INST,LOW 377O 
 00D5  74 0C                    	JZ	MKRCIX		; BRIF not insert mode(do nothing) 
 00D7  9D                       	POPF 
 00D8  8A E8                    	MOV	CH,AL 
 00DA  FE C5                    	INC	CH		; CH=space needed 
 00DC  E8 0B78 R                	CALL	MKRMCH		; Open up space at (DH,DL) for count of CH 
 00DF  E8 00E5 R                	CALL	SCNRDX		; Put terminator table values in CX 
 00E2  C3                       	RET 
 00E3  9D                       MKRCIX:	POPF 
 00E4  C3                       	RET 
                                 
 00E5  91                       SCNRDX:	XCHG	AX,CX 
 00E6  E8 0069 R                	CALL	SCNRDT 
 00E9  91                       	XCHG	AX,CX 
 00EA  C3                       	RET 
                                	SUBTTL  LINE WRAP LOGIC - Character wrap 
                                 
                                 
                                 
                                ;THE LINE WRAP LOGIC IS USED PRIOR TO OUTPUTTING CHARACTERS OR STRINGS 
                                ;   IT WILL RESERVE THE NECESSARY NUMBER OF CHARACTERS ON THE CURRENT 
                                ;   LOGICAL LINE OR WILL RETURN CARRY SET AND DX=POSN WHERE CHARACTER 
                                ;   CAN BE OUTPUT(I.E. IT RETURNS A POSN LESS THAN CURRENT POSN) 
                                 
                                ;SUBROUTINE CHWRAP(CHAR):       ; Do single character wrap 
                                ;**                     on entry:   AX=character 
                                ;**                                 DH=CSRX, DL=CSRY 
                                ;**                     on exit:    if cannot wrap, CF=1 
                                ;**                                 DX=posn where character can be output 
                                ;**                                 cursor posn and terminator table are updated 
                                ;**                     NOTE: if CF=1 then DX may be set to a previous posn 
                                ;**                         where there is enough room to EOL. 
                                ;** 
 00EB  50                       CHWRAP:	PUSH	AX 
 00EC  32 ED                    	XOR	CH,CH 
 00EE  0A E4                    	OR	AH,AH 
 00F0  74 02                    	JZ	CHWRP0		; BRIF Single byte character 
 00F2  B5 01                    	MOV	CH,LOW 1	; It's two byte character 
 00F4  8A CD                    CHWRP0:	MOV	CL,CH 
 00F6  02 EE                    	ADD	CH,DH		; CH=column after char is output 
 00F8  E8 0069 R                	CALL	SCNRDT		; Read terminator 
 00FB  91                       	XCHG	CX,AX 
                                ;** IF POSN .LT. EOL BEGIN 
                                ;** AT THIS POINT AH=POSN(WHERE GOING TO), DX=CURRENT POSN, 
                                ;** AL=LENGTH OF CHARACTER, CX=CURRENT TERMINATORS 
 00FC  9C                       	PUSHF 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-17
LINE WRAP LOGIC - Character wrap                            

 00FD  3A 26 0000 E             	CMP	AH,BYTE PTR LINLEN 
 0101  77 41                    	JA	CHWRP1		; BRIF not space before end of physical line 
 0103  9D                       	POPF 
 0104  E8 00CF R                	CALL	MKRMCI		; If insert mode, open up space for character 
                                ;** *** IF NOT(LINEFEED .EQ. TERMINATOR(CURRENT_LINE) AND POSN .EQ. LINLEN) 
                                ;** *** *** RETURN, OUTPUT IS AT CURRENT POSN 
 0107  72 0F                    	JB	CHWPXI		; EOL terminated, output at current posn 
 0109  74 10                    	JZ	CHWPLF		; BRIF LF terminated 
 010B  80 F9 00                 	CMP	CL,LOW OFFSET TRMWRP 
 010E  74 08                    	JZ	CHWPXI		; BRIF WRAP(always room) 
 0110  3A 26 0000 E             	CMP	AH,BYTE PTR LINLEN 
 0114  72 02                    	JB	CHWPXI		; BRIF NUL_WRAP and not overwriting NULL 
 0116  B1 00                    	MOV	CL,LOW OFFSET TRMWRP 
 0118  EB 6D 90                 CHWPXI:	JMP	CHWRPX		; Overwriting NULL_WRAP, set to WRAP 
 011B  3A 26 0000 E             CHWPLF:	CMP	AH,BYTE PTR LINLEN 
 011F  73 14                    	JAE	CHWPL1		; LF terminated and no room for LF 
 0121  FE C4                    	INC	AH		; Need to terminate at one past posn printing at 
 0123  91                       	XCHG	AX,CX 
 0124  3A E5                    	CMP	AH,CH 
 0126  8A E5                    	MOV	AH,CH 
 0128  77 03                    	JA	CHWPL0		; BRIF current posn below terinator posn 
 012A  E8 008A R                	CALL	SCNWTT		; Terminate line at one more than print posn 
 012D  F8                       CHWPL0:	CLC 
 012E  91                       	XCHG	AX,CX 
 012F  9C                       	PUSHF 
 0130  FE CC                    	DEC	AH		; Restore column actually printing at 
 0132  E9 01BD R                	JMP	CHWRP9		; Update LSTPOS, FSTPOS, cursor posn, exit 
                                ;** *** *** ELSE MOVE LINEFEED TO NEXT LINE 
 0135  E8 0201 R                CHWPL1:	CALL	WRAPLF		; Move linefeed to next line 
 0138  72 07                    	JB	CHWRNI		; Error, output at posn-(char length) 
 013A  F8                       	CLC 
 013B  9C                       	PUSHF 
 013C  8A E5                    	MOV	AH,CH 
 013E  EB 7D 90                 	JMP	CHWRP9		; Exit without updating terminator 
 0141  EB 65 90                 CHWRNI:	JMP	CHWRNO 
                                ;** *** END 
                                 
                                ;** *** DO CASE TERMINATOR(CURRENT_LINE) OF 
                                ;** *** There is not enough room on current line for character 
 0144  9D                       CHWRP1:	POPF 
 0145  72 43                    	JB	CHWREL		; BRIF EOL terminated 
 0147  74 4B                    	JZ	CHWRLF		; BRIF LF terminated 
                                ;** *** CASE: WRAP; NULL_WRAP; BEGIN 
                                ;** *** *** *** SET WRAP TERMINATOR 
 0149  B1 00                    CHWRWP:	MOV	CL,LOW OFFSET TRMWRP 
 014B  8A 2E 0000 E             	MOV	CH,BYTE PTR LINLEN 
 014F  91                       	XCHG	AX,CX 
 0150  E8 008A R                	CALL	SCNWTT		; Set wrap terminator at last column 
 0153  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0157  75 09                    	JNZ	CHWRN0		; BRIF not on last line 
 0159  FE 06 0000 E             	INC	BYTE PTR LSTLIN	; Wrap LSTLIN 
 015D  C6 06 0000 E 00          	MOV	BYTE PTR LSTCOL,LOW 0	; Force update of LSTCOL at CHWRPZ 
 0162  FE C2                    CHWRN0:	INC	DL		; Next line 
 0164  E8 0069 R                	CALL	SCNRDT		; Set up for write at new line 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-18
LINE WRAP LOGIC - Character wrap                            

 0167  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; First column is output posn 
 016B  8A EE                    	MOV	CH,DH 
 016D  02 E9                    	ADD	CH,CL		; CH=POSN going to 
 016F  91                       	XCHG	AX,CX 
 0170  E8 00CF R                	CALL	MKRMCI		; If insert mode, open up space for character 
 0173  80 F9 0A                 	CMP	CL,LOW OFFSET TRMLNF 
 0176  75 0F                    	JNZ	CHWRPX		; BRIF not linefeed terminated 
 0178  91                       	XCHG	AX,CX		; CH=POSN, AX=current terminators 
 0179  FE C5                    	INC	CH		; Need terminator one beyond actual output 
 017B  3A E5                    	CMP	AH,CH 
 017D  8A E5                    	MOV	AH,CH 
 017F  77 03                    	JA	CHWRN2		; BRIF Current terminator beyond posn for output 
 0181  E8 008A R                	CALL	SCNWTT		; Set current terminator to new max posn 
 0184  FE CD                    CHWRN2:	DEC	CH		; Restore POSN going to 
 0186  91                       	XCHG	AX,CX 
 0187  F8                       CHWRPX:	CLC 
 0188  EB 23                    	JMP	SHORT CHWRPZ	; All done 
                                ;** *** *** *** END 
                                ;** *** *** END 
                                ;** *** CASE: EOL 
 018A  E8 021B R                CHWREL:	CALL	MKRMNL		; Make room on next line(make it EOL term'd) 
 018D  72 15                    	JB	CHWRP3		; If error, make room for char on this line 
 018F  E8 00E5 R                	CALL	SCNRDX		; Reread terminator for this line 
 0192  EB B5                    	JMP	SHORT CHWRWP	; Wrap to next line 
                                ;** *** CASE: LF 
 0194  91                       CHWRLF:	XCHG	AX,CX 
 0195  E8 0201 R                	CALL	WRAPLF		; First wrap LF to next line 
 0198  B0 01                    	MOV	AL,LOW OFFSET TRMNWP	; Set to temporary NULL_WRAP at last column 
 019A  8A 26 0000 E             	MOV	AH,BYTE PTR LINLEN 
 019E  E8 008A R                	CALL	SCNWTT 
 01A1  91                       	XCHG	AX,CX 
 01A2  73 A5                    	JNB	CHWRWP		; Go do wrap for char 
                                ;No room, abort 
 01A4  8A 26 0000 E             CHWRP3:	MOV	AH,BYTE PTR LINLEN	; AH=POSN going to 
 01A8  8A F4                    CHWRNO:	MOV	DH,AH 
 01AA  2A F0                    	SUB	DH,AL		; DH=POSN-(char len) 
 01AC  F9                       	STC			; Error return 
                                ;** *** END CASE TERMINATOR(CURRENT_LINE) 
                                 
                                ;** EXIT 
 01AD  9C                       CHWRPZ:	PUSHF 
 01AE  91                       	XCHG	AX,CX		; CH=POSN, AX=current terminators 
 01AF  3A E5                    	CMP	AH,CH 
 01B1  8A E5                    	MOV	AH,CH 
 01B3  77 08                    	JA	CHWRP9		; BRIF Current terminator beyond posn for output 
 01B5  50                       	PUSH	AX 
 01B6  E8 0069 R                	CALL	SCNRDT 
 01B9  58                       	POP	AX 
 01BA  E8 008A R                	CALL	SCNWTT		; Set current terminator to new max posn 
 01BD  88 16 0000 E             CHWRP9:	MOV	BYTE PTR CSRY,DL 
 01C1  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 01C5  75 0A                    	JNZ	CHWNTL		; BRIF not on last logical line 
 01C7  3A 26 0000 E             	CMP	AH,BYTE PTR LSTCOL 
 01CB  72 04                    	JB	CHWNTL		; BRIF not new last position 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-19
LINE WRAP LOGIC - Character wrap                            

 01CD  88 26 0000 E             	MOV	BYTE PTR LSTCOL,AH	; Set new last posn 
 01D1  3A 16 0000 E             CHWNTL:	CMP	DL,BYTE PTR FSTLIN 
 01D5  75 0A                    	JNZ	CHWNTF		; BRIF not on first logical line 
 01D7  3A 36 0000 E             	CMP	DH,BYTE PTR FSTCOL 
 01DB  73 04                    	JAE	CHWNTF		; BRIF not new first position 
 01DD  88 36 0000 E             	MOV	BYTE PTR FSTCOL,DH 
 01E1  FE C4                    CHWNTF:	INC	AH 
 01E3  88 26 0000 E             	MOV	BYTE PTR CSRX,AH	; Set new posn(one past last posn printed at) 
 01E7  38 26 0000 E             	CMP	BYTE PTR LINLEN,AH 
 01EB  73 11                    	JAE	CHWNTG		; BRIF does not go beyond end of physical line 
 01ED  E8 0069 R                	CALL	SCNRDT 
 01F0  72 0C                    	JB	CHWNTG		; BRIF line does not continue 
 01F2  FE 06 0000 E             	INC	BYTE PTR CSRY	;   Logical line continues, put cursor at 
 01F6  8A 26 0000 E             	MOV	AH,BYTE PTR WDOLFT	;       start of next physical line 
 01FA  88 26 0000 E             	MOV	BYTE PTR CSRX,AH 
 01FE  9D                       CHWNTG:	POPF 
 01FF  58                       	POP	AX 
 0200  C3                       	RET 
                                ;Wrap linefeed on end of line to next line 
 0201  FF 36 0000 E             WRAPLF:	PUSH	WORD PTR TRMCUR 
 0205  51                       	PUSH	CX 
 0206  52                       	PUSH	DX 
 0207  8A 36 0000 E             	MOV	DH,BYTE PTR LINLEN 
 020B  B5 01                    	MOV	CH,LOW 1 
 020D  E8 0B78 R                	CALL	MKRMCH		; Insert one space before LF 
 0210  59                       	POP	CX 
 0211  8A CA                    	MOV	CL,DL 
 0213  5A                       	POP	DX 
 0214  87 CA                    	XCHG	CX,DX 
 0216  8F 06 0000 E             	POP	WORD PTR TRMCUR 
 021A  C3                       	RET 
                                	SUBTTL  LINE WRAP LOGIC - Open next line for wrap 
                                 
                                 
                                 
                                ;SUBROUTINE MKRMNL(line)        ; Make the next line a blank, empty line 
                                ;**                     on entry:   DL=current line number 
                                ;**                     on exit:    DL=current line number(may change from entry) 
                                ;**                                 if CF=1 no room available 
                                ;** 
 021B  50                       MKRMNL:	PUSH	AX 
 021C  53                       	PUSH	BX 
 021D  51                       	PUSH	CX 
 021E  52                       	PUSH	DX 
 021F  E8 0069 R                MKRMN0:	CALL	SCNRDT 
 0222  72 12                    	JB	MKRMN5 
 0224  3A 16 0000 E             	CMP	DL,BYTE PTR WDOBOT 
 0228  74 10                    	JZ	MKRMN6 
 022A  72 06                    	JB	MKRMN4 
 022C  8A 16 0000 E             	MOV	DL,BYTE PTR WDOBOT 
 0230  EB ED                    	JMP	SHORT MKRMN0 
 0232  FE C2                    MKRMN4:	INC	DL 
 0234  EB E9                    	JMP	SHORT MKRMN0 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-20
LINE WRAP LOGIC - Open next line for wrap                   

                                ;** IF CURRENT_PHYSICAL .LT. WINDOW_BOTTOM 
 0236  3A 16 0000 E             MKRMN5:	CMP	DL,BYTE PTR WDOBOT 
 023A  5A                       MKRMN6:	POP	DX 
 023B  52                       	PUSH	DX		; Get back posn to scroll from 
 023C  74 19                    	JZ	MKRMN7		; BRIF at bottom of window(scroll up) 
 023E  F5                       	CMC 
 023F  72 13                    	JB	MKRMNZ		; BRIF outside of window 
 0241  3A 16 0000 E             	CMP	DL,BYTE PTR WDOTOP 
 0245  72 0D                    	JB	MKRMNZ		; BRIF outside of window 
 0247  F6 06 0000 E FF          	TEST	BYTE PTR F_EDIT,LOW 377O 
 024C  74 06                    	JZ	MKRMNZ		; BRIF not editing, no need to scroll 
 024E  FE C2                    	INC	DL		; Scroll down starting at next line 
                                ;** *** SCROLL DOWN 
 0250  E8 030E R                	CALL	SCRLD0		; Scroll down to end of window 
 0253  F8                       MKRMNY:	CLC			; Indicate successful 
 0254  5A                       MKRMNZ:	POP	DX		; Restore current line number 
 0255  EB 28                    	JMP	SHORT MKRMNX 
                                ;** *** ELSE IF (FIRST_PHYSICAL(LOGICAL) .NE. WINDOW_TOP) OR NOT(INPUT_EDIT) 
 0257  F6 06 0000 E FF          MKRMN7:	TEST	BYTE PTR F_EDIT,LOW 377O 
 025C  74 0C                    	JZ	MKRMN9		; BRIF not input edit, always allow scroll 
 025E  E8 0D52 R                MKRMN8:	CALL	CSRUP 
 0261  72 F1                    	JB	MKRMNZ		; BRIF logical line starts at top of window(abort) 
 0263  50                       	PUSH	AX 
 0264  E8 0069 R                	CALL	SCNRDT 
 0267  58                       	POP	AX 
 0268  73 F4                    	JNB	MKRMN8		; BRIF previous physical part of this logical 
                                ;** *** SCROLL UP 
 026A  5A                       MKRMN9:	POP	DX 
 026B  52                       	PUSH	DX 
 026C  3A 16 0000 E             	CMP	DL,BYTE PTR WDOBOT	; Full screen scroll? 
 0270  73 05                    	JAE	MKRMNF		; BRIF scroll up entire screen 
 0272  E8 0283 R                	CALL	SCRLUD		; Scroll up from DL to WDOTOP 
 0275  EB 03                    	JMP	SHORT MKRMNU 
 0277  E8 028C R                MKRMNF:	CALL	SCRLUP		; Scroll up entire window 
 027A  5A                       MKRMNU:	POP	DX 
 027B  E8 0D52 R                	CALL	CSRUP		; Return line number of original line 
 027E  F8                       	CLC 
 027F  59                       MKRMNX:	POP	CX 
 0280  5B                       	POP	BX 
 0281  58                       	POP	AX 
 0282  C3                       	RET 
                                	SUBTTL  SCROLL ROUTINES - Scroll up and down 
                                 
                                 
                                ;Scroll up from DL to WDOTOP 
 0283  51                       SCRLUD:	PUSH	CX 
 0284  8A CA                    	MOV	CL,DL 
 0286  8A 16 0000 E             	MOV	DL,BYTE PTR WDOTOP 
 028A  EB 09                    	JMP	SHORT SCRLU1 
                                ;SCROLL UP 
 028C  8A 16 0000 E             SCRLUP:	MOV	DL,BYTE PTR WDOTOP	; Top line number 
                                ;Scroll up from DL to bottom 
 0290  51                       SCRLU0:	PUSH	CX 
 0291  8A 0E 0000 E             	MOV	CL,BYTE PTR WDOBOT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-21
SCROLL ROUTINES - Scroll up and down                        

 0295  50                       SCRLU1:	PUSH	AX 
 0296  53                       	PUSH	BX 
 0297  52                       	PUSH	DX 
 0298  8A C2                    	MOV	AL,DL 
 029A  8A DA                    	MOV	BL,DL		; From = To = Top line number 
 029C  FE C0                    	INC	AL		; From = To + 1 
 029E  8A 3E 0000 E             	MOV	BH,BYTE PTR WDOLFT 
 02A2  8A E7                    	MOV	AH,BH		; From column = To column = left margin 
 02A4  2A CB                    	SUB	CL,BL		; CL = line count 
 02A6  77 07                    	JA	SCRUL1		; BRIF two or more line scroll 
 02A8  72 24                    	JB	SCRUL4		; BRIF TOP > BOTTOM(should never happen) 
 02AA  50                       	PUSH	AX 
 02AB  8A D3                    	MOV	DL,BL 
 02AD  EB 13                    	JMP	SHORT SCRUL3	; TOP=BOTTOM, just init line 
 02AF  50                       SCRUL1:	PUSH	AX 
 02B0  8A 2E 0000 E             	MOV	CH,BYTE PTR CRTWID	; Scroll entire lines 
 02B4  E8 0000 E                	CALL	SCROLL		; Scroll screen 
                                ;If CSRY, FSTLIN, LSTLIN are within scroll, decrement their values 
 02B7  02 C1                    	ADD	AL,CL		; AL=Last line scrolled + 1 
 02B9  FE C8                    	DEC	AL		; AL=Bottom line scrolled 
                                				; BL=Top line scrolled 
 02BB  B4 FF                    	MOV	AH,LOW 255D	; decrement line# variables in scroll window 
 02BD  E8 02D6 R                	CALL	TSTSCR 
 02C0  8A D0                    	MOV	DL,AL		; DL=bottom line of scroll (initialize it) 
                                ;Clear the last line of the scroll 
 02C2  8A 36 0000 E             SCRUL3:	MOV	DH,BYTE PTR WDOLFT 
 02C6  58                       	POP	AX 
 02C7  0A C9                    	OR	CL,CL 
 02C9  74 03                    	JE	SCRUL4		; No scroll(one line init) 
 02CB  E8 0361 R                	CALL	SCRUTT		; Scroll up terminator table 
 02CE  E8 03BE R                SCRUL4:	CALL	PLINIT		; Init physical line from (DL,DH) to (DL,WDORGT) 
 02D1  5A                       	POP	DX 
 02D2  5B                       	POP	BX 
 02D3  58                       	POP	AX 
 02D4  59                       	POP	CX 
 02D5  C3                       	RET 
                                 
                                ;TSTSCR is called after Scrolling Up or Down to update Line Number variables 
                                ; which may be in the scroll window 
                                ; Entry - BL=top line number of scroll window 
                                ;         AL=bottom line number of scroll window 
                                ;         AH=1 if line# variables are to be incremented, -1 if decremented 
                                ; 
 02D6  56                       TSTSCR:	PUSH	SI 
 02D7  50                       	PUSH	AX 
 02D8  BE 0000 E                	MOV	SI,OFFSET CSRY 
 02DB  E8 02FF R                	CALL	TSTWDO		; Adjust CSRY if its within scroll window 
 02DE  8A 26 0000 E             	MOV	AH,BYTE PTR WDOTOP 
 02E2  38 24                    	CMP	BYTE PTR 0[SI],AH 
 02E4  72 08                    	JB	TCSRY1		; BRIF CSRY above top of window 
 02E6  8A 26 0000 E             	MOV	AH,BYTE PTR WDOBOT 
 02EA  38 24                    	CMP	BYTE PTR 0[SI],AH 
 02EC  76 02                    	JNA	CSRYOK		; BRIF CSRY didn't increment beyond bottom 
 02EE  88 24                    TCSRY1:	MOV	BYTE PTR 0[SI],AH	; Bring it back to within scroll window 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-22
SCROLL ROUTINES - Scroll up and down                        

 02F0  BE 0000 E                CSRYOK:	MOV	SI,OFFSET FSTLIN 
 02F3  58                       	POP	AX 
 02F4  E8 02FF R                	CALL	TSTWDO		; Adjust FSTLIN if its within scroll window 
 02F7  BE 0000 E                	MOV	SI,OFFSET LSTLIN 
 02FA  E8 02FF R                	CALL	TSTWDO		; Adjust LSTLIN if its within scroll window 
 02FD  5E                       	POP	SI 
 02FE  C3                       	RET 
                                 
                                ; If BL .LEQ. [SI] .LEQ. AL then [SI]=[SI]+AH 
                                ; 
 02FF                           TSTWDO: 
 02FF  3A 04                    	CMP	AL,BYTE PTR 0[SI] 
 0301  72 06                    	JB	NINWDO		; BRIF [SI] not within scroll 
 0303  3A 1C                    	CMP	BL,BYTE PTR 0[SI] 
 0305  77 02                    	JA	NINWDO		; BRIF [SI] not within scroll 
 0307  00 24                    	ADD	BYTE PTR 0[SI],AH	; Adjust [SI] for scroll 
 0309  C3                       NINWDO:	RET 
                                 
                                 
                                 
                                ;SCROLL DOWN 
 030A  8A 16 0000 E             SCRLDN:	MOV	DL,BYTE PTR WDOTOP 
                                ;Scroll down from DL to WDOBOT 
 030E  50                       SCRLD0:	PUSH	AX 
 030F  53                       	PUSH	BX 
 0310  51                       	PUSH	CX 
 0311  8A C2                    	MOV	AL,DL 
 0313  8A DA                    	MOV	BL,DL		; From = To = top of scroll 
 0315  FE C3                    	INC	BL		; To = From + 1 
 0317  8A 3E 0000 E             	MOV	BH,BYTE PTR WDOLFT	; Column = left margin 
 031B  8A E7                    	MOV	AH,BH 
 031D  8A 0E 0000 E             	MOV	CL,BYTE PTR WDOBOT 
 0321  2A C8                    	SUB	CL,AL		; Count of lines =(window bottom)-top of scroll 
 0323  50                       	PUSH	AX 
 0324  76 10                    	JBE	SCRDL3		; BRIF null scroll, just clear line 
 0326  8A 2E 0000 E             	MOV	CH,BYTE PTR WDORGT	; Scroll lines, not columns 
 032A  E8 0000 E                SCRLD1:	CALL	SCROLL		; Scroll screen 
                                ;If CSRY, FSTLIN, LSTLIN are within scroll, increment their values 
 032D  02 C1                    	ADD	AL,CL		; AL=Last line scrolled 
 032F  FE C8                    	DEC	AL 
 0331  B4 01                    	MOV	AH,LOW 1	; increment line# variables in scroll window 
 0333  E8 02D6 R                	CALL	TSTSCR 
                                ;Clear the last line of the scroll(in DL) 
 0336  8A 36 0000 E             SCRDL3:	MOV	DH,BYTE PTR WDOLFT 
 033A  58                       	POP	AX 
 033B  0A C9                    	OR	CL,CL 
 033D  78 05                    	JS	SCRDL4		; No scroll(out of window) 
 033F  74 03                    	JE	SCRDL4		; No scroll(one line init) 
 0341  E8 0385 R                	CALL	SCRDTT		; Scroll down term table(mark last line init'd) 
 0344  E8 03BE R                SCRDL4:	CALL	PLINIT		; Init physical line from (DL,DH) to (DL,WDORGT) 
 0347  59                       	POP	CX 
 0348  5B                       	POP	BX 
 0349  58                       	POP	AX 
 034A  C3                       	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-23
SCROLL ROUTINES - Scroll up and down                        

                                 
                                ;SCROLL DOWN current line to next line 
 034B  50                       SCRDLN:	PUSH	AX 
 034C  53                       	PUSH	BX 
 034D  51                       	PUSH	CX 
 034E  8B C2                    	MOV	AX,DX		; Start of scroll is current line 
 0350  8A 26 0000 E             	MOV	AH,BYTE PTR WDOLFT 
 0354  8B D8                    	MOV	BX,AX 
 0356  FE C3                    	INC	BL		; TO start is next line 
 0358  8A 2E 0000 E             	MOV	CH,BYTE PTR WDORGT 
 035C  B1 01                    	MOV	CL,LOW 1	; Scroll one entir line 
 035E  50                       	PUSH	AX 
 035F  EB C9                    	JMP	SHORT SCRLD1	; Do scroll and update LSTPOS, FSTPOS, CSRY 
                                	SUBTTL  SCROLL ROUTINES - Support routines: scroll terminator table, line init 
                                 
                                 
                                 
                                ;Scroll up terminator table(same parameters as SCROLL) 
                                ;                   on entry:   (see SCROLL) 
                                ;                   on exit:    modifies AX, BX, CX 
                                ; 
 0361  52                       SCRUTT:	PUSH	DX 
 0362  8A D3                    	MOV	DL,BL 
 0364  E8 0069 R                	CALL	SCNRDT		; TRMCUR=address of top of scroll 
 0367  8B 1E 0000 E             	MOV	BX,WORD PTR TRMCUR 
 036B  B5 00                    	MOV	CH,LOW 0 
 036D  8B 87 0000 E             SCRUTL:	MOV	AX,WORD PTR LINTTB[BX]	; Get a terminator 
 0371  89 87 FFFE E             	MOV	WORD PTR LINTTB-2[BX],AX	; Save a terminator 
 0375  43                       	INC	BX 
 0376  43                       	INC	BX 
 0377  E2 F4                    	LOOP	SCRUTL		; Continue till done 
 0379  C6 87 FFFE E 00          	MOV	BYTE PTR LINTTB-2[BX],LOW 0	; Terminate end line of scroll 
 037E  C6 87 FFFF E 7F          	MOV	BYTE PTR LINTTB-1[BX],LOW OFFSET TRMEOL 
 0383  5A                       	POP	DX 
 0384  C3                       	RET 
                                 
                                ;Scroll down terminator table(same parameters as SCROLL) 
                                ;                   on entry:   (see SCROLL) 
                                ;                   on exit:    modifies AX, BX, CX 
                                ; 
 0385                           SCRDTT: 
 0385  52                       	PUSH	DX 
 0386  8A D0                    	MOV	DL,AL 
 0388  02 D1                    	ADD	DL,CL 
 038A  E8 0069 R                	CALL	SCNRDT		; TRMCUR=displacement of bottom of scroll + 2 
 038D  8B 1E 0000 E             	MOV	BX,WORD PTR TRMCUR 
 0391  B5 00                    	MOV	CH,LOW 0 
 0393  83 EB 02                 SCRDTL:	SUB	BX,2		; Next posn 
 0396  8B 87 FFFE E             	MOV	AX,WORD PTR LINTTB-2[BX]	; Get a terminator 
 039A  89 87 0000 E             	MOV	WORD PTR LINTTB[BX],AX	; Save a terminator 
 039E  E2 F3                    	LOOP	SCRDTL		; Continue till done 
 03A0  C6 87 FFFE E 00          	MOV	BYTE PTR LINTTB-2[BX],LOW 0	; Terminate end line of scroll 
 03A5  C6 87 FFFF E 7F          	MOV	BYTE PTR LINTTB-1[BX],LOW OFFSET TRMEOL 
 03AA  8A 16 0000 E             	MOV	DL,BYTE PTR WDOBOT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-24
SCROLL ROUTINES - Support routines: scroll terminator table,

 03AE  E8 0D03 R                	CALL	SCNRTL 
 03B1  72 04                    	JB	SCRDT1		; EOL term'd, all done 
 03B3  75 02                    	JNZ	SCRDT1 
 03B5  FE CC                    	DEC	AH 
 03B7  B0 7F                    SCRDT1:	MOV	AL,LOW OFFSET TRMEOL 
 03B9  E8 008A R                	CALL	SCNWTT		; Make sure last line in window is EOL term'd 
 03BC  5A                       	POP	DX 
 03BD  C3                       	RET 
                                 
                                ;Physical line initialization 
                                ;               on entry:   (DH,DL) = start of initialization 
                                ; 
 03BE  51                       PLINIT:	PUSH	CX 
 03BF  50                       	PUSH	AX 
 03C0  E8 0069 R                	CALL	SCNRDT 
 03C3  8A E6                    	MOV	AH,DH 
 03C5  FE CC                    	DEC	AH 
 03C7  53                       	PUSH	BX 
 03C8  8B 1E 0000 E             	MOV	BX,WORD PTR TRMCUR	; Terminate line to left of DH 
 03CC  C6 87 FFFF E 7F          	MOV	BYTE PTR LINTTB-1[BX],LOW OFFSET TRMEOL 
 03D1  88 A7 FFFE E             	MOV	BYTE PTR LINTTB-2[BX],AH 
 03D5  5B                       	POP	BX 
 03D6  58                       	POP	AX 
 03D7  E8 0000 E                PLINI2:	CALL	CLREOL		; Clear to end of line from (DH,DL) 
 03DA  59                       	POP	CX 
 03DB  C3                       	RET 
                                	SUBTTL  LABEL Key Processing 
                                 
                                 
                                ;LABELK - If function key display is off then turn on and exit. 
                                ;         If function key display is on then advance display line and 
                                ;         redisplay. 
                                ;ENTRY  - DX = cursor position 
                                ;EXIT   - DX unmodified 
                                ;USES   - AX,BX,CX 
                                ; 
                                	EXTRN	FKYADV:NEAR,KEYDSP:NEAR,FKYFMT:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	KEYSW:WORD 
 0000                           DSEG	ENDS 
 03DC  50                       LABELK:	PUSH	AX 
 03DD  53                       	PUSH	BX 
 03DE  51                       	PUSH	CX 
 03DF  52                       	PUSH	DX 
 03E0  56                       	PUSH	SI 
 03E1  57                       	PUSH	DI 
 03E2  80 3E 0000 E 00          	CMP	BYTE PTR KEYSW,LOW 0D	;Test for key on 
 03E7  E8 0000 E                	CALL	FKYADV		;If KEYSW was 0(ZF=0) then init PF start key, 
                                				;   else advance to next set of PF keys 
                                				;   return ZF=1 if advance beyond last of PF keys 
 03EA  74 0F                    	JZ	LABOFF		;Process key off request 
 03EC  C6 06 0000 E FF          	MOV	BYTE PTR KEYSW,LOW 255D	;Turn on key display flag 
 03F1  E8 0000 E                LABDSP:	CALL	KEYDSP		;Display function keys 
 03F4  5F                       	POP	DI 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-25
LABEL Key Processing                                        

 03F5  5E                       	POP	SI 
 03F6  5A                       	POP	DX 
 03F7  59                       	POP	CX 
 03F8  5B                       	POP	BX 
 03F9  58                       	POP	AX 
 03FA  C3                       	RET 
                                 
 03FB                           LABOFF: 
 03FB  C6 06 0000 E 00          	MOV	BYTE PTR KEYSW,LOW 0D	;Turn the key flag off 
 0400  EB EF                    	JMP	SHORT LABDSP	;Go clear the function key display line 
                                	SUBTTL  Miscellaneous editor interface routines 
                                 
                                 
                                 
                                ;SUBROUTINE SCNMRK              ; Mark current position as first posn of logical 
                                ;**                 on entry:   ZF=1 indicates INPUT statement, AL=1 indicates 
                                ;**                                 EDIT statement. 
                                ;**                 on exit:    - 
                                ;** 
 0402  9C                       SCNMRK:	PUSHF 
 0403  8A 16 0000 E             	MOV	DL,BYTE PTR CSRY 
 0407  8A 36 0000 E             	MOV	DH,BYTE PTR CSRX 
 040B  FE C8                    	DEC	AL 
 040D  75 06                    	JNZ	SCNMK0		; Not begin of EDIT statement 
 040F  E8 0DD3 R                	CALL	LSTART		; Set (DH,DL)=start of current line 
 0412  53                       	PUSH	BX 
 0413  EB 3F                    	JMP	SHORT SCNMK2 
                                ;** IF NOT TOP OF WINDOW 
 0415  E8 0D52 R                SCNMK0:	CALL	CSRUP		; Move to previous line 
 0418  72 0A                    	JB	SCNMK1		; BRIF at top of window 
                                ;** *** TERMINATE PREVIOUS PHYSICAL LINE 
 041A  E8 0D03 R                	CALL	SCNRTL 
 041D  B0 7F                    	MOV	AL,LOW OFFSET TRMEOL	; Make sure current line is start of logical line 
 041F  E8 008A R                	CALL	SCNWTT 
 0422  FE C2                    	INC	DL		; Restore current line number 
                                ;** IF LINE IS MARKED WITH NULL 
 0424  E8 0069 R                SCNMK1:	CALL	SCNRDT 
 0427  53                       	PUSH	BX 
 0428  8B 1E 0000 E             	MOV	BX,WORD PTR TRMCUR 
 042C  F6 87 FFFF E 80          	TEST	BYTE PTR LINTTB-1[BX],LOW OFFSET TRMNUL 
 0431  74 21                    	JZ	SCNMK2		; BRIF not specially marked line 
 0433  52                       	PUSH	DX 
 0434  51                       	PUSH	CX 
                                ;** SCAN LINE FOR NULL CHAR(255 DECIMAL) 
 0435  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 0439  8A 0E 0000 E             	MOV	CL,BYTE PTR LINLEN 
 043D  E8 0000 E                SCNMKL:	CALL	SCRINP 
 0440  3C FF                    	CMP	AL,LOW 255D 
 0442  74 09                    	JZ	SCNML3		; BRIF is specially marked line 
 0444  FE C6                    SCNML2:	INC	DH 
 0446  80 E9 01                 	SUB	CL,LOW 1 
 0449  77 F2                    	JA	SCNMKL		; BRIF more chars to check 
 044B  0B E4                    	OR	SP,SP 
 044D                           SCNML3: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-26
Miscellaneous editor interface routines                     

 044D  59                       	POP	CX 
 044E  5A                       	POP	DX 
 044F  75 03                    	JNZ	SCNMK2		; BRIF char was not on line, don't clear line 
                                ;** *** DELETE IT 
 0451  E8 0772 R                	CALL	LDELET		; Delete this line 
                                ;** IF NOT DIRECT, SET LSTPOS, FSTPOS = CURRENT_POSN 
 0454                           SCNMK2: 
 0454  88 16 0000 E             	MOV	BYTE PTR CSRY,DL 
 0458  88 36 0000 E             	MOV	BYTE PTR CSRX,DH	; Update CURS_POSN in case of change 
 045C  5B                       	POP	BX 
 045D  9D                       	POPF 
 045E  74 0C                    	JZ	SCNMK3		; INPUT statement, use current posn 
 0460  C6 06 0000 E FF          	MOV	BYTE PTR LSTLIN,LOW 377O	; Direct, set FSTPOS, LSTPOS to min and max 
 0465  C6 06 0000 E 00          	MOV	BYTE PTR FSTLIN,LOW 0 
 046A  EB 14                    	JMP	SHORT SCNMKX 
 046C  88 16 0000 E             SCNMK3:	MOV	BYTE PTR LSTLIN,DL 
 0470  88 16 0000 E             	MOV	BYTE PTR FSTLIN,DL 
 0474  FE CE                    	DEC	DH 
 0476  88 36 0000 E             	MOV	BYTE PTR LSTCOL,DH	; Mark LSTCOL one to left of current posn 
 047A  FE C6                    	INC	DH 
 047C  88 36 0000 E             	MOV	BYTE PTR FSTCOL,DH 
 0480  C3                       SCNMKX:	RET 
                                ;** END SUBROUTINE SCNMRK 
                                	SUBTTL  Read logical line 
                                 
                                 
                                 
                                ;SUBROUTINE SCNRDL              ; Read a logical line 
                                ;**                     on entry:   ZF=1 indicates ignore FSTPOS, LSTPOS(statement 
                                ;**                                     line input). 
                                ;**                                 DX=current posn(within logical line to return) 
                                ;**                                 BX=buffer address 
                                ;**                                 CX=max count 
                                ;**                     on exit:    BX=last char address plus one 
                                ;**                                 CX=CX - (count of chars moved) 
                                ;**                                 DX=destroyed 
                                ;** 
 0481  9C                       SCNRDL:	PUSHF			; Save statement input flag 
                                ;** Set DX=start of move 
                                ;** WHILE ((DL .NE FSTLIN) AND DL IN_SAME_LOGICAL_LINE) 
 0482  3A 16 0000 E             SCRD00:	CMP	DL,BYTE PTR FSTLIN 
 0486  74 0C                    	JZ	SCRD01		; Found first line of logical 
                                ;** *** DL = PREVIOUS LINE 
 0488  E8 0D52 R                	CALL	CSRUP 
 048B  72 07                    	JB	SCRD01		; At top of window, stop here 
 048D  E8 0069 R                	CALL	SCNRDT 
 0490  73 F0                    	JNB	SCRD00		; Still same logical, continue 
 0492  FE C2                    	INC	DL		; Set DL = first physical of logical 
                                ;** IF (STATEMENT_INPUT OR (NOT ON FIRST_LINE)) 
 0494  9D                       SCRD01:	POPF			; We have start line, now get start column 
 0495  9C                       	PUSHF 
                                ;** *** START_COLUMN=LEFT_MARGIN 
 0496  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; Assume start at left margin 
 049A  75 0A                    	JNZ	SCRD02		; BRIF statement input 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-27
Read logical line                                           

 049C  3A 16 0000 E             	CMP	DL,BYTE PTR FSTLIN 
 04A0  75 04                    	JNZ	SCRD02		; BRIF not on FIRST_LINE 
                                ;** *** ELSE START_COLUMN=FIRST_COLUMN 
 04A2  8A 36 0000 E             	MOV	DH,BYTE PTR FSTCOL 
                                 
                                ;** WHILE (POSN IS ON SAME LOGICAL) AND ((POSN .LTE. LSTPOS) OR STATEMENT_INPUT) BEGIN 
 04A6  9D                       SCRD02:	POPF 
 04A7  9C                       	PUSHF 
 04A8  75 0E                    	JNZ	SCRD03		; BRIF statement input, ignore LSTPOS 
 04AA  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 04AE  77 4B                    	JA	SCRDXZ		; **BRIF passed LSTPOS(was at prev. line term'r) 
 04B0  75 06                    	JNZ	SCRD03		; BRIF not at LSTPOS 
 04B2  3A 36 0000 E             	CMP	DH,BYTE PTR LSTCOL 
 04B6  77 43                    	JA	SCRDXZ		; BRIF beyond LSTPOS, all done 
                                ;** *** READ A CHARACTER INTO THE BUFFER 
                                ;** *** DO CASE TERMINATOR OF LINEFEED, NULL_WRAP, WRAP, BEFORE EOL, AT EOL 
 04B8  E8 0069 R                SCRD03:	CALL	SCNRDT 
 04BB  50                       	PUSH	AX 
 04BC  72 0B                    	JB	SCRD04		; BRIF not reading a linefeed 
 04BE  75 09                    	JNZ	SCRD04		; BRIF not reading a linefeed 
 04C0  3A E6                    	CMP	AH,DH 
 04C2  75 05                    	JNZ	SCRD04		; BRIF not reading a linefeed 
                                ;** *** *** CASE: LINEFEED 
 04C4  B8 000A                  SCRDLF:	MOV	AX,OFFSET CHRLNF+0 
 04C7  EB 1B                    	JMP	SHORT SCRD08	; At linefeed terminator, pass linefeed 
 04C9  3A E6                    SCRD04:	CMP	AH,DH 
 04CB  77 13                    	JA	SCRD07		; BRIF within data on screen 
 04CD  72 04                    	JB	SCRD06		; BRIF beyond terminator 
                                ;** *** *** CASE: NULL_WRAP 
 04CF  3C 01                    	CMP	AL,LOW OFFSET TRMNWP 
 04D1  75 0D                    	JNZ	SCRD07		; BRIF not at NULL_WRAP terminator 
 04D3  3C 7F                    SCRD06:	CMP	AL,LOW OFFSET TRMEOL 
 04D5  58                       	POP	AX 
 04D6  74 23                    	JZ	SCRDXZ		; BRIF beyond EOL 
                                ;** *** *** CASE: WRAP 
 04D8  FE C2                    	INC	DL		; Wrap to next line 
 04DA  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 04DE  EB C6                    	JMP	SHORT SCRD02 
                                ;** *** *** CASE: BEFORE EOL 
 04E0                           SCRD07: 
 04E0  F8                       	CLC			; Indicate call is from Screen Editor 
 04E1  E8 0000 E                	CALL	SCRINP		; AX=Character at (DH,DL) 
 04E4  88 07                    SCRD08:	MOV	BYTE PTR 0[BX],AL 
 04E6  49                       	DEC	CX 
 04E7  58                       	POP	AX 
 04E8  74 10                    	JZ	SCRDEX 
 04EA  3C 7F                    	CMP	AL,LOW OFFSET TRMEOL 
 04EC  75 04                    	JNZ	SCRD09		; BRIF not at EOL 
 04EE  3A E6                    	CMP	AH,DH 
 04F0  76 08                    	JBE	SCRDEX		; BRIF at EOL(or beyond), all done 
 04F2  43                       SCRD09:	INC	BX 
 04F3  E8 0D2A R                	CALL	CSRADV 
 04F6  72 03                    	JB	SCRDXZ		; If end of window, all done 
 04F8  EB AC                    	JMP	SHORT SCRD02	; Pass next character 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-28
Read logical line                                           

                                ;** *** *** CASE: AT(OR BEYOND) EOL 
 04FA  43                       SCRDEX:	INC	BX		; Set BX= last posn written plus one 
 04FB  9D                       SCRDXZ:	POPF 
 04FC  E8 0006 R                	CALL	SCNBRK		; Clear any flags associated with INPUT 
 04FF  C3                       	RET 
                                ;** *** *** END 
                                ;** *** END 
                                ;** END SUBROUTINE SCNRDL 
                                	SUBTTL  CONTROL CHARACTER ROUTINES 
                                 
                                 
                                ;CONTROL CHARACTER DISPATCH TABLE 
                                ;** 
 0500  05BF R                   FUNTAB:	DW	OFFSET CTLIGN	; ^@  -  Ignore 
 0502  05BF R                   	DW	OFFSET CTLIGN	; ^A  -  Ignore 
 0504  06F5 R                   	DW	OFFSET BCKWRD	; ^B  -  Back one word 
 0506  05BF R                   	DW	OFFSET CTLIGN	; ^C  -  Ignore 
 0508  05BF R                   	DW	OFFSET CTLIGN	; ^D  -  Ignore 
 050A  0775 R                   	DW	OFFSET LTRUNC	; ^E  -  Truncate logical line 
 050C  0698 R                   	DW	OFFSET FWDWRD	; ^F  -  Forward one word 
 050E  0746 R                   	DW	OFFSET CBEEP	; ^G  -  Beep 
 0510  0842 R                   	DW	OFFSET BAKSPC	; ^H  -  Destructive backspace 
 0512  0651 R                   	DW	OFFSET LTAB	; ^I  -  Destructive tab 
 0514  0A97 R                   	DW	OFFSET LFEED	; ^J  -  Linefeed 
 0516  0752 R                   	DW	OFFSET WHOME	; ^K  -  Home within window 
 0518  074C R                   	DW	OFFSET CCLRSN	; ^L  -  Clear window, home cursor 
 051A  0A80 R                   	DW	OFFSET LCARET	; ^M  -  Carriage return 
 051C  0A69 R                   	DW	OFFSET LAPPND	; ^N  -  Append to end of line 
 051E  05BF R                   	DW	OFFSET CTLIGN	; ^O  -  Ignore 
 0520  05BF R                   	DW	OFFSET CTLIGN	; ^P  -  Ignore 
 0522  05BF R                   	DW	OFFSET CTLIGN	; ^Q  -  Ignore 
 0524  0B72 R                   	DW	OFFSET LINSRT	; ^R  -  Insert a blank 
 0526  05BF R                   	DW	OFFSET CTLIGN	; ^S  -  Ignore 
 0528  03DC R                   	DW	OFFSET LABELK	; ^T  -  LABEL Key 
 052A  0772 R                   	DW	OFFSET LDELET	; ^U  -  Delete a line 
 052C  05BF R                   	DW	OFFSET CTLIGN	; ^V  -  Ignore 
 052E  07BB R                   	DW	OFFSET WDELET	; ^W  -  Delete a word 
 0530  05BF R                   	DW	OFFSET CTLIGN	; ^X  -  Ignore 
 0532  05BF R                   	DW	OFFSET CTLIGN	; ^Y  -  Ignore 
 0534  075B R                   	DW	OFFSET WERASE	; ^Z  -  Erase to end of window 
 0536  05BF R                   	DW	OFFSET CTLIGN	; ^[ or ESC - Ignore 
 0538  05F6 R                   	DW	OFFSET WCSADV	; ^\  -  Cursor advance within window 
 053A  0637 R                   	DW	OFFSET WCSREG	; ^]  -  Cursor regress within window 
 053C  0645 R                   	DW	OFFSET WCSUP	; ^^  -  Cursor up within window 
 053E  064B R                   	DW	OFFSET WCSDWN	; ^_  -  Cursor down within window 
 0540  0858 R                   	DW	OFFSET CDELET	; DEL -  Delete a character 
                                 
                                 
                                ;SUBROUTINE CTLDSP(CONTROL_CHAR); Do control char logic 
                                ;**                         on entry:   AX=control character 
                                ;**                         on exit:    if CF=0 then AX=character to output 
                                ;**                                     if CF=1 then AX is undefined 
 0542                           CTLDSP: 
 0542  E8 004F R                	CALL	SCNPOS		; DH=column, DL=row 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-29
CONTROL CHARACTER ROUTINES                                  

 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	CSRTYP:WORD 
 0000                           DSEG	ENDS 
                                	EXTRN	SETCSR:NEAR 
 0545  C6 06 0000 E 00          	MOV	BYTE PTR CSRTYP,LOW 0D	; Set for off cursor 
 054A  E8 0000 E                	CALL	SETCSR		; Ensure that the cursor is off 
 054D  8A 36 0000 E             	MOV	DH,BYTE PTR CSRX	; Set DH=true posn(not width truncated) 
 0551  F6 06 0000 E FF          	TEST	BYTE PTR ESCFLG,LOW 377O 
 0556  75 68                    	JNZ	DOESC		; BRIF in middle of escape sequence 
 0558  3C 1B                    	CMP	AL,LOW 33O 
 055A  74 64                    	JZ	DOESC 
 055C                           CTLDS0: 
                                 
 055C                           CTLDP0: 
 055C                           CTLDP1: 
                                	EXTRN	EDTMAP:NEAR,PRTMAP:NEAR 
 055C  F6 06 0000 E FF          	TEST	BYTE PTR F_EDIT,LOW 377O	; Test for Screen Edit mode 
 0561  74 0A                    	JZ	CTLPRT		; BRIF not edit mode 
 0563  80 FC 01                 	CMP	AH,LOW 1D	; Set PSW.C if two byte character 
 0566  F5                       	CMC 
 0567  E8 0000 E                	CALL	EDTMAP		; Map edit function/output character code 
 056A  EB 08 90                 	JMP	CTLEDT 
                                 
 056D  80 FC 01                 CTLPRT:	CMP	AH,LOW 1D	; Set PSW.C if two byte character 
 0570  F5                       	CMC 
 0571  E8 0000 E                	CALL	PRTMAP		; Map print function/output character codes 
 0574  74 48                    CTLEDT:	JZ	CTLDPY		; Ignore this character 
                                				; Print or perform the editor function 
 0576  80 FC FF                 	CMP	AH,LOW 255D	; Is it an editor function (&HFF)? 
 0579  75 33                    	JNZ	CTLDSX		; No - print the character 
 057B  32 E4                    	XOR	AH,AH		; Clear (no longer needed) editor function flag 
 057D  3C 7F                    	CMP	AL,LOW 177O	; Delete function? 
 057F  75 02                    	JNZ	CTLNDL		; BRIF not DEL 
 0581  B0 20                    	MOV	AL,LOW " "	; DEL code 
 0583  3C FF                    CTLNDL:	CMP	AL,LOW 255D 
 0585  75 11                    	JNZ	CTLNMK		; BRIF not "mark line for deletion" 
 0587  50                       	PUSH	AX 
 0588  53                       	PUSH	BX 
 0589  E8 0069 R                	CALL	SCNRDT 
 058C  8B 1E 0000 E             	MOV	BX,WORD PTR TRMCUR 
 0590  80 8F FFFF E 80          	OR	BYTE PTR LINTTB-1[BX],LOW OFFSET TRMNUL	; Set "not for input" flag on this line 
 0595  5B                       	POP	BX 
 0596  58                       	POP	AX 
                                ;       STC 
 0597  C3                       	RET 
 0598  3C 21                    CTLNMK:	CMP	AL,LOW OFFSET " "+1	; Test for legal function code 
 059A  73 22                    	JNB	CTLDPY		; Ignore this code 
 059C  50                       	PUSH	AX 
 059D  E8 05D7 R                	CALL	CTLIRS		; Possibly reset insert flag 
 05A0  03 C0                    	ADD	AX,AX		; Two bytes per entry 
 05A2  8B D8                    	MOV	BX,AX 
 05A4  B8 05B0 R                	MOV	AX,OFFSET CTLDPX 
 05A7  50                       	PUSH	AX		; Put return on stack 
 05A8  2E: 8B 87 0500 R         	MOV	AX,WORD PTR FUNTAB[BX] 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-30
CONTROL CHARACTER ROUTINES                                  

 05AD  50                       	PUSH	AX		; Put routine address on stack 
 05AE  F8                       CTLDSX:	CLC 
 05AF  C3                       	RET			; Go do control routine 
                                ;** *** UPDATE CURRENT_POSN, RETURN 
 05B0  88 16 0000 E             CTLDPX:	MOV	BYTE PTR CSRY,DL 
 05B4  88 36 0000 E             	MOV	BYTE PTR CSRX,DH	; Update cursor posn 
 05B8  58                       	POP	AX 
 05B9  2C 0D                    	SUB	AL,LOW OFFSET CHRRET 
 05BB  A2 0000 E                	MOV	BYTE PTR F_CRET,AL	; F.CRET = 0 if character was Carriage return 
 05BE                           CTLDPY: 
 05BE  F9                       	STC 
 05BF                           CTLIGN: 
 05BF  C3                       CTLDPZ:	RET 
                                ;** ESCAPE SEQUENCE PROCESSING 
 05C0  E8 0000 E                DOESC:	CALL	SCROUT		; Returns carry set if continuation of escape sequence 
 05C3  1A C0                    	SBB	AL,AL		; If ESC sequence, AL=FF else AL=0 
 05C5  A2 0000 E                	MOV	BYTE PTR ESCFLG,AL	; Set/Reset flag 
 05C8  EB F4                    	JMP	SHORT CTLDPY 
                                ;** END SUBROUTINE CTLDSP 
                                 
                                ;THE CONTROL CHARACTERS WHICH RESET INSERT FLAG ARE IN TABLE BELOW: 
                                ; 
 05CA                           CTLITB: 
 05CA  15                       	DB	OFFSET CHRLDL	; LINE_DELETE 
 05CB  0C                       	DB	OFFSET CHRERA	; ERASE_SCREEN 
 05CC  06                       	DB	OFFSET CHRFDW	; FORWARD_WORD 
 05CD  02                       	DB	OFFSET CHRBKW	; BACKWARD_WORD 
 05CE  0E                       	DB	OFFSET CHRAPP	; APPEND_TO_LINE 
 05CF  01                       	DB	OFFSET CHREDT	; EDIT_PREVIOUS_LINE 
 05D0  05                       	DB	OFFSET CHRCLE	; CLEAR_TO_END 
 05D1  07                       	DB	OFFSET CHRBEL	; BELL 
 05D2  0B                       	DB	OFFSET CHRHOM	; HOME 
 05D3  1C                       	DB	OFFSET CHRADV	; CURSOR_ADV 
 05D4  1D                       	DB	OFFSET CHRREG	; CURSOR_REG 
 05D5  1E                       	DB	OFFSET CHRUP	; CURSOR_UP 
 05D6  1F                       	DB	OFFSET CHRDWN	; CURSOR_DOWN 
 = 000D                         	CTLCNT=$-CTLITB 
                                 
                                ;SUBROUTINE CTLIRS              ; Reset insert flag for specified characters 
                                ;**                 on entry:   AL=character 
                                ;**                 on exit:    DI garbaged 
                                ;** 
 05D7  50                       CTLIRS:	PUSH	AX 
 05D8  53                       	PUSH	BX 
 05D9  51                       	PUSH	CX 
 05DA  57                       	PUSH	DI 
                                ;** IF (SPECIAL_ACTION(CTLKEY)) 
 05DB  BF 05CA R                	MOV	DI,OFFSET CTLITB	; DI= [control char table] 
 05DE  B9 000D                  	MOV	CX,OFFSET CTLCNT	; CX= count of entries in table 
 05E1  8B D9                    	MOV	BX,CX 
 05E3  06                       	PUSH	ES 
 05E4  0E                       	PUSH	CS		; Scan in code segment 
 05E5  07                       	POP	ES 
 05E6  FC                       	CLD			; Scan forward 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-31
CONTROL CHARACTER ROUTINES                                  

 05E7  F2/ AE                    REPNE	SCASB			; Scan for character in table 
 05E9  07                       	POP	ES 
 05EA  75 05                    	JNE	INCNOT		; BRIF did not find the control character 
                                ;** *** F.INSRT=FALSE 
 05EC  C6 06 0000 E 00          	MOV	BYTE PTR F_INST,LOW 0	; Reset insert flag 
 05F1  5F                       INCNOT:	POP	DI 
 05F2  59                       	POP	CX 
 05F3  5B                       	POP	BX 
 05F4  58                       	POP	AX 
 05F5  C3                       	RET 
                                ;** END SUBROUTINE CTLIRS 
                                ;** *** END 
                                 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Cursor movement by character, line and TAB 
                                 
                                 
                                 
                                ;The control character routines are entered with DH=current column and 
                                ;   DL=current line. They return updated posn in the same registers. They 
                                ;   can modify AX, BX, CX but must save any other registers used. 
                                 
                                ;CURSOR CONTROL 
                                ;   The cursor control routines are somewhat special. Except for cursor advance, 
                                ;   the cursor is made to stay within previously printed data. The cursor 
                                ;   advance routine will append blanks by changing the logical right margin, 
                                ;   without actually printing anything. All of the cursor control routines 
                                ;   will update FSTPOS and LSTPOS as long as the cursor stays within a logical 
                                ;   line. When the cursor leaves a logical line, the FSTPOS and LSTPOS values 
                                ;   do not change. If the cursor is then moved back onto the original logical 
                                ;   line, the values are updated once more. 
                                ; 
                                ;Cursor advance 
 05F6  E8 0D2A R                WCSADV:	CALL	CSRADV		; Advance cursor 
 05F9  72 3B                    	JB	WCSABT		; BRIF can't do, quit 
                                ;       CALL    SCNRDT          ; AH=end of this physical, AL=terminator 
                                ;       CMPB    DH,AH 
                                ;If cursor beyond previously printed data, don't update LSTCOL 
                                ;       JAE     WCSABT          ; BRIF not to left of line terminator posn 
                                ;If cursor beyond previous LSTPOS and on same logical, update LSTPOS 
 05FB  52                       UPDPOS:	PUSH	DX 
 05FC  FE CE                    	DEC	DH		; LSTCOL is to left of cursor 
 05FE  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0602  72 1F                    	JB	UPDPS3		; BRIF not new LSTPOS 
 0604  74 13                    	JZ	UPDPS2		; BRIF on same line, possibly update LSTPOS 
 0606  52                       	PUSH	DX 
 0607  E8 0DD3 R                	CALL	LSTART		; Get start line of current logical 
 060A  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 060E  5A                       	POP	DX 
 060F  77 12                    	JA	UPDPS3		; BRIF LSTPOS not on current logical line 
                                ;LSTPOS on current logical, previous physical 
 0611  88 16 0000 E             	MOV	BYTE PTR LSTLIN,DL	; Set LSTPOS to current 
 0615  88 36 0000 E             	MOV	BYTE PTR LSTCOL,DH 
 0619  3A 36 0000 E             UPDPS2:	CMP	DH,BYTE PTR LSTCOL 
 061D  76 04                    	JBE	UPDPS3		; BRIF not new last posn 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-32
CONTROL CHARACTER ROUTINES - Cursor movement by character, l

 061F  88 36 0000 E             	MOV	BYTE PTR LSTCOL,DH	; Set new last posn 
                                ;If cursor before previous FSTPOS and on same logical, update FSTPOS 
 0623  FE C6                    UPDPS3:	INC	DH		; Restore column 
 0625  3A 16 0000 E             	CMP	DL,BYTE PTR FSTLIN 
 0629  75 0A                    	JNZ	UPDPSX		; BRIF not on same line as first position 
 062B  3A 36 0000 E             	CMP	DH,BYTE PTR FSTCOL 
 062F  73 04                    	JAE	UPDPSX		; BRIF not new first position 
 0631  88 36 0000 E             	MOV	BYTE PTR FSTCOL,DH	; Set new first position to current position 
 0635  5A                       UPDPSX:	POP	DX 
 0636  C3                       WCSABT:	RET 
                                 
                                ;Cursor regress 
 0637  E8 0D3E R                WCSREG:	CALL	CSRREG		; Move cursor 
 063A  72 FA                    	JB	WCSABT		; Can't move, quit 
 063C  E8 0069 R                WCSRET:	CALL	SCNRDT 
 063F  3A E6                    	CMP	AH,DH 
 0641  73 B8                    	JNB	UPDPOS		; Within logical, update FSTPOS, LSTPOS, return 
                                ;Cursor to right of line terminator, don't update LSTCOL 
 0643  EB F1                    	JMP	SHORT WCSABT	; Return 
                                 
                                ;Cursor up 
 0645  E8 0D52 R                WCSUP:	CALL	CSRUP		; Move cursor 
 0648  73 F2                    	JNB	WCSRET		; BRIF successful, possibly update FSTPOS, LSTPOS 
 064A  C3                       	RET			; Unsuccessful, return(NOP) 
                                 
                                ;Cursor down 
 064B  E8 0D65 R                WCSDWN:	CALL	CSRDWN		; Move cursor 
 064E  73 EC                    	JNB	WCSRET		; BRIF successful, possibly update FSTPOS, LSTPOS 
 0650  C3                       	RET			; Unsuccessful, return(NOP) 
                                 
                                ;TAB                            ; Move cursor to next TAB stop 
                                ; 
 0651  F6 06 0000 E FF          LTAB:	TEST	BYTE PTR F_INST,LOW 377O 
 0656  74 1F                    	JZ	LTABL		; BRIF not insert TAB 
                                ;Insert spaces until CSRX is at TAB stop or LINLEN 
 0658  B8 0020                  LTABIL:	MOV	AX," " 
 065B  E8 00B0 R                	CALL	SCNOUT		; Insert a blank 
 065E  8A 16 0000 E             	MOV	DL,BYTE PTR CSRY 
 0662  8A 36 0000 E             	MOV	DH,BYTE PTR CSRX 
 0666  3A 36 0000 E             	CMP	DH,BYTE PTR LINLEN 
 066A  77 2B                    	JA	LTABZ		; All done, at end of line 
 066C  FE CE                    	DEC	DH 
 066E  F6 C6 07                 	TEST	DH,LOW 7O 
 0671  75 E5                    	JNZ	LTABIL		; Keep inserting 
 0673  FE C6                    	INC	DH 
 0675  EB 20                    	JMP	SHORT LTABZ	; All done, at TAB stop 
                                ;Non-insert TAB, just pass over characters 
 0677  3A 36 0000 E             LTABL:	CMP	DH,BYTE PTR LINLEN 
 067B  73 0B                    	JAE	LTABX0		; BRIF need to wrap 
 067D  FE C6                    	INC	DH 
 067F  F6 C6 07                 	TEST	DH,LOW 7O 
 0682  75 F3                    	JNZ	LTABL 
 0684  FE C6                    	INC	DH 
 0686  EB 0C                    	JMP	SHORT LTABX	; BRIF reached good posn 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-33
CONTROL CHARACTER ROUTINES - Cursor movement by character, l

 0688  3A 16 0000 E             LTABX0:	CMP	DL,BYTE PTR WDOBOT 
 068C  73 09                    	JAE	LTABZ		; BRIF no room to end of page 
 068E  FE C2                    	INC	DL 
 0690  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; Else move to start of next line 
 0694  E8 05FB R                LTABX:	CALL	UPDPOS		; Update LSTPOS 
 0697  C3                       LTABZ:	RET 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Cursor movement by word 
                                 
                                 
                                ;Advance cursor to beginning of next word within screen 
 0698  52                       FWDWRD:	PUSH	DX 
 0699  FF 36 0000 E             	PUSH	WORD PTR LSTLIN 
 069D  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 06A1  75 0B                    	JNZ	FWDWR0		; BRIF LSTPOS not on this line 
 06A3  3A 36 0000 E             	CMP	DH,BYTE PTR LSTCOL 
 06A7  72 05                    	JB	FWDWR0		; BRIF within logical line 
 06A9  C6 06 0000 E FF          	MOV	BYTE PTR LSTLIN,LOW 377O	; Ignore LSTPOS in scan 
 06AE  F8                       FWDWR0:	CLC 
 06AF  E8 06D4 R                FWDWR1:	CALL	FWDWDL		; Try within logical 
 06B2  72 09                    	JB	FWDWR2		; BRIF unsuccessful 
 06B4  8F 06 0000 E             	POP	WORD PTR LSTLIN 
 06B8  E8 05FB R                	CALL	UPDPOS 
 06BB  58                       	POP	AX		; Remove old posn from stack 
 06BC  C3                       	RET 
                                ;Reached end of logical line, try next logical 
 06BD  E8 0D65 R                FWDWR2:	CALL	CSRDWN 
 06C0  72 07                    	JB	FWDWRZ		; BRIF end of screen 
 06C2  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; Start scan again at next line 
 06C6  F9                       	STC 
 06C7  EB E6                    	JMP	SHORT FWDWR1	; Continue scan 
                                ;Unsuccessful, return cursor to original posn 
 06C9  8F 06 0000 E             FWDWRZ:	POP	WORD PTR LSTLIN 
 06CD  5A                       	POP	DX 
 06CE  C3                       	RET 
                                 
 06CF  E8 0D78 R                FWDWD0:	CALL	LCSADV 
 06D2  72 12                    	JB	FWDWD3		; At end of logical line 
                                ;Advance cursor to beginning of next word within logical line 
 06D4  72 0A                    FWDWDL:	JB	FWDWD2		; Start as though between words 
 06D6  E8 0DF0 R                	CALL	ANCHK		; Check if current char is within word 
 06D9  73 F4                    	JNB	FWDWD0		; BRIF still within previous word 
                                ;At space between words 
 06DB  E8 0D78 R                FWDWD1:	CALL	LCSADV 
 06DE  72 06                    	JB	FWDWD3		; At end of logical line, check next logical 
 06E0  E8 0DF0 R                FWDWD2:	CALL	ANCHK 
 06E3  72 F6                    	JB	FWDWD1 
 06E5  C3                       FWDWDX:	RET			; Return, DX=posn of new word or end of logical line 
 06E6  75 FD                    FWDWD3:	JNZ	FWDWDX		; BRIF not stop at LSTPOS 
                                ;Stopped at LSTPOS, continue scan to end of physical line 
 06E8  3A E6                    	CMP	AH,DH 
 06EA  77 02                    	JA	FWDWD4		; BRIF more this line 
 06EC  F9                       	STC 
 06ED  C3                       	RET 
 06EE  C6 06 0000 E FF          FWDWD4:	MOV	BYTE PTR LSTLIN,LOW 377O	; Ignore LSTPOS from here on 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-34
CONTROL CHARACTER ROUTINES - Cursor movement by word        

 06F3  EB E6                    	JMP	SHORT FWDWD1	; Since crossed LSTPOS, passed end of current word 
                                 
                                ;Regress cursor to start of previous word 
 06F5  FF 36 0000 E             BCKWRD:	PUSH	WORD PTR FSTCOL 
 06F9  52                       	PUSH	DX 
 06FA  3A 36 0000 E             	CMP	DH,BYTE PTR FSTLIN 
 06FE  75 0B                    	JNZ	BCKWD2 
 0700  3A 36 0000 E             	CMP	DH,BYTE PTR FSTCOL 
 0704  77 05                    	JA	BCKWD2 
 0706  C6 06 0000 E 00          	MOV	BYTE PTR FSTLIN,LOW 0 
                                ;Assume passed beginning of current word, continue to start of next 
 070B  E8 0DA9 R                BCKWD2:	CALL	LCSREG 
 070E  72 1D                    	JB	BCKWD7		; BRIF At start of line 
 0710  E8 0DF0 R                BCKWD4:	CALL	ANCHK 
 0713  72 F6                    	JB	BCKWD2		; BRIF still between words 
                                ;Scanning previous word, any termination is good 
 0715  E8 0DA9 R                BCKWD5:	CALL	LCSREG 
 0718  72 08                    	JB	BCKWD6		; BRIF at beginning of line, found previous word 
 071A  E8 0DF0 R                	CALL	ANCHK 
 071D  73 F6                    	JNB	BCKWD5		; BRIF not at beginning of word 
 071F  E8 0D2A R                	CALL	CSRADV		; Advance back to start of word 
 0722  58                       BCKWD6:	POP	AX 
 0723  52                       	PUSH	DX		; Push new posn on stack 
 0724  5A                       BCKWDX:	POP	DX 
 0725  8F 06 0000 E             	POP	WORD PTR FSTCOL 
 0729  E8 05FB R                	CALL	UPDPOS 
 072C  C3                       	RET			; Return, DL=posn of previous word 
 072D  75 07                    BCKWD7:	JNZ	BCKWD8		; BRIF not stop at FSTPOS 
 072F  C6 06 0000 E 00          	MOV	BYTE PTR FSTLIN,LOW 0	; Ignore FSTPOS from here on 
 0734  EB D5                    	JMP	SHORT BCKWD2	; Since passed begginning of logical, between words 
 0736  E8 0D52 R                BCKWD8:	CALL	CSRUP		; Try previous logical line 
 0739  72 E9                    	JB	BCKWDX		; At beginning of screen 
 073B  E8 0069 R                	CALL	SCNRDT		; Read previous line teminator 
 073E  0A E4                    	OR	AH,AH 
 0740  74 F4                    	JZ	BCKWD8		; Previous line is null, try next previous 
 0742  8A F4                    	MOV	DH,AH 
 0744  EB CA                    	JMP	SHORT BCKWD4	; Continue scan 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Screen home, truncate and clear 
                                 
                                 
                                	EXTRN	BEEP:NEAR 
 0746  E8 0000 E                CBEEP:	CALL	BEEP		; Sound Bell 
 0749  E9 004F R                	JMP	SCNPOS		; return current cursor location 
                                 
                                	EXTRN	CLRSCN:NEAR 
                                ;Clear the screen 
 074C                           CCLRSN: 
 074C  F8                       	CLC			; no-carry = internal parameter 
 074D  B0 02                    	MOV	AL,LOW 2	; specify text only 
 074F  E8 0000 E                	CALL	CLRSCN		; OEM supplied Clear-Screen Routine 
                                				;fall into WHOME 
                                 
                                ;Home the cursor 
 0752  8A 16 0000 E             WHOME:	MOV	DL,BYTE PTR WDOTOP 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-35
CONTROL CHARACTER ROUTINES - Screen home, truncate and clear

 0756  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 075A  C3                       	RET 
                                 
                                ;Erase to the end of the screen 
 075B  E8 03BE R                WERASE:	CALL	PLINIT		; Clear current physical to end of line 
 075E  52                       	PUSH	DX 
 075F  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; Clear rest of lines from left margin 
                                ;WHILE POSN .LTE. WDOBOT 
                                ;** IF DATA_EXISTS(POSN) THEN INITIALIZE LINE 
 0763  FE C2                    WERAS0:	INC	DL 
 0765  3A 16 0000 E             	CMP	DL,BYTE PTR WDOBOT 
 0769  77 05                    	JA	WERASX		; Beyond window, exit 
 076B  E8 03BE R                	CALL	PLINIT		; Clear this line 
 076E  EB F3                    	JMP	SHORT WERAS0	; Init next line 
 0770  5A                       WERASX:	POP	DX		; Return DX=cursor posn 
 0771  C3                       	RET 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Line truncate and delete 
                                 
                                 
                                 
                                ;Delete entire logical line 
 0772  E8 0DD3 R                LDELET:	CALL	LSTART		; Get start of logical line in DX 
                                 
                                ;Truncate line from posn in DX 
 0775  52                       LTRUNC:	PUSH	DX 
 0776  E8 0D03 R                	CALL	SCNRTL		; AH=last valid data on physical line 
 0779  9C                       	PUSHF 
 077A  F9                       	STC			; Indicate don't clear line by scrolling 
 077B  E8 0798 R                	CALL	LCLEAR		; Clear this physical line 
 077E  72 15                    	JB	LTRUN9		; Reached LSTPOS, all done 
 0780  FE C2                    	INC	DL 
                                ;"Suck up" remaining physical lines attached to current logical 
 0782  9D                       LTRUN1:	POPF 
 0783  72 11                    	JB	LTRUNX		; Reached end of logical line 
 0785  E8 0D03 R                	CALL	SCNRTL 
 0788  9C                       	PUSHF 
 0789  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 078D  F8                       	CLC 
 078E  E8 0798 R                	CALL	LCLEAR		; Clear this line from start of line 
 0791  72 02                    	JB	LTRUN9		; Reached LSTPOS, all done 
 0793  EB ED                    	JMP	SHORT LTRUN1 
 0795  9D                       LTRUN9:	POPF 
 0796  5A                       LTRUNX:	POP	DX 
 0797  C3                       	RET 
                                 
                                ;Clear current physical to end of physical or LSTPOS, whichever is smallest 
                                ; (DH,DL)=start posn, AH=TERM_POSN, if CF=1, don't scroll 
 0798  9C                       LCLEAR:	PUSHF 
 0799  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 079D  74 13                    	JZ	LCLER2		; BRIF clear up to LSTPOS 
 079F  3A 36 0000 E             LCLER0:	CMP	DH,BYTE PTR WDORGT 
 07A3  77 13                    	JA	LCLER5		; BRIF beyond end of physical(just exit) 
 07A5  9D                       	POPF 
 07A6  73 05                    	JNB	LCLER1		; BRIF clear line by scroll 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-36
CONTROL CHARACTER ROUTINES - Line truncate and delete       

 07A8  E8 03BE R                	CALL	PLINIT		; Clear this physical line 
 07AB  F8                       	CLC 
 07AC  C3                       	RET 
 07AD  E8 0290 R                LCLER1:	CALL	SCRLU0		; Scroll up from bottom to current line 
 07B0  F8                       	CLC 
 07B1  C3                       	RET 
 07B2  9D                       LCLER2:	POPF 
 07B3  E8 03BE R                	CALL	PLINIT 
 07B6  F9                       	STC 
 07B7  C3                       	RET 
 07B8  9D                       LCLER5:	POPF 
 07B9  F8                       	CLC 
 07BA  C3                       	RET 
                                 
                                 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Character and word delete 
                                 
                                 
                                 
                                ;Word delete 
                                ; 
 07BB                           WDELET: 
 07BB  3A 36 0000 E             	CMP	DH,BYTE PTR LINLEN 
 07BF  76 05                    	JBE	WDELT0		; BRIF on physical line 
 07C1  E8 0D2A R                	CALL	CSRADV		; Put cursor on next line 
 07C4  72 4A                    	JB	WDELTZ		; BRIF at end of screen 
 07C6                           WDELT0: 
 07C6  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN	; ** 
 07CA  75 06                    	JNZ	WDELT2		; **BRIF not on LSTPOS line 
 07CC  3A 36 0000 E             	CMP	DH,BYTE PTR LSTCOL	; ** 
 07D0  73 3E                    	JAE	WDELTZ		; **BRIF at or beyond LSTPOS(don't do word delete) 
 07D2                           WDELT2:				; ** 
 07D2  52                       	PUSH	DX 
 07D3  3A 36 0000 E             	CMP	DH,BYTE PTR LINLEN 
 07D7  76 03                    	JBE	WDELT4		; Good delete posn(within physical line) 
 07D9  E8 0D78 R                	CALL	LCSADV		; Advance cursor to next physical of logical 
 07DC  52                       WDELT4:	PUSH	DX 
 07DD  F8                       	CLC 
 07DE  FF 36 0000 E             	PUSH	WORD PTR LSTLIN 
 07E2  E8 06D4 R                	CALL	FWDWDL		; Set (DH,DL)= start of next word or end of line 
 07E5  8F 06 0000 E             	POP	WORD PTR LSTLIN 
 07E9  73 02                    	JNB	WDELT6		; BRIF found another word following 
                                ;No word following, just delete to end of line 
 07EB  FE C6                    	INC	DH		; Include terminator in delete 
 07ED  8B CA                    WDELT6:	MOV	CX,DX 
 07EF  5A                       	POP	DX 
 07F0  3A 0E 0000 E             	CMP	CL,BYTE PTR LSTLIN	; ** 
 07F4  72 0E                    	JB	WDELT8		; **BRIF not beyond LSTPOS line 
 07F6  77 06                    	JA	WDELT7		; **BRIF beyond LSTPOS line, use LSTPOS 
 07F8  3A 2E 0000 E             	CMP	CH,BYTE PTR LSTCOL	; **At LSTPOS line, check if column is OK 
 07FC  72 06                    	JB	WDELT8		; **BRIF before LSTPOS, column is OK 
 07FE  8B 0E 0000 E             WDELT7:	MOV	CX,WORD PTR LSTLIN	; **Use LSTPOS as end of delete 
 0802  FE C5                    	INC	CH		; **INC because delete is up to char before this posn 
 0804                           WDELT8:				; ** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-37
CONTROL CHARACTER ROUTINES - Character and word delete      

 0804  3A D1                    	CMP	DL,CL 
 0806  75 09                    	JNZ	WDELTC		; BRIF multiple line delete 
 0808  2A EE                    WDELT9:	SUB	CH,DH		; CH=chars to next word minus one 
 080A  76 03                    	JBE	WDELTX		; BRIF no chars to delete 
 080C  E8 0861 R                	CALL	CDELLG		; Delete CH chars in this line 
 080F  5A                       WDELTX:	POP	DX 
 0810  C3                       WDELTZ:	RET 
 0811  FE C2                    WDELTC:	INC	DL 
 0813  52                       WDELTD:	PUSH	DX 
 0814  51                       	PUSH	CX 
                                ; Delete across physical lines, delete to end of this line 
 0815  3A D1                    	CMP	DL,CL 
 0817  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 081B  74 0E                    	JZ	WDELTE 
 081D  E8 0D03 R                	CALL	SCNRTL 
 0820  8A EC                    	MOV	CH,AH 
 0822  E8 09AF R                	CALL	CDELPH		; Erase intervening line 
 0825  59                       	POP	CX 
 0826  5A                       	POP	DX 
 0827  FE C9                    	DEC	CL		; Each erase of intervening line brings CL closer 
 0829  EB E8                    	JMP	SHORT WDELTD 
 082B  3A 2E 0000 E             WDELTE:	CMP	CH,BYTE PTR WDOLFT 
 082F  76 05                    	JBE	WDELTF		; BRIF at begin of line 
 0831  FE CD                    	DEC	CH 
 0833  E8 0861 R                	CALL	CDELLG		; Delete up to the next word on this line 
 0836  59                       WDELTF:	POP	CX 
 0837  5A                       	POP	DX 
 0838  FE CA                    	DEC	DL		; Go back to original line 
 083A  8A 2E 0000 E             	MOV	CH,BYTE PTR LINLEN 
 083E  FE C5                    	INC	CH 
 0840  EB C6                    	JMP	SHORT WDELT9	; Delete to end of line 
                                 
                                 
                                 
                                ;Destructive back space 
                                ; 
 0842                           BAKSPC: 
 0842  E8 0DA9 R                	CALL	LCSREG		; Back space within logical line 
 0845  E8 0D03 R                	CALL	SCNRTL 
 0848  3A F4                    	CMP	DH,AH 
 084A  76 0C                    	JBE	CDELET		; BRIF current posn less than TERM_POSN 
 084C  3A 26 0000 E             	CMP	AH,BYTE PTR WDOLFT 
 0850  73 04                    	JAE	BAKSP1		; BRIF not on null line 
 0852  8A 26 0000 E             	MOV	AH,BYTE PTR WDOLFT 
 0856  8A F4                    BAKSP1:	MOV	DH,AH		; If beyond terminator, set posn to terminator 
                                 
                                ;Delete character 
                                ; 
 0858  B5 01                    CDELET:	MOV	CH,LOW 1	; Assume one byte char delete 
 085A  3A 36 0000 E             	CMP	DH,BYTE PTR LINLEN 
 085E  76 01                    	JBE	CDELT1		; BRIF within physical line 
 0860  C3                       	RET 
 0861                           CDELT1: 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-38
CONTROL CHARACTER ROUTINES - Character and word delete      

                                ;SUBROUTINE CDELLG:             ; Delete CH characters @(DH,DL) within logical 
                                ;                       On entry:   CH=count, CL= flag, (DH,DL)=posn 
                                ;                                   If CL is non-zero, remove null line from screen 
                                ; 
 0861  52                       CDELLG:	PUSH	DX 
 0862  E8 0D03 R                	CALL	SCNRTL		; Get last valid char posn in AH 
 0865  9C                       	PUSHF 
 0866  E8 09AF R                	CALL	CDELPH		; Delete characters from current physical 
                                				;   returns new term posn in AH 
 0869  32 C9                    	XOR	CL,CL		; CL is iteration counter 
 086B  9D                       	POPF 
 086C  B0 7F                    	MOV	AL,LOW OFFSET TRMEOL 
 086E  72 79                    	JB	CDLGEX		; BRIF was EOL term'd, update terminator, exit 
 0870  75 0E                    	JNZ	CDLGWP		; BRIF line was WRAP or NULL_WRAP term'd, get 
                                				;       chars from next line 
                                ;Line was LF terminated, check for LF delete 
 0872  3A E6                    	CMP	AH,DH 
 0874  B0 0A                    	MOV	AL,LOW OFFSET TRMLNF 
 0876  77 71                    	JA	CDLGEX		; BRIF didn't delete LF, update terminator, exit 
 0878  0A E4                    	OR	AH,AH 
 087A  74 70                    	JZ	CDLGRT		; **BRIF entire line deleted and removed 
 087C  8A E6                    	MOV	AH,DH 
 087E  EB 06                    	JMP	SHORT CDLWP1 
                                ;Need to get chars from next physical line at (AH,DL) posn to end of physical 
 0880  0A E4                    CDLGWP:	OR	AH,AH 
 0882  74 68                    	JZ	CDLGRT		; BRIF entire line deleted and removed 
 0884  FE C4                    	INC	AH 
 0886  3A 16 0000 E             CDLWP1:	CMP	DL,BYTE PTR LSTLIN	; ** 
 088A  74 60                    	JZ	CDLGRT		; **LSTPOS on this line, all done 
 088C  FF 36 0000 E             	PUSH	WORD PTR LSTLIN	; **Save current LSTPOS 
 0890  E8 08F7 R                	CALL	CDUNWP		; Unwrap the characters desired returns terminator 
                                				;     in (AH,AL) and byte count in CH 
 0893  E8 008A R                	CALL	SCNWTT		; Update terminator 
 0896  0A ED                    	OR	CH,CH 
 0898  75 03                    	JNZ	CDLWP2		; BRIF we have characters to unwrap 
 089A  58                       	POP	AX		; Restore the stack 
 089B  EB 4F                    	JMP	SHORT CDLGRT	; Return, all done 
                                ;Need to delete CH characters unwrapped from next line 
 089D  8A 36 0000 E             CDLWP2:	MOV	DH,BYTE PTR WDOLFT	; Unwrapped from start of line 
 08A1  FE C2                    	INC	DL		; Next line 
 08A3  FE C9                    	DEC	CL		; Update iteration counter 
 08A5  E8 0D03 R                	CALL	SCNRTL		; Read next lines terminator 
                                ;Need to restore LSTPOS to old value for character delete 
 08A8  8B 3E 0000 E             	MOV	DI,WORD PTR LSTLIN	; **Save current value of LSTPOS in SI 
 08AC  8F 06 0000 E             	POP	WORD PTR LSTLIN	; **Restore value before CDUNWP so CDELPH works properly 
 08B0  9C                       	PUSHF 
 08B1  57                       	PUSH	DI		; **Save current "true" value of LSTPOS 
 08B2  97                       	XCHG	DI,AX		; ** 
 08B3  3A 06 0000 E             	CMP	AL,BYTE PTR LSTLIN	; ** 
 08B7  9C                       	PUSHF			; ** 
 08B8  97                       	XCHG	DI,AX		; ** 
 08B9  E8 09AF R                	CALL	CDELPH		; Delete chars to end of line or LSTPOS 
 08BC  9D                       	POPF			; ** 
 08BD  5F                       	POP	DI		; ** 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-39
CONTROL CHARACTER ROUTINES - Character and word delete      

 08BE  74 04                    	JZ	CDLGNC		; **BRIF CDUNWP did not change LSTPOS 
 08C0  89 3E 0000 E             	MOV	WORD PTR LSTLIN,DI	; **Restore CDUNWP value of LSTPOS 
 08C4  0A E4                    CDLGNC:	OR	AH,AH 
 08C6  75 1C                    	JNZ	CDLGW1		; BRIF still chars on this line 
 08C8  9D                       	POPF 
 08C9  73 21                    	JNB	CDLGRT		; BRIF LF or wrap term'd, already removed 
 08CB  FE CA                    CDLGNL:	DEC	DL 
 08CD  FE C1                    	INC	CL 
 08CF  E8 0D03 R                	CALL	SCNRTL 
 08D2  72 07                    	JB	CDLGN0		; BRIF previous line EOL term'd, remove null line 
 08D4  74 16                    	JZ	CDLGRT		; BRIF previous line LF term'd, leave null line 
 08D6  B0 7F                    	MOV	AL,LOW OFFSET TRMEOL 
 08D8  E8 008A R                	CALL	SCNWTT		; Previous line was wrapped, terminate it and 
                                				;   remove null line 
 08DB  FE C2                    CDLGN0:	INC	DL 
 08DD  FE C9                    	DEC	CL 
 08DF  E8 0290 R                	CALL	SCRLU0		; Remove null line by scrolling 
 08E2  EB 08                    	JMP	SHORT CDLGRT	; All done 
                                 
 08E4  9D                       CDLGW1:	POPF 
 08E5  72 02                    	JB	CDLGEX		; BRIF at EOL, all done 
 08E7  75 97                    	JNZ	CDLGWP		; BRIF wrapped, unwrap chars from next line 
                                ;We have terminator in (AH,AL), posn in (DH,DL) 
 08E9  E8 008A R                CDLGEX:	CALL	SCNWTT		; Update terminator 
 08EC  02 CA                    CDLGRT:	ADD	CL,DL 
 08EE  5A                       	POP	DX 
 08EF  8A D1                    	MOV	DL,CL 
 08F1  C3                       	RET 
                                 
                                 
                                 
 08F2  B5 00                    CDUWXI:	MOV	CH,LOW 0	; Indicate no characters unwrapped 
 08F4  E9 0999 R                	JMP	CDUWPX		; Indirect jump 
                                 
                                ;SUBROUTINE CDUNWP:             ; "Unwrap" chars from next line 
                                ;                       On entry:   (AH,DL)= destination 
                                ;                       On exit:    (AH,AL)= new line terminator 
                                ;                                   CH=nunber of bytes unwrapped 
                                ; 
 08F7  53                       CDUNWP:	PUSH	BX 
 08F8  51                       	PUSH	CX 
 08F9  52                       	PUSH	DX 
 08FA  FF 36 0000 E             	PUSH	WORD PTR TRMCUR 
 08FE  B0 00                    	MOV	AL,LOW OFFSET TRMWRP 
 0900  8A 2E 0000 E             	MOV	CH,BYTE PTR LINLEN 
 0904  2A EC                    	SUB	CH,AH 
 0906  72 EA                    	JB	CDUWXI		; BRIF no space to unwrap characters to, just exit 
 0908  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN	; ** 
 090C  75 0D                    	JNZ	CDUWP0		; **BRIF not unwrapping to LSTPOS 
 090E  F6 06 0000 E FF          	TEST	BYTE PTR LSTCOL,LOW 377O	; ** 
 0913  75 06                    	JNZ	CDUWP0		; **BRIF have some characters to unwrap 
 0915  8A 26 0000 E             	MOV	AH,BYTE PTR LINLEN	; ** 
 0919  EB D7                    	JMP	SHORT CDUWXI	; **If no characters to unwrap, just exit 
 091B  FE C5                    CDUWP0:	INC	CH 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-40
CONTROL CHARACTER ROUTINES - Character and word delete      

 091D  8B D8                    	MOV	BX,AX		; Put DESTINATION in BX 
 091F  8A DA                    	MOV	BL,DL 
 0921  FE C2                    	INC	DL 
 0923  E8 0D03 R                	CALL	SCNRTL		; Read terminator for next line 
 0926  50                       	PUSH	AX 
 0927  9C                       	PUSHF 
 0928  3A EC                    	CMP	CH,AH 
 092A  76 02                    	JBE	CDUWP1		; BRIF enough characters to satisfy demand 
 092C  8A EC                    	MOV	CH,AH		; Else get all characters in next line 
 092E  B1 01                    CDUWP1:	MOV	CL,LOW 1 
 0930  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 0934  8B C2                    	MOV	AX,DX		; Put SOURCE in AX 
 0936  0A ED                    	OR	CH,CH 
 0938  75 11                    	JNZ	CDUWPN		; BRIF not a null line following 
 093A  9D                       	POPF 
 093B  9C                       	PUSHF 
 093C  74 33                    	JZ	CDUWP4		; BRIF LF term'd, don't remove null line 
 093E  FF 36 0000 E             	PUSH	WORD PTR TRMCUR 
 0942  E8 0290 R                	CALL	SCRLU0		; Get rid of null line following 
 0945  8F 06 0000 E             	POP	WORD PTR TRMCUR 
 0949  EB 26                    	JMP	SHORT CDUWP4	; Set up terminator for return 
 094B                           CDUWPN: 
 094B  E8 0000 E                	CALL	SCROLL		; Scroll chars from old line to new 
 094E  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0952  75 1D                    	JNZ	CDUWP4		; BRIF not on LSTPOS line 
                                ;If LSTPOS is between WDOLFT and SOURCE+COUNT, unwrap LSTPOS 
 0954  50                       	PUSH	AX 
 0955  02 E5                    	ADD	AH,CH 
 0957  2A 26 0000 E             	SUB	AH,BYTE PTR LSTCOL 
 095B  58                       	POP	AX 
 095C  76 13                    	JBE	CDUWP3		; BRIF LSTPOS .GT. SOURCE+COUNT 
 095E  28 26 0000 E             	SUB	BYTE PTR LSTCOL,AH	; LSTCOL=DESTINATION+(LSTPOS-SOURCE) 
 0962  73 05                    	JNB	CDUWPL 
 0964  C6 06 0000 E 00          	MOV	BYTE PTR LSTCOL,LOW 0	; LSTCOL was zero, don't let it go negative 
 0969  00 3E 0000 E             CDUWPL:	ADD	BYTE PTR LSTCOL,BH 
 096D  FE 0E 0000 E             	DEC	BYTE PTR LSTLIN	; LSTLIN is line unwrapped to 
                                COMMENT	% 
                                ; Blank from DESTINATION+COUNT-((SOURCE+COUNT)-LSTPOS) to EOL 
                                	PUSH    AX 
                                	PUSH    DX 
                                	PUSH    CX 
                                	ADDB    DH,CH 
                                	SUBB    DH,AH           ; (DH,DL)=start posn for blanking 
                                	MOVB    CH,LINLEN       ; CH=end column 
                                	MOVI    AX," " 
                                CDUWPB: CALL    SCROUT 
                                	INCB    DH 
                                	CMPB    DH,CH 
                                	JBE     CDUWPB          ; Continue blanking to EOL 
                                	POP     CX 
                                	POP     DX 
                                	POP     AX 
                                % 
 0971                           CDUWP3: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-41
CONTROL CHARACTER ROUTINES - Character and word delete      

                                ;Return terminator for DL-1 
 0971  02 FD                    CDUWP4:	ADD	BH,CH		; Get new terminator posn into BH 
 0973  FE CF                    	DEC	BH 
 0975  9D                       	POPF 
 0976  58                       	POP	AX		; Restore original terminators for this line 
 0977  B3 7F                    	MOV	BL,LOW OFFSET TRMEOL	; Assume line unwrapped is at EOL 
 0979  72 14                    	JB	CDUWPE		; BRIF at EOL 
 097B  B3 0A                    	MOV	BL,LOW OFFSET TRMLNF	; Assume LF was unwrapped on unwrapped line 
 097D  74 14                    	JZ	CDUWP6		; BRIF at LF 
                                ;WRAP or NULL_WRAP, if BH .NE. LINLEN, then it must be LINLEN-1 and NULL_WRAP 
 097F  B3 00                    CDUWP5:	MOV	BL,LOW OFFSET TRMWRP	; Assume line is WRAP 
 0981  3A 3E 0000 E             	CMP	BH,BYTE PTR LINLEN 
 0985  74 10                    	JZ	CDUWP7		; Previous line is full, must be WRAP 
 0987  B3 01                    	MOV	BL,LOW OFFSET TRMNWP 
 0989  8A 3E 0000 E             	MOV	BH,BYTE PTR LINLEN 
 098D  EB 08                    	JMP	SHORT CDUWP7	; Previous line not full even though we had 
                                				;   enough chars to fill it, must be NULL_WRAP 
                                ;EOL terminated 
 098F  0A E4                    CDUWPE:	OR	AH,AH 
 0991  74 04                    	JZ	CDUWP7		; If unwrapped null line, return EOL 
                                ;Was EOL or LF terminated, see if entire line was unwrapped 
 0993  3A E5                    CDUWP6:	CMP	AH,CH 
 0995  75 E8                    	JNZ	CDUWP5		; BRIF wasn't unwrapped, previous line is WRAP 
                                ;terminator=(BH,BL) 
 0997  53                       CDUWP7:	PUSH	BX 
                                ;       ORB     CH,CH 
                                ;       JZ      CDUWP8          ; BRIF no chars to delete from here on 
                                ;       MOVBI   CL,^O377        ; Set flag indicating can remove lines deleted 
                                ;       CALL    CDELLG          ; Delete CH characters at (DH,DL) 
 0998  58                       CDUWP8:	POP	AX 
 0999  8F 06 0000 E             CDUWPX:	POP	WORD PTR TRMCUR 
 099D  5A                       	POP	DX 
 099E  8A FD                    	MOV	BH,CH 
 09A0  59                       	POP	CX 
 09A1  8A EF                    	MOV	CH,BH 
 09A3  5B                       	POP	BX 
 09A4  C3                       	RET 
                                ;Needed one char and first char on next line is DBLCHR 
 09A5  58                       CDUWPF:	POP	AX 
 09A6  9D                       	POPF			; Clean up stack 
 09A7  8A 26 0000 E             	MOV	AH,BYTE PTR LINLEN 
 09AB  B0 01                    	MOV	AL,LOW OFFSET TRMNWP	; Set terminator to NULL_WRAP 
 09AD  EB E8                    	JMP	SHORT CDUWP7 
                                 
                                 
                                 
                                ;SUBROUTINE CDELPH              ; Delete chars on physical line 
                                ;                       On entry:   (DH,DL)=posn to start delete from 
                                ;                                   (AH,AL)=line terminator for line DL 
                                ;                                   CH=count 
                                ;                       On exit:    AH=term posn 
                                ;                                   (DH,DL)=posn 
                                ; 
 09AF                           CDELPH:				;PUSH    SI 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-42
CONTROL CHARACTER ROUTINES - Character and word delete      

 09AF  33 F6                    	XOR	SI,SI		; Set SI to zero(flag no char restore necessary) 
 09B1  53                       	PUSH	BX 
 09B2  51                       	PUSH	CX 
 09B3  52                       	PUSH	DX 
 09B4  50                       	PUSH	AX 
 09B5  3A F4                    	CMP	DH,AH 
 09B7  77 48                    	JA	CDEL9I		; BRIF delete beyond or at physical end 
 09B9  8B DA                    	MOV	BX,DX		; (BH,BL)=DESTINATION 
 09BB  8B C2                    	MOV	AX,DX 
 09BD  02 E5                    	ADD	AH,CH		; (AH,AL)=SOURCE 
 09BF  59                       	POP	CX		; CH=end of physical line 
 09C0  51                       	PUSH	CX 
 09C1  3A E5                    	CMP	AH,CH 
 09C3  76 04                    	JBE	CDELP0		; BRIF not deleting more than we have 
 09C5  8A E5                    	MOV	AH,CH 
 09C7  FE C4                    	INC	AH		; Delete entire line 
 09C9  3A 16 0000 E             CDELP0:	CMP	DL,BYTE PTR LSTLIN 
 09CD  75 0E                    	JNZ	CDELP1		; BRIF not on line with LSTPOS 
 09CF  3A 2E 0000 E             	CMP	CH,BYTE PTR LSTCOL 
 09D3  76 08                    	JBE	CDELP1		; BRIF physical end less than LSTPOS 
 09D5  8A 2E 0000 E             	MOV	CH,BYTE PTR LSTCOL	; Use LSTPOS as end of this line 
 09D9  3A F5                    	CMP	DH,CH 
 09DB  77 24                    	JA	CDEL9I		; BRIF delete beyond terminator 
 09DD                           CDELP1: 
 09DD  51                       	PUSH	CX		; Save last posn of SOURCE 
 09DE  2A EC                    	SUB	CH,AH 
 09E0  9C                       	PUSHF 
 09E1  8A F7                    	MOV	DH,BH 
 09E3  02 F5                    	ADD	DH,CH		; (DH,DL)=end of DESTINATION 
 09E5  9D                       	POPF 
 09E6  72 07                    	JB	CDELP4		; BRIF SOURCE greater than logical end of physical 
 09E8  B1 01                    	MOV	CL,LOW 1 
 09EA  FE C5                    	INC	CH 
 09EC  E8 0000 E                	CALL	SCROLL		; Move characters to left 
                                ;Blank from end of SOURCE to end of DESTINATION+1 
 09EF  59                       CDELP4:	POP	CX		; CH=end column of SOURCE 
 09F0  FE C6                    	INC	DH		; DH=end column of DESTINATION plus one 
 09F2  52                       	PUSH	DX 
 09F3  B8 0020                  	MOV	AX," " 
 09F6  3A F5                    CDELP5:	CMP	DH,CH 
 09F8  77 09                    	JA	CDELP6 
 09FA  E8 0000 E                	CALL	SCROUT		; Blank this posn 
 09FD  FE C6                    	INC	DH 
 09FF  EB F5                    	JMP	SHORT CDELP5 
 0A01  EB 4F                    CDEL9I:	JMP	SHORT CDELP9	; Indirect to CDELP9 
 0A03  5A                       CDELP6:	POP	DX		; Restore end column of DESTINATION plus one 
 0A04  58                       	POP	AX		; Restore terminator passed to routine 
                                ;CH=last valid column, DH=first blanking column, AH=term column, AL=term type 
 0A05  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0A09  75 15                    	JNZ	CDELP7		; BRIF was not delete before LSTPOS 
 0A0B  3A 2E 0000 E             	CMP	CH,BYTE PTR LSTCOL 
 0A0F  72 0F                    	JB	CDELP7		; BRIF delete up to terminator 
                                ;Delete included LSTPOS, subtract total deleted from LSTCOL 
 0A11  5A                       	POP	DX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-43
CONTROL CHARACTER ROUTINES - Character and word delete      

 0A12  59                       	POP	CX 
 0A13  28 2E 0000 E             	SUB	BYTE PTR LSTCOL,CH 
 0A17  73 0D                    	JAE	CDEL8A		; **BRIF LSTCOL valid 
 0A19  C6 06 0000 E 00          	MOV	BYTE PTR LSTCOL,LOW 0	; **Set LSTCOL to 0 
 0A1E  EB 06                    	JMP	SHORT CDEL8A	; Delete up to LSTPOS, adjust LSTPOS 
                                ;Deleted all data up to terminator, adjust terminator 
 0A20  8A E6                    CDELP7:	MOV	AH,DH 
 0A22  FE CC                    	DEC	AH		; Set terminator to last column of DESTINATION 
 0A24  5A                       CDELP8:	POP	DX		; (DH,DL)=original posn(start of DESTINATION) 
 0A25  59                       	POP	CX		; CL=flag 
 0A26  3A F4                    CDEL8A:	CMP	DH,AH 
 0A28  76 31                    	JBE	CDELPX		; BRIF still data remaining to right 
 0A2A  80 FE 01                 	CMP	DH,LOW 1 
 0A2D  75 2C                    	JNZ	CDELPX		; BRIF still data remaining to left 
 0A2F  3C 7F                    	CMP	AL,LOW OFFSET TRMEOL 
 0A31  74 28                    	JZ	CDELPX		; BRIF don't remove null line 
                                ;We have null line, remove it from the screen 
 0A33  FF 36 0000 E             	PUSH	WORD PTR TRMCUR 
 0A37  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN	; **If LSTPOS is wiped out, put it at 
                                				; ** end of previous line 
 0A3B  75 0C                    	JNZ	CDEL8B		; **BRIF not wiped out 
 0A3D  FE 0E 0000 E             	DEC	BYTE PTR LSTLIN	; ** 
 0A41  8A 3E 0000 E             	MOV	BH,BYTE PTR WDOLFT	; ** 
 0A45  88 3E 0000 E             	MOV	BYTE PTR LSTCOL,BH	; ** 
 0A49                           CDEL8B:				; ** 
 0A49  E8 0290 R                	CALL	SCRLU0		; Scroll up from bottom of screen to DL 
 0A4C  8F 06 0000 E             	POP	WORD PTR TRMCUR 
 0A50  EB 09                    	JMP	SHORT CDELPX	; All done 
                                ;We are deleting to right of line terminator 
 0A52  58                       CDELP9:	POP	AX		; Restore terminator passed 
 0A53  3C 0A                    	CMP	AL,LOW OFFSET TRMLNF 
 0A55  8A F4                    	MOV	DH,AH		; DH=end of valid data plus one 
 0A57  74 C7                    	JZ	CDELP7		; BRIF LF term'd, delete it 
 0A59  5A                       	POP	DX		; Delete beyond valid data, ignore it 
 0A5A  59                       	POP	CX 
 0A5B  5B                       CDELPX:	POP	BX 
 0A5C  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0A60  74 06                    	JZ	CDELPF		; BRIF not on LSTPOS line, no update 
 0A62  3A 26 0000 E             	CMP	AH,BYTE PTR LSTCOL 
 0A66  73 00                    	JAE	CDELPF		; BRIF LSTPOS is within line, no update 
                                				;POP     SI 
 0A68  C3                       CDELPF:	RET 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Line append, carriage return and linefeed 
                                 
                                 
                                 
                                ;Append to end of logical line 
                                ; 
 0A69                           LAPPND: 
 0A69  E8 0069 R                LAPPN0:	CALL	SCNRDT 
 0A6C  72 04                    	JB	LAPPN1		; BRIF we are at last line in logical 
 0A6E  FE C2                    	INC	DL 
 0A70  EB F7                    	JMP	SHORT LAPPN0	; See if next line is last line in logical 
 0A72  8A F4                    LAPPN1:	MOV	DH,AH		; Set current posn to EOL 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-44
CONTROL CHARACTER ROUTINES - Line append, carriage return an

 0A74  3A 26 0000 E             	CMP	AH,BYTE PTR LINLEN 
 0A78  73 03                    	JNB	LAPPN2		; If end of window, advance cursor posn here 
 0A7A  E9 05F6 R                	JMP	WCSADV		; Use logical cursor advance(advances LSTPOS) 
                                ;This will set the cursor posn one beyond end(wrap next char typed) 
 0A7D  FE C6                    LAPPN2:	INC	DH 
 0A7F  C3                       	RET 
                                 
                                ;Carriage return 
                                ; 
 0A80                           LCARET: 
 0A80  E8 0069 R                	CALL	SCNRDT 
 0A83  72 08                    	JB	LCRET1		; BRIF this line already EOL terminated 
 0A85  74 04                    	JZ	LCRET0		; BRIF LF terminated 
 0A87  3C 01                    	CMP	AL,LOW OFFSET TRMNWP 
 0A89  75 02                    	JNZ	LCRET1		; BRIF not NULL_WRAP terminated 
 0A8B  FE CC                    LCRET0:	DEC	AH		; Do not include LF or NULL_WRAP in line 
 0A8D  B0 7F                    LCRET1:	MOV	AL,LOW OFFSET TRMEOL 
 0A8F  E8 008A R                	CALL	SCNWTT		; Make this line EOL terminated 
 0A92  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; And move posn to left margin 
 0A96  C3                       	RET 
                                 
                                ;Line feed 
                                ; 
 0A97  BE 0000                  LFEED:	MOV	SI,0 
 0A9A  F6 06 0000 E FF          	TEST	BYTE PTR F_CRET,LOW 377O 
 0A9F  74 43                    	JZ	LFD90I		; BRIF LF following CR 
 0AA1  F6 06 0000 E FF          	TEST	BYTE PTR F_INST,LOW 377O 
 0AA6  74 3E                    	JZ	LFED30		; BRIF not insert mode 
 0AA8  E8 0D03 R                	CALL	SCNRTL 
 0AAB  3A E6                    	CMP	AH,DH 
 0AAD  72 37                    	JB	LFED30		; Inserting beyond end of physical(just append) 
                                ;Insert mode, move characters from cursor to EOL onto the next line 
 0AAF  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0AB3  74 2C                    	JZ	CBEPI2		; BRIF on LSTPOS line, can't do insert LF 
                                ; IMPROVEMENT: Find last physical in this logical and see if it can be moved 
                                ;   down one line. If not, abort before any inserts 
 0AB5                           LFED10: 
 0AB5  F8                       	CLC			; Indicate call is from Screen Editor 
 0AB6  E8 0000 E                	CALL	SCRINP 
 0AB9  8B F0                    	MOV	SI,AX		; Save first char in SI 
 0ABB  B8 0020                  	MOV	AX," " 
 0ABE  E8 0000 E                	CALL	SCROUT 
 0AC1  52                       	PUSH	DX 
 0AC2  B5 01                    LFED12:	MOV	CH,LOW 1 
 0AC4  E8 0B78 R                	CALL	MKRMCH		; Move everything over one 
 0AC7  FE C6                    	INC	DH 
 0AC9  3A 36 0000 E             	CMP	DH,BYTE PTR LINLEN 
 0ACD  76 F3                    	JBE	LFED12		; Keep going until the end of the line 
 0ACF  8A E2                    	MOV	AH,DL 
 0AD1  5A                       	POP	DX		; Restore posn 
 0AD2  8A D4                    	MOV	DL,AH 
 0AD4  E8 03BE R                	CALL	PLINIT		; Terminate line at current posn 
 0AD7  3A 16 0000 E             	CMP	DL,BYTE PTR WDOBOT 
 0ADB  75 55                    	JNZ	LFED43		; Change terminator to LF and goto next line 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-45
CONTROL CHARACTER ROUTINES - Line append, carriage return an

 0ADD  E9 0B64 R                	JMP	LFEEDX 
                                ;No room!! 
 0AE0  9D                       CBEEPI:	POPF			; Clean stack 
 0AE1  E9 0746 R                CBEPI2:	JMP	CBEEP 
 0AE4  EB 67                    LFD90I:	JMP	SHORT LFED90	; Indirect jump to LFED90 
                                ;Insert beyond end of physical=append 
                                ; Append LF to end of physical line 
 0AE6  E8 0D03 R                LFED30:	CALL	SCNRTL 
 0AE9  9C                       	PUSHF 
 0AEA  72 02                    	JB	LFED31		; BRIF need one more space to output LF 
 0AEC  74 02                    	JZ	LFED32		; BRIF already LF terminated, don't need space 
 0AEE  FE C4                    LFED31:	INC	AH		; Need one more space at terminator posn 
 0AF0  3A 26 0000 E             LFED32:	CMP	AH,BYTE PTR LINLEN 
 0AF4  76 2C                    	JBE	LFED40		; BRIF have room on this line 
 0AF6  E8 0C04 R                	CALL	LFWRAP		; Wrap linefeed to next line 
 0AF9  72 74                    	JB	LFED69		; BRIF no room 
                                ;The possibilities at this point are WRAP or EOL terminated 
 0AFB  9D                       	POPF 
 0AFC  73 0C                    	JNB	LFED34		; BRIF not EOL term'd(no change to terminator) 
 0AFE  E8 0069 R                	CALL	SCNRDT 
 0B01  8A 26 0000 E             	MOV	AH,BYTE PTR LINLEN	; EOL terminated, change to WRAP at LINLEN 
 0B05  B0 00                    	MOV	AL,LOW OFFSET TRMWRP 
 0B07  E8 008A R                	CALL	SCNWTT 
 0B0A  8A 36 0000 E             LFED34:	MOV	DH,BYTE PTR WDOLFT 
 0B0E  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0B12  75 08                    	JNZ	LFED35		; BRIF not extending LSTPOS 
 0B14  FE 06 0000 E             	INC	BYTE PTR LSTLIN	; Move LSTPOS with LF 
 0B18  88 36 0000 E             	MOV	BYTE PTR LSTCOL,DH 
 0B1C  FE C2                    LFED35:	INC	DL		; Move to new line(created by MKRMNL above) 
 0B1E  8A E6                    	MOV	AH,DH 
 0B20  EB 10                    	JMP	SHORT LFED43 
 0B22  9D                       LFED40:	POPF 
 0B23  73 05                    	JNB	LFED42		; BRIF not EOL, just change terminator to LF 
 0B25  E8 021B R                LFED41:	CALL	MKRMNL		; Open up next line 
 0B28  72 3A                    	JB	LFEEDX		; No room for LF 
                                ;SUCCESS: terminate current line with LF 
 0B2A  8A F4                    LFED42:	MOV	DH,AH 
 0B2C  B8 0020                  	MOV	AX," " 
 0B2F  E8 0000 E                	CALL	SCROUT		; Put a blank at terminator posn 
 0B32  E8 0069 R                LFED43:	CALL	SCNRDT		; Reread terminator in case of MKRMNL scroll up 
 0B35  8A E6                    	MOV	AH,DH 
 0B37  B0 0A                    	MOV	AL,LOW OFFSET TRMLNF 
 0B39  E8 008A R                	CALL	SCNWTT		; And terminate line with LF 
 0B3C  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0B40  75 12                    	JNZ	LFED95		; BRIF no LSTPOS update 
 0B42  C6 06 0000 E 00          	MOV	BYTE PTR LSTCOL,LOW 0	; LSTPOS moves to line beyond linefeed 
 0B47  FE 06 0000 E             	INC	BYTE PTR LSTLIN 
 0B4B  EB 07                    	JMP	SHORT LFED95 
 0B4D  56                       LFED90:	PUSH	SI 
 0B4E  E8 021B R                	CALL	MKRMNL		; Open up next line 
 0B51  5E                       	POP	SI 
 0B52  72 10                    	JB	LFEEDX		; No room 
 0B54  E8 0D65 R                LFED95:	CALL	CSRDWN		; Move to next line 
 0B57  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-46
CONTROL CHARACTER ROUTINES - Line append, carriage return an

 0B5B  0B F6                    	OR	SI,SI 
 0B5D  74 05                    	JZ	LFEEDX 
 0B5F  8B C6                    	MOV	AX,SI 
 0B61  E8 0000 E                	CALL	SCROUT		; Restore first char of insert linefeed 
 0B64  3A 16 0000 E             LFEEDX:	CMP	DL,BYTE PTR WDOBOT 
 0B68  76 04                    	JBE	LFEEDZ 
 0B6A  8A 16 0000 E             	MOV	DL,BYTE PTR WDOBOT 
 0B6E  C3                       LFEEDZ:	RET 
                                ;No room for linefeed, terminate this line and exit 
 0B6F  58                       LFED69:	POP	AX 
 0B70  EB F2                    	JMP	SHORT LFEEDX 
                                	SUBTTL  CONTROL CHARACTER ROUTINES - Insert and MKRMCH 
                                 
                                 
 0B72  80 36 0000 E FF          LINSRT:	XOR	BYTE PTR F_INST,LOW 377O	;Toggle insert flag 
 0B77  C3                       	RET 
                                 
                                ;SUBROUTINE MKRMCH              ; This routine opens up space in logical lines 
                                ;**                     On entry:   (DH,DL)=posn to open space 
                                ;**                                 CH=number of spaces to open(1 or 2) 
                                ;**                     On exit:    (DH,DL)=same posn(DL value can change) 
                                ;** 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	BUF:WORD 
 0000                           DSEG	ENDS 
 0B78  56                       MKRMCH:	PUSH	SI 
 0B79  50                       	PUSH	AX 
 0B7A  51                       	PUSH	CX 
 0B7B  52                       	PUSH	DX 
 0B7C  BE 0000 E                	MOV	SI,OFFSET BUF 
 0B7F  BF 0080 E                	MOV	DI,OFFSET BUF+128D	; SI and DI are overflow character buffers 
 0B82  E8 0069 R                	CALL	SCNRDT 
 0B85  9C                       	PUSHF 
 0B86  50                       	PUSH	AX 
 0B87  E8 0C1A R                	CALL	MVCHLN		; Move characters over put overflow at [DI] 
 0B8A  32 C9                    	XOR	CL,CL		; CL=Iteration depth(and count of physical lines) 
 0B8C  0A ED                    MKRMC0:	OR	CH,CH 
 0B8E  75 0B                    	JNZ	MKRMC1		; BRIF line overflowed 
 0B90  58                       	POP	AX 
 0B91  9D                       	POPF 
 0B92  02 CA                    MKRMCX:	ADD	CL,DL		; CL=original line number 
 0B94  5A                       	POP	DX		; DH=orginal column 
 0B95  8A D1                    	MOV	DL,CL		; DL=original line number 
 0B97  59                       MKRMX2:	POP	CX 
 0B98  58                       	POP	AX 
 0B99  5E                       	POP	SI 
 0B9A  C3                       	RET 
                                ;Line overflow we must wrap char to next line 
 0B9B  58                       MKRMC1:	POP	AX 
 0B9C  9D                       	POPF			; Get back old terminator 
 0B9D  72 0F                    	JB	MKRMC3		; BRIF was EOL term'd 
 0B9F  75 1E                    	JNZ	MKRMC4		; BRIF was WRAP or NULL_WRAP term'd 
                                ;Linefeed, make room for linefeed on next line 
 0BA1  50                       	PUSH	AX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-47
CONTROL CHARACTER ROUTINES - Insert and MKRMCH              

 0BA2  E8 0C04 R                	CALL	LFWRAP 
 0BA5  58                       	POP	AX 
 0BA6  72 0D                    	JB	MKRMCQ		;  No room, throw away overflow 
 0BA8  FE CD                    	DEC	CH 
 0BAA  74 E6                    	JZ	MKRMCX		; Only wrapped the linefeed, done 
 0BAC  EB 11                    	JMP	SHORT MKRMC4	; Pass overflow to next line 
                                ;EOL terminatedd 
 0BAE  50                       MKRMC3:	PUSH	AX 
 0BAF  E8 021B R                	CALL	MKRMNL		; Open up next line for overflow 
 0BB2  58                       	POP	AX 
 0BB3  73 0A                    	JNB	MKRMC4		; BRIF room, wrap overflow 
                                ;No room for wrap, terminate this line with EOL and exit 
 0BB5  E8 0069 R                MKRMCQ:	CALL	SCNRDT 
 0BB8  B0 7F                    	MOV	AL,LOW OFFSET TRMEOL 
 0BBA  E8 008A R                	CALL	SCNWTT		; No room for overflow, just terminate line 
 0BBD  EB D3                    	JMP	SHORT MKRMCX 
                                ;Insert overflow on next line 
 0BBF  3A 16 0000 E             MKRMC4:	CMP	DL,BYTE PTR LSTLIN 
 0BC3  75 17                    	JNZ	MKRMC6		; BRIF not on LSTPOS line 
                                ;AH=Old terminator posn, CH=Overflow count 
 0BC5  2A E5                    	SUB	AH,CH 
 0BC7  3C 01                    	CMP	AL,LOW OFFSET TRMNWP 
 0BC9  75 02                    	JNZ	MKRMC5		; BRIF wasn't NULL_WRAP, don't adjust posn 
 0BCB  FE CC                    	DEC	AH 
                                ;AH=First position wrapped - 1 
 0BCD  3A 26 0000 E             MKRMC5:	CMP	AH,BYTE PTR LSTCOL 
 0BD1  73 09                    	JAE	MKRMC6		; BRIF did not wrap LSTCOL 
                                ;Wrapped LSTPOS 
 0BD3  C6 06 0000 E 00          	MOV	BYTE PTR LSTCOL,LOW 0	; Set LSTPOS to start of next line 
 0BD8  FE 06 0000 E             	INC	BYTE PTR LSTLIN 
 0BDC  FE C2                    MKRMC6:	INC	DL		; (DH,DL)=start of next line 
 0BDE  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT 
 0BE2  FE C9                    	DEC	CL		; Decrement interation counter 
 0BE4  87 F7                    	XCHG	SI,DI		; Use other overflow buffer for this line 
 0BE6  E8 0069 R                	CALL	SCNRDT 
 0BE9  9C                       	PUSHF 
 0BEA  50                       	PUSH	AX 
 0BEB  51                       	PUSH	CX		; Save char count 
 0BEC  E8 0C1A R                	CALL	MVCHLN		; Make room on this line for previous overflow 
 0BEF  8B D9                    	MOV	BX,CX		; Save count of overflow 
 0BF1  59                       	POP	CX		; Get back overflow count in CH 
 0BF2  56                       	PUSH	SI		; Save pointer to characters for insertion 
                                ;Loop to output characters which overflowed onto this line from previous line 
 0BF3  FC                       MKRMC7:	CLD			; Scan forwards 
 0BF4  AD                       	LODSW			; Get a character 
 0BF5  E8 0000 E                	CALL	SCROUT		; Output it 
 0BF8  FE C6                    	INC	DH 
 0BFA  80 ED 01                 	SUB	CH,LOW 1 
 0BFD  77 F4                    	JA	MKRMC7		; Output the next char 
 0BFF  5E                       	POP	SI 
 0C00  8A EF                    	MOV	CH,BH		; Restore overflow count for this line 
 0C02  EB 88                    	JMP	SHORT MKRMC0	; Wrap new overflow 
                                 
                                ;Wrap a linefeed to next line 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-48
CONTROL CHARACTER ROUTINES - Insert and MKRMCH              

 0C04  FE C2                    LFWRAP:	INC	DL 
 0C06  E8 021B R                	CALL	MKRMNL 
 0C09  72 09                    	JB	LFWPEX		;  room, throw away overflow 
 0C0B  52                       	PUSH	DX 
 0C0C  E8 034B R                	CALL	SCRDLN		; Scroll this line down to next 
 0C0F  5A                       	POP	DX 
 0C10  E8 0D13 R                	CALL	LFTERM		; Make this line LF term'd 
 0C13  F8                       	CLC 
 0C14  FE CA                    LFWPEX:	DEC	DL		; Restore original line number 
 0C16  C3                       	RET 
                                 
                                ;SUBROUTINE MVCHLN              ; Open up space in physical line 
                                ;**                     On entry:   (DH,DL)=posn to open space at 
                                ;**                                 SI=address of buffer to put overflow chars 
                                ;**                     On exit:    (DH,DL)=same posn(DL might change if scroll) 
                                ;**                                 CH=No. of bytes overflowed 
                                ;**                                 BX destroyed 
                                ;** 
 0C17  E9 0CD3 R                MVC30I:	JMP	MVCH30 
                                ;MVC80I: JMP     MVCH80 
 0C1A  57                       MVCHLN:	PUSH	DI 
 0C1B  51                       	PUSH	CX 
 0C1C  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0C20  8A 0E 0000 E             	MOV	CL,BYTE PTR LINLEN 
 0C24  75 04                    	JNZ	MVCH00		; BRIF within logical EOL(unless beyond TERM_POS) 
 0C26  8A 0E 0000 E             	MOV	CL,BYTE PTR LSTCOL 
 0C2A  E8 0D03 R                MVCH00:	CALL	SCNRTL		; AX=current physical terminator 
 0C2D  3A E6                    	CMP	AH,DH 
 0C2F  72 E6                    	JB	MVC30I		; BRIF inserting beyond end of physical 
 0C31  3A 16 0000 E             	CMP	DL,BYTE PTR LSTLIN 
 0C35  75 06                    	JNZ	MVCH03 
 0C37  3A CC                    	CMP	CL,AH 
 0C39  73 02                    	JNB	MVCH03		; BRIF LSTPOS .GTE. TERM_POSN 
 0C3B  8A E1                    	MOV	AH,CL		; Else use LSTPOS as TERM_POSN 
                                ;We are inserting before end of physical line and LSTPOS .GTE. TERM_POSN 
 0C3D  52                       MVCH03:	PUSH	DX 
 0C3E  50                       	PUSH	AX 
 0C3F  02 EC                    	ADD	CH,AH		; CH=last column for space needed 
 0C41  2A 2E 0000 E             	SUB	CH,BYTE PTR LINLEN 
 0C45  77 04                    	JA	MVCH10		; BRIF overflow 
 0C47  32 FF                    	XOR	BH,BH		; Indicate no overflow 
 0C49  EB 1A                    	JMP	SHORT MVCH20 
                                ;We have overflow bytes to save 
 0C4B  8A F4                    MVCH10:	MOV	DH,AH 
 0C4D  2A F5                    	SUB	DH,CH 
 0C4F  FE C6                    	INC	DH		; DH=column of first overflow to save 
 0C51  F8                       	CLC			; Indicate call is from Screen Editor 
 0C52  E8 0000 E                	CALL	SCRINP		; Read an overflow char 
 0C55  8B D9                    	MOV	BX,CX		; Save overflow count in BH 
                                ;Loop to move overflow character to save buffer 
 0C57  FC                       MVCH14:	CLD 
 0C58  AB                       	STOSW			; Save overflow char 
 0C59  FE CD                    	DEC	CH 
 0C5B  74 08                    	JZ	MVCH20		; All done with overflow save 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-49
CONTROL CHARACTER ROUTINES - Insert and MKRMCH              

 0C5D  FE C6                    	INC	DH 
 0C5F  F8                       	CLC			; Indicate call is from Screen Editor 
 0C60  E8 0000 E                	CALL	SCRINP		; Read an overflow char 
 0C63  EB F2                    	JMP	SHORT MVCH14	; And save it 
                                ;Move characters in line over 
 0C65  8B CB                    MVCH20:	MOV	CX,BX		; Restore # bytes overflowed to CH 
 0C67  58                       	POP	AX		; AH=term posn 
 0C68  2A E5                    	SUB	AH,CH		; Adjust term posn so move doesn't overflow 
 0C6A  5A                       	POP	DX		; DH=start column of insert 
 0C6B  5B                       	POP	BX		; BH=number of bytes to move over 
 0C6C  8A CB                    	MOV	CL,BL 
 0C6E  51                       	PUSH	CX		; Save overflow count and CL for restore on exit 
 0C6F  8A EC                    	MOV	CH,AH		; CH=last column to move 
 0C71  2A EE                    	SUB	CH,DH 
 0C73  FE C5                    	INC	CH		; CH=count of chars from CURPOS to TERMPOS 
 0C75  9C                       	PUSHF 
 0C76  B1 01                    	MOV	CL,LOW 1	; Move on one line 
 0C78  8B C2                    	MOV	AX,DX		; FROM=CURPOS 
 0C7A  8A DA                    	MOV	BL,DL 
 0C7C  02 FE                    	ADD	BH,DH		; TO=CURPOS+COUNT 
 0C7E  9D                       	POPF 
 0C7F  75 04                    	JNZ	MVCH21		; BRIF count not zero, do move 
 0C81  8A FE                    	MOV	BH,DH		; All characters to move overflowed 
 0C83  EB 07                    	JMP	SHORT MVCH22	; Just update terminator to current posn 
 0C85  E8 0000 E                MVCH21:	CALL	SCROL2		; Move over characters 
 0C88  02 FD                    	ADD	BH,CH		; New TERMPOS=TO+number of characters moved 
 0C8A  FE CF                    	DEC	BH 
 0C8C  59                       MVCH22:	POP	CX		; CH=-(No. of bytes wrapped) 
                                ;CH=overflow count, CL=insert count, BH=terminator posn 
 0C8D  E8 0069 R                MVCH23:	CALL	SCNRDT 
 0C90  72 22                    	JB	MVCH25 
 0C92  74 20                    	JZ	MVCH25 
                                ;We have wrapped chars, terminate either WRAP or NULL_WRAP 
 0C94  3A 3E 0000 E             MVCH24:	CMP	BH,BYTE PTR LINLEN 
 0C98  B0 00                    	MOV	AL,LOW OFFSET TRMWRP 
 0C9A  74 1C                    	JZ	MVCH26 
 0C9C  0A ED                    	OR	CH,CH 
 0C9E  74 18                    	JZ	MVCH26 
 0CA0  B0 01                    	MOV	AL,LOW OFFSET TRMNWP	; Null wrap that does not overflow changes to wrap 
 0CA2  8A 3E 0000 E             	MOV	BH,BYTE PTR LINLEN 
 0CA6  50                       	PUSH	AX 
 0CA7  52                       	PUSH	DX 
 0CA8  8A F7                    	MOV	DH,BH 
 0CAA  B8 0020                  	MOV	AX," "		; Blank DBLCHR destroyed by scroll 
 0CAD  E8 0000 E                	CALL	SCROUT 
 0CB0  5A                       	POP	DX 
 0CB1  58                       	POP	AX 
 0CB2  EB 04                    	JMP	SHORT MVCH26 
                                ;Was EOL or LF terminated 
 0CB4  0A ED                    MVCH25:	OR	CH,CH 
 0CB6  75 DC                    	JNZ	MVCH24		; Overflow means WRAP or NULL_WRAP 
 0CB8  3A E7                    MVCH26:	CMP	AH,BH 
 0CBA  77 05                    	JA	MVCH27		; Terminator beyond scroll end 
 0CBC  8A E7                    	MOV	AH,BH 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-50
CONTROL CHARACTER ROUTINES - Insert and MKRMCH              

                                ;AH=New terminator, CL=insert count 
 0CBE  E8 008A R                	CALL	SCNWTT		; Update terminator 
 0CC1  3A 16 0000 E             MVCH27:	CMP	DL,BYTE PTR LSTLIN 
 0CC5  75 0A                    	JNZ	MVCHEX		; BRIF move is not on LSTPOS line 
 0CC7  3A 3E 0000 E             	CMP	BH,BYTE PTR LSTCOL 
 0CCB  76 04                    	JBE	MVCHEX		; BRIF end of move is before LSTPOS 
 0CCD  88 3E 0000 E             	MOV	BYTE PTR LSTCOL,BH	; Else add number moved over to LSTPOS 
 0CD1  5F                       MVCHEX:	POP	DI 
 0CD2  C3                       	RET 
                                ;Inserting beyond end of logical 
 0CD3  8A CD                    MVCH30:	MOV	CL,CH		; Save insert count in CL 
 0CD5  02 EE                    	ADD	CH,DH		; CH=end of insert 
 0CD7  3C 0A                    	CMP	AL,LOW OFFSET TRMLNF 
 0CD9  74 02                    	JZ	MVCH31		; BRIF LF term'd cannot push null off end 
 0CDB  FE CD                    	DEC	CH		; Ignore one null push off end of physical 
 0CDD  3A 2E 0000 E             MVCH31:	CMP	CH,BYTE PTR LINLEN 
 0CE1  76 19                    	JBE	MVCH33		; BRIF have room 
                                ;No room, return blanks overflow, update terminator 
 0CE3  2A 2E 0000 E             	SUB	CH,BYTE PTR LINLEN	; CH=No. of overflow bytes 
 0CE7  B8 0020                  	MOV	AX," " 
 0CEA  51                       	PUSH	CX 
 0CEB  FC                       MVCH32:	CLD			; Store overflow bytes(All blanks) 
 0CEC  AB                       	STOSW 
 0CED  FE CD                    	DEC	CH 
 0CEF  75 FA                    	JNZ	MVCH32 
 0CF1  59                       	POP	CX		; Restore CH=number of overflow bytes 
 0CF2  5B                       	POP	BX 
 0CF3  8A FD                    	MOV	BH,CH 
 0CF5  53                       	PUSH	BX		; Put overflow count with original CL on stack 
 0CF6  8A 3E 0000 E             	MOV	BH,BYTE PTR LINLEN	; BH=term posn, CH=overflow count, CL=insert count 
 0CFA  EB 91                    	JMP	SHORT MVCH23	; Update terminator and LSTPOS, exit 
                                ;Have room, just update terminator 
 0CFC  5B                       MVCH33:	POP	BX 
 0CFD  B7 00                    	MOV	BH,LOW 0	; Put overflow count(=0) on stack for return 
 0CFF  86 FD                    	XCHG	BH,CH		; BH=term posn, CH=overflow count, CL=insert count 
 0D01  EB 8A                    	JMP	SHORT MVCH23	; New term posn still .LTE. LINLEN 
                                COMMENT	% 
                                ;On LSTLIN, possibly insert to LSTPOS or LSTPOS+COUNT 
                                ;N.B. We are guaranteed to be at a posn to left of TERM_POS 
                                ;Two cases: insert up to LSTPOS or insert up to LSTPOS+COUNT 
                                MVCH80: PUSH    DX 
                                	PUSH    CX 
                                	PUSH    AX 
                                	MOVB    CL,AH           ; Save TERM_POS in CL for compare 
                                	MOVB    DH,LSTCOL 
                                ;Scan from LSTPOS+1 to lesser of (LSTPOS+COUNT,TERM_POS) or non-blank character 
                                MVCH81: INCB    DH              ; Next column 
                                IFN     IBMLIK,< 
                                	CLC                     ; Indicate call is from Screen Editor 
                                >                               ; IFN IBMLIK 
                                	CALL    SCRINP          ; AX=character at this posn 
                                IFN     DBLCHR,< 
                                	JNB     MVCH82          ; BRIF not reading second of double byte char 
                                	INCB    DH              ; Restore DH(SCRINP decremented it) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-51
CONTROL CHARACTER ROUTINES - Insert and MKRMCH              

                                >                               ; IFN DBLCHR 
                                MVCH82: CMPI    AX," " 
                                	JNZ     MVCH86          ; Found non-blank 
                                	CMPB    DH,CL 
                                	JAE     MVCH84          ; At TERM_POS 
                                MVCH83: DECB    CH 
                                	JNZ     MVCH81          ; Not at LSTPOS+COUNT, continue scan 
                                ;Insert to LSTPOS+COUNT [;or TERM_POS+COUNT, whichever is smaller] 
                                MVCH84: POP     AX 
                                	POP     CX 
                                	POP     DX 
                                	MOVB    AH,LSTCOL       ; Change end of FROM insert window to LSTPOS 
                                MVCH85: JMP     MVCH03          ; Insert to LSTPOS 
                                ;Insert to last blank after LSTPOS 
                                MVCH86: POP     AX              ; AX=current terminators 
                                	POP     BX              ; BH=Count desired 
                                	MOVB    CH,DH           ; CH=end of TO insert window 
                                	DECB    CH 
                                	POP     DX              ; (DH,DL)=current posn 
                                	ADDB    BH,DH           ; BH=start of TO insert window 
                                	SUBB    CH,BH           ; CH=character count to move 
                                	JB      MVCH89          ; BRIF at end, just overwrite last char 
                                	INCB    CH 
                                	MOVBI   CL,1            ; Move on one line 
                                	MOVB    BL,DL           ; (BH,BL)=start of TO window 
                                	MOV     AX,DX           ; (AH,AL)=start of FROM window 
                                IFN     DBLCHR,< 
                                	PUSH    DX 
                                	PUSH    AX 
                                	MOV     DX,AX 
                                	ADDB    DH,CH 
                                IFN     IBMLIK,< 
                                	CLC                     ; Indicate call is from Screen Editor 
                                >                               ; IFN IBMLIK 
                                	CALL    SCRINP          ; Are we going to scroll half of a double byte char? 
                                	MOVI    AX," " 
                                	JNB     MVCH88 
                                	INCB    DH 
                                MVCH88: CALL    SCROUT          ; Obliterate double byte char scrolled on top of 
                                	POP     AX 
                                	POP     DX 
                                >                               ; IFN DBLCHR 
                                	CALL    SCROL2          ; Move characters over 
                                MVCH89: POP     CX 
                                	XORB    CH,CH           ; No characters wrapped 
                                	JMP     MVCHEX          ; All done 
                                % 
                                ;SUBROUTINE SCROL2              ; Used by insert code to move over chars in line 
                                ;                           On entry:   AH,BH,CH=scroll parameters 
                                ; 
 =                              	SCROL2	EQU	SCROLL	; No DBLCHR save/restore 
                                ;SUBROUTINE SCNRTL              ; Read logical terminator for physical line 
                                ;**                     On entry:   DL=line number 
                                ;**                     On exit:    AX=terminators 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-52
CONTROL CHARACTER ROUTINES - Insert and MKRMCH              

                                ;**                                 CF set indicates EOL terminator 
                                ;**                                 CF clear, ZF set indicates LF terminator 
                                ;**                                 If NULL_WRAP terminator AH=TERM_POS-1 
 0D03  E8 0069 R                SCNRTL:	CALL	SCNRDT		; Get terminators 
 0D06  72 0A                    	JB	SCNRT2		; BRIF not NULL_WRAP 
 0D08  74 08                    	JZ	SCNRT2		; BRIF not NULL_WRAP 
 0D0A  9C                       	PUSHF 
 0D0B  3C 01                    	CMP	AL,LOW OFFSET TRMNWP 
 0D0D  75 02                    	JNZ	SCNRT1		; BRIF not NULL_WRAP 
 0D0F  FE CC                    	DEC	AH		; Is NULL_WRAP, decrement posn 
 0D11  9D                       SCNRT1:	POPF 
 0D12  C3                       SCNRT2:	RET 
                                 
                                ;Wrap a linefeed(already a successful MKRMNL) 
 0D13  FF 36 0000 E             LFTERM:	PUSH	WORD PTR TRMCUR 
 0D17  50                       	PUSH	AX 
 0D18  E8 0069 R                	CALL	SCNRDT		; Read next line terminator 
 0D1B  B0 0A                    	MOV	AL,LOW OFFSET TRMLNF 
 0D1D  8A 26 0000 E             	MOV	AH,BYTE PTR WDOLFT 
 0D21  E8 008A R                	CALL	SCNWTT		; Write out LF terminator at left margin plus one 
 0D24  58                       	POP	AX 
 0D25  8F 06 0000 E             	POP	WORD PTR TRMCUR 
 0D29  C3                       	RET 
                                	SUBTTL CURSOR MOVEMENT within window 
                                 
                                 
                                 
                                ;       These routines return CF=1 when they do not change the posn. 
                                ; 
                                ;Cursor right within window(or within physical line if outside window) 
 0D2A  FE C6                    CSRADV:	INC	DH		; Next column 
 0D2C  38 36 0000 E             	CMP	BYTE PTR LINLEN,DH 
 0D30  73 0B                    	JAE	CSRRET		; BRIF Good value 
 0D32  FE CE                    	DEC	DH 
 0D34  E8 0D65 R                	CALL	CSRDWN 
 0D37  72 04                    	JB	CSRRET		; BRIF can't change physical lines 
 0D39  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; First column 
 0D3D  C3                       CSRRET:	RET 
                                 
                                ;Cursor left within window(or within physical line if outside window) 
 0D3E  FE CE                    CSRREG:	DEC	DH		; Previous column 
 0D40  3A 36 0000 E             	CMP	DH,BYTE PTR WDOLFT 
 0D44  73 F7                    	JNB	CSRRET		; BRIF good value 
 0D46  FE C6                    	INC	DH		; Restore column 
 0D48  E8 0D52 R                	CALL	CSRUP 
 0D4B  72 F0                    	JB	CSRRET		; BRIF can't change physical lines 
 0D4D  8A 36 0000 E             	MOV	DH,BYTE PTR LINLEN	; Last column 
 0D51  C3                       	RET 
                                 
                                ;Cursor up within window(or NOP if outside window) 
 0D52  38 16 0000 E             CSRUP:	CMP	BYTE PTR WDOBOT,DL 
 0D56  72 E5                    	JB	CSRRET		; BRIF outside of window 
 0D58  3A 16 0000 E             	CMP	DL,BYTE PTR WDOTOP 
 0D5C  72 DF                    	JB	CSRRET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-53
CURSOR MOVEMENT within window                               

 0D5E  F9                       	STC 
 0D5F  74 DC                    	JZ	CSRRET		; BRIF at top or outside of window 
 0D61  F8                       	CLC 
 0D62  FE CA                    	DEC	DL 
 0D64  C3                       	RET 
                                 
                                ;Cursor down within window(or NOP if outside window) 
 0D65  3A 16 0000 E             CSRDWN:	CMP	DL,BYTE PTR WDOTOP 
 0D69  72 D2                    	JB	CSRRET		; BRIF outside window 
 0D6B  38 16 0000 E             	CMP	BYTE PTR WDOBOT,DL 
 0D6F  72 CC                    	JB	CSRRET		; BRIF at bottom or outside of window 
 0D71  F9                       	STC 
 0D72  74 C9                    	JZ	CSRRET 
 0D74  F8                       	CLC 
 0D75  FE C2                    	INC	DL		; Next line 
 0D77  C3                       	RET 
                                	SUBTTL CURSOR MOVEMENT within logical line 
                                 
                                 
                                 
                                ;Cursor advance within logical line 
                                ;                   on entry:   DH=current column, DL=current line 
                                ;                   on exit:    If CF clear, DH=new column, DL=new line 
                                ;                                   Else DH=EOL column, DL=EOL line 
                                ;                                   ZF=1 if stop at LSTPOS 
                                ;                               AH=terminator column, AL=terminator value 
                                ; 
 0D78  3A 16 0000 E             LCSADV:	CMP	DL,BYTE PTR LSTLIN 
 0D7C  75 0D                    	JNZ	LCSAD0		; BRIF not at LSTPOS 
 0D7E  3A 36 0000 E             	CMP	DH,BYTE PTR LSTCOL 
 0D82  72 07                    	JB	LCSAD0		; BRIF not at LSTPOS 
 0D84  E8 0069 R                	CALL	SCNRDT 
 0D87  3A E4                    	CMP	AH,AH		; Set ZF=1 if stop at LSTPOS 
 0D89  F9                       	STC 
 0D8A  C3                       LCSADX:	RET 
 0D8B  E8 0069 R                LCSAD0:	CALL	SCNRDT 
 0D8E  72 11                    	JB	LCSAD2		; BRIF at last line 
 0D90  E8 0D2A R                LCSAD1:	CALL	CSRADV 
 0D93  72 10                    	JB	LCSADA		; BRIF at end of window 
 0D95  3A E6                    	CMP	AH,DH 
 0D97  73 F1                    	JNB	LCSADX		; BRIF within logical line 
 0D99  FE C2                    	INC	DL 
 0D9B  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; Else wrap to next physical of logical 
 0D9F  F8                       	CLC 
 0DA0  C3                       	RET 
 0DA1  3A E6                    LCSAD2:	CMP	AH,DH 
 0DA3  77 EB                    	JA	LCSAD1		; BRIF not at EOL or beyond 
 0DA5  0A F6                    LCSADA:	OR	DH,DH		; ZF=1(not stop at LSTPOS) 
 0DA7  F9                       	STC 
 0DA8  C3                       	RET 
                                ;Cursor regress within logical line 
                                ;                   on entry:   DH=current column, DL=current line 
                                ;                   on exit:    If CF clear, DH=new column, DL=new line 
                                ;                                   Else DH=EOL column, DL=EOL line 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-54
CURSOR MOVEMENT within logical line                         

                                ;                                   If stop at FSTPOS, ZF is set 
                                ; 
 0DA9  3A 16 0000 E             LCSREG:	CMP	DL,BYTE PTR FSTLIN 
 0DAD  75 08                    	JNZ	LCSRG0		; BRIF not at FSTPOS 
 0DAF  3A 36 0000 E             	CMP	DH,BYTE PTR FSTCOL 
 0DB3  77 02                    	JA	LCSRG0		; BRIF not at FSTPOS 
 0DB5  F9                       	STC 
 0DB6  C3                       	RET			; ZF=1, CF=1, stop at FSTPOS 
 0DB7  53                       LCSRG0:	PUSH	BX 
 0DB8  8B DA                    	MOV	BX,DX 
 0DBA  E8 0D3E R                	CALL	CSRREG 
 0DBD  72 0F                    	JB	LCSRGA		; BRIF at top of window 
 0DBF  3A DA                    	CMP	BL,DL 
 0DC1  74 0E                    	JZ	LCSRGX		; BRIF on same line, must be good posn 
 0DC3  E8 0069 R                	CALL	SCNRDT 
 0DC6  73 09                    	JNB	LCSRGX		; BRIF still on same logical line 
 0DC8  8A D3                    	MOV	DL,BL		; Move back to line we were on 
 0DCA  8A 36 0000 E             	MOV	DH,BYTE PTR WDOLFT	; And posn at start of that line 
 0DCE  0A F6                    LCSRGA:	OR	DH,DH		; ZF=0(not stop at FSTPOS) 
 0DD0  F9                       	STC 
 0DD1  5B                       LCSRGX:	POP	BX 
 0DD2  C3                       	RET			; Return CF set(at EOL) 
                                 
 0DD3                           LSTART: 
 0DD3  3A 16 0000 E             LSTRT0:	CMP	DL,BYTE PTR FSTLIN 
 0DD7  74 0C                    	JZ	LSTRT1 
 0DD9  E8 0D52 R                	CALL	CSRUP 
 0DDC  72 07                    	JB	LSTRT1		; Top of window must be start of line 
 0DDE  E8 0069 R                	CALL	SCNRDT 
 0DE1  73 F0                    	JNB	LSTRT0		; BRIF this line is part of logical 
 0DE3  FE C2                    	INC	DL 
 0DE5  8A 36 0000 E             LSTRT1:	MOV	DH,BYTE PTR WDOLFT 
 0DE9  72 04                    	JB	LSTRTX		; BRIF not using FSTPOS, use left margin 
 0DEB  8A 36 0000 E             	MOV	DH,BYTE PTR FSTCOL 
 0DEF  C3                       LSTRTX:	RET 
                                	SUBTTL  MISCELLANEOUS ROUTINES 
                                 
                                 
                                 
                                ;********************************************************* 
                                ;CHECK FOR WORD OR NON-WORD CHAR(ALPHA NUMERIC) 
                                ; 
 0DF0  52                       ANCHK:	PUSH	DX 
 0DF1  F8                       	CLC			; Indicate call is from Screen Editor 
 0DF2  E8 0000 E                	CALL	SCRINP		; Read character at current posn in DX 
 0DF5  73 02                    	JNB	ANCH0		; BRIF DH was not decremented 
 0DF7  FE C6                    	INC	DH 
 0DF9  0A E4                    ANCH0:	OR	AH,AH 
 0DFB  75 18                    	JNZ	ANCNO		; BRIF is two-byte character - reject 
 0DFD  3C 30                    	CMP	AL,LOW 60O 
 0DFF  72 14                    	JB	ANCNO		; BRIF is not alpha-numeric 
 0E01  3C 3A                    	CMP	AL,LOW 72O 
 0E03  72 13                    	JB	ANYES		; BRIF is numeric 
 0E05  3C 41                    	CMP	AL,LOW 101O 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASIPage     1-55
MISCELLANEOUS ROUTINES                                      

 0E07  72 0C                    	JB	ANCNO		; BRIF is not alpha-numeric 
 0E09  3C 5B                    	CMP	AL,LOW 133O 
 0E0B  72 0B                    	JB	ANYES		; BRIF is alpha 
 0E0D  3C 61                    	CMP	AL,LOW 141O 
 0E0F  72 04                    	JB	ANCNO		; BRIF is not alpha-numeric 
 0E11  3C 7B                    	CMP	AL,LOW 173O 
 0E13  72 03                    	JB	ANYES		; BRIF is small alpha 
 0E15  F9                       ANCNO:	STC 
 0E16  5A                       	POP	DX 
 0E17  C3                       	RET 
                                 
 0E18  F8                       ANYES:	CLC 
 0E19  5A                       	POP	DX 
 0E1A  C3                       	RET 
 0E1B                           CSEG	ENDS 
                                	END 

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-1
                                                             

Macros:

		N a m e			Lines

ACRLF  . . . . . . . . . . . . .  	   2
ADR  . . . . . . . . . . . . . .  	   1
CALLOS . . . . . . . . . . . . .  	   1
CHRGET . . . . . . . . . . . . .  	   1
COMPAR . . . . . . . . . . . . .  	   2
DBGBRK . . . . . . . . . . . . .  	   1
DC . . . . . . . . . . . . . . .  	   6
DJNZ . . . . . . . . . . . . . .  	   2
FSIGN  . . . . . . . . . . . . .  	   1
GETYPE . . . . . . . . . . . . .  	   1
INS86  . . . . . . . . . . . . .  	  13
INST . . . . . . . . . . . . . .  	   1
LDDR . . . . . . . . . . . . . .  	   8
LDIR . . . . . . . . . . . . . .  	   8
MOVRI  . . . . . . . . . . . . .  	   6
OUTCHR . . . . . . . . . . . . .  	   1
POPR . . . . . . . . . . . . . .  	   2
PUSHM  . . . . . . . . . . . . .  	   5
PUSHR  . . . . . . . . . . . . .  	   2
ROFFST . . . . . . . . . . . . .  	   2
SYNCHK . . . . . . . . . . . . .  	   2

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CSEG . . . . . . . . . . . . . .  	0E1B	PARA	PUBLIC	'CODESG'
DSEG . . . . . . . . . . . . . .  	0000	PARA	PUBLIC	'DATASG'

Symbols:            

                N a m e         	Type	Value	Attr         

ALTAIR . . . . . . . . . . . . .  	Number	0000	
ANCH0  . . . . . . . . . . . . .  	L NEAR	0DF9	CSEG
ANCHK  . . . . . . . . . . . . .  	L NEAR	0DF0	CSEG
ANCNO  . . . . . . . . . . . . .  	L NEAR	0E15	CSEG
ANSI . . . . . . . . . . . . . .  	Number	0001	
ANYES  . . . . . . . . . . . . .  	L NEAR	0E18	CSEG
ASCBS  . . . . . . . . . . . . .  	Number	0008	
ASCCR  . . . . . . . . . . . . .  	Number	000D	
ASCCTC . . . . . . . . . . . . .  	Number	0003	
ASCCTS . . . . . . . . . . . . .  	Number	0013	
ASCCTZ . . . . . . . . . . . . .  	Number	001A	
ASCESC . . . . . . . . . . . . .  	Number	001B	
ASCLF  . . . . . . . . . . . . .  	Number	000A	
ASCSPC . . . . . . . . . . . . .  	Number	0020	
ASCTAB . . . . . . . . . . . . .  	Number	0009	

BAKSP1 . . . . . . . . . . . . .  	L NEAR	0856	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-2
                                                             

BAKSPC . . . . . . . . . . . . .  	L NEAR	0842	CSEG
BASDEB . . . . . . . . . . . . .  	Number	0000	
BCKWD2 . . . . . . . . . . . . .  	L NEAR	070B	CSEG
BCKWD4 . . . . . . . . . . . . .  	L NEAR	0710	CSEG
BCKWD5 . . . . . . . . . . . . .  	L NEAR	0715	CSEG
BCKWD6 . . . . . . . . . . . . .  	L NEAR	0722	CSEG
BCKWD7 . . . . . . . . . . . . .  	L NEAR	072D	CSEG
BCKWD8 . . . . . . . . . . . . .  	L NEAR	0736	CSEG
BCKWDX . . . . . . . . . . . . .  	L NEAR	0724	CSEG
BCKWRD . . . . . . . . . . . . .  	L NEAR	06F5	CSEG
BEEP . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
BEEPSW . . . . . . . . . . . . .  	Number	0001	
BINCSW . . . . . . . . . . . . .  	Number	0000	
BINFID . . . . . . . . . . . . .  	Number	00FF	
BLODSW . . . . . . . . . . . . .  	Number	0001	
BSVFID . . . . . . . . . . . . .  	Number	00FD	
BUF  . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
BUFLEN . . . . . . . . . . . . .  	Number	00FF	

CANON  . . . . . . . . . . . . .  	Number	0000	
CASSW  . . . . . . . . . . . . .  	Number	0000	
CBEEP  . . . . . . . . . . . . .  	L NEAR	0746	CSEG
CBEEPI . . . . . . . . . . . . .  	L NEAR	0AE0	CSEG
CBEPI2 . . . . . . . . . . . . .  	L NEAR	0AE1	CSEG
CCLRSN . . . . . . . . . . . . .  	L NEAR	074C	CSEG
CDEL8A . . . . . . . . . . . . .  	L NEAR	0A26	CSEG
CDEL8B . . . . . . . . . . . . .  	L NEAR	0A49	CSEG
CDEL9I . . . . . . . . . . . . .  	L NEAR	0A01	CSEG
CDELET . . . . . . . . . . . . .  	L NEAR	0858	CSEG
CDELLG . . . . . . . . . . . . .  	L NEAR	0861	CSEG
CDELP0 . . . . . . . . . . . . .  	L NEAR	09C9	CSEG
CDELP1 . . . . . . . . . . . . .  	L NEAR	09DD	CSEG
CDELP4 . . . . . . . . . . . . .  	L NEAR	09EF	CSEG
CDELP5 . . . . . . . . . . . . .  	L NEAR	09F6	CSEG
CDELP6 . . . . . . . . . . . . .  	L NEAR	0A03	CSEG
CDELP7 . . . . . . . . . . . . .  	L NEAR	0A20	CSEG
CDELP8 . . . . . . . . . . . . .  	L NEAR	0A24	CSEG
CDELP9 . . . . . . . . . . . . .  	L NEAR	0A52	CSEG
CDELPF . . . . . . . . . . . . .  	L NEAR	0A68	CSEG
CDELPH . . . . . . . . . . . . .  	L NEAR	09AF	CSEG
CDELPX . . . . . . . . . . . . .  	L NEAR	0A5B	CSEG
CDELT1 . . . . . . . . . . . . .  	L NEAR	0861	CSEG
CDLGEX . . . . . . . . . . . . .  	L NEAR	08E9	CSEG
CDLGN0 . . . . . . . . . . . . .  	L NEAR	08DB	CSEG
CDLGNC . . . . . . . . . . . . .  	L NEAR	08C4	CSEG
CDLGNL . . . . . . . . . . . . .  	L NEAR	08CB	CSEG
CDLGRT . . . . . . . . . . . . .  	L NEAR	08EC	CSEG
CDLGW1 . . . . . . . . . . . . .  	L NEAR	08E4	CSEG
CDLGWP . . . . . . . . . . . . .  	L NEAR	0880	CSEG
CDLWP1 . . . . . . . . . . . . .  	L NEAR	0886	CSEG
CDLWP2 . . . . . . . . . . . . .  	L NEAR	089D	CSEG
CDUNWP . . . . . . . . . . . . .  	L NEAR	08F7	CSEG
CDUWP0 . . . . . . . . . . . . .  	L NEAR	091B	CSEG
CDUWP1 . . . . . . . . . . . . .  	L NEAR	092E	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-3
                                                             

CDUWP3 . . . . . . . . . . . . .  	L NEAR	0971	CSEG
CDUWP4 . . . . . . . . . . . . .  	L NEAR	0971	CSEG
CDUWP5 . . . . . . . . . . . . .  	L NEAR	097F	CSEG
CDUWP6 . . . . . . . . . . . . .  	L NEAR	0993	CSEG
CDUWP7 . . . . . . . . . . . . .  	L NEAR	0997	CSEG
CDUWP8 . . . . . . . . . . . . .  	L NEAR	0998	CSEG
CDUWPE . . . . . . . . . . . . .  	L NEAR	098F	CSEG
CDUWPF . . . . . . . . . . . . .  	L NEAR	09A5	CSEG
CDUWPL . . . . . . . . . . . . .  	L NEAR	0969	CSEG
CDUWPN . . . . . . . . . . . . .  	L NEAR	094B	CSEG
CDUWPX . . . . . . . . . . . . .  	L NEAR	0999	CSEG
CDUWXI . . . . . . . . . . . . .  	L NEAR	08F2	CSEG
CHRADV . . . . . . . . . . . . .  	Number	001C	
CHRAPP . . . . . . . . . . . . .  	Number	000E	
CHRBAK . . . . . . . . . . . . .  	Number	0008	
CHRBEL . . . . . . . . . . . . .  	Number	0007	
CHRBKW . . . . . . . . . . . . .  	Number	0002	
CHRCAN . . . . . . . . . . . . .  	Number	0003	
CHRCLE . . . . . . . . . . . . .  	Number	0005	
CHRDEL . . . . . . . . . . . . .  	Number	007F	
CHRDWN . . . . . . . . . . . . .  	Number	001F	
CHREDT . . . . . . . . . . . . .  	Number	0001	
CHRERA . . . . . . . . . . . . .  	Number	000C	
CHRFDW . . . . . . . . . . . . .  	Number	0006	
CHRFKD . . . . . . . . . . . . .  	Number	0014	
CHRHCN . . . . . . . . . . . . .  	Number	0004	
CHRHOM . . . . . . . . . . . . .  	Number	000B	
CHRINS . . . . . . . . . . . . .  	Number	0012	
CHRLDL . . . . . . . . . . . . .  	Number	0015	
CHRLNF . . . . . . . . . . . . .  	Number	000A	
CHRREG . . . . . . . . . . . . .  	Number	001D	
CHRRET . . . . . . . . . . . . .  	Number	000D	
CHRTAB . . . . . . . . . . . . .  	Number	0009	
CHRUP  . . . . . . . . . . . . .  	Number	001E	
CHSEAT . . . . . . . . . . . . .  	Number	0001	
CHWNTF . . . . . . . . . . . . .  	L NEAR	01E1	CSEG
CHWNTG . . . . . . . . . . . . .  	L NEAR	01FE	CSEG
CHWNTL . . . . . . . . . . . . .  	L NEAR	01D1	CSEG
CHWPL0 . . . . . . . . . . . . .  	L NEAR	012D	CSEG
CHWPL1 . . . . . . . . . . . . .  	L NEAR	0135	CSEG
CHWPLF . . . . . . . . . . . . .  	L NEAR	011B	CSEG
CHWPXI . . . . . . . . . . . . .  	L NEAR	0118	CSEG
CHWRAP . . . . . . . . . . . . .  	L NEAR	00EB	CSEG
CHWREL . . . . . . . . . . . . .  	L NEAR	018A	CSEG
CHWRLF . . . . . . . . . . . . .  	L NEAR	0194	CSEG
CHWRN0 . . . . . . . . . . . . .  	L NEAR	0162	CSEG
CHWRN2 . . . . . . . . . . . . .  	L NEAR	0184	CSEG
CHWRNI . . . . . . . . . . . . .  	L NEAR	0141	CSEG
CHWRNO . . . . . . . . . . . . .  	L NEAR	01A8	CSEG
CHWRP0 . . . . . . . . . . . . .  	L NEAR	00F4	CSEG
CHWRP1 . . . . . . . . . . . . .  	L NEAR	0144	CSEG
CHWRP3 . . . . . . . . . . . . .  	L NEAR	01A4	CSEG
CHWRP9 . . . . . . . . . . . . .  	L NEAR	01BD	CSEG
CHWRPX . . . . . . . . . . . . .  	L NEAR	0187	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-4
                                                             

CHWRPZ . . . . . . . . . . . . .  	L NEAR	01AD	CSEG
CHWRWP . . . . . . . . . . . . .  	L NEAR	0149	CSEG
CLMWID . . . . . . . . . . . . .  	Number	000E	
CLREOL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CLRSCN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CMPUTN . . . . . . . . . . . . .  	Number	0000	
COMMNT . . . . . . . . . . . . .  	Number	0000	
CONSSW . . . . . . . . . . . . .  	Number	0001	
CONTO  . . . . . . . . . . . . .  	Number	000F	
CONTRO . . . . . . . . . . . . .  	Number	0001	
CPM  . . . . . . . . . . . . . .  	Number	0001	
CPM110 . . . . . . . . . . . . .  	Number	0000	
CPM2 . . . . . . . . . . . . . .  	Number	0001	
CPM86  . . . . . . . . . . . . .  	Number	0000	
CPMA75 . . . . . . . . . . . . .  	Number	0000	
CPMADD . . . . . . . . . . . . .  	Number	0000	
CPMCON . . . . . . . . . . . . .  	Number	0000	
CPMLIF . . . . . . . . . . . . .  	Number	0000	
CPMMDS . . . . . . . . . . . . .  	Number	0000	
CPMPER . . . . . . . . . . . . .  	Number	0000	
CPMRSH . . . . . . . . . . . . .  	Number	0000	
CPMSBC . . . . . . . . . . . . .  	Number	0000	
CPMSER . . . . . . . . . . . . .  	Number	0000	
CRONLY . . . . . . . . . . . . .  	Number	0000	
CRTWID . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSRADV . . . . . . . . . . . . .  	L NEAR	0D2A	CSEG
CSRDWN . . . . . . . . . . . . .  	L NEAR	0D65	CSEG
CSRREG . . . . . . . . . . . . .  	L NEAR	0D3E	CSEG
CSRRET . . . . . . . . . . . . .  	L NEAR	0D3D	CSEG
CSRTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSRUP  . . . . . . . . . . . . .  	L NEAR	0D52	CSEG
CSRX . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSRY . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSRYOK . . . . . . . . . . . . .  	L NEAR	02F0	CSEG
CTLCNT . . . . . . . . . . . . .  	Number	000D	
CTLDP0 . . . . . . . . . . . . .  	L NEAR	055C	CSEG
CTLDP1 . . . . . . . . . . . . .  	L NEAR	055C	CSEG
CTLDPX . . . . . . . . . . . . .  	L NEAR	05B0	CSEG
CTLDPY . . . . . . . . . . . . .  	L NEAR	05BE	CSEG
CTLDPZ . . . . . . . . . . . . .  	L NEAR	05BF	CSEG
CTLDS0 . . . . . . . . . . . . .  	L NEAR	055C	CSEG
CTLDSP . . . . . . . . . . . . .  	L NEAR	0542	CSEG
CTLDSX . . . . . . . . . . . . .  	L NEAR	05AE	CSEG
CTLEDT . . . . . . . . . . . . .  	L NEAR	0574	CSEG
CTLIGN . . . . . . . . . . . . .  	L NEAR	05BF	CSEG
CTLIRS . . . . . . . . . . . . .  	L NEAR	05D7	CSEG
CTLITB . . . . . . . . . . . . .  	L NEAR	05CA	CSEG
CTLNDL . . . . . . . . . . . . .  	L NEAR	0583	CSEG
CTLNMK . . . . . . . . . . . . .  	L NEAR	0598	CSEG
CTLPRT . . . . . . . . . . . . .  	L NEAR	056D	CSEG

DATPSC . . . . . . . . . . . . .  	Number	0080	
DBLCHR . . . . . . . . . . . . .  	Number	0000	
DBLTRN . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-5
                                                             

DEBUG  . . . . . . . . . . . . .  	Text  		
DISK . . . . . . . . . . . . . .  	Number	0001	
DMC  . . . . . . . . . . . . . .  	Number	0000	
DOESC  . . . . . . . . . . . . .  	L NEAR	05C0	CSEG
DOS  . . . . . . . . . . . . . .  	Number	0000	
DRVPOS . . . . . . . . . . . . .  	Number	0000	
DUPONT . . . . . . . . . . . . .  	Number	0000	
DYNCOM . . . . . . . . . . . . .  	Number	0001	

EDIT80 . . . . . . . . . . . . .  	Number	0000	
EDTMAP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ESCCTL . . . . . . . . . . . . .  	Number	0000	
ESCFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
EXIDY  . . . . . . . . . . . . .  	Number	0000	

FAST . . . . . . . . . . . . . .  	Number	0001	
FIVDSK . . . . . . . . . . . . .  	Number	0001	
FIVEO  . . . . . . . . . . . . .  	Number	0001	
FIVLPT . . . . . . . . . . . . .  	Number	0001	
FIVMEM . . . . . . . . . . . . .  	Number	0001	
FKEYON . . . . . . . . . . . . .  	Number	0001	
FKFSRL . . . . . . . . . . . . .  	Number	0000	
FKYADV . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FKYFMT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FSTCOL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FSTLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FUNTAB . . . . . . . . . . . . .  	L NEAR	0500	CSEG
FWDWD0 . . . . . . . . . . . . .  	L NEAR	06CF	CSEG
FWDWD1 . . . . . . . . . . . . .  	L NEAR	06DB	CSEG
FWDWD2 . . . . . . . . . . . . .  	L NEAR	06E0	CSEG
FWDWD3 . . . . . . . . . . . . .  	L NEAR	06E6	CSEG
FWDWD4 . . . . . . . . . . . . .  	L NEAR	06EE	CSEG
FWDWDL . . . . . . . . . . . . .  	L NEAR	06D4	CSEG
FWDWDX . . . . . . . . . . . . .  	L NEAR	06E5	CSEG
FWDWR0 . . . . . . . . . . . . .  	L NEAR	06AE	CSEG
FWDWR1 . . . . . . . . . . . . .  	L NEAR	06AF	CSEG
FWDWR2 . . . . . . . . . . . . .  	L NEAR	06BD	CSEG
FWDWRD . . . . . . . . . . . . .  	L NEAR	0698	CSEG
FWDWRZ . . . . . . . . . . . . .  	L NEAR	06C9	CSEG
F_CRET . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
F_EDIT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
F_INST . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External

GENBIN . . . . . . . . . . . . .  	Number	0001	
GENDSK . . . . . . . . . . . . .  	Number	0000	
GENIO  . . . . . . . . . . . . .  	Number	0001	
GESBC  . . . . . . . . . . . . .  	Number	0000	
GIO86  . . . . . . . . . . . . .  	Number	0001	
GRPINI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GW . . . . . . . . . . . . . . .  	Number	0001	
GWCASS . . . . . . . . . . . . .  	Number	0000	
GWDBUG . . . . . . . . . . . . .  	Number	0000	
G_BIN  . . . . . . . . . . . . .  	Number	001A	
G_BOT  . . . . . . . . . . . . .  	Number	001C	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-6
                                                             

G_CLS  . . . . . . . . . . . . .  	Number	0006	
G_EOF  . . . . . . . . . . . . .  	Number	0000	
G_GCW  . . . . . . . . . . . . .  	Number	0018	
G_GPS  . . . . . . . . . . . . .  	Number	0012	
G_GWD  . . . . . . . . . . . . .  	Number	0014	
G_LOC  . . . . . . . . . . . . .  	Number	0002	
G_LOF  . . . . . . . . . . . . .  	Number	0004	
G_OPN  . . . . . . . . . . . . .  	Number	000C	
G_RND  . . . . . . . . . . . . .  	Number	000A	
G_SCW  . . . . . . . . . . . . .  	Number	0016	
G_SIN  . . . . . . . . . . . . .  	Number	000E	
G_SOT  . . . . . . . . . . . . .  	Number	0010	
G_SWD  . . . . . . . . . . . . .  	Number	0008	

HEATH  . . . . . . . . . . . . .  	Number	0000	
HEXOCT . . . . . . . . . . . . .  	Number	0001	
HGHBIT . . . . . . . . . . . . .  	Number	0001	
HLPEDT . . . . . . . . . . . . .  	Number	0000	

I8086  . . . . . . . . . . . . .  	Number	0001	
I8251  . . . . . . . . . . . . .  	Number	0000	
IBMCSR . . . . . . . . . . . . .  	Number	0001	
IBMEOL . . . . . . . . . . . . .  	Number	0001	
IBMLIK . . . . . . . . . . . . .  	Number	0001	
IBMTOK . . . . . . . . . . . . .  	Number	0001	
INCNOT . . . . . . . . . . . . .  	L NEAR	05F1	CSEG
INKEYF . . . . . . . . . . . . .  	Number	0001	
INLADD . . . . . . . . . . . . .  	Number	0000	
INSTSW . . . . . . . . . . . . .  	Number	0000	
INTEL  . . . . . . . . . . . . .  	Number	0000	
INTFHW . . . . . . . . . . . . .  	Number	0000	
INTFSW . . . . . . . . . . . . .  	Number	0000	
INTLEC . . . . . . . . . . . . .  	Number	0000	
INTROM . . . . . . . . . . . . .  	Number	0000	
INVLIN . . . . . . . . . . . . .  	Number	0001	
ISC  . . . . . . . . . . . . . .  	Number	0000	
ISIS . . . . . . . . . . . . . .  	Number	0000	

JISKTN . . . . . . . . . . . . .  	Number	0000	

KANABS . . . . . . . . . . . . .  	Number	0000	
KANJFN . . . . . . . . . . . . .  	Number	0000	
KEYDSP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
KEYSTA . . . . . . . . . . . . .  	Number	0000	
KEYSW  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
KILLER . . . . . . . . . . . . .  	Number	0000	

LABDSP . . . . . . . . . . . . .  	L NEAR	03F1	CSEG
LABELK . . . . . . . . . . . . .  	L NEAR	03DC	CSEG
LABKEY . . . . . . . . . . . . .  	Number	0001	
LABOFF . . . . . . . . . . . . .  	L NEAR	03FB	CSEG
LAPPN0 . . . . . . . . . . . . .  	L NEAR	0A69	CSEG
LAPPN1 . . . . . . . . . . . . .  	L NEAR	0A72	CSEG
LAPPN2 . . . . . . . . . . . . .  	L NEAR	0A7D	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-7
                                                             

LAPPND . . . . . . . . . . . . .  	L NEAR	0A69	CSEG
LCARET . . . . . . . . . . . . .  	L NEAR	0A80	CSEG
LCLEAR . . . . . . . . . . . . .  	L NEAR	0798	CSEG
LCLER0 . . . . . . . . . . . . .  	L NEAR	079F	CSEG
LCLER1 . . . . . . . . . . . . .  	L NEAR	07AD	CSEG
LCLER2 . . . . . . . . . . . . .  	L NEAR	07B2	CSEG
LCLER5 . . . . . . . . . . . . .  	L NEAR	07B8	CSEG
LCRET0 . . . . . . . . . . . . .  	L NEAR	0A8B	CSEG
LCRET1 . . . . . . . . . . . . .  	L NEAR	0A8D	CSEG
LCSAD0 . . . . . . . . . . . . .  	L NEAR	0D8B	CSEG
LCSAD1 . . . . . . . . . . . . .  	L NEAR	0D90	CSEG
LCSAD2 . . . . . . . . . . . . .  	L NEAR	0DA1	CSEG
LCSADA . . . . . . . . . . . . .  	L NEAR	0DA5	CSEG
LCSADV . . . . . . . . . . . . .  	L NEAR	0D78	CSEG
LCSADX . . . . . . . . . . . . .  	L NEAR	0D8A	CSEG
LCSREG . . . . . . . . . . . . .  	L NEAR	0DA9	CSEG
LCSRG0 . . . . . . . . . . . . .  	L NEAR	0DB7	CSEG
LCSRGA . . . . . . . . . . . . .  	L NEAR	0DCE	CSEG
LCSRGX . . . . . . . . . . . . .  	L NEAR	0DD1	CSEG
LDELET . . . . . . . . . . . . .  	L NEAR	0772	CSEG
LEN2 . . . . . . . . . . . . . .  	Number	0001	
LEN3 . . . . . . . . . . . . . .  	Number	0001	
LENGTH . . . . . . . . . . . . .  	Number	0002	
LFD90I . . . . . . . . . . . . .  	L NEAR	0AE4	CSEG
LFED10 . . . . . . . . . . . . .  	L NEAR	0AB5	CSEG
LFED12 . . . . . . . . . . . . .  	L NEAR	0AC2	CSEG
LFED30 . . . . . . . . . . . . .  	L NEAR	0AE6	CSEG
LFED31 . . . . . . . . . . . . .  	L NEAR	0AEE	CSEG
LFED32 . . . . . . . . . . . . .  	L NEAR	0AF0	CSEG
LFED34 . . . . . . . . . . . . .  	L NEAR	0B0A	CSEG
LFED35 . . . . . . . . . . . . .  	L NEAR	0B1C	CSEG
LFED40 . . . . . . . . . . . . .  	L NEAR	0B22	CSEG
LFED41 . . . . . . . . . . . . .  	L NEAR	0B25	CSEG
LFED42 . . . . . . . . . . . . .  	L NEAR	0B2A	CSEG
LFED43 . . . . . . . . . . . . .  	L NEAR	0B32	CSEG
LFED69 . . . . . . . . . . . . .  	L NEAR	0B6F	CSEG
LFED90 . . . . . . . . . . . . .  	L NEAR	0B4D	CSEG
LFED95 . . . . . . . . . . . . .  	L NEAR	0B54	CSEG
LFEED  . . . . . . . . . . . . .  	L NEAR	0A97	CSEG
LFEEDX . . . . . . . . . . . . .  	L NEAR	0B64	CSEG
LFEEDZ . . . . . . . . . . . . .  	L NEAR	0B6E	CSEG
LFTERM . . . . . . . . . . . . .  	L NEAR	0D13	CSEG
LFWPEX . . . . . . . . . . . . .  	L NEAR	0C14	CSEG
LFWRAP . . . . . . . . . . . . .  	L NEAR	0C04	CSEG
LINCNT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
LINLEN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
LINLN  . . . . . . . . . . . . .  	Number	0050	
LINSRT . . . . . . . . . . . . .  	L NEAR	0B72	CSEG
LINTTB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
LISTEN . . . . . . . . . . . . .  	Number	0001	
LNGVAR . . . . . . . . . . . . .  	Number	0001	
LOKHED . . . . . . . . . . . . .  	Number	0000	
LONGI  . . . . . . . . . . . . .  	Number	0000	
LPT3 . . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-8
                                                             

LPTLEN . . . . . . . . . . . . .  	Number	0084	
LPTSW  . . . . . . . . . . . . .  	Number	0001	
LSTART . . . . . . . . . . . . .  	L NEAR	0DD3	CSEG
LSTCOL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
LSTLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
LSTRT0 . . . . . . . . . . . . .  	L NEAR	0DD3	CSEG
LSTRT1 . . . . . . . . . . . . .  	L NEAR	0DE5	CSEG
LSTRTX . . . . . . . . . . . . .  	L NEAR	0DEF	CSEG
LTAB . . . . . . . . . . . . . .  	L NEAR	0651	CSEG
LTABIL . . . . . . . . . . . . .  	L NEAR	0658	CSEG
LTABL  . . . . . . . . . . . . .  	L NEAR	0677	CSEG
LTABX  . . . . . . . . . . . . .  	L NEAR	0694	CSEG
LTABX0 . . . . . . . . . . . . .  	L NEAR	0688	CSEG
LTABZ  . . . . . . . . . . . . .  	L NEAR	0697	CSEG
LTRUN1 . . . . . . . . . . . . .  	L NEAR	0782	CSEG
LTRUN9 . . . . . . . . . . . . .  	L NEAR	0795	CSEG
LTRUNC . . . . . . . . . . . . .  	L NEAR	0775	CSEG
LTRUNX . . . . . . . . . . . . .  	L NEAR	0796	CSEG

MDS  . . . . . . . . . . . . . .  	Number	0000	
MDSISS . . . . . . . . . . . . .  	Number	0000	
MELCO  . . . . . . . . . . . . .  	Number	0000	
MEMIMG . . . . . . . . . . . . .  	Number	0001	
MKRCIX . . . . . . . . . . . . .  	L NEAR	00E3	CSEG
MKRMC0 . . . . . . . . . . . . .  	L NEAR	0B8C	CSEG
MKRMC1 . . . . . . . . . . . . .  	L NEAR	0B9B	CSEG
MKRMC3 . . . . . . . . . . . . .  	L NEAR	0BAE	CSEG
MKRMC4 . . . . . . . . . . . . .  	L NEAR	0BBF	CSEG
MKRMC5 . . . . . . . . . . . . .  	L NEAR	0BCD	CSEG
MKRMC6 . . . . . . . . . . . . .  	L NEAR	0BDC	CSEG
MKRMC7 . . . . . . . . . . . . .  	L NEAR	0BF3	CSEG
MKRMCH . . . . . . . . . . . . .  	L NEAR	0B78	CSEG
MKRMCI . . . . . . . . . . . . .  	L NEAR	00CF	CSEG
MKRMCQ . . . . . . . . . . . . .  	L NEAR	0BB5	CSEG
MKRMCX . . . . . . . . . . . . .  	L NEAR	0B92	CSEG
MKRMN0 . . . . . . . . . . . . .  	L NEAR	021F	CSEG
MKRMN4 . . . . . . . . . . . . .  	L NEAR	0232	CSEG
MKRMN5 . . . . . . . . . . . . .  	L NEAR	0236	CSEG
MKRMN6 . . . . . . . . . . . . .  	L NEAR	023A	CSEG
MKRMN7 . . . . . . . . . . . . .  	L NEAR	0257	CSEG
MKRMN8 . . . . . . . . . . . . .  	L NEAR	025E	CSEG
MKRMN9 . . . . . . . . . . . . .  	L NEAR	026A	CSEG
MKRMNF . . . . . . . . . . . . .  	L NEAR	0277	CSEG
MKRMNL . . . . . . . . . . . . .  	L NEAR	021B	CSEG
MKRMNU . . . . . . . . . . . . .  	L NEAR	027A	CSEG
MKRMNX . . . . . . . . . . . . .  	L NEAR	027F	CSEG
MKRMNY . . . . . . . . . . . . .  	L NEAR	0253	CSEG
MKRMNZ . . . . . . . . . . . . .  	L NEAR	0254	CSEG
MKRMX2 . . . . . . . . . . . . .  	L NEAR	0B97	CSEG
MOSTEK . . . . . . . . . . . . .  	Number	0000	
MULSEG . . . . . . . . . . . . .  	Number	0001	
MVC30I . . . . . . . . . . . . .  	L NEAR	0C17	CSEG
MVCH00 . . . . . . . . . . . . .  	L NEAR	0C2A	CSEG
MVCH03 . . . . . . . . . . . . .  	L NEAR	0C3D	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-9
                                                             

MVCH10 . . . . . . . . . . . . .  	L NEAR	0C4B	CSEG
MVCH14 . . . . . . . . . . . . .  	L NEAR	0C57	CSEG
MVCH20 . . . . . . . . . . . . .  	L NEAR	0C65	CSEG
MVCH21 . . . . . . . . . . . . .  	L NEAR	0C85	CSEG
MVCH22 . . . . . . . . . . . . .  	L NEAR	0C8C	CSEG
MVCH23 . . . . . . . . . . . . .  	L NEAR	0C8D	CSEG
MVCH24 . . . . . . . . . . . . .  	L NEAR	0C94	CSEG
MVCH25 . . . . . . . . . . . . .  	L NEAR	0CB4	CSEG
MVCH26 . . . . . . . . . . . . .  	L NEAR	0CB8	CSEG
MVCH27 . . . . . . . . . . . . .  	L NEAR	0CC1	CSEG
MVCH30 . . . . . . . . . . . . .  	L NEAR	0CD3	CSEG
MVCH31 . . . . . . . . . . . . .  	L NEAR	0CDD	CSEG
MVCH32 . . . . . . . . . . . . .  	L NEAR	0CEB	CSEG
MVCH33 . . . . . . . . . . . . .  	L NEAR	0CFC	CSEG
MVCHEX . . . . . . . . . . . . .  	L NEAR	0CD1	CSEG
MVCHLN . . . . . . . . . . . . .  	L NEAR	0C1A	CSEG

NAMLEN . . . . . . . . . . . . .  	Number	0028	
NASCOM . . . . . . . . . . . . .  	Number	0000	
NATROM . . . . . . . . . . . . .  	Number	0000	
NBANKS . . . . . . . . . . . . .  	Number	0001	
NCRBAS . . . . . . . . . . . . .  	Number	0000	
NCRCAS . . . . . . . . . . . . .  	Number	0000	
NCRDEB . . . . . . . . . . . . .  	Number	0000	
NCRELS . . . . . . . . . . . . .  	Number	0000	
NCRLPT . . . . . . . . . . . . .  	Number	0001	
NECBAS . . . . . . . . . . . . .  	Number	0000	
NEWCHP . . . . . . . . . . . . .  	Number	0001	
NINWDO . . . . . . . . . . . . .  	L NEAR	0309	CSEG
NMCOMT . . . . . . . . . . . . .  	Number	0002	
NMKEYF . . . . . . . . . . . . .  	Number	000A	
NMKEYT . . . . . . . . . . . . .  	Number	000E	
NMLINE . . . . . . . . . . . . .  	Number	0019	
NMLPT  . . . . . . . . . . . . .  	Number	0003	
NMPAGE . . . . . . . . . . . . .  	Number	0001	
NMPENT . . . . . . . . . . . . .  	Number	0001	
NMSTRT . . . . . . . . . . . . .  	Number	0004	
NOATDL . . . . . . . . . . . . .  	Number	0000	
NOCTLA . . . . . . . . . . . . .  	Number	0000	
NODOT  . . . . . . . . . . . . .  	Number	0000	
NOEDIT . . . . . . . . . . . . .  	Number	0000	
NOIOS  . . . . . . . . . . . . .  	Number	0000	
NONULL . . . . . . . . . . . . .  	Number	0000	
NOPEKS . . . . . . . . . . . . .  	Number	0000	
NOROMP . . . . . . . . . . . . .  	Number	0000	
NORUBT . . . . . . . . . . . . .  	Number	0000	
NOUSR  . . . . . . . . . . . . .  	Number	0000	
NOVARP . . . . . . . . . . . . .  	Number	0000	
NUMLEV . . . . . . . . . . . . .  	Number	006E	
NUMTMP . . . . . . . . . . . . .  	Number	000A	
NUMTRP . . . . . . . . . . . . .  	Number	0015	

OEMRAM . . . . . . . . . . . . .  	Number	0000	
ONTEL  . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-10
                                                             


PALSIZ . . . . . . . . . . . . .  	Number	0000	
PANBAS . . . . . . . . . . . . .  	Number	0000	
PCS  . . . . . . . . . . . . . .  	Number	0000	
PLAYSW . . . . . . . . . . . . .  	Number	0001	
PLINI2 . . . . . . . . . . . . .  	L NEAR	03D7	CSEG
PLINIT . . . . . . . . . . . . .  	L NEAR	03BE	CSEG
PROFID . . . . . . . . . . . . .  	Number	00FE	
PRTMAP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PURE . . . . . . . . . . . . . .  	Number	0001	

QUEUE  . . . . . . . . . . . . .  	Number	0001	

REALIO . . . . . . . . . . . . .  	Number	0001	
RMX  . . . . . . . . . . . . . .  	Number	0000	
RSHACK . . . . . . . . . . . . .  	Number	0000	
RSTLES . . . . . . . . . . . . .  	Number	0001	

SBC  . . . . . . . . . . . . . .  	Number	0000	
SBC86  . . . . . . . . . . . . .  	Number	0000	
SCNBRK . . . . . . . . . . . . .  	L NEAR	0006	CSEG	Global
SCNCLR . . . . . . . . . . . . .  	L NEAR	003E	CSEG	Global
SCNGWI . . . . . . . . . . . . .  	L NEAR	0064	CSEG	Global
SCNIPL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	Global
SCNLOC . . . . . . . . . . . . .  	L NEAR	0036	CSEG	Global
SCNMK0 . . . . . . . . . . . . .  	L NEAR	0415	CSEG
SCNMK1 . . . . . . . . . . . . .  	L NEAR	0424	CSEG
SCNMK2 . . . . . . . . . . . . .  	L NEAR	0454	CSEG
SCNMK3 . . . . . . . . . . . . .  	L NEAR	046C	CSEG
SCNMKL . . . . . . . . . . . . .  	L NEAR	043D	CSEG
SCNMKX . . . . . . . . . . . . .  	L NEAR	0480	CSEG
SCNML2 . . . . . . . . . . . . .  	L NEAR	0444	CSEG
SCNML3 . . . . . . . . . . . . .  	L NEAR	044D	CSEG
SCNMRK . . . . . . . . . . . . .  	L NEAR	0402	CSEG	Global
SCNOTX . . . . . . . . . . . . .  	L NEAR	00CB	CSEG
SCNOUT . . . . . . . . . . . . .  	L NEAR	00B0	CSEG	Global
SCNPOS . . . . . . . . . . . . .  	L NEAR	004F	CSEG	Global
SCNPS1 . . . . . . . . . . . . .  	L NEAR	0062	CSEG
SCNRDL . . . . . . . . . . . . .  	L NEAR	0481	CSEG	Global
SCNRDT . . . . . . . . . . . . .  	L NEAR	0069	CSEG	Global
SCNRDX . . . . . . . . . . . . .  	L NEAR	00E5	CSEG
SCNRT1 . . . . . . . . . . . . .  	L NEAR	0D11	CSEG
SCNRT2 . . . . . . . . . . . . .  	L NEAR	0D12	CSEG
SCNRTL . . . . . . . . . . . . .  	L NEAR	0D03	CSEG
SCNRTX . . . . . . . . . . . . .  	L NEAR	0088	CSEG
SCNSIZ . . . . . . . . . . . . .  	Number	2814		Global
SCNSWI . . . . . . . . . . . . .  	L NEAR	0016	CSEG	Global
SCNWTT . . . . . . . . . . . . .  	L NEAR	008A	CSEG
SCP  . . . . . . . . . . . . . .  	Number	0001	
SCRD00 . . . . . . . . . . . . .  	L NEAR	0482	CSEG
SCRD01 . . . . . . . . . . . . .  	L NEAR	0494	CSEG
SCRD02 . . . . . . . . . . . . .  	L NEAR	04A6	CSEG
SCRD03 . . . . . . . . . . . . .  	L NEAR	04B8	CSEG
SCRD04 . . . . . . . . . . . . .  	L NEAR	04C9	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-11
                                                             

SCRD06 . . . . . . . . . . . . .  	L NEAR	04D3	CSEG
SCRD07 . . . . . . . . . . . . .  	L NEAR	04E0	CSEG
SCRD08 . . . . . . . . . . . . .  	L NEAR	04E4	CSEG
SCRD09 . . . . . . . . . . . . .  	L NEAR	04F2	CSEG
SCRDEX . . . . . . . . . . . . .  	L NEAR	04FA	CSEG
SCRDL3 . . . . . . . . . . . . .  	L NEAR	0336	CSEG
SCRDL4 . . . . . . . . . . . . .  	L NEAR	0344	CSEG
SCRDLF . . . . . . . . . . . . .  	L NEAR	04C4	CSEG
SCRDLN . . . . . . . . . . . . .  	L NEAR	034B	CSEG
SCRDT1 . . . . . . . . . . . . .  	L NEAR	03B7	CSEG
SCRDTL . . . . . . . . . . . . .  	L NEAR	0393	CSEG
SCRDTT . . . . . . . . . . . . .  	L NEAR	0385	CSEG
SCRDXZ . . . . . . . . . . . . .  	L NEAR	04FB	CSEG
SCRINP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SCRLD0 . . . . . . . . . . . . .  	L NEAR	030E	CSEG
SCRLD1 . . . . . . . . . . . . .  	L NEAR	032A	CSEG
SCRLDN . . . . . . . . . . . . .  	L NEAR	030A	CSEG
SCRLU0 . . . . . . . . . . . . .  	L NEAR	0290	CSEG
SCRLU1 . . . . . . . . . . . . .  	L NEAR	0295	CSEG
SCRLUD . . . . . . . . . . . . .  	L NEAR	0283	CSEG
SCRLUP . . . . . . . . . . . . .  	L NEAR	028C	CSEG
SCRN86 . . . . . . . . . . . . .  	Number	0001	
SCRNIO . . . . . . . . . . . . .  	Number	0001	
SCROL2 . . . . . . . . . . . . .  	Alias	 SCROLL		
SCROLL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SCROLT . . . . . . . . . . . . .  	Number	0001	
SCROUT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SCRUL1 . . . . . . . . . . . . .  	L NEAR	02AF	CSEG
SCRUL3 . . . . . . . . . . . . .  	L NEAR	02C2	CSEG
SCRUL4 . . . . . . . . . . . . .  	L NEAR	02CE	CSEG
SCRUTL . . . . . . . . . . . . .  	L NEAR	036D	CSEG
SCRUTT . . . . . . . . . . . . .  	L NEAR	0361	CSEG
SETCSR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SGSATS . . . . . . . . . . . . .  	Number	0000	
SHORTJ . . . . . . . . . . . . .  	Number	0001	
SHTCHN . . . . . . . . . . . . .  	Number	0000	
SHTERR . . . . . . . . . . . . .  	Number	0000	
SHTINS . . . . . . . . . . . . .  	Number	0000	
SHTLHM . . . . . . . . . . . . .  	Number	0000	
SHTLIN . . . . . . . . . . . . .  	Number	0000	
SHTPRO . . . . . . . . . . . . .  	Number	0000	
SHTREN . . . . . . . . . . . . .  	Number	0000	
SIXDIG . . . . . . . . . . . . .  	Number	0000	
SMALL  . . . . . . . . . . . . .  	Number	0000	
SPCDSK . . . . . . . . . . . . .  	Number	0000	
SPCNDS . . . . . . . . . . . . .  	Number	0000	
STRING . . . . . . . . . . . . .  	Number	0001	
STRSIZ . . . . . . . . . . . . .  	Number	0003	
SUPRSH . . . . . . . . . . . . .  	Number	0001	
SWAPSW . . . . . . . . . . . . .  	Number	0001	

TCSRY1 . . . . . . . . . . . . .  	L NEAR	02EE	CSEG
TEK  . . . . . . . . . . . . . .  	Number	0000	
TERMSW . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-12
                                                             

TIMSHR . . . . . . . . . . . . .  	Number	0000	
TRMCUR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TRMEOL . . . . . . . . . . . . .  	Number	007F		Global
TRMLNF . . . . . . . . . . . . .  	Number	000A		Global
TRMNUL . . . . . . . . . . . . .  	Number	0080		Global
TRMNWP . . . . . . . . . . . . .  	Number	0001		Global
TRMWRP . . . . . . . . . . . . .  	Number	0000		Global
TRNCHR . . . . . . . . . . . . .  	Number	0000	
TRSER2 . . . . . . . . . . . . .  	Number	0000	
TRUANS . . . . . . . . . . . . .  	Number	0000	
TRUROM . . . . . . . . . . . . .  	Number	0001	
TSDISK . . . . . . . . . . . . .  	Number	0000	
TSLPT  . . . . . . . . . . . . .  	Number	0000	
TSTSCR . . . . . . . . . . . . .  	L NEAR	02D6	CSEG
TSTWDO . . . . . . . . . . . . .  	L NEAR	02FF	CSEG
TTBIN0 . . . . . . . . . . . . .  	L NEAR	00A4	CSEG
TTBINI . . . . . . . . . . . . .  	L NEAR	009E	CSEG
TXTWDO . . . . . . . . . . . . .  	Number	0000	

UPDPOS . . . . . . . . . . . . .  	L NEAR	05FB	CSEG
UPDPS2 . . . . . . . . . . . . .  	L NEAR	0619	CSEG
UPDPS3 . . . . . . . . . . . . .  	L NEAR	0623	CSEG
UPDPSX . . . . . . . . . . . . .  	L NEAR	0635	CSEG

WCSABT . . . . . . . . . . . . .  	L NEAR	0636	CSEG
WCSADV . . . . . . . . . . . . .  	L NEAR	05F6	CSEG
WCSDWN . . . . . . . . . . . . .  	L NEAR	064B	CSEG
WCSREG . . . . . . . . . . . . .  	L NEAR	0637	CSEG
WCSRET . . . . . . . . . . . . .  	L NEAR	063C	CSEG
WCSUP  . . . . . . . . . . . . .  	L NEAR	0645	CSEG
WDELET . . . . . . . . . . . . .  	L NEAR	07BB	CSEG
WDELT0 . . . . . . . . . . . . .  	L NEAR	07C6	CSEG
WDELT2 . . . . . . . . . . . . .  	L NEAR	07D2	CSEG
WDELT4 . . . . . . . . . . . . .  	L NEAR	07DC	CSEG
WDELT6 . . . . . . . . . . . . .  	L NEAR	07ED	CSEG
WDELT7 . . . . . . . . . . . . .  	L NEAR	07FE	CSEG
WDELT8 . . . . . . . . . . . . .  	L NEAR	0804	CSEG
WDELT9 . . . . . . . . . . . . .  	L NEAR	0808	CSEG
WDELTC . . . . . . . . . . . . .  	L NEAR	0811	CSEG
WDELTD . . . . . . . . . . . . .  	L NEAR	0813	CSEG
WDELTE . . . . . . . . . . . . .  	L NEAR	082B	CSEG
WDELTF . . . . . . . . . . . . .  	L NEAR	0836	CSEG
WDELTX . . . . . . . . . . . . .  	L NEAR	080F	CSEG
WDELTZ . . . . . . . . . . . . .  	L NEAR	0810	CSEG
WDOBOT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
WDOLFT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
WDORGT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
WDOTOP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
WERAS0 . . . . . . . . . . . . .  	L NEAR	0763	CSEG
WERASE . . . . . . . . . . . . .  	L NEAR	075B	CSEG
WERASX . . . . . . . . . . . . .  	L NEAR	0770	CSEG
WHOME  . . . . . . . . . . . . .  	L NEAR	0752	CSEG
WRAPLF . . . . . . . . . . . . .  	L NEAR	0201	CSEG

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:44:53
 
SCNDRV  This is the OS independent Screen Driver for GW BASISymbols-13
                                                             

XTNSYS . . . . . . . . . . . . .  	Number	0000	

Z80  . . . . . . . . . . . . . .  	Number	0001	
Z80MAC . . . . . . . . . . . . .  	Number	0001	

_OFFST . . . . . . . . . . . . .  	Number	001E	


   2886 Source  Lines
   2918 Total   Lines
    639 Symbols

  29246 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
