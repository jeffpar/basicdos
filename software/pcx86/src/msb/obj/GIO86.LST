Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-1
                                                            

                                ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                                 
 0008                           	.RADIX  8		; To be safe 
                                 
 0000                           CSEG	SEGMENT PUBLIC 'CODESG' 
                                	ASSUME  CS:CSEG 
                                 
                             C  INCLUDE	OEM.INC 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
                             C  	PAGE	,132D 
                             C  	SUBTTL  Common file to produce 2-segment 8086 GW-CPM BASIC 
                             C   
                             C  	.SALL 
                             C   
 000A                        C  	.RADIX	10 
 = 0000                      C  	OEMRAM=0D 
                             C  ;Pascal program HFILE searches for the following line - DO NOT MODIFY 
                             C  ;** (VERSION SPECIFIC VALUES) ************************************************ 
 = 0019                      C  	NMLINE=25		;Max screen display text lines 
 = 0001                      C  	NBANKS=1		;Number of graphic planes 
 = 0000                      C  	PALSIZ=0		;Size of OEM color palette 
 = 0000                      C  	DBLCHR=0		;Editor support for KANJI chars 
 = 0000                      C  	KANABS=0		;Kana BASIC (Japanese JIS codes) 
 = 0000                      C  	KANJFN=0		;KANJI String Functions KPOS, KLEN .. 
 = 0000                      C  	JISKTN=0		;&K, &J constants (KANJI) 
 = 0001                      C  	SUPRSH=1		;1=super shift key feature 
 = 000A                      C  	NMKEYF=10		;number of function keys 
 = 000E                      C  	NMKEYT=14		;number of function key traps 
 = 0001                      C  	FKEYON=1		;yes=display function keys 
 = 0001                      C  	SCROLT=1		;Line 25 allocated for status only 
 = 0001                      C  	PLAYSW=1		;for PLAY statement 
 = 0001                      C  	BEEPSW=1		;for SOUND, BEEP statements 
 = 0003                      C  	NMLPT=3			;number of line printers 
 = 0001                      C  	CONSSW=1		;Device CONS: 
 = 0002                      C  	NMCOMT=2		;number of COMmunications ports 
 = 0001                      C  	NMPENT=1		;number of light pens 
 = 0004                      C  	NMSTRT=4		;number of joysticks 
 = 0000                      C  	GWCASS=0		;Cassette switch (CSAVE,CLOAD,MOTOR) 
 = 0001                      C  	IBMLIK=1		;IBM compatibility package 
 = 0001                      C  	IBMTOK=1		;IBM token compatibility 
 = 0001                      C  	DYNCOM=1		;Dynamic communication buffers 
                             C  ;** (END OF VERSION SPECIFIC VALUES) ***************************************** 
                             C  ;Pascal program HFILE searches for the previous line - DO NOT MODIFY 
                             C  ; 
 = 0015                      C  	NUMTRP=NMKEYT+NMCOMT+NMPENT+NMSTRT 
 = 0001                      C  	GW=1			;GW BASIC 
 = 0000                      C  	ESCCTL=0		;Escape Sequence processing in SCROUT 
 = 0000                      C  	GWDBUG=0		;DEBUG statement (TEST VERSIONS ONLY) 
                             C  				; Support is in BINTRP.MAC and GWSTS.MAC 
 = 0000                      C  	SIXDIG=0		;# of digits of accuracy assumed when formatting 
                             C  				;single precision numbers for output. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-2
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  				; 0 := 7 digits 
                             C  				; 1 := 6 digits 
 = 0000                      C  	CASSW=0			;CASSETTE SWITCH 
 = 0001                      C  	LABKEY=1		;^T (LABEL) key capability 
 = 0001                      C  	HGHBIT=1		;8-bit characters (ASCII & Graphics) 
 = 0001                      C  	QUEUE=1			;Queued painting algorithm (vs. stack) 
 = 0001                      C  	GIO86=1			;BASIC-86 Generalized I/O 
 = 0001                      C  	SCRNIO=1		;Screen editor 
 = 0001                      C  	SCRN86=1		;8086 Screen editor 
 = 0001                      C  	I8086=1			;CROSS ASSEMBLING FOR 8086 
 = 0001                      C  	MULSEG=1		;MULTI-SEGMENT 8086 BASIC 
 = 0000                      C  	SMALL=0			;"SMALL" VERSION OF 8086 BASIC IF SET 
 = 0001                      C  	TRUROM=1 
 = 0000                      C  	SBC86=0			;SBC 86/02 BOARD? 
 = 0001                      C  	SHORTJ=1		;USE INTRA-SEGMENT SHORT JUMPS 
                             C  				;IN 8086 CODE 
 = 0001                      C  	LNGVAR=1		;LONG VARIABLE NAME SUPPORT (EXTENDED ONLY) 
 = 0000                      C  	SHTERR=0		;SHORT (2 CHAR) ERROR MESSAGES 
 = 0000                      C  	SHTINS=0		;INSTR IN NON-FAST LEN2 VERSIONS 
 = 0000                      C  	SHTLHM=0		;LEFT HAND SIDE MID IN NON FAST LEN2 VERSIONS 
 = 0000                      C  	SHTCHN=0		;ALLOW CHAIN IN NON-5.0 
 = 0000                      C  	SHTPRO=0		;ALLOW PROTECTED FILES IN NON-FIVDSK 
 = 0000                      C  	SHTLIN=0		;ALLOW LINE INPUT IN NON-EXTENDED NON-FAST 
 = 0000                      C  	SHTREN=0		;ALLOW RENUM IN NON-FST VERSIONS 
 = 0001                      C  	INKEYF=1		;ADDS INKEY$ FUNCTION 
 = 0000                      C  	NOIOS=0			;NO I/O STATMENTS (INP,OUT, WAIT) 
 = 0000                      C  	NOPEKS=0		;NO PEEK, POKE 
 = 0000                      C  	NOUSR=0			;NO USR 
 = 0000                      C  	NOCTLA=0		;NO CONTROL-A IN EXTENDED 
 = 0000                      C  	NORUBT=0		;NO RUBOUT 
 = 0000                      C  	NOROMP=0		;NO ROM PROGRAM FEATURE 
 = 0000                      C  	NOATDL=0		;NO AUTO DELETE IN NON-FAST EXTENDED 
 = 0000                      C  	NODOT=0			;NO DOT IN LEN2 
 = 0000                      C  	NOEDIT=0		;NO EDIT COMMAND 
 = 0000                      C  	CRONLY=0		;ONLY PUT OUT CR, NOT CRLF TO TERMINAL 
                             C  				;AND FILES 
 = 0000                      C  	NONULL=0		;NO NULL COMMAND, PUT OUT NULLS IN CRDO & OUTCH1 
 = 0000                      C  	NOVARP=0		;NO VARPTR FUNCTION 
 = 0001                      C  	FIVEO=1			;GENERATE VERSION WITH RELEASE 5.0 FEATURES 
 = 0001                      C  	FIVMEM=1 
 = 0001                      C  	ANSI=1 
 = 0001                      C  	FIVDSK=1		;5.0 NEW DSK CODE 
 = 0001                      C  	FIVLPT=1		;WIDTH LPRINT AND 255 FEATURE 
 = 0001                      C  	HEXOCT=1		;&H..., HEX$, &O..., OCT$ 
 = 0000                      C  	BINCSW=0		;&B..., BIN$ 
 = 0001                      C  	BLODSW=1		;BLOAD, BSAVE COMMANDS 
 = 0001                      C  	MEMIMG=1		;MEMORY IMAGE FILES 
 = 0001                      C  	GENBIN=1 
                             C   
 = 0000                      C  	TRUANS=0		;TRUE ANSI VERSION (STATIC SCAN, ON ERROR) 
 = 0000                      C  	COMMNT=0		;DONT WANT BIG COMMENT 
 = 0000                      C  	INTEL=0			;INTEL PROPRIETARY 
 = 0000                      C  	INTFSW=0		;INTEL FLOATING POINT 
 = 0000                      C  	INTFHW=0 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-3
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	RMX=0			;INTEL RMX VERSION 
 = 0000                      C  	EDIT80=0		;FOR EDIT80 I/O ROUTINES 
 = 0000                      C  	RSHACK=0 
 = 0000                      C  	INTLEC=0 
 = 0002                      C  	LENGTH=2		;  1 MEANS 8K, 2 MEANS 12K 
 = 0000                      C  	BASDEB=0		;WHETHER DBG WILL BE LOADED WITH BASIC 
 = 0001                      C  	RSTLES=1		;WHETHER BASIC WILL USE RST LOCATIONS 
                             C  				;TO MAKE ITSELF SMALLER & QUICKER 
 = 0001                      C  	REALIO=1		;WHETHER SIMULATE (=0) OR ON MACHINE (=1) 
 = 0001                      C  	GENIO=1			;USE G/P ROUTINES 
 = 0001                      C  	CHSEAT=1		;CHSNS eats chars 
 = 0000                      C  	GENDSK=0		;USE G/P DSK CODE 
 = 0000                      C  	LONGI=0			;WHETHER WE ASK "TERMINAL WIDTH?" 
                             C  				;AND WANT SIN-TAN-COS-ATN? 
 = 0000                      C  	INSTSW=0		;FOR INSTR INSTRUCTION 
 = 0001                      C  	SWAPSW=1		;FOR SWAP STATEMENT 
 = 0000                      C  	MDS=0			;FOR INTEL MDS SYSTEMS 
 = 0000                      C  	SBC=0			;FOR INTEL SINGLE BOARD COMPUTER 
                             C  				;1=SBC 80/10, 2=SBC 80/20 
 = 0001                      C  	PURE=1			;ON FOR PURE CODE 
 = 0000                      C  	KILLER=0		;FOR ROM VERSION THAT WONT RUN IN RAM 
 = 0000                      C  	INTROM=0 
 = 0001                      C  	LPTSW=1 
 = 0001                      C  	NCRLPT=1 
 = 0000                      C  	NCRCAS=0 
 = 0000                      C  	ISC=0			;FOR ISC VERSION 
 = 0000                      C  	LPT3=0			;THREE LPT DRIVER VERSION(QUME,OKIA,CENT) 
 = 0000                      C  	TSLPT=0 
                             C   
 = 0000                      C  	DOS=0			;ON TO GEN ROUTINES FOR DOS 
 = 0001                      C  	DISK=1			;FILE I/O FEATURES 
 = 0000                      C  	TIMSHR=0		;NO TIME-SHARING DISK 
 = 0000                      C  	TSDISK=0		;NO TIME-SHARING DISK FOR US 
 = 0000                      C  	SPCDSK=0		;MAY HAVE MM'S DISK CODE 
 = 0000                      C  	SPCNDS=0 
 = 0001                      C  	FAST=1			;CONSTANT COMPRESSION, RENUM & FRIENDS 
 = 0000                      C  	KEYSTA=0 
 = 0000                      C  	ISIS=0			;FOR VERSION TO RUN UNDER INTEL'S ISIS II DOS 
 = 0000                      C  	MDSISS=0		;FOR MDS VERSION THAT RUNS UNDER ISIS-II 
 = 0001                      C  	CPM=1			;FOR CPM compatible operating systems 
 = 0001                      C  	CPM2=1			;VERSION 2. CPM 
 = 0000                      C  	CPM86=0			;FOR CP/M-86 operating system 
 = 0001                      C  	SCP=1			;MS-DOS operating system 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	CPMSER=0		;CHECK CPM SERIAL #'S 
 = 0000                      C  	CPMADD=0		;FOR VERSION TO RUN ON ADDS CPM 
 = 0000                      C  	CPMA75=0		;FOR VERSION TO RUN ON ADDS SYSTEM 75 
                             C  				;CP/M 
 = 0000                      C  	CPMRSH=0		;FOR RADIO SHACK CPM/M 
 = 0000                      C  	CPM110=0		;FOR CP/M @1100 HEX (INTERALIA) 
 = 0000                      C  	CPMSBC=0		;FOR VERSION TO RUN ON SBC CP/M AT 4100H 
 = 0000                      C  	CPMPER=0		;FOR PERTEC VERSION OF CPM 
 = 0000                      C  	CPMLIF=0		;LIFEBOAT CP/M AT 4200H 
 = 0000                      C  	CPMMDS=0		;MOHAWK DATA SYSTEMS CP/M 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-4
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	CPMCON=0 
 = 0000                      C  	Z80=0 
 = 0001                      C  	DISK=1 
 = 0001                      C  	NCRLPT=1 
 = 0001                      C  	RSTLES=1 
 = 0000                      C  	DRVPOS=CPMADD 
 = 0000                      C  	TRNCHR=CPMADD 
 = 0000                      C  	INLADD=CPMADD 
 = 0001                      C  	LISTEN=1		;ON MEANS LISTEN FOR ^C 
 = 0001                      C  	LISTEN=1 
 = 0000                      C  	LEN2=0 
 = 0001                      C  	LEN2=1 
 = 0001                      C  	HEXOCT=1 
 = 0002                      C  	LENGTH=2 
 = 0001                      C  	RSTLES=1 
 = 0001                      C  	FIVLPT=1 
 = 0000                      C  	I8251=0			;THIS SWITCH IS USED FOR ROSEMOUNT VERSION 
 = 0001                      C  	CONTRO=1		;ALLOW ^O 
 = 0001                      C  	LEN3=LEN2 OR CASSW 
                             C   
                             C   
                             C   
 = 0001                      C  	STRING=1 
 = 0001                      C  	NCRLPT=1 
                             C   
                             C  ; *** OEM Switches which need to be defaulted to 0 
                             C  ; 
 = 0000                      C  	CMPUTN=0 
 = 0000                      C  	DUPONT=0 
 = 0000                      C  	EXIDY=0 
 = 0000                      C  	GESBC=0 
 = 0000                      C  	HEATH=0 
 = 0000                      C  	LOKHED=0 
 = 0000                      C  	MOSTEK=0 
 = 0000                      C  	TEK=0 
 = 0000                      C  	TRSER2=0 
 = 0000                      C  	NASCOM=0 
 = 0000                      C  	NATROM=0 
 = 0000                      C  	NCRBAS=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRELS=0 
 = 0000                      C  	ONTEL=0 
 = 0000                      C  	PCS=0 
 = 0000                      C  	SGSATS=0 
 = 0000                      C  	ALTAIR=0 
 = 0000                      C  	DMC=0 
 = 0000                      C  	PANBAS=0 
 = 0000                      C  	XTNSYS=0 
 = 0000                      C  	NECBAS=0 
                             C  ;******************************************************************* 
                             C  ; Z80 related macros 
                             C  ;******************************************************************* 
 = 0001                      C  	Z80=1			;FOR VERSION THAT RUNS ON BOTH 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-5
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  				;8080'S AND ZILOG Z-80'S 
 = 0001                      C  	Z80MAC=1		;USE 8080 MACROS INSTEAD OF Z80 INSTRUCTIONS 
 = 0000                      C  	Z80=0 
 = 0001                      C  	Z80=1 
                             C  LDIR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	INXF	H 
                             C  	INXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  LDDR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	DCXF	H 
                             C  	DCXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  DJNZ	MACRO	    DEST 
                             C  	DCR	B 
                             C  	JNZ	DEST 
                             C  ENDM 
                             C  ;******************************************************************* 
                             C  ; Define reset routines. 
                             C  ;******************************************************************* 
                             C  FSIGN	MACRO 
                             C  	CALL	SIGN 
                             C  ENDM 
                             C  PUSHM	MACRO 
                             C  	MOV	WORD PTR C,WORD PTR M 
                             C  	INX	H 
                             C  	MOV	WORD PTR B,WORD PTR M 
                             C  	INX	H 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  SYNCHK	MACRO	X 
                             C  	CALL	SYNCHR 
                             C  	DB	OFFSET X 
                             C  ENDM 
                             C  OUTCHR	MACRO 
                             C  	CALL	OUTDO 
                             C  ENDM 
                             C  CHRGET	MACRO 
                             C  	CALL	CHRGTR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	CALL	DCOMPR 
                             C  ENDM 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-6
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  GETYPE	MACRO 
                             C  	CALL	GETYPR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	DB	73O 
                             C  	DB	332O 
                             C   ENDM 
                             C  ACRLF	MACRO 
                             C  	DB	13D 
                             C  	DB	10D 
                             C  ENDM 
                             C  PUSHR	MACRO 
                             C  	PUSH	WORD PTR D 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  POPR	MACRO 
                             C  	POP	WORD PTR B 
                             C  	POP	WORD PTR D 
                             C  ENDM 
                             C  MOVRI	MACRO	B,C,D,E 
                             C  	DB	1O		; "LXI  B" 
                             C  	DB	OFFSET C 
                             C  	DB	OFFSET B 
                             C  	DB	21O		; "LXI  D" 
                             C  	DB	OFFSET E 
                             C  	DB	OFFSET D 
                             C  ENDM 
                             C  INST	MACRO	X 
                             C  	DB	OX 
                             C  ENDM 
                             C   
                             C   
 = 000F                      C  	CONTO=15		;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O) 
 = 0000                      C  	DBLTRN=0		;FOR DOUBLE PRECISION TRANSCENDENTALS 
                             C   
 = 000E                      C  	CLMWID=14D		;MAKE COMMA COLUMNS FOURTEEN CHARACTERS 
 = 0080                      C  	DATPSC=128D		;NUMBER OF DATA BYTES IN DISK SECTOR 
 = 0050                      C  	LINLN=80D		;TERMINAL LINE LENGTH 
 = 0084                      C  	LPTLEN=132D 
 = 00FF                      C  	BUFLEN=255		;LONG LINES 
 = 0028                      C  	NAMLEN=40D		;MAXIMUM LENGTH NAME -- 3 TO 127 
                             C   
 = 006E                      C  	NUMLEV=110D		;NUMBER OF STACK LEVELS RESERVED 
                             C  				;BY AN EXPLICIT CALL TO GETSTK 
 = 0004                      C  	STRSIZ=4 
 = 0003                      C  	STRSIZ=3 
 = 0003                      C  	NUMTMP=3		;NUMBER OF STRING TEMPORARIES 
 = 000A                      C  	NUMTMP=10 
                             C   
 0008                        C  	.RADIX	8 
                             C  ; 
                             C  ; Useful macros 
                             C  ; 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-7
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  ACRLF   MACRO 
                             C          DB      13D 
                             C          DB      10D 
                             C  ENDM 
                             C   
                             C  INS86   MACRO   A,B,C,D 
                             C          DB      A&O 
                             C  IFNB    <B> 
                             C          DB      B&O 
                             C  ENDIF 
                             C  IFNB    <D> 
                             C          DB      C&O 
                             C          DB      D&O 
                             C  ENDIF 
                             C  IFB     <D> 
                             C   IFNB   <C> 
                             C          DW      C 
                             C    ENDIF 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  CALLOS  MACRO 
                             C          CALL    CPMENT 
                             C  ENDM 
                             C   
                             C  POPR    MACRO 
                             C          POP     CX 
                             C          POP     DX 
                             C  ENDM 
                             C   
                             C  ADR     MACRO   X 
                             C          DW      X 
                             C  ENDM 
                             C   
                             C  DC      MACRO   ARG 
                             C          IRPC    ZZ,<ARG> 
                             C              IFDIF       <ZZ>,<">
                             C                  DB      "&ZZ&" 
                             C                  _A="&ZZ&" 
                             C              ENDIF 
                             C          ENDM 
                             C  ENDM 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-8
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C          PAGE 
                             C   
                             C  DBGBRK	MACRO 
                             C  	DB	0CDh,06h,0CCh 
                             C  	ENDM 
                                 
                                 
                                	TITLE   GIO86   - BASIC-86 Interpreter Device Independent I/O Module 
                                 
                                COMMENT	* 
                                 
                                --------- --- ---- -- --------- 
                                COPYRIGHT (C) 1982 BY MICROSOFT 
                                --------- --- ---- -- --------- 
                                 
                                        T. Corbett      Microsoft Inc. 
                                 
                                        * 
                             C  	INCLUDE	GIO86U.INC 
                             C  ; [ This translation created 12-Jan-83 by Version 4.3 ] 
                             C   
                             C  	SUBTTL GIO86U - Device Independent I/O Constants and Macros 
                             C   
                             C  COMMENT	* 
                             C   
                             C  --------- --- ---- -- --------- 
                             C  COPYRIGHT (C) 1982 BY MICROSOFT 
                             C  --------- --- ---- -- --------- 
                             C   
                             C          Programmer: Tom Corbett,  Microsoft Inc. 
                             C   
                             C          * 
                             C   
                             C  ROFFST	MACRO	NAME,SIZE	;define record macro 
                             C  	NAME=_OFFST 
                             C  	_OFFST=_OFFST+SIZE 
                             C  ENDM  
                             C   
                             C   
                             C  ;ASCII character definitions 
                             C  ; 
 = 0003                      C  	ASCCTC=3D		;CTL-C 
 = 0008                      C  	ASCBS=8D		;backspace 
 = 0009                      C  	ASCTAB=9D		;Tab 
 = 000A                      C  	ASCLF=10D		;Line Feed 
 = 000D                      C  	ASCCR=13D		;Carriage Return 
 = 0013                      C  	ASCCTS=19D		;CTL-S 
 = 001A                      C  	ASCCTZ=26D		;Control Z (End-of-file for some devices) 
 = 001B                      C  	ASCESC=27D		;Escape 
 = 0020                      C  	ASCSPC=32D		;Space 
                             C   
                             C  ;Special File ID's (identified by 1st byte of file) 
                             C  ; 
 = 00FF                      C  	BINFID=255D		;files created by SAVE "fn" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-9
GIO86U - Device Independent I/O Constants and Macros        

 = 00FE                      C  	PROFID=254D		;files created by SAVE "fn",P 
 = 00FD                      C  	BSVFID=253D		;files created by BSAVE "fn" 
                             C   
                             C  ;Generalized I/O Function Codes: 
                             C  ; 
 = 0000                      C  	_OFFST=0		;initialize count 
                             C  	ROFFST	G_EOF,2		;test EOF for file opened to this device 
                             C  	ROFFST	G_LOC,2		;LOC 
                             C  	ROFFST	G_LOF,2		;LOF 
                             C  	ROFFST	G_CLS,2		;perform special CLOSE functions for this device 
                             C  	ROFFST	G_SWD,2		;set device width 
                             C  	ROFFST	G_RND,2		;GET/PUT random record from/to this device 
                             C  	ROFFST	G_OPN,2		;perform special OPEN functions for this device 
                             C  	ROFFST	G_SIN,2		;input 1 byte from file opened on this device 
                             C  	ROFFST	G_SOT,2		;output 1 byte to file opened on this device 
                             C  	ROFFST	G_GPS,2		;POS 
                             C  	ROFFST	G_GWD,2		;get device width 
                             C  	ROFFST	G_SCW,2		;set device column width 
                             C  	ROFFST	G_GCW,2		;get device column width 
                             C  	ROFFST	G_BIN,2		;block input from file opened on this device 
                             C  	ROFFST	G_BOT,2		;block output to file opened on this device 
                             C   
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-10
GIO86U - Device Independent I/O Constants and Macros        

                             C          PAGE 
                                 
                                	.SALL 
                                 
                                 
 = 0000                         CPM86=0 
 = 0001                         IBMCSR=IBMLIK			;IBM Compatible Cursor Handling 
                                 
                             C  	INCLUDE	MSDOSU.INC 
                             C  ; [ This translation created 12-Jan-83 by Version 4.3 ] 
                             C   
                             C  	SUBTTL    MSDOSU - MS-DOS Constants and Data-Structure Definitions 
                             C   
                             C  COMMENT	* 
                             C   
                             C  --------- --- ---- -- --------- 
                             C  COPYRIGHT (C) 1982 BY MICROSOFT 
                             C  --------- --- ---- -- --------- 
                             C   
                             C  	Programmer: Tom Corbett,  Microsoft Inc. 
                             C   
                             C  	* 
                             C   
                             C  CALLOS	MACRO	FUNC 
                             C  IFNB	<FUNC>   
                             C  	MOV	AH,LOW OFFSET FUNC 
                             C  ENDIF  
                             C  	INT	33D		;MSDOS system call 
                             C  ENDM  
                             C   
                             C  ROFFST	MACRO	NAME,SIZE	;define record macro 
                             C  	NAME=_OFFST 
                             C  	_OFFST=_OFFST+SIZE 
                             C  ENDM  
                             C   
                             C   
                             C  ; MSDOS System Call codes 
                             C  ; 
 = 0005                      C  	C_PRTO=5D		;Printer output 
 = 0006                      C  	C_DCIO=6D		;Direct console I/O 
 = 000D                      C  	C_REST=13D		;INITIALIZE BDOS 
 = 000E                      C  	C_SDRV=14D		;SET CURRENTLY SELECTED DRIVE 
 = 000F                      C  	C_OPEN=15D 
 = 0010                      C  	C_CLOS=16D 
 = 0011                      C  	C_SEAR=17D		;SEARCH FOR FILE 
 = 0013                      C  	C_DELE=19D 
 = 0014                      C  	C_READ=20D 
 = 0016                      C  	C_MAKE=22D 
 = 0017                      C  	C_RENA=23D 
 = 0019                      C  	C_GDRV=25D		;GET CURRENTLY SELECTED DRIVE 
 = 001A                      C  	C_BUFF=26D		;SET DMA ADDRESS 
 = 0021                      C  	C_RNDR=33D		;Random read 
 = 0022                      C  	C_RNDW=34D		;Random write 
 = 0027                      C  	C_RBR=39D		;Random Block Read 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-11
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

 = 0029                      C  	C_PARS=41D		;Parse Filename 
                             C   
 = 000B                      C  	FNAML=11D		;number of bytes in Filename with extension 
 = 0080                      C  	DATPSC=128D		;bytes per sector 
 = 0026                      C  	FCBSIZ=38D		;File Control Block size 
                             C   
                             C  ;MS-DOS FILE-DATA-BLOCK Record Definition 
                             C  ; 
 = 0000                      C  	_OFFST=0		;initialize count 
                             C  	ROFFST	F_NUL1,1	;not used by basic interpreter 
                             C  	ROFFST	F_NUM,1		;file number 0..255 
                             C  	ROFFST	F_NUL2,2	;not used by basic interpreter 
                             C  	ROFFST	F_NEXT,2	;thread for linked list, [MEMSIZ]=end 
                             C  	ROFFST	F_MODE,1	;file mode: 
 = 0001                      C  	MD_SQI=1D		;sequential input 
 = 0002                      C  	MD_SQO=2D		;sequential output 
 = 0004                      C  	MD_RND=4D		;random 
 = 0008                      C  	MD_APP=8D		;append 
                             C  	ROFFST	F_FCB,FCBSIZ	;File Control Block: used to communicate with OS 
                             C  	ROFFST	F_CLOC,2	;for seq files: num sectors read/written   (LOCOFS) 
                             C  				;for rnd files: last record number + 1 
                             C  	ROFFST	F_ORCT,1	;"Original Byte Count"                     (ORNOFS) 
                             C  				;for seq input: #bytes in sector when read 
                             C  				;for seq output: #bytes in output sector 
                             C  				;for random files: bytes per sector 
                             C  	ROFFST	F_BREM,1	;number of bytes till end-of-buffer        (NMLOFS) 
                             C  	ROFFST	F_CODE,1	;file encoding: 
 = 0000                      C  	FC_ASC=0		;Ascii SAVE, Data files 
 = 0001                      C  	FC_BIN=1		;binary file (BSAVE, binary SAVE) 
                             C  	ROFFST	F_BAKC,1	;holds next sequential input when F.FLBS.FL.BKC is true 
                             C  	ROFFST	F_NUL3,1	;not used by basic interpreter 
                             C  	ROFFST	F_DEV,1		;Device number                             (FL.DSK) 
                             C  	ROFFST	F_WID,1		;File width 
                             C  	ROFFST	F_NUL4,1	;not used by basic interpreter 
                             C  	ROFFST	F_FLGS,1	;flags 
 = 0080                      C  	FL_BKC=200O		;when true, F.BAKC contains next sequential input 
                             C  	ROFFST	F_POS,1		;Current column position                   (FL.OPS) 
                             C  	ROFFST	FDBSIZ,0	;size of device independent part of FDB 
                             C  				;device dependant FDB entries start here 
                             C   
                             C  	ROFFST	DATOFS,DATPSC	;Operating System interface buffer 
                             C  	ROFFST	FD_SIZ,2	;variable record length for random files 
                             C  	ROFFST	FD_PHY,2	;current physical record number 
                             C  	ROFFST	FD_LOG,2	;current logical record number 
                             C  	ROFFST	F_NUL5,1	;Future use 
                             C  	ROFFST	FD_OPS,2	;current output position for sequential I/O 
                             C  	ROFFST	FD_DAT,0	;field buffer of random file 
                             C   
                             C  ; OFFSETS INTO MSDOS FCB 
                             C  ; 
 = 0007                      C  	FCB_DV=F_FCB+0D		;DRIVE (0=default, 1=A:, 2=B:, ...) 
 = 0008                      C  	FCB_FN=F_FCB+1D		;FILE NAME 
 = 0010                      C  	FCB_FT=F_FCB+9D		;EXTENSION 
 = 0013                      C  	FCB_EX=F_FCB+12D	;FILE EXTENT (identifies block of 128 logical records) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-12
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

 = 0015                      C  	FCB_RC=F_FCB+14D	;RECORD SIZE 
 = 0017                      C  	FCB_FS=F_FCB+16D	;FILE SIZE IN BYTES 
 = 001B                      C  	FCB_DT=F_FCB+20D	;Date of last write to file 
 = 001D                      C  	FCB_DT=F_FCB+22D	;Time of last write to file 
 = 0027                      C  	FCB_NR=F_FCB+32D	;NEXT RECORD NUMBER 
 = 0028                      C  	FCB_RN=F_FCB+33D	;CP/M 2.x Random Record Number 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-13
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

                             C          PAGE 
                                 
                                 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	ASSUME DS:DSEG 
                                	EXTRN	DEVPTR:WORD,DEVTBL:WORD,DEVINI:WORD,DEVTRM:WORD 
                                	EXTRN	NLONLY:WORD,RUNFLG:WORD 
                                	EXTRN	FILMOD:WORD,FILDEV:WORD,FILNM:WORD,FILEXT:WORD 
                                	EXTRN	PTRFIL:WORD,FILTAB:WORD,STKLOW:WORD 
 0000                           DSEG	ENDS 
                                 
                                	EXTRN	SNERR:NEAR,FCERR:NEAR 
                                	EXTRN	FRESTR:NEAR,GETYPR:NEAR 
                                	EXTRN	$_KYBD:NEAR,$_LPT1:NEAR,$_NDEV:NEAR 
                                	EXTRN	DERBFM:NEAR,DERBFN:NEAR,DERFAO:NEAR,DERFNO:NEAR,DERIFN:NEAR 
                                	EXTRN	DERDNA:NEAR,DERFDR:NEAR 
                                 
                                DOSIO	MACRO	DFUN 
                                	MOV	AH,LOW OFFSET DFUN 
                                	INT	33D		;MS-DOS system call 
                                ENDM 
                                 
                                 
                                 
                                	SUBTTL OPEN statement 
                                 
                                	PUBLIC	OPEN 
                                	EXTRN	$LEN:NEAR,EQULTK:NEAR,$FOR:NEAR,$INPUT:NEAR,GETBYT:NEAR 
                                	EXTRN	GWWID:NEAR 
                                 
                                ; OPEN Statement 
                                ; Syntax: 
                                ;  OPEN filespec FOR mode AS fnum [LEN=random-record-length] 
                                ;  OPEN mode,fnum,filespec[,random-record-length] 
                                ; 
 0000  E8 0000 E                OPEN:	CALL	FRMEVL		;read the file mode or filename 
 0003  8A 07                    	MOV	AL,BYTE PTR 0[BX]	;get terminator 
 0005  3C 2C                    	CMP	AL,LOW 54O	;followed by comma? (then 
                                				; non-spcdsk open...) 
 0007  75 45                    	JNZ	NOTNSO		;nope, must be SPCDSK form 
 0009  53                       	PUSH	BX		;save the text pointer 
 000A  E8 0000 E                	CALL	FRESTR		;free string temp & check string 
 000D  8A 07                    	MOV	AL,BYTE PTR 0[BX]	;make sure its not a null string 
 000F  0A C0                    	OR	AL,AL 
 0011  74 38                    	JZ	ERBFM0		;if so, "bad file mode" 
 0013  43                       	INC	BX 
 0014  8B 1F                    	MOV	BX,WORD PTR 0[BX]	;[BX] points at mode character 
 0016  8A 07                    	MOV	AL,BYTE PTR 0[BX]	;[A]=mode character 
 0018  24 DF                    	AND	AL,LOW OFFSET -1-" "	;force to upper case 
 001A  B6 02                    	MOV	DH,LOW OFFSET MD_SQO	;assume its "O" 
 001C  3C 4F                    	CMP	AL,LOW "O"	;is it? 
 001E  74 12                    	JZ	HAVMOD		;[D] has correct mode 
 0020  B6 01                    	MOV	DH,LOW OFFSET MD_SQI	;assume sequential 
 0022  3C 49                    	CMP	AL,LOW "I"	;is it? 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-14
OPEN statement                                              

 0024  74 0C                    	JZ	HAVMOD		;[D] says sequential input 
 0026  B6 08                    	MOV	DH,LOW OFFSET MD_APP	;append? 
 0028  3C 41                    	CMP	AL,LOW "A"	;test 
 002A  74 06                    	JZ	HAVMOD		;allow it 
 002C  B6 04                    	MOV	DH,LOW OFFSET MD_RND	;must be random 
 002E  3C 52                    	CMP	AL,LOW "R" 
 0030  75 19                    	JNZ	ERBFM0		;if not, no match so "bad file mode" 
 0032  88 36 0000 E             HAVMOD:	MOV	BYTE PTR FILMOD,DH	;set file mode 
 0036  5B                       	POP	BX		;get back the text pointer 
 0037  E8 0000 E                	CALL	SYNCHR 
 003A  2C                       	DB	OFFSET 54O	;skip comma before file number 
 003B  E8 03CA R                HAVMD1:	CALL	POFNUM		;[AL]=the file number 
 003E  50                       	PUSH	AX		;save file number 
 003F  E8 0000 E                	CALL	SYNCHR 
 0042  2C                       	DB	OFFSET 54O	;skip comma before name 
 0043  E8 0756 R                	CALL	NAMSCN		;parse filename setting FILDEV, FILNM, FILEXT 
 0046  E8 00C1 R                	CALL	PORLEN		;parse reclen parm 
 0049  EB 69                    	JMP	SHORT OPEN1	;branch to common code (with Fnum on stack) 
                                 
 004B  E9 0000 E                ERBFM0:	JMP	DERBFM		;bad file mode error 
                                 
 004E  E8 0759 R                NOTNSO:	CALL	NAMSC1		;parse filename setting FILDEV, FILNM, FILEXT 
 0051  B6 04                    	MOV	DH,LOW OFFSET MD_RND	;Assume there is no FOR, in which 
                                				;case the default mode is random. 
 0053  8A 07                    	MOV	AL,BYTE PTR 0[BX] 
 0055  3C 00 E                  	CMP	AL,LOW OFFSET $FOR	;Is there a 'FOR'? 
 0057  75 48                    	JNZ	GOTMOD		;No, better see 'AS' 
 0059  E8 0000 E                	CALL	CHRGTR 
 005C  3C 00 E                  	CMP	AL,LOW OFFSET $INPUT	;Input mode? 
 005E  B6 01                    	MOV	DH,LOW OFFSET MD_SQI	;Assume it is 
 0060  74 3C                    	JZ	GOTMD1		;Yes, have file mode 
 0062  3C 41                    	CMP	AL,LOW "A"	;test 
 0064  75 1C                    	JNE	NTAPP		;branch if not append (might be OUTPUT) 
 0066  E8 0000 E                	CALL	SYNCHR 
 0069  41                       	DB	OFFSET "A" 
 006A  E8 0000 E                	CALL	SYNCHR 
 006D  50                       	DB	OFFSET "P" 
 006E  E8 0000 E                	CALL	SYNCHR 
 0071  50                       	DB	OFFSET "P" 
 0072  E8 0000 E                	CALL	SYNCHR 
 0075  45                       	DB	OFFSET "E" 
 0076  E8 0000 E                	CALL	SYNCHR 
 0079  4E                       	DB	OFFSET "N" 
 007A  E8 0000 E                	CALL	SYNCHR 
 007D  44                       	DB	OFFSET "D" 
 007E  B6 08                    	MOV	DH,LOW OFFSET MD_APP	;append file mode 
 0080  EB 1F                    	JMP	SHORT GOTMOD	;allow it 
 0082                           NTAPP: 
 0082  E8 0000 E                	CALL	SYNCHR 
 0085  4F                       	DB	OFFSET "O"	;it must be OUTPUT 
 0086  E8 0000 E                	CALL	SYNCHR 
 0089  55                       	DB	OFFSET "U" 
 008A  E8 0000 E                	CALL	SYNCHR 
 008D  54                       	DB	OFFSET "T" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-15
OPEN statement                                              

 008E  E8 0000 E                	CALL	SYNCHR 
 0091  50                       	DB	OFFSET "P" 
 0092  E8 0000 E                	CALL	SYNCHR 
 0095  55                       	DB	OFFSET "U" 
 0096  E8 0000 E                	CALL	SYNCHR 
 0099  54                       	DB	OFFSET "T" 
 009A  B6 02                    	MOV	DH,LOW OFFSET MD_SQO 
 009C  EB 03                    	JMP	SHORT GOTMOD 
                                 
 009E  E8 0000 E                GOTMD1:	CALL	CHRGTR 
 00A1  88 36 0000 E             GOTMOD:	MOV	BYTE PTR FILMOD,DH	;set file mode 
 00A5  E8 0000 E                	CALL	SYNCHR 
 00A8  41                       	DB	OFFSET "A" 
 00A9  E8 0000 E                	CALL	SYNCHR 
 00AC  53                       	DB	OFFSET "S"	;Must have 'AS' 
 00AD  E8 03CA R                	CALL	POFNUM		;[AL]=file # 
 00B0  50                       	PUSH	AX		;save file# 
 00B1  E8 00CC R                	CALL	PNRLEN		;parse new reclen parameter 
 00B4  4B                       OPEN1:	DEC	BX 
 00B5  E8 0000 E                	CALL	CHRGTR 
 00B8  75 45                    	JNZ	SNERR1		;error if not end-of-statement 
 00BA  58                       	POP	AX		;[AL]=file number 
 00BB  E8 0471 R                	CALL	OPNFIL		;branch to general file-open code 
 00BE  E9 0A74 R                	JMP	FINPRT		;reset PTRFIL to 0 (keyboard/crt) 
                                 
                                ;PORLEN - parse old variable record length field 
                                ; Entry - [FILMOD]=file mode 
                                ; Exit  - [CX]=reclen if reclen parm included, else 0 
                                ; 
 00C1  E8 00E7 R                PORLEN:	CALL	PRLENC 
 00C4  74 20                    	JZ	PRLENX 
 00C6  E8 0000 E                	CALL	SYNCHR 
 00C9  2C                       	DB	OFFSET 54O 
 00CA  EB 11                    	JMP	SHORT VARECS 
                                 
                                ;PNRLEN - parse new variable record length field 
                                ; Entry - [FILMOD]=file mode 
                                ; Exit  - [CX]=reclen if reclen parm included, else 0 
                                ; 
 00CC  E8 00E7 R                PNRLEN:	CALL	PRLENC 
 00CF  74 15                    	JZ	PRLENX 
 00D1  E8 0000 E                	CALL	SYNCHR 
 00D4  FF                       	DB	OFFSET 377O	;else parse "LEN=record-length" 
 00D5  E8 0000 E                	CALL	SYNCHR 
 00D8  00 E                     	DB	OFFSET $LEN	;LEN is a 2-byte token 
 00D9  E8 0000 E                	CALL	SYNCHR 
 00DC  00 E                     	DB	OFFSET EQULTK 
                                	EXTRN	INTID2:NEAR 
 00DD  E8 0000 E                VARECS:	CALL	INTID2		;[DX]=record size (0..32767) 
 00E0  8B CA                    	MOV	CX,DX		;return it in CX 
 00E2  0B C9                    	OR	CX,CX 
 00E4  74 16                    	JZ	FCERR1		;0 is illegal value 
 00E6  C3                       PRLENX:	RET 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-16
OPEN statement                                              

                                ;PRLENC - see if reclen parm is expected 
                                ; 
 00E7                           PRLENC: 
 00E7  B9 0000                  	MOV	CX,0		;indicates reclen parm not included 
 00EA  A0 0000 E                	MOV	AL,BYTE PTR FILMOD	;[AL]=requested file mode 
 00ED  3C 04                    	CMP	AL,LOW OFFSET MD_RND 
 00EF  75 08                    	JNZ	NOLEN		;branch if file mode is not RANDOM 
 00F1  4B                       	DEC	BX		;decrement text pointer 
 00F2  E8 0000 E                	CALL	CHRGTR		;re-get last character parsed 
 00F5  74 02                    	JZ	NOLEN		;branch if end-of-statement 
 00F7  B1 01                    	MOV	CL,LOW 1	;indicates reclen parm included 
 00F9  0B C9                    NOLEN:	OR	CX,CX		;set NZ if reclen parm included 
 00FB  C3                       	RET 
                                 
 00FC  E9 0000 E                FCERR1:	JMP	FCERR		;function call error 
                                 
 00FF  E9 0000 E                SNERR1:	JMP	SNERR		;syntax error 
                                 
                                	SUBTTL CLOSE, WIDTH Statements 
                                 
                                	PUBLIC	CLOSE 
                                 
                                ; CLOSE Statement 
                                ;  Syntax: CLOSE [[#]n [,[#]n ...]] 
                                ; 
 0102  75 03                    CLOSE:	JNZ	CLOS1		;branch if statement has parm 
 0104  E9 049A R                	JMP	CLSALL		;close all files if no parm given 
 0107  3C 23                    CLOS1:	CMP	AL,LOW "#" 
 0109  75 03                    	JNZ	NOLBS		;branch if no # 
 010B  E8 0000 E                	CALL	CHRGTR		;skip # 
 010E                           NOLBS: 
 010E  E8 0000 E                	CALL	GETBYT		;[AL]=file# 
 0111  E8 04B5 R                	CALL	CLSFIL		;close file [AL] and return 
 0114  4B                       	DEC	BX 
 0115  E8 0000 E                	CALL	CHRGTR 
 0118  3C 2C                    	CMP	AL,LOW 54O	;check for comma 
 011A  75 5A                    	JNZ	RET6		;branch if end of file list 
 011C  E8 0000 E                	CALL	CHRGTR		;skip comma 
 011F  EB E6                    	JMP	SHORT CLOS1	;close next file in list 
                                 
                                	PUBLIC	WIDTHS 
                                 
                                ; WIDTH Y[,X]/[#fnum,]/[device,]   Statement 
                                ; Entry - (BX) = text pointer 
                                ; 
 0121  3C 23                    WIDTHS:	CMP	AL,LOW "#" 
 0123  74 3D                    	JZ	FILWID		;Is files WIDTH specification 
 0125  3C 2C                    	CMP	AL,LOW 54O 
 0127  74 57                    	JZ	CRTWD1		;branch if Comma 
                                	EXTRN	$LPRINT:NEAR,$_LPT1:NEAR 
 0129  3C 00 E                  	CMP	AL,LOW OFFSET $LPRINT 
 012B  75 07                    	JNZ	NOTLPR		;branch if not WIDTH LPRINT 
 012D  E8 0000 E                	CALL	CHRGTR		;skip LPRINT 
 0130  B0 00 E                  	MOV	AL,LOW OFFSET $_LPT1 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-17
CLOSE, WIDTH Statements                                     

 0132  EB 1F                    	JMP	SHORT ITSWLP 
 0134                           NOTLPR: 
 0134  53                       	PUSH	BX		;save Text Pointer in case CRT width 
 0135  E8 0000 E                	CALL	FRMEVL		;evaluate string or number 
 0138  E8 0000 E                	CALL	GETYPR 
 013B  75 42                    	JNZ	CRTWD		;brif not string argument. CRT width 
 013D  5E                       	POP	SI		;discard old text pointer 
 013E  53                       	PUSH	BX		;save text pointer 
 013F  E8 0000 E                	CALL	FRESTR		;release temporary string descriptor 
                                				;[BX] points to string descriptor 
 0142  8A 0F                    	MOV	CL,BYTE PTR 0[BX] 
 0144  B5 00                    	MOV	CH,LOW 0	;[CX]=length of string 
 0146  8B 77 01                 	MOV	SI,WORD PTR 1[BX]	;SI points to start of string 
 0149  E8 07D1 R                	CALL	PARDEV		;AL=-(device number) 
 014C  5B                       	POP	BX		;restore text pointer 
 014D  50                       	PUSH	AX		;save device id 
 014E  E8 0000 E                	CALL	SYNCHR 
 0151  2C                       	DB	OFFSET 54O 
 0152  58                       	POP	AX		;[AL]=device id 
 0153                           ITSWLP: 
 0153  50                       	PUSH	AX		;save device id 
 0154  E8 0177 R                	CALL	GETWDT		;[DL]=width 
 0157  58                       	POP	AX		;[AL]=device id 
 0158  E8 073C R                	CALL	CDEVID		;[DI]=device dispatch table offset 
 015B  74 29                    	JZ	ERIFN0		;illegal file name if device=disk 
 015D  B4 08                    	MOV	AH,LOW OFFSET G_SWD	;select set-width function 
 015F  E9 0719 R                	JMP	TBLDSP		;dispatch function [AH] for device [DI] 
                                 
 0162  E8 03CF R                FILWID:	CALL	PRFNUM		;[AL]=file number 
 0165  E8 089E R                	CALL	FDBPTR		;[SI] points to file-data-block 
 0168  74 1F                    	JZ	ERFNO1		;branch if file not opened 
 016A  56                       	PUSH	SI 
 016B  E8 0000 E                	CALL	SYNCHR 
 016E  2C                       	DB	OFFSET 54O 
 016F  E8 0177 R                	CALL	GETWDT		;[AL]=width (1..255) 
 0172  5E                       	POP	SI		;SI points to file data block 
 0173  88 44 35                 	MOV	BYTE PTR F_WID[SI],AL	;save width in FDB 
 0176  C3                       RET6:	RET 
                                 
 0177  E8 0000 E                GETWDT:	CALL	GETBYT 
 017A  0A C0                    	OR	AL,AL 
 017C  74 05                    	JZ	FCERR2		;width of 0 is illegal 
 017E  C3                       	RET			;return if width is between 1 and 255 
                                 
 017F  5B                       CRTWD:	POP	BX		;restore text pointer 
 0180  E9 0000 E                CRTWD1:	JMP	GWWID 
                                 
 0183  E9 0000 E                FCERR2:	JMP	FCERR 
 0186  E9 0000 E                ERIFN0:	JMP	DERIFN		;illegal file name error 
 0189  E9 0000 E                ERFNO1:	JMP	DERFNO		;file not open error 
 018C  E9 0000 E                ERDNA1:	JMP	DERDNA		;Device not available 
                                 
                                	SUBTTL BSAVE, BLOAD Statements 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-18
BSAVE, BLOAD Statements                                     

                                 
                                	PUBLIC	BLOAD,BSAVE 
                                	EXTRN	GETBYT:NEAR,SYNCHR:NEAR,MAKINT:NEAR,CHRGTR:NEAR,SNERR:NEAR 
                                	EXTRN	PRODIR:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	SAVLEN:WORD,SAVSEG:WORD 
 0000                           DSEG	ENDS 
                                 
                                ; BSAVE Statement - Save memory image to file 
                                ; Syntax: BSAVE name, start-adr, byte-count 
                                ; 
 018F  E8 020A R                BSAVE:	CALL	BPARMS		;parse parms 
 0192  FE C0                    	INC	AL 
 0194  75 2D                    	JNZ	SNERR2		;Error if 1 or no parms. 
 0196  53                       	PUSH	BX		;save text pointer 
 0197  51                       	PUSH	CX		;SAVE start-adr 
 0198  B0 02                    	MOV	AL,LOW OFFSET MD_SQO	;open file 0 for output 
 019A  E8 046A R                	CALL	NULOPM 
 019D  E8 0890 R                	CALL	SCDBIN		;set file-code to binary 
 01A0  B0 FD                    	MOV	AL,LOW OFFSET BSVFID	;output binary file ID 
 01A2  E8 058E R                	CALL	OUTDO		;output to file 
 01A5  A1 0000 E                	MOV	AX,WORD PTR SAVSEG	;DX=Segment from DEF SEG statement 
 01A8  E8 0598 R                	CALL	OUT16		;write segment adr to file 
 01AB  58                       	POP	AX		;[AX]=start-adr 
 01AC  50                       	PUSH	AX 
 01AD  E8 0598 R                	CALL	OUT16		;output start adr 
 01B0  A1 0000 E                	MOV	AX,WORD PTR SAVLEN	;[DX]=number of bytes 
 01B3  8B C8                    	MOV	CX,AX		;[CX]=length 
 01B5  E8 0598 R                	CALL	OUT16		;output end adr + 1 
 01B8  5B                       	POP	BX		;[BX]=start-adr 
 01B9  8B 16 0000 E             	MOV	DX,WORD PTR SAVSEG	;DX=Segment adr 
 01BD  E8 060D R                	CALL	OUTBLK		;output binary 
 01C0  EB 41 90                 	JMP	LODEND		;exit 
                                 
 01C3  E9 0000 E                SNERR2:	JMP	SNERR 
                                 
                                ; BLOAD Statement - load memory image from disk 
                                ; Syntax: BLOAD name[, start-adr] 
                                ; 
 01C6                           BLOAD: 
 01C6  E8 020A R                	CALL	BPARMS		;Get Parms if any. 
 01C9  0A C0                    	OR	AL,AL 
 01CB  74 04                    	JZ	BLODP		;Will set -1 if start-adr only given. 
 01CD  FE C0                    	INC	AL 
 01CF  74 F2                    	JZ	SNERR2		;error if 2 parms given 
 01D1  FE C8                    BLODP:	DEC	AL		;AL=1: no start-adr parm, -1: start-adr parm 
 01D3  53                       	PUSH	BX		;save text pointer 
 01D4  50                       	PUSH	AX		;save Parm Switch 
 01D5  51                       	PUSH	CX		;save start-adr parm 
 01D6  B0 01                    	MOV	AL,LOW OFFSET MD_SQI 
 01D8  E8 046A R                	CALL	NULOPM		;Open File 0 for INPUT 
 01DB  E8 0890 R                	CALL	SCDBIN		;set file code to binary 
 01DE  E8 04E5 R                	CALL	INCHR		;[A]=1st byte from file 
 01E1  3C FD                    	CMP	AL,LOW OFFSET BSVFID	;make sure this was created by BSAVE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-19
BSAVE, BLOAD Statements                                     

 01E3  75 22                    	JNZ	ERBFM2		;else BAD FILE MODE 
 01E5  59                       	POP	CX		;[CX]=start-adr parm 
 01E6  E8 05A3 R                	CALL	INP16		;[AX]=next 16 bits from file 
 01E9  8B D0                    	MOV	DX,AX		;[DX]=default segment 
 01EB  E8 05A3 R                	CALL	INP16		;[AX]=next 16 bits from file 
 01EE  8B D8                    	MOV	BX,AX		;[BX]=default start-adr 
 01F0  58                       	POP	AX		;AL=1: no start-adr parm, -1: start-adr parm 
 01F1  FE C8                    	DEC	AL 
 01F3  74 06                    	JZ	DEFSAD		;branch if no start-adr parm given 
 01F5  8B 16 0000 E             	MOV	DX,WORD PTR SAVSEG	;[DX]=segment parm 
 01F9  8B D9                    	MOV	BX,CX		;[BX]=start-adr parm 
 01FB  E8 05A3 R                DEFSAD:	CALL	INP16		;[AX]=file length 
 01FE  8B C8                    	MOV	CX,AX		;[CX]=file length 
 0200  E8 0617 R                	CALL	INPBLK		;do the load 
 0203                           LODEND: 
 0203  5B                       	POP	BX		;restore text pointer 
 0204  E9 0A74 R                	JMP	FINPRT		;close file 0, reset PTRFIL 
                                 
 0207  E9 0000 E                ERBFM2:	JMP	DERBFM		;bad file mode error 
                                 
                                ;BPARMS - Parse parms for BLOAD and BSAVE 
                                ; Exit  - [AL]=(1,0,-1) if 0,1,2 parameters parsed. 
                                ;         [BX] is preserved (text pointer) 
                                ;         [CX] = start-adr 
                                ;         [SAVLEN] = file size (if BSAVE) 
                                ; 
 020A                           BPARMS: 
 020A  E8 0000 E                	CALL	PRODIR		;Don't allow in direct mode if protected 
 020D  E8 0756 R                	CALL	NAMSCN		;scan file name and disk number 
                                				;setting FILDEV, FILNM, FILEXT 
 0210  72 03                    	JB	BNAMOK		;Extension supplied by user 
 0212  E8 0451 R                	CALL	NAMBAS		;Supply ".BAS" default extension 
 0215                           BNAMOK: 
 0215  4B                       	DEC	BX 
 0216  E8 0000 E                	CALL	CHRGTR		;See if any parms 
 0219  75 03                    	JNZ	BPARM2		;Brif parms follow 
 021B  B0 01                    	MOV	AL,LOW 1	;No Parms, use file header if BLOAD. 
 021D  C3                       	RET			; else exit. 
 021E                           BPARM2: 
 021E  E8 0000 E                	CALL	SYNCHR 
 0221  2C                       	DB	OFFSET ","	;Must see comma first 
 0222  E8 0432 R                	CALL	ADRGET		;get start-adr (0..65535) 
 0225  52                       	PUSH	DX		;save it 
 0226  4B                       	DEC	BX 
 0227  E8 0000 E                	CALL	CHRGTR 
 022A  75 04                    	JNZ	BPARM3		;Brif 2nd Parm given. 
 022C  59                       	POP	CX		;[CX]=start adr 
 022D  32 C0                    	XOR	AL,AL		;Set 0 if 1 parm only given. 
 022F  C3                       	RET 
 0230                           BPARM3: 
 0230  E8 0000 E                	CALL	SYNCHR 
 0233  2C                       	DB	OFFSET "," 
 0234  E8 0432 R                	CALL	ADRGET		;[DX]=number of bytes for bsave (0..65535) 
 0237  87 DA                    	XCHG	BX,DX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-20
BSAVE, BLOAD Statements                                     

 0239  89 1E 0000 E             	MOV	WORD PTR SAVLEN,BX	;Save end ADDRESS+1(start+count) 
 023D  87 DA                    	XCHG	BX,DX		;[BX]=text pointer 
 023F  4B                       	DEC	BX 
 0240  E8 0000 E                	CALL	CHRGTR 
 0243  75 04                    	JNZ	SNERR3		;must be end of statement 
 0245  59                       	POP	CX		;[CX]=start-adr 
 0246  B0 FF                    	MOV	AL,LOW 377O	;Set -1 if 2 parms given. 
 0248  C3                       	RET 
                                 
 0249  E9 0000 E                SNERR3:	JMP	SNERR 
                                 
                                	SUBTTL LPRINT, PRINT Statements 
                                 
                                	PUBLIC	LPRINT,PRINT 
                                	EXTRN	PRINUS:NEAR,IMOD:NEAR,FOUT:NEAR,STRLIT:NEAR,STRPRT:NEAR 
                                	EXTRN	USINTK:NEAR,TABTK:NEAR,SPCTK:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	FACLO:WORD 
 0000                           DSEG	ENDS 
                                 
 024C  E9 0000 E                JPRINU:	JMP	PRINUS		;Print Using 
                                 
 024F  E8 0581 R                PRINTX:	CALL	CRDO		;output terminating CR 
 0252  59                       PRNTX1:	POP	CX		;discard line width, last comma column 
 0253  E9 0A74 R                	JMP	FINPRT		;close file#0, reset PTRFIL to keyboard 
                                 
 0256  C7 06 0000 E FFFF        LPRINT:	MOV	WORD PTR PTRFIL,-1	;future output will go to Line Printer 
 025C  EB 05                    	JMP	SHORT PRINT1 
 025E                           PRINT: 
 025E  B1 02                    	MOV	CL,LOW OFFSET MD_SQO	;setup output file 
 0260  E8 03E4 R                	CALL	FILGET 
 0263  E8 0641 R                PRINT1:	CALL	PTRWDC		;[CH]=width, [CL]=last comma column 
 0266  51                       	PUSH	CX		;save on stack 
 0267  4B                       NEWCHR:	DEC	BX 
 0268  E8 0000 E                	CALL	CHRGTR		;get another character 
 026B  74 E2                    	JZ	PRINTX		;print CR if end without punctuation 
 026D  74 E3                    PRINTC:	JZ	PRNTX1		;branch if end of statement 
 026F  59                       	POP	CX		;refresh [CH]=width, [CL]=last comma column 
 0270  3C 00 E                  	CMP	AL,LOW OFFSET USINTK	;is it "print using" ? 
 0272  74 D8                    	JZ	JPRINU		;IF SO, USE A SPECIAL HANDLER 
 0274  51                       	PUSH	CX		;save [CH]=width, [CL]=last comma column 
 0275  3C 00 E                  	CMP	AL,LOW OFFSET TABTK 
 0277  74 10                    	JZ	TABERJ		;the TAB function? 
 0279  3C 00 E                  	CMP	AL,LOW OFFSET SPCTK 
 027B  74 0C                    	JZ	TABERJ		;the SPC function? 
 027D  53                       	PUSH	BX		;save the text pointer 
 027E  3C 2C                    	CMP	AL,LOW 44D 
 0280  74 72                    	JZ	COMPRT		;Print Comma 
 0282  3C 3B                    	CMP	AL,LOW 59D	;is it a ";" 
 0284  75 06                    	JNZ	PRTS 
 0286  E9 0367 R                	JMP	NOTABR 
 0289  E9 030F R                TABERJ:	JMP	TABER 
 028C  5A                       PRTS:	POP	DX		;get rid of old text pointer 
 028D  E8 0000 E                	CALL	FRMEVL		;evaluate the formula 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-21
LPRINT, PRINT Statements                                    

 0290  53                       	PUSH	BX		;save text pointer 
 0291  E8 0000 E                	CALL	GETYPR		;see if we have a string 
 0294  74 34                    	JZ	STRDON		;if so, print special 
 0296  4B                       	DEC	BX 
 0297  E8 0000 E                	CALL	CHRGTR		;[BX]=addr of number terminator(non-blank) 
 029A  80 3F 2C                 	CMP	BYTE PTR 0[BX],LOW 54O 
 029D  9C                       	PUSHF			;remember if value was comma terminated 
 029E  E8 0000 E                	CALL	FOUT		;make a number into a string 
 02A1  E8 0000 E                	CALL	STRLIT		;make it a string 
 02A4  C6 07 20                 	MOV	BYTE PTR 0[BX],LOW " "	;put a space at the end 
 02A7  9D                       	POPF 
 02A8  5B                       	POP	BX 
 02A9  59                       	POP	CX		;restore [CH]=width, [CL]=last comma column 
 02AA  51                       	PUSH	CX 
 02AB  53                       	PUSH	BX 
 02AC  8B 1E 0000 E             	MOV	BX,WORD PTR FACLO	;[BX]=address of string descriptor 
 02B0  75 16                    	JNZ	INCLEN		;BRIF not comma terminated(print the space too) 
 02B2  E8 0637 R                	CALL	PTRGPS		;[AL]=file's current position 
 02B5  02 07                    	ADD	AL,BYTE PTR 0[BX]	;add length of string we will output 
                                ;At this point we have [AL]=posn after number is printed(without space), 
                                ;  [CH]=device width, [CL]=last comma posn, [BX]=addr of string descriptor. 
                                ;IF number output stops at comma column minus one 
                                ;THEN don't append blank(This insures that another number will appear at the 
                                ;next comma column, instead of the second column posn after this string) 
 02B7  80 FD FF                 	CMP	CH,LOW 255D	;infinite width? 
 02BA  74 04                    	JZ	MODCOM		;do modulus to determine next comma column 
 02BC  3A C1                    	CMP	AL,CL		;compare with last comma column 
 02BE  73 08                    	JNB	INCLEN		;Will do CR after do output, 
                                				; make string include blank 
                                ;Determine if posn in [AL] is one less than a comma column 
 02C0  FE C0                    MODCOM:	INC	AL 
 02C2  2C 0E                    MODCM1:	SUB	AL,LOW OFFSET CLMWID	;[AL]=modulus CLMWID 
 02C4  77 FC                    	JA	MODCM1 
 02C6  74 02                    	JZ	STRDON		;BRIF at comma column, exclude trailing space 
 02C8  FF 07                    INCLEN:	INC	WORD PTR 0[BX]	;increment the length to include the space 
                                				;NOTE:number is less than 255(can do INC) 
 02CA  5B                       STRDON:	POP	BX 
 02CB  59                       	POP	CX 
 02CC  51                       	PUSH	CX		;refresh [CH]=width, [CL]=last comma column 
 02CD  53                       	PUSH	BX 
 02CE  8B 1E 0000 E             	MOV	BX,WORD PTR FACLO	;BX points to string descriptor 
 02D2  FE C5                    	INC	CH 
 02D4  74 17                    	JZ	LINCH2		;branch if infinite (255) line width 
 02D6  FE CD                    	DEC	CH		;restore [CH]=device width 
 02D8  E8 0637 R                	CALL	PTRGPS		;[AL]=file's current column pos 
 02DB  0A C0                    	OR	AL,AL		;don't CR if string longer than line 
 02DD  74 0E                    	JZ	LINCH2		;  length if position is 0 
 02DF  02 07                    	ADD	AL,BYTE PTR 0[BX]	;[AL]=column + string size 
 02E1  F5                       	CMC			;set nc if overflow on check 
 02E2  73 04                    	JAE	LINCHK		;start on a new line if overflow 
 02E4  FE C8                    	DEC	AL 
 02E6  3A C5                    	CMP	AL,CH		;check for overlap 
 02E8  72 03                    LINCHK:	JB	LINCH2		;branch if still on current line 
 02EA  E8 0581 R                	CALL	CRDO		;else output CR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-22
LPRINT, PRINT Statements                                    

 02ED  E8 0000 E                LINCH2:	CALL	STRPRT		;PRINT THE string/number 
 02F0  5B                       	POP	BX		;restore text pointer 
 02F1  E9 0267 R                	JMP	NEWCHR		;print some more 
                                 
                                ;PRINT comma (text pointer stacked) 
                                ; 
 02F4  E8 0637 R                COMPRT:	CALL	PTRGPS		;[AL]=file's current column position 
 02F7  80 FD FF                 	CMP	CH,LOW 255D	;infinite width? 
 02FA  74 09                    	JZ	MORCOM		;do modulus 
 02FC  3A C1                    	CMP	AL,CL		;compare current with last comma column 
 02FE  72 05                    CHKCOM:	JB	MORCOM		;branch if not beyond last comma col 
 0300  E8 0581 R                	CALL	CRDO		;start new line 
 0303  EB 62                    	JMP	SHORT NOTABR	;AND QUIT IF BEYOND LAST COMMA FIELD 
 0305  2C 0E                    MORCOM:	SUB	AL,LOW OFFSET CLMWID	;[AL]=MODULUS CLMWID 
 0307  73 FC                    	JAE	MORCOM 
 0309  F6 D8                    	NEG	AL 
 030B  FE C8                    	DEC	AL		;fill the print position out 
                                				;to an even CLMWID, so 
                                				;we print CLMWID-[AL] MOD CLMWID spaces 
 030D  EB 4B                    	JMP	SHORT ASPA2	;go print [AL]+1 spaces 
                                 
                                ;PRINT TAB(N) & SPC(N) 
                                ; 
 030F  50                       TABER:	PUSH	AX		;remember IF [A]=SPCTK or TABTK 
 0310  E8 0000 E                	CALL	CHRGTR 
 0313  E8 0432 R                	CALL	ADRGET		;[DX]=parameter (0..65535) 
 0316  58                       	POP	AX		;see if its SPC or TAB 
 0317  50                       	PUSH	AX 
 0318  0B D2                    	OR	DX,DX 
 031A  7F 05                    	JG	TBNONG		;branch if greater than 0 
 031C  BA 0000                  	MOV	DX,0		;map negative parms to 0 
 031F  EB 05                    	JMP	SHORT SPCNDC 
 0321  3C 00 E                  TBNONG:	CMP	AL,LOW OFFSET SPCTK	;if space leave alone 
 0323  74 01                    	JZ	SPCNDC 
 0325  4A                       	DEC	DX		;offset TAB by 1 
 0326  53                       SPCNDC:	PUSH	BX		;save the text pointer 
 0327  8A DD                    	MOV	BL,CH		;[BL]=file width 
 0329  8A C5                    	MOV	AL,CH		;[AL]=file width 
 032B  FE C0                    	INC	AL		;test for width of 255 (no folding) 
 032D  74 07                    	JZ	LNOMOD		;if so, don't mod 
 032F  B7 00                    	MOV	BH,LOW 0	;MOD out by line length 
 0331  E8 0000 E                	CALL	IMOD		;[BX]=[DX] MOD filewidth 
 0334  87 D3                    	XCHG	DX,BX		;set [DL] = position to go to 
 0336  5B                       LNOMOD:	POP	BX		;get back the text pointer 
 0337  E8 0000 E                	CALL	SYNCHR 
 033A  29                       	DB	OFFSET ")" 
 033B  4B                       	DEC	BX 
 033C  58                       	POP	AX		;get back SPCTK or TABTK 
 033D  2C 00 E                  	SUB	AL,LOW OFFSET SPCTK	;was it SPCTK? 
 033F  53                       	PUSH	BX		;save the text pointer 
 0340  74 03                    	JZ	DOSIZT		;value in [AL] 
 0342  E8 0637 R                	CALL	PTRGPS		;[AL]=file position 
 0345  F6 D8                    DOSIZT:	NEG	AL		;print [E]-[A] spaces 
 0347  FE C8                    	DEC	AL 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-23
LPRINT, PRINT Statements                                    

 0349  02 C2                    	ADD	AL,DL 
 034B  72 0D                    	JB	ASPA2		;print if past current 
 034D  FE C0                    	INC	AL 
 034F  74 16                    	JZ	NOTABR		;do nothing if at current 
 0351  E8 0581 R                	CALL	CRDO		;go to a new line 
 0354  8A C2                    	MOV	AL,DL		;get the position to go to 
 0356  FE C8                    	DEC	AL 
 0358  78 0D                    	JS	NOTABR 
 035A  FE C0                    ASPA2:	INC	AL 
 035C  8A D0                    ASPAC:	MOV	DL,AL		;[B]=number of spaces to print 
 035E  B0 20                    	MOV	AL,LOW " "	;[A]=space 
 0360  E8 058E R                REPOUT:	CALL	OUTDO		;PRINT [AL] 
 0363  FE CA                    	DEC	DL		;decrement the count 
 0365  75 F9                    	JNZ	REPOUT 
 0367  5B                       NOTABR:	POP	BX		;pick up text pointer 
 0368  E8 0000 E                	CALL	CHRGTR		;and the next character 
 036B  E9 026D R                	JMP	PRINTC		;and since we just printed 
                                				;spaces, don't call crdo 
                                				;if it's the end of the line 
                                 
                                	SUBTTL EOF, LOC, LOF  Functions 
                                 
                                	PUBLIC	EOF,LOC,LOF 
                                	EXTRN	CONINT:NEAR 
                                 
                                ; EOF(n) Function - returns -1 if eof, else 0 
                                ; Entry - [FAC] = file number 
                                ; Exit  - [FAC] = -1 if EOF, else 0. 
                                ; 
 036E  E8 089B R                EOF:	CALL	FACFPT		;[SI] points to FDB for file [FAC] 
 0371  74 16                    	JZ	ERFNO4		;error if file not opened 
 0373  33 DB                    	XOR	BX,BX		;BX=0 (assume not at eof) 
 0375  F6 44 37 80              	TEST	BYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC 
 0379  75 16                    	JNZ	GFUNX		;if character backed up, no eof 
 037B  4B                       	DEC	BX		;[BX]=-1 (EOF true) 
 037C  80 7C 2F 00              	CMP	BYTE PTR F_ORCT[SI],LOW 0 
 0380  74 0F                    	JE	GFUNX		;branch if FDB EOF flag set 
 0382  B4 00                    	MOV	AH,LOW OFFSET G_EOF	;End of file function 
 0384  E8 06E7 R                	CALL	SIDSP 
 0387  EB 08                    	JMP	SHORT GFUNX	;return result in FAC 
                                 
 0389  E9 0000 E                ERFNO4:	JMP	DERFNO		;file not open error 
                                 
                                ; LOC(n) Function 
                                ; Entry - [FAC] = file number 
                                ; Exit  - [FAC] = current record number 
                                ; 
 038C  B4 02                    LOC:	MOV	AH,LOW OFFSET G_LOC	;LOC function 
 038E  E8 06C0 R                GENFUN:	CALL	FACDSP		;[BX]=EOF(file [FAC]) 
 0391  E9 0000 E                GFUNX:	JMP	MAKINT		;return result in FAC 
                                 
                                ; LOF(n) Function 
                                ; Entry - [FAC] = file number 
                                ; Exit  - [FAC] = length of file in bytes 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-24
EOF, LOC, LOF  Functions                                    

                                ; 
 0394  B4 04                    LOF:	MOV	AH,LOW OFFSET G_LOF	;LOF Function 
 0396  E9 06C0 R                	JMP	FACDSP		;[FAC]=LOF(file [FAC]) 
                                 
                                	SUBTTL GET/PUT - Random disk I/O Statements 
                                 
                                	PUBLIC	DPUTG 
                                 
                                ;Syntax - GET fn [,recnum]   (if no recnum next relative record assumed) 
                                ;         PUT fn [,recnum] 
                                ; Entry - [BX] = text pointer 
                                ;         [CX] = 0 for GET, 1 for PUT 
                                ; 
 0399                           DPUTG: 
 0399  51                       	PUSH	CX		;save GET/PUT Flag 
 039A  E8 03CA R                	CALL	POFNUM		;[AL]=file number 
 039D  E8 089E R                	CALL	FDBPTR		;[SI] points to File Data Block of file [AL] 
 03A0  74 63                    	JZ	ERFNO3		;branch if file not open 
 03A2  80 7C 06 04              	CMP	BYTE PTR F_MODE[SI],LOW OFFSET MD_RND 
 03A6  75 1F                    	JNE	ERBFM1		;Not random - bad file mode 
 03A8  56                       	PUSH	SI		;save FDB pointer 
 03A9  4B                       	DEC	BX 
 03AA  E8 0000 E                	CALL	CHRGTR		;reget next character 
 03AD  74 0E                    	JZ	RELRND		;branch if end-of-statement (relative record) 
 03AF  E8 0000 E                	CALL	SYNCHR 
 03B2  2C                       	DB	OFFSET 54O	;parse required comma 
 03B3  E8 0432 R                	CALL	ADRGET		;[DX]=record number (0..65535) 
 03B6  5E                       	POP	SI		;restore FDB pointer 
 03B7  58                       	POP	AX		;restore GET/PUT flag 
 03B8  05 0002                  	ADD	AX,2		;[AX]=2 for GET [DX], 3 for PUT [DX] 
 03BB  EB 02                    	JMP	SHORT RELRN1 
 03BD  5E                       RELRND:	POP	SI		;restore FDB pointer 
 03BE  58                       	POP	AX 
 03BF  53                       RELRN1:	PUSH	BX		;save text pointer 
                                				;[AL]=0,1,2,3 for GET PUT GETrel PUTrel 
 03C0  B4 0A                    	MOV	AH,LOW OFFSET G_RND	;select Random I/O function code 
 03C2  E8 06E7 R                	CALL	SIDSP		;dispatch to routine for FDB SI 
 03C5  5B                       	POP	BX		;restore text pointer 
 03C6  C3                       	RET 
                                 
 03C7  E9 0000 E                ERBFM1:	JMP	DERBFM 
                                 
                                	SUBTTL Misc. Parsing Routines 
                                 
                                ;POFNUM - Parse optional file number "[#]n" 
                                ; Entry - [BX] = text pointer 
                                ; Exit  - [BX] = updated text pointer, [AL]=file number 
                                ;         All other registers preserved 
                                ; 
 03CA  80 3F 23                 POFNUM:	CMP	BYTE PTR 0[BX],LOW "#"	;[AL]=current character 
 03CD  75 04                    	JNZ	GETNZB		;branch if optional # not included 
                                 
                                ;PRFNUM - Parse required file number "#n" 
                                ; Entry - [BX] = text pointer 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-25
Misc. Parsing Routines                                      

                                ; Exit  - [BX] = updated text pointer, [AL]=file number 
                                ;         All other registers preserved 
                                ; 
 03CF  E8 0000 E                PRFNUM:	CALL	SYNCHR 
 03D2  23                       	DB	OFFSET "#" 
                                 
                                ;GETNZB - Parse byte (1..255) expression, returning result in [AL] 
                                ; Entry - [BX] = text pointer 
                                ; Exit  - [BX] = updated text pointer, [AL]=byte parsed 
                                ;         All other registers preserved 
                                ; 
 03D3  52                       GETNZB:	PUSH	DX 
 03D4  51                       	PUSH	CX 
 03D5  E8 0000 E                	CALL	GETBYT		;[AL]=file number 
 03D8  0A C0                    	OR	AL,AL 
 03DA  74 03                    	JZ	ERBFN1		;bad file number if 0 
 03DC  59                       	POP	CX 
 03DD  5A                       	POP	DX 
 03DE  C3                       RET9:	RET 
                                 
 03DF  E9 0000 E                ERBFN1:	JMP	DERBFN		;bad file number 
                                 
                                	PUBLIC	FILINP,FILGET,GETPTR,FILSET,FILSCN 
 03E2  B1 01                    FILINP:	MOV	CL,LOW OFFSET MD_SQI	;MUST BE SEQUENTIAL INPUT 
 03E4  3C 23                    FILGET:	CMP	AL,LOW "#"	;NUMBER SIGN THERE? 
 03E6  75 F6                    	JNZ	RET9		;NO, NOT FILE INPUT 
 03E8  51                       	PUSH	CX		;SAVE EXPECTED MODE 
 03E9  E8 0408 R                	CALL	FILSCN		;READ AND GET POINTER 
 03EC  74 17                    	JZ	ERFNO3		;ERROR IF FILE NOT OPEN 
 03EE  5A                       	POP	DX		;[DL]=FILE MODE 
 03EF  3A C2                    	CMP	AL,DL		;IS IT RIGHT? 
 03F1  74 04                    	JZ	GDFILM		;GOOD FILE MODE 
 03F3  3C 04                    	CMP	AL,LOW OFFSET MD_RND	;ALLOW STUFF WITH RANDOM FILES 
 03F5  75 0B                    	JNZ	ERBFM3		;IF NOT, "BAD FILE MODE" 
 03F7                           GDFILM: 
 03F7  E8 0000 E                	CALL	SYNCHR 
 03FA  2C                       	DB	OFFSET 54O	;GO PAST THE COMMA 
 03FB  8B D1                    FILSET:	MOV	DX,CX		;SETUP PTRFIL 
 03FD  89 0E 0000 E             	MOV	WORD PTR PTRFIL,CX 
 0401  C3                       	RET 
                                 
 0402  E9 0000 E                ERBFM3:	JMP	DERBFM 
 0405  E9 0000 E                ERFNO3:	JMP	DERFNO 
                                 
                                 
                                ;FILSCN - parse file number 
                                ; Entry - [BX]=text pointer 
                                ; Exit  - [DL]=file number, [SI], [CX] point to file data block for file [DL] 
                                ;         [AL]=file mode, FLAGS.Z is set if file is not open. 
                                ;         note - if file is not open, no FDB exists 
                                ; 
 0408  E8 03CA R                FILSCN:	CALL	POFNUM		;[AL]=file number 
                                 
 040B  8A D0                    FILIDX:	MOV	DL,AL		;return file number in [DL] 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-26
Misc. Parsing Routines                                      

 040D  E8 089E R                FILID2:	CALL	FDBPTR		;SI points to FDB for file [AL] 
 0410  74 07                    	JZ	NTOPEN		;branch if file is not open 
 0412  8B CE                    	MOV	CX,SI		;CX  points to FDB 
 0414  8A 44 06                 	MOV	AL,BYTE PTR F_MODE[SI]	;[AL]=file mode 
 0417  0A C0                    	OR	AL,AL		;set non-zero (file is opened) 
 0419  C3                       NTOPEN:	RET 
                                 
                                ;GETPTR IS CALLED FROM VARPTR(#<EXPRESSION>) 
                                ; Entry - [AL]=file number 
                                ; Exit  - [DX] points to random file buffer, or sector buffer of file 
                                ; 
 041A  E8 089E R                GETPTR:	CALL	FDBPTR		;SI points to File Data Block 
 041D  74 E6                    	JZ	ERFNO3		;error if file not open 
 041F  BA 0006                  	MOV	DX,OFFSET F_MODE	;Return pointer to MODE 
 0422  03 D6                    	ADD	DX,SI		;Return result in [DX] 
 0424  C3                       	RET 
                                 
                                ;DIRDO is called to make sure direct statement is not found when loading file 
                                ; If device is keyboard, control transfers to GONE with AX used. 
                                ; 
                                	PUBLIC	DIRDO 
 0425  A1 0000 E                DIRDO:	MOV	AX,WORD PTR PTRFIL 
 0428  0B C0                    	OR	AX,AX 
 042A  75 03                    	JNZ	ERFDR		;if device not keyboard then 
                                				;   error(direct statement in file) 
                                EXTRN	GONE:NEAR 
 042C  E9 0000 E                	JMP	GONE		;else OK 
                                 
 042F  E9 0000 E                ERFDR:	JMP	DERFDR 
                                 
                                ;ADRGET - parse 16 bit expression 
                                ; Entry - [BX]=text pointer 
                                ; Exit  - [DX]=result (0..65535) 
                                ;         [BX]=updated text pointer 
                                ;         AX used, other registers preserved. 
                                ; 
                                	PUBLIC	ADRGET 
 0432  51                       ADRGET:	PUSH	CX 
                                EXTRN	FRMEVL:NEAR 
 0433  E8 0000 E                	CALL	FRMEVL 
 0436  53                       	PUSH	BX 
                                EXTRN	FRQINT:NEAR 
 0437  E8 0000 E                	CALL	FRQINT		;Make Unsigned 16 bits 
 043A  5A                       	POP	DX 
 043B  87 DA                    	XCHG	BX,DX		;Offset in [DX], text pointer in [BX] 
 043D  59                       	POP	CX 
 043E  C3                       	RET 
                                 
                                	SUBTTL Major I/O Routines 
                                 
                                ;PRGFIL is called to open file #0 (SAVE/LOAD/MERGE etc.) 
                                ; Entry - [BX]=text pointer, pointing at filename 
                                ;         [DH]=file mode 
                                ; Exit  - [PTRFIL] points to files FDB (directing all future I/O to file) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-27
Major I/O Routines                                          

                                ;         [BX]=[TEMP]=updated text pointer 
                                ;         SI may be destroyed. 
                                ; 
                                	PUBLIC	PRGFIL 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	TEMP:WORD 
 0000                           DSEG	ENDS 
 043F  88 36 0000 E             PRGFIL:	MOV	BYTE PTR FILMOD,DH	;save file mode (MD.SQI / MD.SQO) 
 0443  E8 0756 R                	CALL	NAMSCN		;scan filename 
 0446  89 1E 0000 E             	MOV	WORD PTR TEMP,BX	;PRGFIN restores text pointer when done 
 044A  72 03                    	JB	PRGFIX		;Exit - "." found in name 
 044C  E8 0451 R                	CALL	NAMBAS		;Add ".BAS" extension to disk file names 
 044F  EB 1C                    PRGFIX:	JMP	SHORT NULOPN	;open file #0 
                                 
                                ;NAMBAS is called to add the ".BAS" extension to disk file names 
                                ;Entry - FILDEV points to device id 
                                ;Exit  - SI destroyed 
                                ; 
 0451  BE 0000 E                NAMBAS:	MOV	SI,OFFSET FILDEV	;SI points to device id 
 0454  F6 04 FF                 	TEST	BYTE PTR 0[SI],LOW 377O 
 0457  78 10                    	JS	NAMBAX		;Exit if device is not DISK 
 0459  83 C6 09                 	ADD	SI,9D		;SI points to Extention 
 045C  80 3C 20                 	CMP	BYTE PTR 0[SI],LOW " "	;if blank extention, default to ".BAS" 
 045F  75 08                    	JNE	NAMBAX		;Exit if device is not DISK 
 0461  C7 04 4142               	MOV	WORD PTR 0[SI],OFFSET (400O*"A")+"B" 
 0465  C6 44 02 53              	MOV	BYTE PTR 2[SI],LOW "S" 
 0469  C3                       NAMBAX:	RET 
                                 
                                ;NULOPN opens File 0 with mode [AL]. 
                                ; Exit  - [PTRFIL] points to files FDB (directing all future I/O to file) 
                                ; 
                                	PUBLIC	NULOPM 
 046A  A2 0000 E                NULOPM:	MOV	BYTE PTR FILMOD,AL	;FILMOD=file mode 
 046D  32 C0                    NULOPN:	XOR	AL,AL		;[AL]=file number 
 046F  33 C9                    	XOR	CX,CX		;random record length = 0 
                                				;fall into OPNFIL 
                                 
                                ;OPNFIL - general file-open routine 
                                ; Entry - [AL]=file number (0..n) 
                                ;         [CX]=record length (0=default) 
                                ;         [FILMOD]=mode (MD.SQI / MD.SQO / MD.RND / MD.APP) 
                                ;         [FILDEV]=device id 
                                ;         [FILNM]=filename 
                                ;         [FILEXT]=1..3 byte filename extension 
                                ; Exit  - [PTRFIL] points to files FDB (directing all future I/O to file) 
                                ;         all registers preserved 
                                ; 
 0471  9C                       OPNFIL:	PUSHF 
 0472  50                       	PUSH	AX 
 0473  53                       	PUSH	BX 
 0474  51                       	PUSH	CX 
 0475  52                       	PUSH	DX 
 0476  56                       	PUSH	SI 
 0477  57                       	PUSH	DI 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-28
Major I/O Routines                                          

 0478  8A D8                    	MOV	BL,AL 
 047A  B7 00                    	MOV	BH,LOW 0	;[BX]=file number 
 047C  E8 089E R                	CALL	FDBPTR		;see if file is already open 
 047F  75 16                    	JNZ	ERFAO1		;error if already open 
 0481  A0 0000 E                	MOV	AL,BYTE PTR FILDEV	;[AL]=device id 
 0484  E8 073C R                	CALL	CDEVID		;[DI]=device dispatch table offset (AL) 
 0487  B4 0C                    	MOV	AH,LOW OFFSET G_OPN	;open function code (AL is still DEVICE ID) 
 0489  E8 0719 R                	CALL	TBLDSP		;call device-dependent open routine 
 048C  5F                       	POP	DI 
 048D  5E                       	POP	SI 
 048E  5A                       	POP	DX 
 048F  59                       	POP	CX 
 0490  5B                       	POP	BX 
 0491  58                       	POP	AX 
 0492  9D                       	POPF 
 0493  C3                       	RET 
                                 
 0494  E9 0000 E                FCERR3:	JMP	FCERR 
 0497  E9 0000 E                ERFAO1:	JMP	DERFAO		;file already opened error 
                                 
                                ;CLSALL - close all opened files 
                                ; Entry - none 
                                ; Exit  - All registers preserved 
                                ; 
                                	PUBLIC	CLSALL 
 049A  50                       CLSALL:	PUSH	AX 
 049B  56                       	PUSH	SI 
 049C  8B 36 0000 E             	MOV	SI,WORD PTR FILTAB	;Get address of next file block 
 04A0  3B 36 0000 E             CLSAL1:	CMP	SI,WORD PTR STKLOW 
 04A4  74 0C                    	JZ	CLSALX		;Branch if finished 
 04A6  FF 74 04                 	PUSH	WORD PTR F_NEXT[SI]	;save pointer to next entry in chain 
 04A9  8A 44 01                 	MOV	AL,BYTE PTR F_NUM[SI]	;[AL]=file number 
 04AC  E8 04B5 R                	CALL	CLSFIL		;Close file [AL] 
 04AF  5E                       	POP	SI		;SI points to next FDB in chain 
 04B0  EB EE                    	JMP	SHORT CLSAL1	;Keep looping till all files closed 
 04B2  5E                       CLSALX:	POP	SI 
 04B3  58                       	POP	AX 
 04B4  C3                       	RET 
                                 
                                ;CLSFIL - close file [AL] 
                                ; Exit  - Flags, AX, SI used, all other registers are preserved 
                                ; 
                                	PUBLIC	CLSFIL 
 04B5  8A 26 0000 E             CLSFIL:	MOV	AH,BYTE PTR NLONLY 
 04B9  F6 C4 80                 	TEST	AH,LOW 200O	;see if Chain All / Load, R in progress 
 04BC  75 26                    	JNZ	RET22		;branch if Dont-Close-Any-Files flag set 
 04BE  F6 C4 01                 	TEST	AH,LOW 1	;see if Load/Merge/Chain is in progress 
 04C1  74 04                    	JZ	CLSFL1		;branch if Dont-Close-File-0 flag not set 
 04C3  0A C0                    	OR	AL,AL 
 04C5  74 1D                    	JZ	RET22		;branch if trying to close file 0 
 04C7  E8 089E R                CLSFL1:	CALL	FDBPTR		;[SI] points to FDB [AL] 
 04CA  74 18                    	JZ	RET22		;branch if file already closed 
 04CC  53                       	PUSH	BX 
 04CD  51                       	PUSH	CX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-29
Major I/O Routines                                          

 04CE  52                       	PUSH	DX 
 04CF  89 36 0000 E             	MOV	WORD PTR FREFDB,SI	;So FINPRT will force close file if low-level 
                                				;close routine gets I/O error 
 04D3  B4 06                    	MOV	AH,LOW OFFSET G_CLS 
 04D5  E8 06E7 R                	CALL	SIDSP		;close FDB pointed to by [SI] 
 04D8  C7 06 0000 E 0000        	MOV	WORD PTR FREFDB,0 
 04DE  E8 08F4 R                	CALL	FFREE		;Deallocate FDB and remove from FDB Chain 
 04E1  5A                       	POP	DX 
 04E2  59                       	POP	CX 
 04E3  5B                       	POP	BX 
 04E4  C3                       RET22:	RET 
                                 
                                ;INCHR - get next byte from file PTRFIL 
                                ; Exit  - [AL]=byte, [FLAGS], [AH] destroyed. 
                                ;         All other regs preserved 
                                ;         if END-OF-FILE then 
                                ;            if program load was in progress, file 0 closed etc. 
                                ;            else Read-Past-End error is generated 
                                ; 
                                	PUBLIC	INCHR 
                                	EXTRN	PRGFIN:NEAR,KYBSIN:NEAR 
 04E5                           INCHR: 
 04E5  56                       	PUSH	SI 
 04E6  E8 0534 R                	CALL	INCHRE		;[AL]=next byte from PTRFIL, carry if EOF 
 04E9  73 47                    	JAE	INCHRX		;branch if not EOF 
 04EB  80 7C 01 00              	CMP	BYTE PTR F_NUM[SI],LOW 0	;EOF on ASCII file #0 = end of Load/Chain/Merge 
 04EF  74 03                    	JE	FL0EOF		;branch if EOF reached for file #0 
                                EXTRN	DERRPE:NEAR 
 04F1  E9 0000 E                	JMP	DERRPE		;Input past end error 
 04F4  80 7C 31 01              FL0EOF:	CMP	BYTE PTR F_CODE[SI],LOW OFFSET FC_BIN 
 04F8  75 02                    	JNE	LDREOF		;branch if not binary file (must be ascii LOAD) 
 04FA  F9                       	STC			;else must be BLOAD/binary LOAD 
 04FB  C3                       	RET			;return EOF indication to caller 
 04FC                           LDREOF: 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	CHNFLG:WORD 
 0000                           DSEG	ENDS 
                                	EXTRN	CHNRET:NEAR 
 04FC  80 3E 0000 E 00          	CMP	BYTE PTR CHNFLG,LOW 0	;chain in progress? 
 0501  74 03                    	JE	NOTCHN		;branch if not chaining 
 0503  E9 0000 E                	JMP	CHNRET		;perform variable block transfer, etc. 
                                				; close all files 
 0506                           NOTCHN: 
 0506  53                       	PUSH	BX		;save all registers 
 0507  51                       	PUSH	CX 
 0508  52                       	PUSH	DX 
 0509  A0 0000 E                	MOV	AL,BYTE PTR NLONLY	;get load flags 
 050C  24 80                    	AND	AL,LOW 200O	;leave others open, null gets closed 
 050E  A2 0000 E                	MOV	BYTE PTR NLONLY,AL	;allow other files to be closed 
 0511  E8 0000 E                	CALL	PRGFIN		;close the file 
 0514  5A                       	POP	DX 
 0515  59                       	POP	CX 
 0516  5B                       	POP	BX 
 0517  A0 0000 E                	MOV	AL,BYTE PTR RUNFLG	;run it or not? 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-30
Major I/O Routines                                          

 051A  0A C0                    	OR	AL,AL 
 051C  74 06                    	JZ	NORUNC		;dont run program 
                                	EXTRN	RUNC:NEAR 
 051E  E8 0000 E                	CALL	RUNC		;run it 
                                	EXTRN	NEWSTT:NEAR 
 0521  E9 0000 E                	JMP	NEWSTT 
 0524  53                       NORUNC:	PUSH	BX 
 0525  51                       	PUSH	CX 
 0526  52                       	PUSH	DX 
                                	EXTRN	REDDY:NEAR,STROUT:NEAR 
 0527  BB 0000 E                	MOV	BX,OFFSET REDDY	;print prompt "ok" 
 052A  E8 0000 E                	CALL	STROUT 
 052D  5A                       	POP	DX 
 052E  59                       	POP	CX 
 052F  5B                       	POP	BX 
 0530  B0 0D                    	MOV	AL,LOW 13D 
 0532  5E                       INCHRX:	POP	SI 
 0533  C3                       	RET 
                                 
                                ;INCHRE - get next byte from file PTRFIL. 
                                ; Exit  - Carry set if EOF, else [AL]=byte. 
                                ;         SI points to FDB 
                                ;         All other regs preserved 
                                ; 
                                	PUBLIC	INDSKC		;Referenced by DSKCOM 
 0534                           INDSKC: 
 0534  8B 36 0000 E             INCHRE:	MOV	SI,WORD PTR PTRFIL	;SI points to current FDB 
                                				;fall into INCHSI 
                                 
                                ;INCHSI - get next byte from file SI (CTL Z = end-of-file) 
                                ; Exit  - Carry set if EOF, else [AL]=byte. 
                                ;         All other regs preserved 
                                ; 
                                	PUBLIC	INCHSI 
 0538  46                       INCHSI:	INC	SI 
 0539  74 32                    	JZ	ERBFM6		;branch if Line Printer (can't input) 
 053B  4E                       	DEC	SI 
 053C  75 03                    	JNZ	INGFDB		;branch if not Keyboard (got FDB) 
                                	EXTRN	INCHRI:NEAR 
 053E  E9 0000 E                	JMP	INCHRI 
 0541  80 7C 06 02              INGFDB:	CMP	BYTE PTR F_MODE[SI],LOW OFFSET MD_SQO 
 0545  74 26                    	JZ	ERBFM6 
 0547  80 7C 2F 00              	CMP	BYTE PTR F_ORCT[SI],LOW 0 
 054B  74 0E                    	JZ	INCEOF		;branch if EOF already reached 
 054D  F6 44 37 80              	TEST	BYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC 
 0551  75 12                    	JNZ	GETBKC		;branch if char backed up 
 0553  B4 0E                    	MOV	AH,LOW OFFSET G_SIN 
 0555  E8 06E7 R                	CALL	SIDSP		;[AL]=next input from file 
 0558  72 01                    	JB	INCEOF		;branch if device detected EOF 
 055A  C3                       	RET 
                                 
 055B  C6 44 2F 00              INCEOF:	MOV	BYTE PTR F_ORCT[SI],LOW 0	;indicates EOF on future calls 
 055F  C6 44 30 00              	MOV	BYTE PTR F_BREM[SI],LOW 0 
 0563  F9                       	STC			;tells caller EOF reached 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-31
Major I/O Routines                                          

 0564  C3                       	RET 
                                 
 0565  80 64 37 7F              GETBKC:	AND	BYTE PTR F_FLGS[SI],LOW OFFSET 255D-FL_BKC	;clear Backup Present flag 
 0569  8A 44 32                 	MOV	AL,BYTE PTR F_BAKC[SI]	;return Backed-up character 
 056C  C3                       	RET			;with no carry (no-eof) 
                                 
 056D  E9 0000 E                ERBFM6:	JMP	DERBFM		;bad file mode error 
                                 
                                	PUBLIC	CRFIN,CRDONZ,FININL,CRDO 
 0570  32 C0                    CRFIN:	XOR	AL,AL		;all references should be eliminated 
 0572  C3                       	RET 
                                 
                                ;CRDONZ - output carriage return if file PTRFIL is not at left margin 
                                ; 
 0573  E8 0637 R                CRDONZ:	CALL	PTRGPS		;[AH]=0-relative column for PTRFIL 
 0576  0A E4                    	OR	AH,AH 
 0578  75 07                    	JNZ	CRDO		;if not at column 0, output CRLF 
 057A  C3                       	RET 
                                 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	BUFMIN:WORD 
 0000                           DSEG	ENDS 
 057B  C6 07 00                 FININL:	MOV	BYTE PTR 0[BX],LOW 0 
 057E  BB 0000 E                	MOV	BX,OFFSET BUFMIN 
                                 
                                ;CRDO - output ascii carriage return to current file 
                                ; 
 0581  B0 0D                    CRDO:	MOV	AL,LOW OFFSET ASCCR 
 0583  E8 058E R                	CALL	OUTDO		;output Carriage Return 
 0586  B0 0A                    	MOV	AL,LOW OFFSET ASCLF	;output Line Feed 
 0588  E8 058E R                	CALL	OUTDO 
 058B  32 C0                    	XOR	AL,AL		;must return with [AL]=0 and FLAGS.Z true 
 058D  C3                       	RET 
                                 
                                ;OUTDO - output [AL] to current file (force CR if end-of-line) 
                                ; Exit - All registers preserved (including FLAGS) 
                                ; 
                                	PUBLIC	OUTDO,FILOU3 
 058E                           FILOU3: 
 058E                           OUTDO: 
 058E  9C                       	PUSHF 
 058F  50                       	PUSH	AX 
 0590  B4 10                    	MOV	AH,LOW OFFSET G_SOT 
 0592  E8 06DD R                	CALL	PTRDSP		;dispatch to function [DL] for PTRFIL 
 0595  58                       	POP	AX 
 0596  9D                       	POPF 
 0597  C3                       	RET 
                                 
                                ;OUT16 - output data [AX] to current file 
                                ; 
 0598  50                       OUT16:	PUSH	AX 
 0599  E8 058E R                	CALL	OUTDO		;output low-byte first 
 059C  86 E0                    	XCHG	AH,AL 
 059E  E8 058E R                	CALL	OUTDO		;then output high-byte 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-32
Major I/O Routines                                          

 05A1  58                       	POP	AX 
 05A2  C3                       	RET 
                                 
                                ;INP16 reads the next 16 bits from file PTRFIL 
                                ; Exit  - [AX]=result. Carry set if EOF. 
                                ;         All other registers are preserved. 
                                ; 
 05A3  53                       INP16:	PUSH	BX 
 05A4  E8 04E5 R                	CALL	INCHR		;get low-byte first 
 05A7  8A D8                    	MOV	BL,AL 
 05A9  E8 04E5 R                	CALL	INCHR		;then get high-byte 
 05AC  8A F8                    	MOV	BH,AL 
 05AE  8B C3                    	MOV	AX,BX 
 05B0  5B                       INP16X:	POP	BX 
 05B1  C3                       	RET 
                                 
                                ;BAKCHR - backup sequential input file 
                                ; Entry - [AL] = char to be backed up 
                                ;         [PTRFIL] points to FDB of file to be backed up 
                                ; 
                                	PUBLIC	BAKCHR,BCHRSI 
 05B2  56                       BAKCHR:	PUSH	SI 
 05B3  8B 36 0000 E             	MOV	SI,WORD PTR PTRFIL 
 05B7  E8 05BC R                	CALL	BCHRSI 
 05BA  5E                       	POP	SI 
 05BB  C3                       	RET 
                                 
                                ;BCHRSI - backup sequential input file 
                                ; Entry - [AL] = char to be backed up 
                                ;         [SI] points to FDB of file to be backed up 
                                ; 
 05BC  88 44 32                 BCHRSI:	MOV	BYTE PTR F_BAKC[SI],AL 
 05BF  80 4C 37 80              	OR	BYTE PTR F_FLGS[SI],LOW OFFSET FL_BKC	;set flag indicating char backed up 
 05C3  C3                       	RET 
                                 
                                ;BINSAV - Binary SAVE support. 
                                ; 
                                	PUBLIC	BINSAV,BINPSV 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	TXTTAB:WORD 
 0000                           DSEG	ENDS 
                                	EXTRN	PROCHK:NEAR,SCCPTR:NEAR 
 05C4  E8 0000 E                BINSAV:	CALL	SCCPTR		;GET RID OF POINTERS BEFORE SAVING 
 05C7  E8 0000 E                	CALL	PROCHK		;DONT ALLOW BINARY SAVES OF PROTECTED PROGRAMS 
 05CA  E8 0890 R                	CALL	SCDBIN		;Set attribute CODE to BINARY (not ASCII) 
 05CD  B0 FF                    	MOV	AL,LOW 255D	;ALWAYS START WITH 255 
 05CF  E8 058E R                BINPSV:	CALL	FILOU3		;SEND TO FILE 
 05D2  8B 0E 0000 E             	MOV	CX,WORD PTR VARTAB	;GET STOP POINT 
 05D6  8B 1E 0000 E             	MOV	BX,WORD PTR TXTTAB	;GET START POINT 
 05DA  2B CB                    	SUB	CX,BX		;Calculate bytes to SAVE 
 05DC  76 05                    	JBE	BINSVX		;Nothing to SAVE 
 05DE  8C DA                    	MOV	DX,DS		;Get Segment for SAVE 
 05E0  E8 060D R                	CALL	OUTBLK		;Write the block 
 05E3  E9 0000 E                BINSVX:	JMP	PRGFIN		;REGET TEXT POINTER AND CLOSE FILE 0 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-33
Major I/O Routines                                          

                                 
                                ;DEVBIN - General device block input routine.  This routine is called by 
                                ;         device code for devices which have no block I/O capability. 
                                ; Entry - [BX] = Start adr 
                                ;         [CX] = number of bytes to read 
                                ;         [DX] = Segment adr 
                                ;         [SI] = address of FDB 
                                ;         [DI] = device offset (2=COMD, 4=SCRN, etc.) 
                                ; Exit  - [BX] = End+1 
                                ;         Carry set if reached end of data before CX bytes read 
                                ;         SI, CX, AX used. 
                                ; 
                                	PUBLIC	DEVBIN 
 05E6  0B C9                    DEVBIN:	OR	CX,CX 
 05E8  74 22                    	JZ	RET27		;Until end. 
 05EA  B4 0E                    	MOV	AH,LOW OFFSET G_SIN	;sequential input function 
 05EC  E8 06DD R                	CALL	PTRDSP		;[AL]=next byte from file PTRFIL 
 05EF  72 1B                    	JB	RET27		;branch if tried to read past end-of-file 
 05F1  1E                       	PUSH	DS 
 05F2  52                       	PUSH	DX 
 05F3  1F                       	POP	DS		;[DS]=[DX] 
 05F4  88 07                    	MOV	BYTE PTR 0[BX],AL	;Store Byte 
 05F6  1F                       	POP	DS 
 05F7  43                       	INC	BX		;bump destination pointer 
 05F8  49                       	DEC	CX		;decrement byte count 
 05F9  EB EB                    	JMP	SHORT DEVBIN 
                                 
                                ;DEVBOT - General device block output routine.  This routine is called by 
                                ;         device code for devices which have no block I/O capability. 
                                ; Entry - [BX] = Start adr 
                                ;         [CX] = number of bytes to write 
                                ;         [DX] = segment adr 
                                ;         [SI] = address of FDB 
                                ;         [DI] = device offset (2=COMD, 4=SCRN, etc.) 
                                ; Exit  - [BX] = End + 1 
                                ; 
                                	PUBLIC	DEVBOT 
 05FB  0B C9                    DEVBOT:	OR	CX,CX 
 05FD  74 0D                    	JZ	RET27		;Until Len=0. 
 05FF  1E                       	PUSH	DS		;save BASIC's Data Segment 
 0600  52                       	PUSH	DX 
 0601  1F                       	POP	DS		;DS=DX 
 0602  8A 07                    	MOV	AL,BYTE PTR 0[BX] 
 0604  1F                       	POP	DS		;restore BASIC's Data Segment 
 0605  E8 058E R                	CALL	OUTDO		;Write Byte from Memory. 
 0608  43                       	INC	BX 
 0609  49                       	DEC	CX 
 060A  EB EF                    	JMP	SHORT DEVBOT 
 060C  C3                       RET27:	RET 
                                 
                                ;OUTBLK - Write Block of memory to current file 
                                ; Entry - [BX] = Start adr 
                                ;         [CX] = number of bytes to write 
                                ;         [DX] = segment adr 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-34
Major I/O Routines                                          

                                ; Exit  - [BX] = End + 1 
                                ; 
 060D  8B 36 0000 E             OUTBLK:	MOV	SI,WORD PTR PTRFIL 
 0611  B4 1C                    	MOV	AH,LOW OFFSET G_BOT	;Block output function 
 0613  E8 06DD R                	CALL	PTRDSP 
 0616  C3                       	RET 
                                 
                                ; INPBLK - Read block of memory from current file 
                                ; Entry - [BX] = Start adr 
                                ;         [CX] = number of bytes to read 
                                ;         [DX] = Segment adr 
                                ; Exit  - [BX] = End+1 
                                ;         Carry set if reached end of data before CX bytes read 
                                ;         SI, CX, AX used. 
                                ; 
                                	EXTRN	DFSTLD:NEAR 
 0617  8B 36 0000 E             INPBLK:	MOV	SI,WORD PTR PTRFIL 
 061B  B4 1A                    	MOV	AH,LOW OFFSET G_BIN	;block input function 
 061D  E8 06DD R                	CALL	PTRDSP		;[AL]=next byte from file PTRFIL 
 0620  C3                       	RET 
                                 
                                ;FSTLOD - load Binary BASIC program (Called from DSKCOM after LOAD statement) 
                                ; Entry - BX points to destination of program 
                                ;         [FRETOP] - [BX] - ^D86 = maximum legal size of program 
                                ;         [PTRFIL] points to FDB of file to be loaded 
                                ;         (note: 1st byte of file has already been read and was ^D254) 
                                ; 
                                	PUBLIC	FSTLOD 
                                	EXTRN	OUTLOD:NEAR 
 0621                           FSTLOD: 
 0621  8B 0E 0000 E             	MOV	CX,WORD PTR FRETOP	;Bottom of string space 
 0625  83 E9 56                 	SUB	CX,86D		;leave a little breathing room 
 0628  2B CB                    	SUB	CX,BX		;[CX]=maximum legal size of program 
 062A  E8 0890 R                	CALL	SCDBIN		;set CODE attribute to Binary 
 062D  1E                       	PUSH	DS 
 062E  5A                       	POP	DX		;[DX]=segment to be used 
 062F  E8 0617 R                	CALL	INPBLK		;read block from device to disk 
 0632  72 D8                    	JB	RET27		;branch if file fits in memory 
 0634  E9 0000 E                	JMP	OUTLOD		;ERROR AND WIPE OUT PARTIAL GARBAGE 
                                 
                                ;PTRGPS - get column position for file PTRFIL 
                                ; 
                                ; Exit  - [AH] = [AL] = column position 
                                ;         FLAGS.Z is true if at column 0 
                                ;         All other registers are preserved 
                                ; 
                                	PUBLIC	PTRGPS 
 0637  B4 12                    PTRGPS:	MOV	AH,LOW OFFSET G_GPS	;Get column position request-code 
 0639  E8 06DD R                	CALL	PTRDSP		;[AH]=position 
 063C  8A C4                    	MOV	AL,AH		;[AL]=position 
 063E  0A C0                    	OR	AL,AL 
 0640  C3                       	RET 
                                 
                                ;PTRWDC - get line width and last comma column for file PTRFIL 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-35
Major I/O Routines                                          

                                ; Exit  - [CH] = line width 
                                ;         [AH] = [CL] = last comma column 
                                ;         All other registers are preserved 
                                ; 
 0641  E8 0655 R                PTRWDC:	CALL	PTRWID		;[AH]=file PTRFIL's line width 
 0644  8A EC                    	MOV	CH,AH		;[CH]=file width 
 0646  80 EC 0E                 PTRWDL:	SUB	AH,LOW 14D	;T.B.S. eventually, use G.GCW 
 0649  73 FB                    	JAE	PTRWDL 
 064B  80 C4 1C                 	ADD	AH,LOW 28D 
 064E  F6 DC                    	NEG	AH 
 0650  02 E5                    	ADD	AH,CH 
 0652  8A CC                    	MOV	CL,AH		;[CL]=last comma column 
 0654  C3                       	RET 
                                 
                                ;PTRWID - get line width for file PTRFIL 
                                ; Exit  - [AH] = line width 
                                ;         All other registers are preserved 
                                ; 
                                	PUBLIC	PTRWID 
 0655  56                       PTRWID:	PUSH	SI		;save caller's SI 
 0656  8B 36 0000 E             	MOV	SI,WORD PTR PTRFIL 
 065A  46                       	INC	SI 
 065B  74 08                    	JZ	PTRWD1		;if LPT Pseudo FDB, use Device width 
 065D  4E                       	DEC	SI 
 065E  74 05                    	JZ	PTRWD1		;if KYBD Pseudo FDB, use Device width 
 0660  8A 64 35                 	MOV	AH,BYTE PTR F_WID[SI]	;else use FDB width 
 0663  5E                       	POP	SI		;restore caller's SI 
 0664  C3                       	RET 
 0665  5E                       PTRWD1:	POP	SI		;restore caller's SI 
 0666  B4 14                    	MOV	AH,LOW OFFSET G_GWD	;Get file width function code 
 0668  EB 73 90                 	JMP	PTRDSP		;return with [AH]=device width 
                                 
                                 
                                	SUBTTL General routines useful to low-level device drivers 
                                 
                                	PUBLIC	XTABCR,EXPTAB,CRIFEL,UPDPOS 
                                ;XTABCR is called by Device Driver Output routines to Expand Tabs to Spaces 
                                ;         and Force a carriage return if end-of-line. 
                                ; Entry - [AL]=char to be output 
                                ;         [DH]=current column position 
                                ;         [DL]=line width 
                                ;         BX points to raw-output routine 
                                ; Exit  - [DH] is new column position 
                                ;         FLAGS are used, All other registers are preserved. 
                                ; 
 066B  51                       XTABCR:	PUSH	CX 
 066C  B9 068B R                	MOV	CX,OFFSET CRIFEL	;EXPTAB will call CRIFEL which will 
 066F  E8 0674 R                	CALL	EXPTAB		;call raw-output routine [BX] 
 0672  59                       	POP	CX 
 0673  C3                       	RET 
                                 
                                ;EXPTAB is called by Device Driver Output routines to Expand Tabs to Spaces 
                                ; Entry - [AL]=char to be output 
                                ;         [DH]=current column position 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-36
General routines useful to low-level device drivers         

                                ;         CX points to raw-output routine 
                                ; Exit  - [DH] is new column position 
                                ;         FLAGS are used, All other registers are preserved. 
                                ; 
 0674                           EXPTAB: 
 0674  3C 09                    	CMP	AL,LOW OFFSET ASCTAB 
 0676  75 11                    	JNE	NOTTAB		;branch if not tab 
 0678  80 FA 09                 	CMP	DL,LOW 9D 
 067B  72 0B                    	JB	EXTABX		;branch if width is less than 9 
 067D  B0 20                    	MOV	AL,LOW OFFSET ASCSPC	;output spaces till next tab stop 
 067F  FF D1                    EXTABL:	CALL	CX		;output space (update position) 
 0681  F6 C6 07                 	TEST	DH,LOW 7 
 0684  75 F9                    	JNZ	EXTABL		;branch if not at MOD 8 column position 
 0686  B0 09                    	MOV	AL,LOW OFFSET ASCTAB	;restore AL 
 0688  C3                       EXTABX:	RET 
                                 
 0689  FF E1                    NOTTAB:	JMP	CX		;output char and update position 
                                 
                                ;CRIFEL - Force a carriage return if end-of-line (Called by device out routines) 
                                ; Entry - [AL]=char to be output 
                                ;         [DH]=current column position 
                                ;         [DL]=line width 
                                ;         BX points to raw-output routine 
                                ; Exit  - [DH] is new column position 
                                ;         FLAGS are used, All other registers are preserved. 
                                ; 
 068B  3C 20                    CRIFEL:	CMP	AL,LOW 32D 
 068D  72 13                    	JB	NOCR		;branch if non-printable 
 068F  80 FA FF                 	CMP	DL,LOW 255D 
 0692  74 0E                    	JZ	NOCR		;branch if infinite width (255) 
 0694  3A F2                    	CMP	DH,DL		;compare Column with Width 
 0696  72 0A                    	JB	NOCR		;branch if still room on current line 
 0698  50                       	PUSH	AX 
 0699  B0 0D                    	MOV	AL,LOW OFFSET ASCCR 
 069B  FF D3                    	CALL	BX		;output Carriage Return 
 069D  B0 0A                    	MOV	AL,LOW OFFSET ASCLF	;output Line Feed 
 069F  FF D3                    	CALL	BX 
 06A1  58                       	POP	AX		;restore char to be output 
 06A2  FF E3                    NOCR:	JMP	BX		;output char, update position 
                                 
                                ;UPDPOS - update column position (called by device out routines) 
                                ; Entry - [DH] = current 0-relative column position 
                                ;         [AL] = byte to be output 
                                ; Exit  - [DH] = new column position.  All other registers preserved 
                                ; 
 06A4  3C 20                    UPDPOS:	CMP	AL,LOW 32D 
 06A6  72 03                    	JB	NPRINT		;branch if not printable (CTL CHR) 
 06A8  FE C6                    	INC	DH		;bump column position 
 06AA  C3                       	RET 
 06AB  3C 0D                    NPRINT:	CMP	AL,LOW OFFSET ASCCR 
 06AD  75 03                    	JNE	NOTCR		;branch if not carriage return 
 06AF  B6 00                    ZERPOS:	MOV	DH,LOW 0	;reset to left margin 
 06B1  C3                       	RET 
 06B2  3C 08                    NOTCR:	CMP	AL,LOW OFFSET ASCBS 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-37
General routines useful to low-level device drivers         

 06B4  75 06                    	JNE	UPPOSX		;branch if not backspace 
 06B6  0A F6                    	OR	DH,DH 
 06B8  74 02                    	JE	UPPOSX		;don't decrement below 0 
 06BA  FE CE                    	DEC	DH		;decrement position 
 06BC  C3                       UPPOSX:	RET 
                                 
                                	SUBTTL File Dispatch Routines 
                                 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	IOJUMP:WORD 
 0000                           DSEG	ENDS 
                                 
 06BD  E9 0000 E                ERBFN2:	JMP	DERBFN		;bad file number error 
                                 
                                ;FACDSP - Dispatch to I/O routine for file number [FAC] 
                                ; Entry - [AH]=function code (G.OPN, G.CLS, etc.) 
                                ;         [FAC]=file number (note: file must be opened) (0 is illegal) 
                                ; Exit  - DX, AL are used. 
                                ;         All other registers preserved except those changed by device driver 
                                ; 
 06C0  E8 0000 E                FACDSP:	CALL	CONINT		;[DX]=integer equivalent of FAC (file#) 
 06C3  0B D2                    	OR	DX,DX 
 06C5  74 F6                    	JZ	ERBFN2		;file #0 is unavailable to user (bad file num.) 
                                 
                                ;FILDSP - Dispatch to I/O routine for file number [DH] 
                                ; Entry - [AH]=function code (G.OPN, G.CLS, etc.) 
                                ;         [DX]=file number (note: file must be opened) 
                                ; Exit  - All registers preserved except those changed by device driver 
                                ; 
 06C7  56                       FILDSP:	PUSH	SI 
 06C8  50                       	PUSH	AX 
 06C9  0A F6                    	OR	DH,DH 
 06CB  75 0D                    	JNZ	FCERR9		;error if file# greater than 255 
 06CD  8A C2                    	MOV	AL,DL		;[AL]=file number 
 06CF  E8 089E R                	CALL	FDBPTR		;(SI) = file data block pointer 
 06D2  74 7C                    	JZ	ERFNO2		;Error - bad file number 
 06D4  58                       	POP	AX		;restore caller's [AX] 
 06D5  E8 06E7 R                	CALL	SIDSP 
 06D8  5E                       	POP	SI 
 06D9  C3                       	RET 
                                 
 06DA  E9 0000 E                FCERR9:	JMP	FCERR		;Function Call Error 
                                 
                                ;PTRDSP - Dispatch to I/O routine for file with FDB=[PTRFIL] 
                                ; Entry - [AH]=function code (G.OPN, G.CLS, etc.) 
                                ;         [PTRFIL]=points to file's FDB 
                                ; Exit  - All registers preserved except those changed by device driver 
                                ; 
                                	PUBLIC	PTRDSP 
 06DD  56                       PTRDSP:	PUSH	SI 
 06DE  8B 36 0000 E             	MOV	SI,WORD PTR PTRFIL 
 06E2  E8 06E7 R                	CALL	SIDSP 
 06E5  5E                       	POP	SI 
 06E6  C3                       	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-38
File Dispatch Routines                                      

                                 
                                ;SIDSP - Dispatch to I/O routine for file with FDB=[SI] 
                                ; Entry - [AH]=function code (G.OPN, G.CLS, etc.) 
                                ;         [SI]=points to file's FDB 
                                ; Exit  - All registers preserved except those changed by device driver 
                                ; 
 06E7  57                       SIDSP:	PUSH	DI 
 06E8  56                       	PUSH	SI 
 06E9  50                       	PUSH	AX 
 06EA  9C                       	PUSHF 
 06EB  46                       	INC	SI 
 06EC  74 10                    	JZ	LPDSP		;branch if Line Printer Pseudo FDB 
 06EE  4E                       	DEC	SI 
 06EF  75 1A                    	JNZ	SIDSP1		;branch if not Keyboard/CRT Pseudo FDB 
                                ;        MOVI    DI,$CODE+2*<^O400-$.KYBD> 
 06F1  BF 0000 E                	MOV	DI,OFFSET $_KYBD 
 06F4  F7 DF                    	NEG	DI		; Change neg. dev. # to 0 based offset 
 06F6  81 E7 00FF               	AND	DI,377O 
 06FA  D1 E7                    	SHL	DI,1		; ASM86 cann't multiply externals by 2 
 06FC  EB 13                    	JMP	SHORT SIDSP2 
 06FE                           LPDSP: 
                                ;        MOVI    DI,$CODE+2*<^O400-$.LPT1>   ;SI=0 
 06FE  BF 0000 E                	MOV	DI,OFFSET $_LPT1 
 0701  F7 DF                    	NEG	DI		; Change neg. dev. # to 0 based offset 
 0703  81 E7 00FF               	AND	DI,377O 
 0707  D1 E7                    	SHL	DI,1		; ASM86 cann't multiply externals by 2 
 0709  EB 06                    	JMP	SHORT SIDSP2 
 070B  8A 44 34                 SIDSP1:	MOV	AL,BYTE PTR F_DEV[SI]	;(AL) = device number 
 070E  E8 073C R                	CALL	CDEVID		;[DI]=device dispatch table offset 
 0711  9D                       SIDSP2:	POPF 
 0712  58                       	POP	AX		;restore caller's [AX] 
 0713  E8 0719 R                	CALL	TBLDSP		;function [AH] on device [DI] 
 0716  5E                       	POP	SI 
 0717  5F                       	POP	DI 
 0718  C3                       	RET 
                                 
                                ;TBLDSP - Dispatch to I/O routine for device-table [DI] 
                                ; Entry - [AH]=function code (G.OPN, G.CLS, etc.) 
                                ;         DI = -2 * device id (0=disk, 2=keyboard etc.) 
                                ; Exit  - All registers preserved except those changed by device driver 
                                ; 
 0719  57                       TBLDSP:	PUSH	DI 
 071A  9C                       	PUSHF 
 071B  50                       	PUSH	AX 
 071C  A1 0000 E                	MOV	AX,WORD PTR DEVPTR	;AX points to 1st entry in dispatch table 
 071F  03 F8                    	ADD	DI,AX		;DI points to dispatch table pointer for device 
 0721  2E: 8B 3D                	MOV	DI,WORD PTR CS:0[DI]	;DI points to dispatch table for device 
 0724  0B FF                    	OR	DI,DI		;If entry is 0, then 
 0726  74 2B                    	JZ	ERDNA2		;  Error - device not available 
 0728  58                       	POP	AX		;restore function code 
 0729  50                       	PUSH	AX 
 072A  86 E0                    	XCHG	AH,AL 
 072C  98                       	CBW			;[AX]=function code 
 072D  03 F8                    	ADD	DI,AX		;Add function code offset to dispatch 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-39
File Dispatch Routines                                      

 072F  2E: 8B 05                	MOV	AX,WORD PTR CS:0[DI]	;Get address of routine 
 0732  A3 0000 E                	MOV	WORD PTR IOJUMP,AX 
 0735  58                       	POP	AX 
 0736  9D                       	POPF 
 0737  5F                       	POP	DI 
 0738  FF 26 0000 E             	JMP	 WORD PTR IOJUMP	;jump to routine at address [IOJUMP] 
                                 
                                ;CDEVID - convert device id to dispatch table address 
                                ; Entry - [AL]=device id (0..n for disk, -1..-n for non-disk devices) 
                                ; Exit  - [DI]=DEVPTR offset for device (0 for disk, 2 for KYBD, etc.) 
                                ;         FLAGS.Z is true if device=disk 
                                ;         All other registers are preserved. 
                                ; 
 073C  50                       CDEVID:	PUSH	AX 
 073D  0A C0                    	OR	AL,AL 
 073F  78 04                    	JS	CDEV1		;must be a special device 
 0741  32 C0                    	XOR	AL,AL		;(AL) = 0 for disks 
 0743  EB 02                    	JMP	SHORT CDEV2 
 0745  F6 D8                    CDEV1:	NEG	AL		;(AL) = - device number for special 
 0747  9C                       CDEV2:	PUSHF			;save Z=disk 
 0748  98                       	CBW			;[AX]=device number 
 0749  03 C0                    	ADD	AX,AX		; * 2 
 074B  8B F8                    	MOV	DI,AX 
 074D  9D                       	POPF			;restore Z=disk 
 074E  58                       	POP	AX 
 074F  C3                       	RET 
                                 
 0750  E9 0000 E                ERFNO2:	JMP	DERFNO		;file not opened error 
                                 
 0753  E9 0000 E                ERDNA2:	JMP	DERDNA		;device not available error 
                                 
                                	SUBTTL NAMSCN, PARDEV - Device/Filename scanning routines 
                                 
                                	EXTRN	FOPTSZ:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	FILOPT:WORD 
 0000                           DSEG	ENDS 
                                 
                                ;T.B.S. - FOPTSZ should eventually be used instead of CMPI CX,^D64, but 
                                ; the DEC-Macros don't permit this. 
                                 
                                ;NAMSCN - parse file-specification [dev:]filename[.extension] 
                                ; Entry - [BX] = text pointer 
                                ; Exit  - [FILDEV] = 0 if default device, 
                                ;                    (1..n) if device=(A:, B:, ...) 
                                ;                    (-1..-n) for DEVTBL entry (1..n) 
                                ;         [FILNM] = filename 
                                ;         [FILEXT] = extention 
                                ;         [BX] = updated text pointer 
                                ;         [AL]=next character 
                                ;         FLAGS.CARRY is set if "." scanned 
                                ;         DX is used. 
                                ;         All other registers preserved 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-40
NAMSCN, PARDEV - Device/Filename scanning routines          

                                	PUBLIC	NAMSCN 
 0756  E8 0000 E                NAMSCN:	CALL	FRMEVL 
                                 
 0759  53                       NAMSC1:	PUSH	BX		;save text pointer 
 075A  E8 0000 E                	CALL	FRESTR		;release string descriptor 
                                				;[BX] points to string descriptor 
 075D  8A 0F                    	MOV	CL,BYTE PTR 0[BX] 
 075F  B5 00                    	MOV	CH,LOW 0	;[CX]=length of string 
 0761  8B 77 01                 	MOV	SI,WORD PTR 1[BX]	;SI points to start of string 
 0764  E8 07D1 R                	CALL	PARDEV		;(AL) = device # 
 0767  A2 0000 E                	MOV	BYTE PTR FILDEV,AL	;Save device # 
 076A  0A C0                    	OR	AL,AL 
 076C  78 02                    	JS	NOTDSK		;branch if special device 
 076E  32 C0                    	XOR	AL,AL		;(AL) = 0 for disks 
 0770  50                       NOTDSK:	PUSH	AX 
 0771  52                       	PUSH	DX 
 0772  57                       	PUSH	DI 
 0773  0A C0                    	OR	AL,AL 
 0775  9C                       	PUSHF			;save NC - indicates "." not scanned 
 0776  BF 0000 E                	MOV	DI,OFFSET FILNM 
 0779  BA 000B                  	MOV	DX,OFFSET FNAML	;filename length 
 077C  79 11                    	JNS	SCAN1		;If disk device, put name in FILNM 
                                 
                                ; This code copies Device Dependent Options to FILOPT which is a 
                                ; buffer scanned by device drivers at device open time. 
                                ; 
 077E  BF 0000 E                	MOV	DI,OFFSET FILOPT 
 0781  E3 08                    	JCXZ	SCOM1		;Will copy 1 to 
 0783  83 F9 40                 	CMP	CX,64D		;compare with option buffer size 
 0786  73 18                    	JAE	ERIFN1		;"Bad File Name" if too long 
 0788  FC                       	CLD			;set Post-Increment mode 
                                                             ;Copy string to FILNM 
 0789  F3/ A4                    REP	MOVSB 
 078B                           SCOM1: 
 078B  88 0D                    	MOV	BYTE PTR 0[DI],CL	;Terminate option string with 0 
 078D  EB 1D                    	JMP	SHORT SCNAM3 
                                 
 078F  E3 37                    SCAN1:	JCXZ	FILSPC		;End of string 
 0791  49                       	DEC	CX 
 0792  FC                       	CLD			;set Post-Increment mode 
 0793  AC                       	LODSB			;Get filename character 
 0794  3C 2A                    	CMP	AL,LOW "*"	;filename can't have wildcard chars 
 0796  74 08                    	JE	ERIFN1 
 0798  3C 3F                    	CMP	AL,LOW "?" 
 079A  74 04                    	JE	ERIFN1 
 079C  3C 20                    	CMP	AL,LOW " " 
 079E  73 03                    	JAE	SCNAM2 
                                 
 07A0  E9 0000 E                ERIFN1:	JMP	DERIFN		;Illegal file name error 
                                 
 07A3  3C 2E                    SCNAM2:	CMP	AL,LOW "." 
 07A5  74 0B                    	JE	FILLNM 
 07A7  FC                       	CLD			;set Post-Increment mode 
 07A8  AA                       	STOSB			;Store character 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-41
NAMSCN, PARDEV - Device/Filename scanning routines          

 07A9  4A                       	DEC	DX 
 07AA  75 E3                    	JNZ	SCAN1		;Keep looking for characters 
                                 
 07AC  9D                       SCNAM3:	POPF 
 07AD  5F                       	POP	DI 
 07AE  5A                       	POP	DX 
 07AF  58                       	POP	AX 
 07B0  5B                       	POP	BX		;restore updated text pointer 
 07B1  C3                       	RET 
                                 
 07B2  9D                       FILLNM:	POPF 
 07B3  F9                       	STC			;set carry indicating "." scanned 
 07B4  9C                       	PUSHF 
 07B5  83 FA 0B                 FILNM0:	CMP	DX,OFFSET FNAML	;file name length 
 07B8  74 E6                    	JE	ERIFN1		;Error - extension only ! 
 07BA  83 FA 03                 	CMP	DX,3 
 07BD  72 E1                    	JB	ERIFN1		;Error - 2nd dot 
 07BF  74 CE                    	JE	SCAN1		;Scan extension like filename 
 07C1  B0 20                    	MOV	AL,LOW " " 
 07C3  FC                       	CLD			;set Post-Increment mode 
 07C4  AA                       	STOSB			;Fill with blank 
 07C5  4A                       	DEC	DX 
 07C6  EB ED                    	JMP	SHORT FILNM0	;Keep filling 
                                 
 07C8  B0 20                    FILSPC:	MOV	AL,LOW " "	;Fill short name with spaces 
 07CA  FC                       	CLD			;set Post-Increment mode 
 07CB  AA                       	STOSB 
 07CC  4A                       	DEC	DX 
 07CD  75 F9                    	JNZ	FILSPC		;Keep filling 
 07CF  EB DB                    	JMP	SHORT SCNAM3	;Done with name 
                                 
                                ;PARDEV - Parse device name from string 
                                ; Entry - (CX) = length of string 
                                ;         (SI) = string address 
                                ; EXIT  - (AL) = device # (0 = default , - = special) 
                                ;         (CX) = remaining count 
                                ;         (SI) = address of remaining string 
                                 
 07D1                           PARDEV: 
 07D1  52                       	PUSH	DX 
 07D2  57                       	PUSH	DI 
 07D3  56                       	PUSH	SI 
 07D4  8B D1                    	MOV	DX,CX		;(DX) = original length 
 07D6  0B D2                    	OR	DX,DX		;test for zero length 
 07D8  74 08                    	JZ	NODVNM		;If length = 0 , no device name 
 07DA  FC                       DEVSCN:	CLD			;set Post-Increment mode 
 07DB  AC                       	LODSB			;Get character 
 07DC  3C 3A                    	CMP	AL,LOW ":" 
 07DE  74 0A                    	JE	DEVNM		;Found possible name 
 07E0  E2 F8                    	LOOP	DEVSCN 
                                 
 07E2  8B CA                    NODVNM:	MOV	CX,DX		;No device name - restore everything 
 07E4  5E                       	POP	SI 
 07E5  5F                       	POP	DI 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-42
NAMSCN, PARDEV - Device/Filename scanning routines          

 07E6  5A                       	POP	DX 
 07E7  32 C0                    	XOR	AL,AL		;Default device to 0 
 07E9  C3                       	RET 
                                 
 07EA  5F                       DEVNM:	POP	DI		;Restore old string pointer 
 07EB  87 F7                    	XCHG	SI,DI 
 07ED  57                       	PUSH	DI		;Save new string pointer 
 07EE  2B D1                    	SUB	DX,CX		;(DX) = device name length 
 07F0  74 3F                    	JZ	ERIFN2		;Length = 0 - illegal file name 
 07F2  49                       	DEC	CX		;Count off : 
 07F3  83 FA 01                 	CMP	DX,1 
 07F6  74 3C                    	JE	DSKNAM		;Length = 1 - must be disk name 
                                 
 07F8  8B 3E 0000 E             	MOV	DI,WORD PTR DEVTBL 
 07FC  4F                       	DEC	DI 
 07FD  56                       DEVSRC:	PUSH	SI 
 07FE  52                       	PUSH	DX 
                                 
 07FF  47                       DEVLOP:	INC	DI 
 0800  FC                       	CLD			;set Post-Increment mode 
 0801  AC                       	LODSB 
 0802  E8 0843 R                	CALL	UPCASE		;Convert to upper case 
 0805  2E: F6 05 80             	TEST	BYTE PTR CS:0[DI],LOW 200O	;Check to see if at device (long name) 
 0809  75 1D                    	JNZ	NMTCH2 
 080B  2E: 38 05                	CMP	BYTE PTR CS:0[DI],AL 
 080E  75 12                    	JNE	NOMTCH 
 0810  4A                       	DEC	DX 
 0811  75 EC                    	JNZ	DEVLOP 
                                 
 0813  47                       FNDDEV:	INC	DI 
 0814  2E: 8A 05                	MOV	AL,BYTE PTR CS:0[DI]	;Get device # 
 0817  0A C0                    	OR	AL,AL 
 0819  79 07                    	JNS	NOMTCH		;Not a device # 
                                 
 081B  5E                       	POP	SI 
 081C  5E                       	POP	SI 
 081D  5E                       DEVRET:	POP	SI		;(SI) = pointer after : 
 081E  5F                       	POP	DI 
 081F  5A                       	POP	DX 
 0820  C3                       	RET			;(CX) = chars left , (AL) = device # 
                                 
 0821  47                       NMTCH1:	INC	DI 
 0822                           NOMTCH: 
 0822  2E: F6 05 80             	TEST	BYTE PTR CS:0[DI],LOW 200O	;Check for device # 
 0826  74 F9                    	JZ	NMTCH1		;  No 
 0828  5A                       NMTCH2:	POP	DX 
 0829  5E                       	POP	SI 
 082A  2E: 80 7D 01 00          	CMP	BYTE PTR CS:1[DI],LOW 0	;End of table? 
 082F  75 CC                    	JNE	DEVSRC		;  No - check next entry 
                                 
 0831  E9 0000 E                ERIFN2:	JMP	DERIFN		;Error - bad filename (device name) 
                                 
 0834                           DSKNAM: 
 0834  FC                       	CLD			;set Post-Increment mode 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-43
NAMSCN, PARDEV - Device/Filename scanning routines          

 0835  AC                       	LODSB			;Refetch character 
 0836  E8 0843 R                	CALL	UPCASE 
 0839  2C 40                    	SUB	AL,LOW OFFSET "A"-1	;Convert letter to 1-26 (let @ be 0) 
 083B  72 F4                    	JB	ERIFN2		;  Less than @ 
 083D  3C 1A                    	CMP	AL,LOW OFFSET "Z" AND 37O 
 083F  73 F0                    	JAE	ERIFN2		;  Greater than Z 
 0841  EB DA                    	JMP	SHORT DEVRET 
                                 
 0843  3C 61                    UPCASE:	CMP	AL,LOW "a"	;Convert (AL) to upper case 
 0845  72 06                    	JB	UPRET 
 0847  3C 7A                    	CMP	AL,LOW "z" 
 0849  77 02                    	JA	UPRET 
 084B  24 DF                    	AND	AL,LOW OFFSET 255D-" " 
 084D  C3                       UPRET:	RET 
                                 
                                	SUBTTL File Data Block Management Routines 
                                 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	VARTAB:WORD,ARYTAB:WORD,MEMSIZ:WORD,FRETOP:WORD,SAVFRE:WORD 
                                	EXTRN	FILTAB:WORD,STREND:WORD 
 0000                           DSEG	ENDS 
                                	EXTRN	ERROM:NEAR,ERROR:NEAR 
                                	EXTRN	SKPNAM:NEAR,GARBA2:NEAR 
                                ;INIFDB - Special device open common routine 
                                ; Allocates, initializes and links new FDB into FDB Chain. 
                                ; Entry - (AL) = file device 
                                ;         (AH) = valid file modes 
                                ;         (CX) = buffer size (not including basic FDB size) 
                                ;         (DL) = file width 
                                ;         (DH) = initial file position 
                                ;         (BX) = file number 
                                ; Exit -  SI points to new File Data Block 
                                ;         [PTRFIL] points to new FDB 
                                ;         All other registers preserved. 
                                ; 
                                	PUBLIC	INIFDB 
 084E  51                       INIFDB:	PUSH	CX 
 084F  57                       	PUSH	DI 
 0850  84 26 0000 E             	TEST	BYTE PTR FILMOD,AH	;Check for valid file mode 
 0854  74 2C                    	JZ	ERBFM4		;  Bad file mode 
 0856  83 C1 39                 	ADD	CX,OFFSET FDBSIZ	;(CX) = size of block to allocate 
 0859  E8 08B5 R                	CALL	FALLOC		;SI points to Allocated block 
 085C  89 36 0000 E             	MOV	WORD PTR PTRFIL,SI 
 0860  88 5C 01                 	MOV	BYTE PTR F_NUM[SI],BL	;Set file number 
 0863  88 44 34                 	MOV	BYTE PTR F_DEV[SI],AL	;Set file device 
 0866  C6 44 37 00              	MOV	BYTE PTR F_FLGS[SI],LOW 0 
 086A  C6 44 31 00              	MOV	BYTE PTR F_CODE[SI],LOW OFFSET FC_ASC	;default file-code to ASCII 
 086E  8A 0E 0000 E             	MOV	CL,BYTE PTR FILMOD 
 0872  88 4C 06                 	MOV	BYTE PTR F_MODE[SI],CL	;Set file mode 
 0875  88 54 35                 	MOV	BYTE PTR F_WID[SI],DL	;Set file width 
 0878  88 74 38                 	MOV	BYTE PTR F_POS[SI],DH	;Set file position 
 087B  C6 44 2F 01              	MOV	BYTE PTR F_ORCT[SI],LOW 1	;indicates not at EOF 
 087F  5F                       	POP	DI 
 0880  59                       	POP	CX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-44
File Data Block Management Routines                         

 0881  C3                       	RET 
                                 
 0882  E9 0000 E                ERBFM4:	JMP	DERBFM		;Bad file mode 
                                 
                                ;SCDASC - Set file-attribute CODE for file PTRFIL to ASCII 
                                ; Exit  - all registers preserved. 
                                ; 
                                	PUBLIC	SCDASC 
 0885  56                       SCDASC:	PUSH	SI 
 0886  8B 36 0000 E             	MOV	SI,WORD PTR PTRFIL 
 088A  C6 44 31 00              	MOV	BYTE PTR F_CODE[SI],LOW OFFSET FC_ASC 
 088E  5E                       	POP	SI 
 088F  C3                       	RET 
                                 
                                ;SCDBIN - Set file-attribute CODE for file PTRFIL to binary 
                                ; Exit  - all registers preserved. 
                                ; 
                                	PUBLIC	SCDBIN 
 0890  56                       SCDBIN:	PUSH	SI 
 0891  8B 36 0000 E             	MOV	SI,WORD PTR PTRFIL 
 0895  C6 44 31 01              	MOV	BYTE PTR F_CODE[SI],LOW OFFSET FC_BIN 
 0899  5E                       	POP	SI 
 089A  C3                       	RET 
                                 
                                ;FDBPTR - Transform file number into File-Data-Block pointer 
                                ; Entry - [FAC] = file number (0..n) 
                                ; Exit  - if File-Data-Block is allocated, 
                                ;            SI points to 1st byte of File-Data-Block 
                                ;         else FLAGS.Z is true 
                                ;         DX, AX are used 
                                ; 
 089B  E8 0000 E                FACFPT:	CALL	CONINT		;[AL] = file number 
                                				;fall into FDBPTR 
                                 
                                ;FDBPTR - Transform file number into File-Data-Block pointer 
                                ; Entry - [AL] = file number (0..n) 
                                ; Exit  - if File-Data-Block is allocated, 
                                ;            SI points to 1st byte of File-Data-Block 
                                ;         else FLAGS.Z is true 
                                ;         All other registers are preserved 
                                ; 
 089E  8B 36 0000 E             FDBPTR:	MOV	SI,WORD PTR FILTAB	;[SI] points to 1st file-data-block 
 08A2  3B 36 0000 E             GPTRL:	CMP	SI,WORD PTR STKLOW	;compare with nil FDB pointer 
 08A6  74 0C                    	JZ	GPTRX		;branch if at end of FDB chain 
 08A8  3A 44 01                 	CMP	AL,BYTE PTR F_NUM[SI] 
 08AB  74 05                    	JZ	GPTRF		;branch if found FDB 
 08AD  8B 74 04                 	MOV	SI,WORD PTR F_NEXT[SI]	;advance to next FDB in chain 
 08B0  EB F0                    	JMP	SHORT GPTRL 
 08B2  0B F6                    GPTRF:	OR	SI,SI		;set NZ - indicates FDB found 
 08B4  C3                       GPTRX:	RET 
                                 
                                ;FALLOC(nbytes) {allocate file-data-block and link into chain} 
                                ; Entry - CX=size of FDB 
                                ; Exit  - SI points to new FDB (which is already linked into FDB chain) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-45
File Data Block Management Routines                         

                                ;         SI, DI used. 
                                ; 
                                ;  if FRETOP-STREND .LEQ. nbytes then 
                                ;    perform major string garbage collection 
                                ;    if FRETOP-STREND is still .LEQ. nbytes then deverr(Out-of-memory) 
                                ;  temp = FILTAB; 
                                ;  xfrstr(FILTAB,-nbytes); {move string space down nbytes} 
                                ;  FILTAB.F.NEXT := temp; {link new FDB into chain} 
                                ;  return FILTAB; 
                                ; 
 08B5  50                       FALLOC:	PUSH	AX 
 08B6  53                       	PUSH	BX 
 08B7  51                       	PUSH	CX 
 08B8  52                       	PUSH	DX 
 08B9  9C                       	PUSHF 
 08BA  8B C1                    	MOV	AX,CX		;[AX]=size of new FDB 
 08BC  B2 01                    	MOV	DL,LOW 1	;Indicates 1st attempt to find space 
 08BE  8B 1E 0000 E             FALC1:	MOV	BX,WORD PTR FRETOP	;BX points to top of free string space 
 08C2  2B 1E 0000 E             	SUB	BX,WORD PTR STREND	;BX=number of bytes free - 1 
 08C6  3B C3                    	CMP	AX,BX		;compare with requested amount 
 08C8  72 12                    	JB	FALCOK		;branch if its available 
 08CA  FE CA                    	DEC	DL 
 08CC  74 05                    	JZ	FAPAS1		;branch if 1st attempt 
 08CE  B2 00 E                  	MOV	DL,LOW OFFSET ERROM	;else give Out of Memory error 
 08D0  E9 0000 E                	JMP	ERROR 
 08D3  50                       FAPAS1:	PUSH	AX 
 08D4  52                       	PUSH	DX 
 08D5  E8 0000 E                	CALL	GARBA2		;perform major garbage collection 
 08D8  5A                       	POP	DX 
 08D9  58                       	POP	AX 
 08DA  EB E2                    	JMP	SHORT FALC1	;now that its compressed, try again 
                                 
 08DC  F7 D8                    FALCOK:	NEG	AX		;indicates moving strings down 
 08DE  8B 36 0000 E             	MOV	SI,WORD PTR FILTAB	;SI points to lowest FDB in chain 
 08E2  56                       	PUSH	SI		;save for link 
 08E3  E8 0919 R                	CALL	XFRSTR		;move string space 
 08E6  5B                       	POP	BX 
 08E7  8B 36 0000 E             	MOV	SI,WORD PTR FILTAB	;SI points to new FDB 
 08EB  89 5C 04                 	MOV	WORD PTR F_NEXT[SI],BX	;link FDB into chain 
                                 
                                	PUBLIC	PDCBAX,PCBAX,PBAX	;generally useful routines 
 08EE  9D                       PFDCBA:	POPF 
 08EF  5A                       PDCBAX:	POP	DX 
 08F0  59                       PCBAX:	POP	CX 
 08F1  5B                       PBAX:	POP	BX 
 08F2  58                       	POP	AX 
 08F3  C3                       	RET 
                                 
                                 
                                ;FFREE(fdbptr) {free file data block} 
                                ;              {ffree is called by clsfil only} 
                                ; Entry - SI points to FDB to be freed 
                                ; Exit  - SI, DI Used 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-46
File Data Block Management Routines                         

                                ;  fdbptr points to low byte of freed file-data-block 
                                ;  remove fdbptr from chain of file-data-blocks (FILTAB) 
                                ;  nbytes := size of freed file-data-block. 
                                ;  xfrstr(fdbptr, nbytes); {move string space and lower-FDB's up nbytes} 
                                ; 
 08F4  50                       FFREE:	PUSH	AX 
 08F5  53                       	PUSH	BX 
 08F6  51                       	PUSH	CX 
 08F7  52                       	PUSH	DX 
 08F8  9C                       	PUSHF 
 08F9  8B 44 04                 	MOV	AX,WORD PTR F_NEXT[SI]	;AX points to next FDB in chain 
 08FC  2B C6                    	SUB	AX,SI		;AX = size of FDB being freed 
 08FE  8B 1E 0000 E             	MOV	BX,WORD PTR FILTAB	;BX points to 1st FDB in chain 
 0902  3B DE                    FFNDL:	CMP	BX,SI		;see if this is the one being freed 
 0904  74 0E                    	JE	FFOUND		;branch if it is 
 0906  72 02                    	JB	STILOK		;branch if still less than expected 
 0908  EB FE                    BADFDB:	JMP	SHORT BADFDB	;better to halt than destroy other data 
 090A                           STILOK: 
 090A  8B 4F 04                 	MOV	CX,WORD PTR F_NEXT[BX]	;CX points to next FDB in chain 
 090D  01 47 04                 	ADD	WORD PTR F_NEXT[BX],AX	;update next-ptr to reflect block move 
 0910  8B D9                    	MOV	BX,CX 
 0912  EB EE                    	JMP	SHORT FFNDL	;continue quest 
                                 
 0914                           FFOUND: 
 0914  E8 0919 R                	CALL	XFRSTR		;move strings and lower FDB's up 
 0917  EB D5                    	JMP	SHORT PFDCBA	;restore registers and exit 
                                 
                                ;XFRSTR(top, nbytes) {transfer string space} 
                                ; Entry - SI points 1 byte above block to be moved 
                                ;         AX = direction and number of bytes to be moved {nbytes} 
                                ;              (if AX .GT. 0 then strings are moved to a higher adr (UP)) 
                                ;         FRETOP points 1 byte below bottom of block to be moved 
                                ; Exit  - FLAGS, AX, BX, CX, DX used (Others preserved) 
                                ; 
                                ;  if moving string space down, nbytes .LS. 0, top=FILTAB 
                                ;  if moving string space up, top=pointer to FDB being released, 
                                ;  perform block move 
                                ;  for each string descriptor in VARTAB, ARYTAB, temporaries do 
                                ;    if str.adr .LSS. top then 
                                ;      str.adr := str.adr + nbytes {update string descriptor} 
                                ;    else if str.adr .LSS. top+nbytes then 
                                ;      str.len := 0 {reset field variables in released FDB} 
                                ;    end; {for each string...} 
                                ;  FILTAB := FILTAB + nbytes; 
                                ;  MEMSIZ := MEMSIZ + nbytes; 
                                ;  FRETOP := FRETOP + nbytes; 
                                ;  SAVFRE := SAVFRE + nbytes; (so CHAIN will work) 
                                ;  PTRFIL := PTRFIL + nbytes; (if it was pointing to a moved FDB) 
                                ; 
 0919  56                       XFRSTR:	PUSH	SI 
 091A  57                       	PUSH	DI 
 091B  4E                       	DEC	SI		;SI points to top of block to be moved 
 091C  8B FE                    	MOV	DI,SI		;DI points to top of block to be moved 
 091E  8B D0                    	MOV	DX,AX		;DX=byte-count adjustment for block move 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-47
File Data Block Management Routines                         

 0920  03 F8                    	ADD	DI,AX		;DI points to top of dest of block move 
 0922  8B CE                    	MOV	CX,SI 
 0924  2B 0E 0000 E             	SUB	CX,WORD PTR FRETOP	;CX = number of bytes to transfer 
 0928  74 56                    	JZ	XFRSTX		;return if string space is empty 
 092A  56                       	PUSH	SI 
 092B  57                       	PUSH	DI 
 092C  FD                       	STD			;set Post-Decrement mode 
 092D  0B C0                    	OR	AX,AX 
 092F  79 07                    	JNS	XFRSUP		;brif moving strings up in memory 
 0931  FC                       	CLD			;set Post-Increment mode 
 0932  2B F1                    	SUB	SI,CX 
 0934  2B F9                    	SUB	DI,CX		;start transfer from bottom 
 0936  46                       	INC	SI		;SI points to bottom of SRC block 
 0937  47                       	INC	DI		;DI points to bottom of DST block 
 0938                           XFRSUP: 
 0938  F3/ A4                    REP	MOVSB			;execute block move 
 093A  5F                       	POP	DI		;restore DI points to TOP of DST block 
 093B  5E                       	POP	SI		;restore SI points to TOP of SRC block 
                                 
                                ;Update all string descriptors in VARTAB 
                                ; SI points to top of source of block move 
                                ; DI points to top of destination of block move 
                                ; DX = byte count adjustment for block move 
                                ; 
 093C  8B 1E 0000 E             	MOV	BX,WORD PTR VARTAB	;Look at simple strings 
 0940  3B 1E 0000 E             CSVAR:	CMP	BX,WORD PTR ARYTAB	;Done if we have reached array table 
 0944  74 12                    	JZ	CAYVAR		;Yes 
 0946  E8 0000 E                	CALL	SKPNAM		;Skip name, returns Z if was a string 
 0949  75 05                    	JNZ	CSKPVA		;Skip this var, not string 
 094B  E8 09A5 R                	CALL	UPDSTD		;Update this string descriptor 
 094E  32 C0                    	XOR	AL,AL		;UPDSTD has already incremented [BX] 
 0950                           CSKPVA: 
 0950  B4 00                    	MOV	AH,LOW 0 
 0952  03 D8                    	ADD	BX,AX		;Add length of VALTYP 
 0954  EB EA                    	JMP	SHORT CSVAR 
                                 
                                ;Update all string descriptors in ARYTAB 
                                ; 
 0956  8B D8                    CAYVA2:	MOV	BX,AX		;BX points to next string descriptor 
 0958  3B 1E 0000 E             CAYVAR:	CMP	BX,WORD PTR STREND	;New limit of search 
 095C  74 22                    	JZ	XFRSTX		;branch if done searching arrays 
 095E  E8 0000 E                	CALL	SKPNAM		;Skip over name 
 0961  9C                       	PUSHF			;save string-name indicator 
 0962  8B 07                    	MOV	AX,WORD PTR 0[BX]	;Get length of array 
 0964  43                       	INC	BX 
 0965  43                       	INC	BX 
 0966  03 C3                    	ADD	AX,BX		;AX points to next entry in ARYTAB 
 0968  9D                       	POPF			;String array? 
 0969  75 EB                    	JNZ	CAYVA2		;No, look at next one 
 096B  50                       	PUSH	AX		;save pointer to end of array 
 096C  8A 07                    	MOV	AL,BYTE PTR 0[BX]	;Pick up number of DIMs 
 096E  B4 00                    	MOV	AH,LOW 0	;Make double with high zero 
 0970  03 D8                    	ADD	BX,AX		;Go past DIMS 
 0972  03 D8                    	ADD	BX,AX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-48
File Data Block Management Routines                         

 0974  43                       	INC	BX		;One more to account for # of DIMs 
 0975  58                       CAYSTR:	POP	AX		;AX points to end of array 
 0976  3B D8                    	CMP	BX,AX		;Are we done with this array? 
 0978  74 DE                    	JZ	CAYVAR		;Get next array 
 097A  50                       	PUSH	AX 
 097B  E8 09A5 R                	CALL	UPDSTD		;Update string descriptor 
 097E  EB F5                    	JMP	SHORT CAYSTR 
                                 
 0980  8B 0E 0000 E             XFRSTX:	MOV	CX,WORD PTR PTRFIL 
 0984  3B 0E 0000 E             	CMP	CX,WORD PTR FRETOP 
 0988  72 08                    	JB	XFSTX1		;brif PTRFIL pointed below moved block 
 098A  3B CE                    	CMP	CX,SI 
 098C  73 04                    	JAE	XFSTX1		;brif PTRFIL pointed above moved block 
 098E  01 16 0000 E             	ADD	WORD PTR PTRFIL,DX	;Adjust PTRFIL for block move 
 0992  01 16 0000 E             XFSTX1:	ADD	WORD PTR FRETOP,DX	;Adjust FRETOP for block move 
 0996  01 16 0000 E             	ADD	WORD PTR SAVFRE,DX	;Adjust SAVFRE for block move 
 099A  01 16 0000 E             	ADD	WORD PTR FILTAB,DX	;Adjust FILTAB for block move 
 099E  01 16 0000 E             	ADD	WORD PTR MEMSIZ,DX	;Adjust MEMSIZ for block move 
 09A2  5F                       	POP	DI 
 09A3  5E                       	POP	SI 
 09A4  C3                       	RET 
                                 
                                 
                                ;Update String Descriptor pointed to by BX. 
                                ; Entry - BX points to string descriptor 
                                ;         SI points to top of source for block move 
                                ;         DI points to top of destination for block move 
                                ;         DX = size and direction of block move 
                                ; Exit  - BX points 1 byte beyond string descriptor 
                                ;         if string descriptor pointed inside buffer being released, len=0 
                                ;         if descriptor points within block-move, its pointer is adjusted. 
                                ;         CX used.  All other registers preserved. 
                                ; 
 09A5                           UPDSTD: 
 09A5  8B 4F 01                 	MOV	CX,WORD PTR 1[BX]	;CX points to string data 
 09A8  3B 0E 0000 E             	CMP	CX,WORD PTR FRETOP 
 09AC  76 0E                    	JBE	UPDSTX		;brif string data is below string space 
 09AE  3B CE                    	CMP	CX,SI 
 09B0  76 07                    	JBE	UPDSTU		;brif string data was block moved 
 09B2  3B CF                    	CMP	CX,DI 
 09B4  77 06                    	JA	UPDSTX		;brif string not in buffer being freed 
 09B6  C6 07 00                 	MOV	BYTE PTR 0[BX],LOW 0	;set string len to 0 (reset field buf) 
 09B9                           UPDSTU: 
 09B9  01 57 01                 	ADD	WORD PTR 1[BX],DX	;adjust pointer for block move 
 09BC                           UPDSTX: 
 09BC  83 C3 03                 	ADD	BX,3		;BX points 1 byte beyond string desc 
 09BF  C3                       	RET 
                                 
                                	SUBTTL General Queue support routines 
                                 
                                	PUBLIC	INITQ,PUTQ,GETQ,NUMQ,LFTQ 
                                 
                                ;These routines are all called with SI pointing to an 8-byte queue descriptor 
                                ; which is organized (invisibly to the caller) as follows: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-49
General Queue support routines                              

                                ; 
 = 0000                         	Q_PUT=0			;points to the next empty byte in the queue 
 = 0002                         	Q_GET=2			;points to the next byte to be fetched (oldest data) 
 = 0004                         	Q_BUF=4			;points to the 1st byte of the physical buffer 
 = 0006                         	Q_END=6			;points 1 byte beyond the end of the physical buffer 
                                 
                                ;   Note: if Q.PUT(SI)=Q.GET(.SI), the queue is empty 
                                ;         Size of queue buffer is Q.END - Q.BUF 
                                ;         Maximum data in queue at any time is Q.END - Q.BUF - 1 
                                 
                                 
                                ;INITQ - initialize queue descriptor for empty queue 
                                ; Entry - SI points to 8 byte queue descriptor 
                                ;         BX points to 1st byte of queue buffer 
                                ;         [AX] = size of queue buffer 
                                ; Exit  - AX is used 
                                ; 
 09C0  89 1C                    INITQ:	MOV	WORD PTR Q_PUT[SI],BX 
 09C2  89 5C 02                 	MOV	WORD PTR Q_GET[SI],BX 
 09C5  89 5C 04                 	MOV	WORD PTR Q_BUF[SI],BX 
 09C8  03 C3                    	ADD	AX,BX 
 09CA  89 44 06                 	MOV	WORD PTR Q_END[SI],AX 
 09CD  C3                       	RET 
                                 
                                ;PUTQ - append data to back of queue 
                                ; Entry - SI points to 8 byte queue descriptor 
                                ;         [AL]=data to be put in queue 
                                ; Exit  - FLAGS.Z is true if queue is full 
                                ; 
 09CE  8B 1C                    PUTQ:	MOV	BX,WORD PTR Q_PUT[SI] 
 09D0  88 07                    	MOV	BYTE PTR 0[BX],AL 
 09D2  E8 09EF R                	CALL	BUMPQP		;advance PUT-POINTER BX 
 09D5  3B 5C 02                 	CMP	BX,WORD PTR Q_GET[SI] 
 09D8  74 02                    	JE	PQFULL		;brif queue is full (ignore new data) 
 09DA  89 1C                    	MOV	WORD PTR Q_PUT[SI],BX	;save new PUT-POINTER 
 09DC  C3                       PQFULL:	RET 
                                 
                                ;GETQ - get next byte from front of queue 
                                ; Entry - SI points to 8 byte queue descriptor 
                                ; Exit  - FLAGS.Z is true if queue is empty 
                                ;         otherwise, [AL]=data to be put in queue 
                                ;         AX is used 
                                ; 
 09DD  8B 5C 02                 GETQ:	MOV	BX,WORD PTR Q_GET[SI] 
 09E0  3B 1C                    	CMP	BX,WORD PTR Q_PUT[SI] 
 09E2  74 0A                    	JE	GQEMTY		;branch if queue is empty 
 09E4  8A 07                    	MOV	AL,BYTE PTR 0[BX]	;get next byte from queue 
 09E6  E8 09EF R                	CALL	BUMPQP		;advance queue pointer BX 
 09E9  89 5C 02                 	MOV	WORD PTR Q_GET[SI],BX	;save new GET-POINTER 
 09EC  0B DB                    	OR	BX,BX		;set NZ so caller knows AL has data 
 09EE  C3                       GQEMTY:	RET 
                                 
 09EF  43                       BUMPQP:	INC	BX 
 09F0  3B 5C 06                 	CMP	BX,WORD PTR Q_END[SI] 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-50
General Queue support routines                              

 09F3  72 03                    	JB	BUMPQX		;branch if no need to Wrap-Around 
 09F5  8B 5C 04                 	MOV	BX,WORD PTR Q_BUF[SI]	;reset pointer to start of buf 
 09F8  C3                       BUMPQX:	RET 
                                 
                                ;LFTQ - How many times can PUTQ be successfully called for queue SI 
                                ; Entry - SI points to 8 byte queue descriptor 
                                ; Exit  - [AX] = number of bytes free in queue (0..QueueSize - 1) 
                                ; 
 09F9  8B 44 02                 LFTQ:	MOV	AX,WORD PTR Q_GET[SI] 
 09FC  48                       	DEC	AX 
 09FD  2B 04                    	SUB	AX,WORD PTR Q_PUT[SI] 
 09FF  EB 05                    	JMP	SHORT NUMQ1 
                                 
                                ;NUMQ - How many times can GETQ be successfully called for queue SI 
                                ; Entry - SI points to 8 byte queue descriptor 
                                ; Exit  - [AX] = number of bytes of data in queue (0..QueueSize - 1) 
                                ; 
 0A01  8B 04                    NUMQ:	MOV	AX,WORD PTR Q_PUT[SI] 
 0A03  2B 44 02                 	SUB	AX,WORD PTR Q_GET[SI] 
 0A06  73 06                    NUMQ1:	JAE	NUMQX		;brif PUT-POINTER exceeds GET-POINTER 
 0A08  03 44 06                 	ADD	AX,WORD PTR Q_END[SI] 
 0A0B  2B 44 04                 	SUB	AX,WORD PTR Q_BUF[SI] 
 0A0E  C3                       NUMQX:	RET 
                                 
                                	SUBTTL I/O Initialization Called by INIT 
                                 
                                	PUBLIC	GIOINI,GIOTRM 
                                 
 0A0F                           GIOINI: 
 0A0F  E8 0AC5 R                	CALL	MSISET		;Init MSDOS interrupts &H23 & &H24 
 0A12  33 C0                    	XOR	AX,AX 
 0A14  A3 0000 E                	MOV	WORD PTR STKLOW,AX 
 0A17  C7 06 0000 E 0000        	MOV	WORD PTR FILTAB,0	;so FDBPTR will work during initialization 
 0A1D  A2 0000 E                	MOV	BYTE PTR NLONLY,AL 
 0A20  8B 1E 0000 E             	MOV	BX,WORD PTR DEVINI	;DI points to array of init routines 
 0A24  E8 0A34 R                	CALL	DOALDV 
 0A27  EB 4B                    	JMP	SHORT FINPRT	;reset PTRFIL to Keyboard 
                                 
 0A29  8B 1E 0000 E             GIOTRM:	MOV	BX,WORD PTR DEVTRM	;DI points to array of terminate routines 
 0A2D  E8 0A34 R                	CALL	DOALDV 
 0A30  E8 0AEB R                	CALL	MSIRST		;Replace MSDOS int vectors &H23 & &H24 
 0A33  C3                       	RET 
                                 
 0A34  B0 00 E                  DOALDV:	MOV	AL,LOW OFFSET $_NDEV 
 0A36  98                       	CBW			;[CX]=number of devices in system 
 0A37  03 C0                    	ADD	AX,AX 
 0A39  74 0E                    	JZ	DOALLX		;branch if no non-disk devices 
 0A3B  8B F8                    	MOV	DI,AX		;[DI]=2*number of non-disk devices 
 0A3D  53                       DOALLP:	PUSH	BX 
 0A3E  57                       	PUSH	DI 
 0A3F  2E: FF 51 FE             	CALL	 WORD PTR CS:-2[BX+DI]	;Call initialization/termination routine 
 0A43  5F                       	POP	DI 
 0A44  5B                       	POP	BX 
 0A45  4F                       	DEC	DI 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-51
I/O Initialization Called by INIT                           

 0A46  4F                       	DEC	DI 
 0A47  75 F4                    	JNZ	DOALLP		;Loop until Device ID = 0 (disk) 
 0A49                           DOALLX: 
 0A49  C3                       	RET 
                                 
                                ;FINLPT forces a carriage return on LPT1 if it is not already at left margin. 
                                ; It then falls into FINPRT. 
                                ; Exit  - AX, SI, DI, FLAGS used, all other registers preserved. 
                                ; 
 0A4A  50                       FINLPT:	PUSH	AX 
 0A4B  B4 12                    	MOV	AH,LOW OFFSET G_GPS	;Get column position request-code 
                                ;        MOVI    DI,$CODE+2*<^O400-$.LPT1> 
 0A4D  BF 0000 E                	MOV	DI,OFFSET $_LPT1 
 0A50  F7 DF                    	NEG	DI		; Change neg. dev. # to 0 based offset 
 0A52  81 E7 00FF               	AND	DI,377O 
 0A56  D1 E7                    	SHL	DI,1		; ASM86 cann't multiply externals by 2 
 0A58  57                       	PUSH	DI		;save Device Code 
 0A59  E8 0719 R                	CALL	TBLDSP		;function [AH] on device [DI] (LPT1) 
 0A5C  5F                       	POP	DI 
 0A5D  0A E4                    	OR	AH,AH		;test LPT1 current column position 
 0A5F  74 12                    	JZ	FINLPX		;branch if at column 0 
 0A61  B8 100D                  	MOV	AX,OFFSET (400O*G_SOT)+13D 
 0A64  57                       	PUSH	DI		;save Device Code 
 0A65  33 F6                    	XOR	SI,SI		;SI=pseudo LPT FDB 
 0A67  E8 0719 R                	CALL	TBLDSP		;Send CR to LPT 
 0A6A  5F                       	POP	DI 
 0A6B  B8 100A                  	MOV	AX,OFFSET (400O*G_SOT)+10D 
 0A6E  33 F6                    	XOR	SI,SI		;SI=pseudo LPT FDB 
 0A70  E8 0719 R                	CALL	TBLDSP		;Send LF to LPT 
 0A73  58                       FINLPX:	POP	AX 
                                				;Fall into FINPRT 
                                 
                                ;FINPRT is called at the end of every BASIC statement and after ERROR. 
                                ; It resets the current file to be Keyboard/Crt. 
                                ; It also frees the File-Data-Block pointed to by FREFDB if it is non-zero. 
                                ; This is useful for Device-Open routines (xxxOPN).  After calling 
                                ; INIFDB to allocate an FDB, they can set FREFDB to point to allocated FDB. 
                                ; When the file gets completely opened, they can reset FREFDB to 0. 
                                ; Then if some error occurs in between, FINPRT will release the FDB. 
                                ; Exit  - AX, SI, DI, FLAGS used, all other registers preserved. 
                                ; 
                                	PUBLIC	FINPRT,FINLPT 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	FREFDB:WORD 
 0000                           DSEG	ENDS 
 0A74                           FINPRT: 
                                	EXTRN	SETCSR:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	CSRY:WORD,CSRX:WORD,CSRTYP:WORD 
 0000                           DSEG	ENDS 
 0A74  52                       	PUSH	DX 
 0A75  8A 16 0000 E             	MOV	DL,BYTE PTR CSRY 
 0A79  8A 36 0000 E             	MOV	DH,BYTE PTR CSRX	;DX=current posn 
 0A7D  C6 06 0000 E 03          	MOV	BYTE PTR CSRTYP,LOW 3D	;Set to user cursor 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-52
I/O Initialization Called by INIT                           

 0A82  E8 0000 E                	CALL	SETCSR		;Display the cursor 
 0A85  5A                       	POP	DX 
 0A86  8B 36 0000 E             	MOV	SI,WORD PTR FREFDB 
 0A8A  0B F6                    	OR	SI,SI 
 0A8C  74 03                    	JZ	NFRFDB		;branch if no FDB needs to be released 
 0A8E  E8 08F4 R                	CALL	FFREE 
 0A91  33 C0                    NFRFDB:	XOR	AX,AX 
 0A93  A3 0000 E                	MOV	WORD PTR FREFDB,AX	;reset FREE-FDB flag 
 0A96  E8 04B5 R                	CALL	CLSFIL		;close file #0 (if NLONLY=0) 
 0A99  33 C0                    	XOR	AX,AX 
 0A9B  F6 06 0000 E 01          	TEST	BYTE PTR NLONLY,LOW 1 
 0AA0  75 03                    	JNZ	RET45		;don't clear PTRFIL if loading program 
 0AA2  A3 0000 E                	MOV	WORD PTR PTRFIL,AX	;future I/O will use Keyboard/CRT 
 0AA5  C3                       RET45:	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-53
I/O Initialization Called by INIT                           

                                	PAGE 
                                	SUBTTL  MSDOS   Abort/Initialization/Termination Processing 
                                 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	DINTAD:WORD,CTLCAD:WORD	;MSDOS Ctl-C and disk error vector 
 0000                           DSEG	ENDS 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	MSDCCF:WORD	;MSDOS control C flag 
 0000                           DSEG	ENDS 
                                 
                                	EXTRN	ERROR:NEAR 
                                	EXTRN	ERRDWP:NEAR,ERRDNR:NEAR,ERRDME:NEAR	;I/O Error numbers 
                                 
                                	PUBLIC	SAVVEC,SETVEC 
                                 
                                ;DSKERR - Processing for MSDOS interrupt &H23 
                                ;         Exit is made through ERROR.  No IRET is executed. 
                                ; 
 0AA6  FB                       DSKERR:	STI 
 0AA7  8B C7                    	MOV	AX,DI		;[AX]= Error code 
 0AA9  83 C4 14                 	ADD	SP,20D		;Adjust stack 
 0AAC  1F                       	POP	DS		;Get BASIC data segment 
 0AAD  07                       	POP	ES		;Get BASIC extra segment 
 0AAE  B2 00 E                  	MOV	DL,LOW OFFSET ERRDWP 
 0AB0  0A C0                    	OR	AL,AL		;Test for "Disk write protect" 
 0AB2  74 08                    	JZ	DSKERX		;Disk write protect 
 0AB4  B2 00 E                  	MOV	DL,LOW OFFSET ERRDNR 
 0AB6  3C 02                    	CMP	AL,LOW 2D	;Test for "Disk not ready" 
 0AB8  74 02                    	JZ	DSKERX		;Disk not ready 
 0ABA  B2 00 E                  	MOV	DL,LOW OFFSET ERRDME	;Else "Disk media error 
 0ABC  E9 0000 E                DSKERX:	JMP	ERROR		;Go report the error and return 
                                				;Extra stuff on stack is removed by ERROR 
                                 
                                ;MSCTLC - Processing for MSDOS interrupt &H23 
                                ; 
 0ABF  C6 06 0000 E FF          MSCTLC:	MOV	BYTE PTR MSDCCF,LOW 377O	;Record control-C event for POLKEY 
 0AC4  CF                       	IRET 
                                 
                                ;MSISET - Set MSDOS termination and Ctl-C processing addresses. 
                                ;         The current addresses are saved for restoration upon termination 
                                ;         All registers preserved. 
                                ; 
                                 
                                 
 0AC5  50                       MSISET:	PUSH	AX 
 0AC6  52                       	PUSH	DX 
 0AC7  06                       	PUSH	ES 
 0AC8  B8 0024                  	MOV	AX,36D		;MSDOS fatal error interrupt 
 0ACB  BB 0000 E                	MOV	BX,OFFSET DINTAD	;Get save location for fatal error 
 0ACE  E8 0B02 R                	CALL	SAVVEC 
 0AD1  48                       	DEC	AX		;MSDOS Ctl-C interrupt 
 0AD2  BB 0000 E                	MOV	BX,OFFSET CTLCAD	;Get save location 
 0AD5  E8 0B02 R                	CALL	SAVVEC 
 0AD8  0E                       	PUSH	CS 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-54
MSDOS   Abort/Initialization/Termination Processing         

 0AD9  07                       	POP	ES		;BASIC code segment to ES 
 0ADA  BA 0ABF R                	MOV	DX,OFFSET MSCTLC	;BASIC Ctl-C handler address 
 0ADD  E8 0B11 R                	CALL	SETVEC		;BASIC Ctl-C handler vector set 
 0AE0  40                       	INC	AX		;MSDOS fatal error interrupt 
 0AE1  BA 0AA6 R                	MOV	DX,OFFSET DSKERR 
 0AE4  E8 0B11 R                	CALL	SETVEC		;BASIC fatal error handler vector set 
 0AE7  07                       	POP	ES 
 0AE8  5A                       	POP	DX 
 0AE9  58                       	POP	AX 
 0AEA  C3                       	RET 
                                 
 0AEB  50                       MSIRST:	PUSH	AX 
 0AEC  06                       	PUSH	ES 
 0AED  B8 0024                  	MOV	AX,36D		;MSDOS fatal error interrupt 
 0AF0  C4 16 0000 E             	LES	DX,DWORD PTR DINTAD	;Get MSDOS fatal error handler add/par 
 0AF4  E8 0B11 R                	CALL	SETVEC 
 0AF7  48                       	DEC	AX		;MSDOS Ctl-C interrupt 
 0AF8  C4 16 0000 E             	LES	DX,DWORD PTR CTLCAD	;Get MSDOS Ctl-C handler add/par 
 0AFC  E8 0B11 R                	CALL	SETVEC 
 0AFF  07                       	POP	ES 
 0B00  58                       	POP	AX 
 0B01  C3                       	RET 
                                ;SAVVEC - Get and store an interrupt vector 
                                ;ENTRY  - AX = interrupt 
                                ;         BX = CS relative address of vector storage area 
                                ;EXIT   - all registers preserved 
                                ; 
 0B02  52                       SAVVEC:	PUSH	DX 
 0B03  06                       	PUSH	ES 
 0B04  E8 0B27 R                	CALL	GETVEC 
 0B07  89 17                    	MOV	WORD PTR 0[BX],DX	;Save address portion 
 0B09  8C C2                    	MOV	DX,ES 
 0B0B  89 57 02                 	MOV	WORD PTR 2[BX],DX	;Save paragraph portion 
 0B0E  07                       	POP	ES 
 0B0F  5A                       	POP	DX 
 0B10  C3                       	RET 
                                 
                                ;SETVEC - Set an interrupt vector 
                                ;ENTRY  - AX    = interrupt number 
                                ;         ES:DX = new interrupt vector 
                                ;EXIT   - All registers preserved 
                                ; 
 0B11  50                       SETVEC:	PUSH	AX 
 0B12  53                       	PUSH	BX 
 0B13  51                       	PUSH	CX 
 0B14  52                       	PUSH	DX 
 0B15  E8 0B22 R                	CALL	XCESDS		;Swap ES and DS 
                                	DOSIO	37D		;Set interrupt 
 0B1C  E8 0B22 R                	CALL	XCESDS		;Swap ES and ES back 
 0B1F  E9 08EF R                	JMP	PDCBAX		;POP DX,CX,BX,AX and RET 
                                 
 0B22  06                       XCESDS:	PUSH	ES 
 0B23  1E                       	PUSH	DS 
 0B24  07                       	POP	ES 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModulePage     1-55
MSDOS   Abort/Initialization/Termination Processing         

 0B25  1F                       	POP	DS 
 0B26  C3                       	RET 
                                 
                                ;GETVEC - Get current interrupt vector 
                                ;ENTRY  - AX    = interrupt number 
                                ;EXIT   - ES:DX = interrupt vector 
                                ;         All other registers preserved 
                                ; 
 0B27  50                       GETVEC:	PUSH	AX 
 0B28  53                       	PUSH	BX 
 0B29  1E                       	PUSH	DS 
 0B2A  D1 E0                    	SHL	AX,1 
 0B2C  D1 E0                    	SHL	AX,1		;Calculate interrupt address 
 0B2E  8B D8                    	MOV	BX,AX 
 0B30  33 C0                    	XOR	AX,AX 
 0B32  8E D8                    	MOV	DS,AX		;Get interrupt paragraph 
 0B34  C4 17                    	LES	DX,DWORD PTR 0[BX]	;Get interrupt vector 
 0B36  1F                       	POP	DS 
 0B37  5B                       	POP	BX 
 0B38  58                       	POP	AX 
 0B39  C3                       	RET 
 0B3A                           CSEG	ENDS 
                                	END 

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-1
                                                             

Macros:

		N a m e			Lines

ACRLF  . . . . . . . . . . . . .  	   2
ADR  . . . . . . . . . . . . . .  	   1
CALLOS . . . . . . . . . . . . .  	   4
CHRGET . . . . . . . . . . . . .  	   1
COMPAR . . . . . . . . . . . . .  	   2
DBGBRK . . . . . . . . . . . . .  	   1
DC . . . . . . . . . . . . . . .  	   6
DJNZ . . . . . . . . . . . . . .  	   2
DOSIO  . . . . . . . . . . . . .  	   2
FSIGN  . . . . . . . . . . . . .  	   1
GETYPE . . . . . . . . . . . . .  	   1
INS86  . . . . . . . . . . . . .  	  13
INST . . . . . . . . . . . . . .  	   1
LDDR . . . . . . . . . . . . . .  	   8
LDIR . . . . . . . . . . . . . .  	   8
MOVRI  . . . . . . . . . . . . .  	   6
OUTCHR . . . . . . . . . . . . .  	   1
POPR . . . . . . . . . . . . . .  	   2
PUSHM  . . . . . . . . . . . . .  	   5
PUSHR  . . . . . . . . . . . . .  	   2
ROFFST . . . . . . . . . . . . .  	   2
SYNCHK . . . . . . . . . . . . .  	   2

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CSEG . . . . . . . . . . . . . .  	0B3A	PARA	PUBLIC	'CODESG'
DSEG . . . . . . . . . . . . . .  	0000	PARA	PUBLIC	'DATASG'

Symbols:            

                N a m e         	Type	Value	Attr         

ADRGET . . . . . . . . . . . . .  	L NEAR	0432	CSEG	Global
ALTAIR . . . . . . . . . . . . .  	Number	0000	
ANSI . . . . . . . . . . . . . .  	Number	0001	
ARYTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ASCBS  . . . . . . . . . . . . .  	Number	0008	
ASCCR  . . . . . . . . . . . . .  	Number	000D	
ASCCTC . . . . . . . . . . . . .  	Number	0003	
ASCCTS . . . . . . . . . . . . .  	Number	0013	
ASCCTZ . . . . . . . . . . . . .  	Number	001A	
ASCESC . . . . . . . . . . . . .  	Number	001B	
ASCLF  . . . . . . . . . . . . .  	Number	000A	
ASCSPC . . . . . . . . . . . . .  	Number	0020	
ASCTAB . . . . . . . . . . . . .  	Number	0009	
ASPA2  . . . . . . . . . . . . .  	L NEAR	035A	CSEG
ASPAC  . . . . . . . . . . . . .  	L NEAR	035C	CSEG

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-2
                                                             

BADFDB . . . . . . . . . . . . .  	L NEAR	0908	CSEG
BAKCHR . . . . . . . . . . . . .  	L NEAR	05B2	CSEG	Global
BASDEB . . . . . . . . . . . . .  	Number	0000	
BCHRSI . . . . . . . . . . . . .  	L NEAR	05BC	CSEG	Global
BEEPSW . . . . . . . . . . . . .  	Number	0001	
BINCSW . . . . . . . . . . . . .  	Number	0000	
BINFID . . . . . . . . . . . . .  	Number	00FF	
BINPSV . . . . . . . . . . . . .  	L NEAR	05CF	CSEG	Global
BINSAV . . . . . . . . . . . . .  	L NEAR	05C4	CSEG	Global
BINSVX . . . . . . . . . . . . .  	L NEAR	05E3	CSEG
BLOAD  . . . . . . . . . . . . .  	L NEAR	01C6	CSEG	Global
BLODP  . . . . . . . . . . . . .  	L NEAR	01D1	CSEG
BLODSW . . . . . . . . . . . . .  	Number	0001	
BNAMOK . . . . . . . . . . . . .  	L NEAR	0215	CSEG
BPARM2 . . . . . . . . . . . . .  	L NEAR	021E	CSEG
BPARM3 . . . . . . . . . . . . .  	L NEAR	0230	CSEG
BPARMS . . . . . . . . . . . . .  	L NEAR	020A	CSEG
BSAVE  . . . . . . . . . . . . .  	L NEAR	018F	CSEG	Global
BSVFID . . . . . . . . . . . . .  	Number	00FD	
BUFLEN . . . . . . . . . . . . .  	Number	00FF	
BUFMIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
BUMPQP . . . . . . . . . . . . .  	L NEAR	09EF	CSEG
BUMPQX . . . . . . . . . . . . .  	L NEAR	09F8	CSEG

CASSW  . . . . . . . . . . . . .  	Number	0000	
CAYSTR . . . . . . . . . . . . .  	L NEAR	0975	CSEG
CAYVA2 . . . . . . . . . . . . .  	L NEAR	0956	CSEG
CAYVAR . . . . . . . . . . . . .  	L NEAR	0958	CSEG
CDEV1  . . . . . . . . . . . . .  	L NEAR	0745	CSEG
CDEV2  . . . . . . . . . . . . .  	L NEAR	0747	CSEG
CDEVID . . . . . . . . . . . . .  	L NEAR	073C	CSEG
CHKCOM . . . . . . . . . . . . .  	L NEAR	02FE	CSEG
CHNFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CHNRET . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CHRGTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CHSEAT . . . . . . . . . . . . .  	Number	0001	
CLMWID . . . . . . . . . . . . .  	Number	000E	
CLOS1  . . . . . . . . . . . . .  	L NEAR	0107	CSEG
CLOSE  . . . . . . . . . . . . .  	L NEAR	0102	CSEG	Global
CLSAL1 . . . . . . . . . . . . .  	L NEAR	04A0	CSEG
CLSALL . . . . . . . . . . . . .  	L NEAR	049A	CSEG	Global
CLSALX . . . . . . . . . . . . .  	L NEAR	04B2	CSEG
CLSFIL . . . . . . . . . . . . .  	L NEAR	04B5	CSEG	Global
CLSFL1 . . . . . . . . . . . . .  	L NEAR	04C7	CSEG
CMPUTN . . . . . . . . . . . . .  	Number	0000	
COMMNT . . . . . . . . . . . . .  	Number	0000	
COMPRT . . . . . . . . . . . . .  	L NEAR	02F4	CSEG
CONINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CONSSW . . . . . . . . . . . . .  	Number	0001	
CONTO  . . . . . . . . . . . . .  	Number	000F	
CONTRO . . . . . . . . . . . . .  	Number	0001	
CPM  . . . . . . . . . . . . . .  	Number	0001	
CPM110 . . . . . . . . . . . . .  	Number	0000	
CPM2 . . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-3
                                                             

CPM86  . . . . . . . . . . . . .  	Number	0000	
CPMA75 . . . . . . . . . . . . .  	Number	0000	
CPMADD . . . . . . . . . . . . .  	Number	0000	
CPMCON . . . . . . . . . . . . .  	Number	0000	
CPMLIF . . . . . . . . . . . . .  	Number	0000	
CPMMDS . . . . . . . . . . . . .  	Number	0000	
CPMPER . . . . . . . . . . . . .  	Number	0000	
CPMRSH . . . . . . . . . . . . .  	Number	0000	
CPMSBC . . . . . . . . . . . . .  	Number	0000	
CPMSER . . . . . . . . . . . . .  	Number	0000	
CRDO . . . . . . . . . . . . . .  	L NEAR	0581	CSEG	Global
CRDONZ . . . . . . . . . . . . .  	L NEAR	0573	CSEG	Global
CRFIN  . . . . . . . . . . . . .  	L NEAR	0570	CSEG	Global
CRIFEL . . . . . . . . . . . . .  	L NEAR	068B	CSEG	Global
CRONLY . . . . . . . . . . . . .  	Number	0000	
CRTWD  . . . . . . . . . . . . .  	L NEAR	017F	CSEG
CRTWD1 . . . . . . . . . . . . .  	L NEAR	0180	CSEG
CSKPVA . . . . . . . . . . . . .  	L NEAR	0950	CSEG
CSRTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSRX . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSRY . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CSVAR  . . . . . . . . . . . . .  	L NEAR	0940	CSEG
CTLCAD . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
C_BUFF . . . . . . . . . . . . .  	Number	001A	
C_CLOS . . . . . . . . . . . . .  	Number	0010	
C_DCIO . . . . . . . . . . . . .  	Number	0006	
C_DELE . . . . . . . . . . . . .  	Number	0013	
C_GDRV . . . . . . . . . . . . .  	Number	0019	
C_MAKE . . . . . . . . . . . . .  	Number	0016	
C_OPEN . . . . . . . . . . . . .  	Number	000F	
C_PARS . . . . . . . . . . . . .  	Number	0029	
C_PRTO . . . . . . . . . . . . .  	Number	0005	
C_RBR  . . . . . . . . . . . . .  	Number	0027	
C_READ . . . . . . . . . . . . .  	Number	0014	
C_RENA . . . . . . . . . . . . .  	Number	0017	
C_REST . . . . . . . . . . . . .  	Number	000D	
C_RNDR . . . . . . . . . . . . .  	Number	0021	
C_RNDW . . . . . . . . . . . . .  	Number	0022	
C_SDRV . . . . . . . . . . . . .  	Number	000E	
C_SEAR . . . . . . . . . . . . .  	Number	0011	

DATOFS . . . . . . . . . . . . .  	Number	0039	
DATPSC . . . . . . . . . . . . .  	Number	0080	
DBLCHR . . . . . . . . . . . . .  	Number	0000	
DBLTRN . . . . . . . . . . . . .  	Number	0000	
DEBUG  . . . . . . . . . . . . .  	Text  		
DEFSAD . . . . . . . . . . . . .  	L NEAR	01FB	CSEG
DERBFM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DERBFN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DERDNA . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DERFAO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DERFDR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DERFNO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DERIFN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-4
                                                             

DERRPE . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DEVBIN . . . . . . . . . . . . .  	L NEAR	05E6	CSEG	Global
DEVBOT . . . . . . . . . . . . .  	L NEAR	05FB	CSEG	Global
DEVINI . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DEVLOP . . . . . . . . . . . . .  	L NEAR	07FF	CSEG
DEVNM  . . . . . . . . . . . . .  	L NEAR	07EA	CSEG
DEVPTR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DEVRET . . . . . . . . . . . . .  	L NEAR	081D	CSEG
DEVSCN . . . . . . . . . . . . .  	L NEAR	07DA	CSEG
DEVSRC . . . . . . . . . . . . .  	L NEAR	07FD	CSEG
DEVTBL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DEVTRM . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DFSTLD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DINTAD . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DIRDO  . . . . . . . . . . . . .  	L NEAR	0425	CSEG	Global
DISK . . . . . . . . . . . . . .  	Number	0001	
DMC  . . . . . . . . . . . . . .  	Number	0000	
DOALDV . . . . . . . . . . . . .  	L NEAR	0A34	CSEG
DOALLP . . . . . . . . . . . . .  	L NEAR	0A3D	CSEG
DOALLX . . . . . . . . . . . . .  	L NEAR	0A49	CSEG
DOS  . . . . . . . . . . . . . .  	Number	0000	
DOSIZT . . . . . . . . . . . . .  	L NEAR	0345	CSEG
DPUTG  . . . . . . . . . . . . .  	L NEAR	0399	CSEG	Global
DRVPOS . . . . . . . . . . . . .  	Number	0000	
DSKERR . . . . . . . . . . . . .  	L NEAR	0AA6	CSEG
DSKERX . . . . . . . . . . . . .  	L NEAR	0ABC	CSEG
DSKNAM . . . . . . . . . . . . .  	L NEAR	0834	CSEG
DUPONT . . . . . . . . . . . . .  	Number	0000	
DYNCOM . . . . . . . . . . . . .  	Number	0001	

EDIT80 . . . . . . . . . . . . .  	Number	0000	
EOF  . . . . . . . . . . . . . .  	L NEAR	036E	CSEG	Global
EQULTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERBFM0 . . . . . . . . . . . . .  	L NEAR	004B	CSEG
ERBFM1 . . . . . . . . . . . . .  	L NEAR	03C7	CSEG
ERBFM2 . . . . . . . . . . . . .  	L NEAR	0207	CSEG
ERBFM3 . . . . . . . . . . . . .  	L NEAR	0402	CSEG
ERBFM4 . . . . . . . . . . . . .  	L NEAR	0882	CSEG
ERBFM6 . . . . . . . . . . . . .  	L NEAR	056D	CSEG
ERBFN1 . . . . . . . . . . . . .  	L NEAR	03DF	CSEG
ERBFN2 . . . . . . . . . . . . .  	L NEAR	06BD	CSEG
ERDNA1 . . . . . . . . . . . . .  	L NEAR	018C	CSEG
ERDNA2 . . . . . . . . . . . . .  	L NEAR	0753	CSEG
ERFAO1 . . . . . . . . . . . . .  	L NEAR	0497	CSEG
ERFDR  . . . . . . . . . . . . .  	L NEAR	042F	CSEG
ERFNO1 . . . . . . . . . . . . .  	L NEAR	0189	CSEG
ERFNO2 . . . . . . . . . . . . .  	L NEAR	0750	CSEG
ERFNO3 . . . . . . . . . . . . .  	L NEAR	0405	CSEG
ERFNO4 . . . . . . . . . . . . .  	L NEAR	0389	CSEG
ERIFN0 . . . . . . . . . . . . .  	L NEAR	0186	CSEG
ERIFN1 . . . . . . . . . . . . .  	L NEAR	07A0	CSEG
ERIFN2 . . . . . . . . . . . . .  	L NEAR	0831	CSEG
ERRDME . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRDNR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-5
                                                             

ERRDWP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERROM  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERROR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ESCCTL . . . . . . . . . . . . .  	Number	0000	
EXIDY  . . . . . . . . . . . . .  	Number	0000	
EXPTAB . . . . . . . . . . . . .  	L NEAR	0674	CSEG	Global
EXTABL . . . . . . . . . . . . .  	L NEAR	067F	CSEG
EXTABX . . . . . . . . . . . . .  	L NEAR	0688	CSEG

FACDSP . . . . . . . . . . . . .  	L NEAR	06C0	CSEG
FACFPT . . . . . . . . . . . . .  	L NEAR	089B	CSEG
FACLO  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FALC1  . . . . . . . . . . . . .  	L NEAR	08BE	CSEG
FALCOK . . . . . . . . . . . . .  	L NEAR	08DC	CSEG
FALLOC . . . . . . . . . . . . .  	L NEAR	08B5	CSEG
FAPAS1 . . . . . . . . . . . . .  	L NEAR	08D3	CSEG
FAST . . . . . . . . . . . . . .  	Number	0001	
FCBSIZ . . . . . . . . . . . . .  	Number	0026	
FCB_DT . . . . . . . . . . . . .  	Number	001D	
FCB_DV . . . . . . . . . . . . .  	Number	0007	
FCB_EX . . . . . . . . . . . . .  	Number	0013	
FCB_FN . . . . . . . . . . . . .  	Number	0008	
FCB_FS . . . . . . . . . . . . .  	Number	0017	
FCB_FT . . . . . . . . . . . . .  	Number	0010	
FCB_NR . . . . . . . . . . . . .  	Number	0027	
FCB_RC . . . . . . . . . . . . .  	Number	0015	
FCB_RN . . . . . . . . . . . . .  	Number	0028	
FCERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FCERR1 . . . . . . . . . . . . .  	L NEAR	00FC	CSEG
FCERR2 . . . . . . . . . . . . .  	L NEAR	0183	CSEG
FCERR3 . . . . . . . . . . . . .  	L NEAR	0494	CSEG
FCERR9 . . . . . . . . . . . . .  	L NEAR	06DA	CSEG
FC_ASC . . . . . . . . . . . . .  	Number	0000	
FC_BIN . . . . . . . . . . . . .  	Number	0001	
FDBPTR . . . . . . . . . . . . .  	L NEAR	089E	CSEG
FDBSIZ . . . . . . . . . . . . .  	Number	0039	
FD_DAT . . . . . . . . . . . . .  	Number	00C2	
FD_LOG . . . . . . . . . . . . .  	Number	00BD	
FD_OPS . . . . . . . . . . . . .  	Number	00C0	
FD_PHY . . . . . . . . . . . . .  	Number	00BB	
FD_SIZ . . . . . . . . . . . . .  	Number	00B9	
FFNDL  . . . . . . . . . . . . .  	L NEAR	0902	CSEG
FFOUND . . . . . . . . . . . . .  	L NEAR	0914	CSEG
FFREE  . . . . . . . . . . . . .  	L NEAR	08F4	CSEG
FILDEV . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FILDSP . . . . . . . . . . . . .  	L NEAR	06C7	CSEG
FILEXT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FILGET . . . . . . . . . . . . .  	L NEAR	03E4	CSEG	Global
FILID2 . . . . . . . . . . . . .  	L NEAR	040D	CSEG
FILIDX . . . . . . . . . . . . .  	L NEAR	040B	CSEG
FILINP . . . . . . . . . . . . .  	L NEAR	03E2	CSEG	Global
FILLNM . . . . . . . . . . . . .  	L NEAR	07B2	CSEG
FILMOD . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FILNM  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-6
                                                             

FILNM0 . . . . . . . . . . . . .  	L NEAR	07B5	CSEG
FILOPT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FILOU3 . . . . . . . . . . . . .  	L NEAR	058E	CSEG	Global
FILSCN . . . . . . . . . . . . .  	L NEAR	0408	CSEG	Global
FILSET . . . . . . . . . . . . .  	L NEAR	03FB	CSEG	Global
FILSPC . . . . . . . . . . . . .  	L NEAR	07C8	CSEG
FILTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FILWID . . . . . . . . . . . . .  	L NEAR	0162	CSEG
FININL . . . . . . . . . . . . .  	L NEAR	057B	CSEG	Global
FINLPT . . . . . . . . . . . . .  	L NEAR	0A4A	CSEG	Global
FINLPX . . . . . . . . . . . . .  	L NEAR	0A73	CSEG
FINPRT . . . . . . . . . . . . .  	L NEAR	0A74	CSEG	Global
FIVDSK . . . . . . . . . . . . .  	Number	0001	
FIVEO  . . . . . . . . . . . . .  	Number	0001	
FIVLPT . . . . . . . . . . . . .  	Number	0001	
FIVMEM . . . . . . . . . . . . .  	Number	0001	
FKEYON . . . . . . . . . . . . .  	Number	0001	
FL0EOF . . . . . . . . . . . . .  	L NEAR	04F4	CSEG
FL_BKC . . . . . . . . . . . . .  	Number	0080	
FNAML  . . . . . . . . . . . . .  	Number	000B	
FNDDEV . . . . . . . . . . . . .  	L NEAR	0813	CSEG
FOPTSZ . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FOUT . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FREFDB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FRESTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRETOP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FRMEVL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRQINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FSTLOD . . . . . . . . . . . . .  	L NEAR	0621	CSEG	Global
F_BAKC . . . . . . . . . . . . .  	Number	0032	
F_BREM . . . . . . . . . . . . .  	Number	0030	
F_CLOC . . . . . . . . . . . . .  	Number	002D	
F_CODE . . . . . . . . . . . . .  	Number	0031	
F_DEV  . . . . . . . . . . . . .  	Number	0034	
F_FCB  . . . . . . . . . . . . .  	Number	0007	
F_FLGS . . . . . . . . . . . . .  	Number	0037	
F_MODE . . . . . . . . . . . . .  	Number	0006	
F_NEXT . . . . . . . . . . . . .  	Number	0004	
F_NUL1 . . . . . . . . . . . . .  	Number	0000	
F_NUL2 . . . . . . . . . . . . .  	Number	0002	
F_NUL3 . . . . . . . . . . . . .  	Number	0033	
F_NUL4 . . . . . . . . . . . . .  	Number	0036	
F_NUL5 . . . . . . . . . . . . .  	Number	00BF	
F_NUM  . . . . . . . . . . . . .  	Number	0001	
F_ORCT . . . . . . . . . . . . .  	Number	002F	
F_POS  . . . . . . . . . . . . .  	Number	0038	
F_WID  . . . . . . . . . . . . .  	Number	0035	

GARBA2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GDFILM . . . . . . . . . . . . .  	L NEAR	03F7	CSEG
GENBIN . . . . . . . . . . . . .  	Number	0001	
GENDSK . . . . . . . . . . . . .  	Number	0000	
GENFUN . . . . . . . . . . . . .  	L NEAR	038E	CSEG
GENIO  . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-7
                                                             

GESBC  . . . . . . . . . . . . .  	Number	0000	
GETBKC . . . . . . . . . . . . .  	L NEAR	0565	CSEG
GETBYT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GETNZB . . . . . . . . . . . . .  	L NEAR	03D3	CSEG
GETPTR . . . . . . . . . . . . .  	L NEAR	041A	CSEG	Global
GETQ . . . . . . . . . . . . . .  	L NEAR	09DD	CSEG	Global
GETVEC . . . . . . . . . . . . .  	L NEAR	0B27	CSEG
GETWDT . . . . . . . . . . . . .  	L NEAR	0177	CSEG
GETYPR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GFUNX  . . . . . . . . . . . . .  	L NEAR	0391	CSEG
GIO86  . . . . . . . . . . . . .  	Number	0001	
GIOINI . . . . . . . . . . . . .  	L NEAR	0A0F	CSEG	Global
GIOTRM . . . . . . . . . . . . .  	L NEAR	0A29	CSEG	Global
GONE . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GOTMD1 . . . . . . . . . . . . .  	L NEAR	009E	CSEG
GOTMOD . . . . . . . . . . . . .  	L NEAR	00A1	CSEG
GPTRF  . . . . . . . . . . . . .  	L NEAR	08B2	CSEG
GPTRL  . . . . . . . . . . . . .  	L NEAR	08A2	CSEG
GPTRX  . . . . . . . . . . . . .  	L NEAR	08B4	CSEG
GQEMTY . . . . . . . . . . . . .  	L NEAR	09EE	CSEG
GW . . . . . . . . . . . . . . .  	Number	0001	
GWCASS . . . . . . . . . . . . .  	Number	0000	
GWDBUG . . . . . . . . . . . . .  	Number	0000	
GWWID  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
G_BIN  . . . . . . . . . . . . .  	Number	001A	
G_BOT  . . . . . . . . . . . . .  	Number	001C	
G_CLS  . . . . . . . . . . . . .  	Number	0006	
G_EOF  . . . . . . . . . . . . .  	Number	0000	
G_GCW  . . . . . . . . . . . . .  	Number	0018	
G_GPS  . . . . . . . . . . . . .  	Number	0012	
G_GWD  . . . . . . . . . . . . .  	Number	0014	
G_LOC  . . . . . . . . . . . . .  	Number	0002	
G_LOF  . . . . . . . . . . . . .  	Number	0004	
G_OPN  . . . . . . . . . . . . .  	Number	000C	
G_RND  . . . . . . . . . . . . .  	Number	000A	
G_SCW  . . . . . . . . . . . . .  	Number	0016	
G_SIN  . . . . . . . . . . . . .  	Number	000E	
G_SOT  . . . . . . . . . . . . .  	Number	0010	
G_SWD  . . . . . . . . . . . . .  	Number	0008	

HAVMD1 . . . . . . . . . . . . .  	L NEAR	003B	CSEG
HAVMOD . . . . . . . . . . . . .  	L NEAR	0032	CSEG
HEATH  . . . . . . . . . . . . .  	Number	0000	
HEXOCT . . . . . . . . . . . . .  	Number	0001	
HGHBIT . . . . . . . . . . . . .  	Number	0001	

I8086  . . . . . . . . . . . . .  	Number	0001	
I8251  . . . . . . . . . . . . .  	Number	0000	
IBMCSR . . . . . . . . . . . . .  	Number	0001	
IBMLIK . . . . . . . . . . . . .  	Number	0001	
IBMTOK . . . . . . . . . . . . .  	Number	0001	
IMOD . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INCEOF . . . . . . . . . . . . .  	L NEAR	055B	CSEG
INCHR  . . . . . . . . . . . . .  	L NEAR	04E5	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-8
                                                             

INCHRE . . . . . . . . . . . . .  	L NEAR	0534	CSEG
INCHRI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INCHRX . . . . . . . . . . . . .  	L NEAR	0532	CSEG
INCHSI . . . . . . . . . . . . .  	L NEAR	0538	CSEG	Global
INCLEN . . . . . . . . . . . . .  	L NEAR	02C8	CSEG
INDSKC . . . . . . . . . . . . .  	L NEAR	0534	CSEG	Global
INGFDB . . . . . . . . . . . . .  	L NEAR	0541	CSEG
INIFDB . . . . . . . . . . . . .  	L NEAR	084E	CSEG	Global
INITQ  . . . . . . . . . . . . .  	L NEAR	09C0	CSEG	Global
INKEYF . . . . . . . . . . . . .  	Number	0001	
INLADD . . . . . . . . . . . . .  	Number	0000	
INP16  . . . . . . . . . . . . .  	L NEAR	05A3	CSEG
INP16X . . . . . . . . . . . . .  	L NEAR	05B0	CSEG
INPBLK . . . . . . . . . . . . .  	L NEAR	0617	CSEG
INSTSW . . . . . . . . . . . . .  	Number	0000	
INTEL  . . . . . . . . . . . . .  	Number	0000	
INTFHW . . . . . . . . . . . . .  	Number	0000	
INTFSW . . . . . . . . . . . . .  	Number	0000	
INTID2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INTLEC . . . . . . . . . . . . .  	Number	0000	
INTROM . . . . . . . . . . . . .  	Number	0000	
IOJUMP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ISC  . . . . . . . . . . . . . .  	Number	0000	
ISIS . . . . . . . . . . . . . .  	Number	0000	
ITSWLP . . . . . . . . . . . . .  	L NEAR	0153	CSEG

JISKTN . . . . . . . . . . . . .  	Number	0000	
JPRINU . . . . . . . . . . . . .  	L NEAR	024C	CSEG

KANABS . . . . . . . . . . . . .  	Number	0000	
KANJFN . . . . . . . . . . . . .  	Number	0000	
KEYSTA . . . . . . . . . . . . .  	Number	0000	
KILLER . . . . . . . . . . . . .  	Number	0000	
KYBSIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

LABKEY . . . . . . . . . . . . .  	Number	0001	
LDREOF . . . . . . . . . . . . .  	L NEAR	04FC	CSEG
LEN2 . . . . . . . . . . . . . .  	Number	0001	
LEN3 . . . . . . . . . . . . . .  	Number	0001	
LENGTH . . . . . . . . . . . . .  	Number	0002	
LFTQ . . . . . . . . . . . . . .  	L NEAR	09F9	CSEG	Global
LINCH2 . . . . . . . . . . . . .  	L NEAR	02ED	CSEG
LINCHK . . . . . . . . . . . . .  	L NEAR	02E8	CSEG
LINLN  . . . . . . . . . . . . .  	Number	0050	
LISTEN . . . . . . . . . . . . .  	Number	0001	
LNGVAR . . . . . . . . . . . . .  	Number	0001	
LNOMOD . . . . . . . . . . . . .  	L NEAR	0336	CSEG
LOC  . . . . . . . . . . . . . .  	L NEAR	038C	CSEG	Global
LODEND . . . . . . . . . . . . .  	L NEAR	0203	CSEG
LOF  . . . . . . . . . . . . . .  	L NEAR	0394	CSEG	Global
LOKHED . . . . . . . . . . . . .  	Number	0000	
LONGI  . . . . . . . . . . . . .  	Number	0000	
LPDSP  . . . . . . . . . . . . .  	L NEAR	06FE	CSEG
LPRINT . . . . . . . . . . . . .  	L NEAR	0256	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-9
                                                             

LPT3 . . . . . . . . . . . . . .  	Number	0000	
LPTLEN . . . . . . . . . . . . .  	Number	0084	
LPTSW  . . . . . . . . . . . . .  	Number	0001	

MAKINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MDS  . . . . . . . . . . . . . .  	Number	0000	
MDSISS . . . . . . . . . . . . .  	Number	0000	
MD_APP . . . . . . . . . . . . .  	Number	0008	
MD_RND . . . . . . . . . . . . .  	Number	0004	
MD_SQI . . . . . . . . . . . . .  	Number	0001	
MD_SQO . . . . . . . . . . . . .  	Number	0002	
MEMIMG . . . . . . . . . . . . .  	Number	0001	
MEMSIZ . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
MODCM1 . . . . . . . . . . . . .  	L NEAR	02C2	CSEG
MODCOM . . . . . . . . . . . . .  	L NEAR	02C0	CSEG
MORCOM . . . . . . . . . . . . .  	L NEAR	0305	CSEG
MOSTEK . . . . . . . . . . . . .  	Number	0000	
MSCTLC . . . . . . . . . . . . .  	L NEAR	0ABF	CSEG
MSDCCF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
MSIRST . . . . . . . . . . . . .  	L NEAR	0AEB	CSEG
MSISET . . . . . . . . . . . . .  	L NEAR	0AC5	CSEG
MULSEG . . . . . . . . . . . . .  	Number	0001	

NAMBAS . . . . . . . . . . . . .  	L NEAR	0451	CSEG
NAMBAX . . . . . . . . . . . . .  	L NEAR	0469	CSEG
NAMLEN . . . . . . . . . . . . .  	Number	0028	
NAMSC1 . . . . . . . . . . . . .  	L NEAR	0759	CSEG
NAMSCN . . . . . . . . . . . . .  	L NEAR	0756	CSEG	Global
NASCOM . . . . . . . . . . . . .  	Number	0000	
NATROM . . . . . . . . . . . . .  	Number	0000	
NBANKS . . . . . . . . . . . . .  	Number	0001	
NCRBAS . . . . . . . . . . . . .  	Number	0000	
NCRCAS . . . . . . . . . . . . .  	Number	0000	
NCRDEB . . . . . . . . . . . . .  	Number	0000	
NCRELS . . . . . . . . . . . . .  	Number	0000	
NCRLPT . . . . . . . . . . . . .  	Number	0001	
NECBAS . . . . . . . . . . . . .  	Number	0000	
NEWCHR . . . . . . . . . . . . .  	L NEAR	0267	CSEG
NEWSTT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NFRFDB . . . . . . . . . . . . .  	L NEAR	0A91	CSEG
NLONLY . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NMCOMT . . . . . . . . . . . . .  	Number	0002	
NMKEYF . . . . . . . . . . . . .  	Number	000A	
NMKEYT . . . . . . . . . . . . .  	Number	000E	
NMLINE . . . . . . . . . . . . .  	Number	0019	
NMLPT  . . . . . . . . . . . . .  	Number	0003	
NMPENT . . . . . . . . . . . . .  	Number	0001	
NMSTRT . . . . . . . . . . . . .  	Number	0004	
NMTCH1 . . . . . . . . . . . . .  	L NEAR	0821	CSEG
NMTCH2 . . . . . . . . . . . . .  	L NEAR	0828	CSEG
NOATDL . . . . . . . . . . . . .  	Number	0000	
NOCR . . . . . . . . . . . . . .  	L NEAR	06A2	CSEG
NOCTLA . . . . . . . . . . . . .  	Number	0000	
NODOT  . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-10
                                                             

NODVNM . . . . . . . . . . . . .  	L NEAR	07E2	CSEG
NOEDIT . . . . . . . . . . . . .  	Number	0000	
NOIOS  . . . . . . . . . . . . .  	Number	0000	
NOLBS  . . . . . . . . . . . . .  	L NEAR	010E	CSEG
NOLEN  . . . . . . . . . . . . .  	L NEAR	00F9	CSEG
NOMTCH . . . . . . . . . . . . .  	L NEAR	0822	CSEG
NONULL . . . . . . . . . . . . .  	Number	0000	
NOPEKS . . . . . . . . . . . . .  	Number	0000	
NOROMP . . . . . . . . . . . . .  	Number	0000	
NORUBT . . . . . . . . . . . . .  	Number	0000	
NORUNC . . . . . . . . . . . . .  	L NEAR	0524	CSEG
NOTABR . . . . . . . . . . . . .  	L NEAR	0367	CSEG
NOTCHN . . . . . . . . . . . . .  	L NEAR	0506	CSEG
NOTCR  . . . . . . . . . . . . .  	L NEAR	06B2	CSEG
NOTDSK . . . . . . . . . . . . .  	L NEAR	0770	CSEG
NOTLPR . . . . . . . . . . . . .  	L NEAR	0134	CSEG
NOTNSO . . . . . . . . . . . . .  	L NEAR	004E	CSEG
NOTTAB . . . . . . . . . . . . .  	L NEAR	0689	CSEG
NOUSR  . . . . . . . . . . . . .  	Number	0000	
NOVARP . . . . . . . . . . . . .  	Number	0000	
NPRINT . . . . . . . . . . . . .  	L NEAR	06AB	CSEG
NTAPP  . . . . . . . . . . . . .  	L NEAR	0082	CSEG
NTOPEN . . . . . . . . . . . . .  	L NEAR	0419	CSEG
NULOPM . . . . . . . . . . . . .  	L NEAR	046A	CSEG	Global
NULOPN . . . . . . . . . . . . .  	L NEAR	046D	CSEG
NUMLEV . . . . . . . . . . . . .  	Number	006E	
NUMQ . . . . . . . . . . . . . .  	L NEAR	0A01	CSEG	Global
NUMQ1  . . . . . . . . . . . . .  	L NEAR	0A06	CSEG
NUMQX  . . . . . . . . . . . . .  	L NEAR	0A0E	CSEG
NUMTMP . . . . . . . . . . . . .  	Number	000A	
NUMTRP . . . . . . . . . . . . .  	Number	0015	

OEMRAM . . . . . . . . . . . . .  	Number	0000	
ONTEL  . . . . . . . . . . . . .  	Number	0000	
OPEN . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	Global
OPEN1  . . . . . . . . . . . . .  	L NEAR	00B4	CSEG
OPNFIL . . . . . . . . . . . . .  	L NEAR	0471	CSEG
OUT16  . . . . . . . . . . . . .  	L NEAR	0598	CSEG
OUTBLK . . . . . . . . . . . . .  	L NEAR	060D	CSEG
OUTDO  . . . . . . . . . . . . .  	L NEAR	058E	CSEG	Global
OUTLOD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

PALSIZ . . . . . . . . . . . . .  	Number	0000	
PANBAS . . . . . . . . . . . . .  	Number	0000	
PARDEV . . . . . . . . . . . . .  	L NEAR	07D1	CSEG
PBAX . . . . . . . . . . . . . .  	L NEAR	08F1	CSEG	Global
PCBAX  . . . . . . . . . . . . .  	L NEAR	08F0	CSEG	Global
PCS  . . . . . . . . . . . . . .  	Number	0000	
PDCBAX . . . . . . . . . . . . .  	L NEAR	08EF	CSEG	Global
PFDCBA . . . . . . . . . . . . .  	L NEAR	08EE	CSEG
PLAYSW . . . . . . . . . . . . .  	Number	0001	
PNRLEN . . . . . . . . . . . . .  	L NEAR	00CC	CSEG
POFNUM . . . . . . . . . . . . .  	L NEAR	03CA	CSEG
PORLEN . . . . . . . . . . . . .  	L NEAR	00C1	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-11
                                                             

PQFULL . . . . . . . . . . . . .  	L NEAR	09DC	CSEG
PRFNUM . . . . . . . . . . . . .  	L NEAR	03CF	CSEG
PRGFIL . . . . . . . . . . . . .  	L NEAR	043F	CSEG	Global
PRGFIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRGFIX . . . . . . . . . . . . .  	L NEAR	044F	CSEG
PRINT  . . . . . . . . . . . . .  	L NEAR	025E	CSEG	Global
PRINT1 . . . . . . . . . . . . .  	L NEAR	0263	CSEG
PRINTC . . . . . . . . . . . . .  	L NEAR	026D	CSEG
PRINTX . . . . . . . . . . . . .  	L NEAR	024F	CSEG
PRINUS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRLENC . . . . . . . . . . . . .  	L NEAR	00E7	CSEG
PRLENX . . . . . . . . . . . . .  	L NEAR	00E6	CSEG
PRNTX1 . . . . . . . . . . . . .  	L NEAR	0252	CSEG
PROCHK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRODIR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PROFID . . . . . . . . . . . . .  	Number	00FE	
PRTS . . . . . . . . . . . . . .  	L NEAR	028C	CSEG
PTRDSP . . . . . . . . . . . . .  	L NEAR	06DD	CSEG	Global
PTRFIL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PTRGPS . . . . . . . . . . . . .  	L NEAR	0637	CSEG	Global
PTRWD1 . . . . . . . . . . . . .  	L NEAR	0665	CSEG
PTRWDC . . . . . . . . . . . . .  	L NEAR	0641	CSEG
PTRWDL . . . . . . . . . . . . .  	L NEAR	0646	CSEG
PTRWID . . . . . . . . . . . . .  	L NEAR	0655	CSEG	Global
PURE . . . . . . . . . . . . . .  	Number	0001	
PUTQ . . . . . . . . . . . . . .  	L NEAR	09CE	CSEG	Global

QUEUE  . . . . . . . . . . . . .  	Number	0001	
Q_BUF  . . . . . . . . . . . . .  	Number	0004	
Q_END  . . . . . . . . . . . . .  	Number	0006	
Q_GET  . . . . . . . . . . . . .  	Number	0002	
Q_PUT  . . . . . . . . . . . . .  	Number	0000	

REALIO . . . . . . . . . . . . .  	Number	0001	
REDDY  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RELRN1 . . . . . . . . . . . . .  	L NEAR	03BF	CSEG
RELRND . . . . . . . . . . . . .  	L NEAR	03BD	CSEG
REPOUT . . . . . . . . . . . . .  	L NEAR	0360	CSEG
RET22  . . . . . . . . . . . . .  	L NEAR	04E4	CSEG
RET27  . . . . . . . . . . . . .  	L NEAR	060C	CSEG
RET45  . . . . . . . . . . . . .  	L NEAR	0AA5	CSEG
RET6 . . . . . . . . . . . . . .  	L NEAR	0176	CSEG
RET9 . . . . . . . . . . . . . .  	L NEAR	03DE	CSEG
RMX  . . . . . . . . . . . . . .  	Number	0000	
RSHACK . . . . . . . . . . . . .  	Number	0000	
RSTLES . . . . . . . . . . . . .  	Number	0001	
RUNC . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RUNFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External

SAVFRE . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SAVLEN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SAVSEG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SAVVEC . . . . . . . . . . . . .  	L NEAR	0B02	CSEG	Global
SBC  . . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-12
                                                             

SBC86  . . . . . . . . . . . . .  	Number	0000	
SCAN1  . . . . . . . . . . . . .  	L NEAR	078F	CSEG
SCCPTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SCDASC . . . . . . . . . . . . .  	L NEAR	0885	CSEG	Global
SCDBIN . . . . . . . . . . . . .  	L NEAR	0890	CSEG	Global
SCNAM2 . . . . . . . . . . . . .  	L NEAR	07A3	CSEG
SCNAM3 . . . . . . . . . . . . .  	L NEAR	07AC	CSEG
SCOM1  . . . . . . . . . . . . .  	L NEAR	078B	CSEG
SCP  . . . . . . . . . . . . . .  	Number	0001	
SCRN86 . . . . . . . . . . . . .  	Number	0001	
SCRNIO . . . . . . . . . . . . .  	Number	0001	
SCROLT . . . . . . . . . . . . .  	Number	0001	
SETCSR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SETVEC . . . . . . . . . . . . .  	L NEAR	0B11	CSEG	Global
SGSATS . . . . . . . . . . . . .  	Number	0000	
SHORTJ . . . . . . . . . . . . .  	Number	0001	
SHTCHN . . . . . . . . . . . . .  	Number	0000	
SHTERR . . . . . . . . . . . . .  	Number	0000	
SHTINS . . . . . . . . . . . . .  	Number	0000	
SHTLHM . . . . . . . . . . . . .  	Number	0000	
SHTLIN . . . . . . . . . . . . .  	Number	0000	
SHTPRO . . . . . . . . . . . . .  	Number	0000	
SHTREN . . . . . . . . . . . . .  	Number	0000	
SIDSP  . . . . . . . . . . . . .  	L NEAR	06E7	CSEG
SIDSP1 . . . . . . . . . . . . .  	L NEAR	070B	CSEG
SIDSP2 . . . . . . . . . . . . .  	L NEAR	0711	CSEG
SIXDIG . . . . . . . . . . . . .  	Number	0000	
SKPNAM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SMALL  . . . . . . . . . . . . .  	Number	0000	
SNERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SNERR1 . . . . . . . . . . . . .  	L NEAR	00FF	CSEG
SNERR2 . . . . . . . . . . . . .  	L NEAR	01C3	CSEG
SNERR3 . . . . . . . . . . . . .  	L NEAR	0249	CSEG
SPCDSK . . . . . . . . . . . . .  	Number	0000	
SPCNDC . . . . . . . . . . . . .  	L NEAR	0326	CSEG
SPCNDS . . . . . . . . . . . . .  	Number	0000	
SPCTK  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STILOK . . . . . . . . . . . . .  	L NEAR	090A	CSEG
STKLOW . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
STRDON . . . . . . . . . . . . .  	L NEAR	02CA	CSEG
STREND . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
STRING . . . . . . . . . . . . .  	Number	0001	
STRLIT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STROUT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRPRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRSIZ . . . . . . . . . . . . .  	Number	0003	
SUPRSH . . . . . . . . . . . . .  	Number	0001	
SWAPSW . . . . . . . . . . . . .  	Number	0001	
SYNCHR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

TABER  . . . . . . . . . . . . .  	L NEAR	030F	CSEG
TABERJ . . . . . . . . . . . . .  	L NEAR	0289	CSEG
TABTK  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TBLDSP . . . . . . . . . . . . .  	L NEAR	0719	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:38:05
 
GIO86   - BASIC-86 Interpreter Device Independent I/O ModuleSymbols-13
                                                             

TBNONG . . . . . . . . . . . . .  	L NEAR	0321	CSEG
TEK  . . . . . . . . . . . . . .  	Number	0000	
TEMP . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TIMSHR . . . . . . . . . . . . .  	Number	0000	
TRNCHR . . . . . . . . . . . . .  	Number	0000	
TRSER2 . . . . . . . . . . . . .  	Number	0000	
TRUANS . . . . . . . . . . . . .  	Number	0000	
TRUROM . . . . . . . . . . . . .  	Number	0001	
TSDISK . . . . . . . . . . . . .  	Number	0000	
TSLPT  . . . . . . . . . . . . .  	Number	0000	
TXTTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External

UPCASE . . . . . . . . . . . . .  	L NEAR	0843	CSEG
UPDPOS . . . . . . . . . . . . .  	L NEAR	06A4	CSEG	Global
UPDSTD . . . . . . . . . . . . .  	L NEAR	09A5	CSEG
UPDSTU . . . . . . . . . . . . .  	L NEAR	09B9	CSEG
UPDSTX . . . . . . . . . . . . .  	L NEAR	09BC	CSEG
UPPOSX . . . . . . . . . . . . .  	L NEAR	06BC	CSEG
UPRET  . . . . . . . . . . . . .  	L NEAR	084D	CSEG
USINTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

VARECS . . . . . . . . . . . . .  	L NEAR	00DD	CSEG
VARTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External

WIDTHS . . . . . . . . . . . . .  	L NEAR	0121	CSEG	Global

XCESDS . . . . . . . . . . . . .  	L NEAR	0B22	CSEG
XFRSTR . . . . . . . . . . . . .  	L NEAR	0919	CSEG
XFRSTX . . . . . . . . . . . . .  	L NEAR	0980	CSEG
XFRSUP . . . . . . . . . . . . .  	L NEAR	0938	CSEG
XFSTX1 . . . . . . . . . . . . .  	L NEAR	0992	CSEG
XTABCR . . . . . . . . . . . . .  	L NEAR	066B	CSEG	Global
XTNSYS . . . . . . . . . . . . .  	Number	0000	

Z80  . . . . . . . . . . . . . .  	Number	0001	
Z80MAC . . . . . . . . . . . . .  	Number	0001	
ZERPOS . . . . . . . . . . . . .  	L NEAR	06AF	CSEG

$FOR . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$INPUT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$LEN . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$LPRINT  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$_KYBD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$_LPT1 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$_NDEV . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
_OFFST . . . . . . . . . . . . .  	Number	00C2	


   2805 Source  Lines
   2890 Total   Lines
    678 Symbols

  28122 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
