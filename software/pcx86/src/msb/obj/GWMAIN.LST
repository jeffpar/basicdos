Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-1
                                                            

                                ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                                 
 0008                           	.RADIX	8		; To be safe 
                                 
 0000                           CSEG	SEGMENT PUBLIC 'CODESG' 
                                	ASSUME	CS:CSEG 
                                 
                             C  INCLUDE BINTRP.INC 
                             C  ; 
                             C  ;               Include file for BINTRP.ASM 
                             C  ; 
                             C   
                             C  INCLUDE OEM.INC                   ; General def
				initions 
                             C  ; [ This translation created 10-Feb-83 by Versi
				on 4.3 ] 
                             C   
                             C  	PAGE	,132D 
                             C  	SUBTTL  Common file to produce 2-segment 8086 GW-CPM BASIC 
                             C   
                             C  	.SALL 
                             C   
 000A                        C  	.RADIX	10 
 = 0000                      C  	OEMRAM=0D 
                             C  ;Pascal program HFILE searches for the following line - DO NOT MODIFY 
                             C  ;** (VERSION SPECIFIC VALUES) ************************************************ 
 = 0019                      C  	NMLINE=25		;Max screen display text lines 
 = 0001                      C  	NBANKS=1		;Number of graphic planes 
 = 0000                      C  	PALSIZ=0		;Size of OEM color palette 
 = 0000                      C  	DBLCHR=0		;Editor support for KANJI chars 
 = 0000                      C  	KANABS=0		;Kana BASIC (Japanese JIS codes) 
 = 0000                      C  	KANJFN=0		;KANJI String Functions KPOS, KLEN .. 
 = 0000                      C  	JISKTN=0		;&K, &J constants (KANJI) 
 = 0001                      C  	SUPRSH=1		;1=super shift key feature 
 = 000A                      C  	NMKEYF=10		;number of function keys 
 = 000E                      C  	NMKEYT=14		;number of function key traps 
 = 0001                      C  	FKEYON=1		;yes=display function keys 
 = 0001                      C  	SCROLT=1		;Line 25 allocated for status only 
 = 0001                      C  	PLAYSW=1		;for PLAY statement 
 = 0001                      C  	BEEPSW=1		;for SOUND, BEEP statements 
 = 0003                      C  	NMLPT=3			;number of line printers 
 = 0001                      C  	CONSSW=1		;Device CONS: 
 = 0002                      C  	NMCOMT=2		;number of COMmunications ports 
 = 0001                      C  	NMPENT=1		;number of light pens 
 = 0004                      C  	NMSTRT=4		;number of joysticks 
 = 0000                      C  	GWCASS=0		;Cassette switch (CSAVE,CLOAD,MOTOR) 
 = 0001                      C  	IBMLIK=1		;IBM compatibility package 
 = 0001                      C  	IBMTOK=1		;IBM token compatibility 
 = 0001                      C  	DYNCOM=1		;Dynamic communication buffers 
                             C  ;** (END OF VERSION SPECIFIC VALUES) ***************************************** 
                             C  ;Pascal program HFILE searches for the previous line - DO NOT MODIFY 
                             C  ; 
 = 0015                      C  	NUMTRP=NMKEYT+NMCOMT+NMPENT+NMSTRT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-2
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0001                      C  	GW=1			;GW BASIC 
 = 0000                      C  	ESCCTL=0		;Escape Sequence processing in SCROUT 
 = 0000                      C  	GWDBUG=0		;DEBUG statement (TEST VERSIONS ONLY) 
                             C  				; Support is in BINTRP.MAC and GWSTS.MAC 
 = 0000                      C  	SIXDIG=0		;# of digits of accuracy assumed when formatting 
                             C  				;single precision numbers for output. 
                             C  				; 0 := 7 digits 
                             C  				; 1 := 6 digits 
 = 0000                      C  	CASSW=0			;CASSETTE SWITCH 
 = 0001                      C  	LABKEY=1		;^T (LABEL) key capability 
 = 0001                      C  	HGHBIT=1		;8-bit characters (ASCII & Graphics) 
 = 0001                      C  	QUEUE=1			;Queued painting algorithm (vs. stack) 
 = 0001                      C  	GIO86=1			;BASIC-86 Generalized I/O 
 = 0001                      C  	SCRNIO=1		;Screen editor 
 = 0001                      C  	SCRN86=1		;8086 Screen editor 
 = 0001                      C  	I8086=1			;CROSS ASSEMBLING FOR 8086 
 = 0001                      C  	MULSEG=1		;MULTI-SEGMENT 8086 BASIC 
 = 0000                      C  	SMALL=0			;"SMALL" VERSION OF 8086 BASIC IF SET 
 = 0001                      C  	TRUROM=1 
 = 0000                      C  	SBC86=0			;SBC 86/02 BOARD? 
 = 0001                      C  	SHORTJ=1		;USE INTRA-SEGMENT SHORT JUMPS 
                             C  				;IN 8086 CODE 
 = 0001                      C  	LNGVAR=1		;LONG VARIABLE NAME SUPPORT (EXTENDED ONLY) 
 = 0000                      C  	SHTERR=0		;SHORT (2 CHAR) ERROR MESSAGES 
 = 0000                      C  	SHTINS=0		;INSTR IN NON-FAST LEN2 VERSIONS 
 = 0000                      C  	SHTLHM=0		;LEFT HAND SIDE MID IN NON FAST LEN2 VERSIONS 
 = 0000                      C  	SHTCHN=0		;ALLOW CHAIN IN NON-5.0 
 = 0000                      C  	SHTPRO=0		;ALLOW PROTECTED FILES IN NON-FIVDSK 
 = 0000                      C  	SHTLIN=0		;ALLOW LINE INPUT IN NON-EXTENDED NON-FAST 
 = 0000                      C  	SHTREN=0		;ALLOW RENUM IN NON-FST VERSIONS 
 = 0001                      C  	INKEYF=1		;ADDS INKEY$ FUNCTION 
 = 0000                      C  	NOIOS=0			;NO I/O STATMENTS (INP,OUT, WAIT) 
 = 0000                      C  	NOPEKS=0		;NO PEEK, POKE 
 = 0000                      C  	NOUSR=0			;NO USR 
 = 0000                      C  	NOCTLA=0		;NO CONTROL-A IN EXTENDED 
 = 0000                      C  	NORUBT=0		;NO RUBOUT 
 = 0000                      C  	NOROMP=0		;NO ROM PROGRAM FEATURE 
 = 0000                      C  	NOATDL=0		;NO AUTO DELETE IN NON-FAST EXTENDED 
 = 0000                      C  	NODOT=0			;NO DOT IN LEN2 
 = 0000                      C  	NOEDIT=0		;NO EDIT COMMAND 
 = 0000                      C  	CRONLY=0		;ONLY PUT OUT CR, NOT CRLF TO TERMINAL 
                             C  				;AND FILES 
 = 0000                      C  	NONULL=0		;NO NULL COMMAND, PUT OUT NULLS IN CRDO & OUTCH1 
 = 0000                      C  	NOVARP=0		;NO VARPTR FUNCTION 
 = 0001                      C  	FIVEO=1			;GENERATE VERSION WITH RELEASE 5.0 FEATURES 
 = 0001                      C  	FIVMEM=1 
 = 0001                      C  	ANSI=1 
 = 0001                      C  	FIVDSK=1		;5.0 NEW DSK CODE 
 = 0001                      C  	FIVLPT=1		;WIDTH LPRINT AND 255 FEATURE 
 = 0001                      C  	HEXOCT=1		;&H..., HEX$, &O..., OCT$ 
 = 0000                      C  	BINCSW=0		;&B..., BIN$ 
 = 0001                      C  	BLODSW=1		;BLOAD, BSAVE COMMANDS 
 = 0001                      C  	MEMIMG=1		;MEMORY IMAGE FILES 
 = 0001                      C  	GENBIN=1 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-3
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C   
 = 0000                      C  	TRUANS=0		;TRUE ANSI VERSION (STATIC SCAN, ON ERROR) 
 = 0000                      C  	COMMNT=0		;DONT WANT BIG COMMENT 
 = 0000                      C  	INTEL=0			;INTEL PROPRIETARY 
 = 0000                      C  	INTFSW=0		;INTEL FLOATING POINT 
 = 0000                      C  	INTFHW=0 
 = 0000                      C  	RMX=0			;INTEL RMX VERSION 
 = 0000                      C  	EDIT80=0		;FOR EDIT80 I/O ROUTINES 
 = 0000                      C  	RSHACK=0 
 = 0000                      C  	INTLEC=0 
 = 0002                      C  	LENGTH=2		;  1 MEANS 8K, 2 MEANS 12K 
 = 0000                      C  	BASDEB=0		;WHETHER DBG WILL BE LOADED WITH BASIC 
 = 0001                      C  	RSTLES=1		;WHETHER BASIC WILL USE RST LOCATIONS 
                             C  				;TO MAKE ITSELF SMALLER & QUICKER 
 = 0001                      C  	REALIO=1		;WHETHER SIMULATE (=0) OR ON MACHINE (=1) 
 = 0001                      C  	GENIO=1			;USE G/P ROUTINES 
 = 0001                      C  	CHSEAT=1		;CHSNS eats chars 
 = 0000                      C  	GENDSK=0		;USE G/P DSK CODE 
 = 0000                      C  	LONGI=0			;WHETHER WE ASK "TERMINAL WIDTH?" 
                             C  				;AND WANT SIN-TAN-COS-ATN? 
 = 0000                      C  	INSTSW=0		;FOR INSTR INSTRUCTION 
 = 0001                      C  	SWAPSW=1		;FOR SWAP STATEMENT 
 = 0000                      C  	MDS=0			;FOR INTEL MDS SYSTEMS 
 = 0000                      C  	SBC=0			;FOR INTEL SINGLE BOARD COMPUTER 
                             C  				;1=SBC 80/10, 2=SBC 80/20 
 = 0001                      C  	PURE=1			;ON FOR PURE CODE 
 = 0000                      C  	KILLER=0		;FOR ROM VERSION THAT WONT RUN IN RAM 
 = 0000                      C  	INTROM=0 
 = 0001                      C  	LPTSW=1 
 = 0001                      C  	NCRLPT=1 
 = 0000                      C  	NCRCAS=0 
 = 0000                      C  	ISC=0			;FOR ISC VERSION 
 = 0000                      C  	LPT3=0			;THREE LPT DRIVER VERSION(QUME,OKIA,CENT) 
 = 0000                      C  	TSLPT=0 
                             C   
 = 0000                      C  	DOS=0			;ON TO GEN ROUTINES FOR DOS 
 = 0001                      C  	DISK=1			;FILE I/O FEATURES 
 = 0000                      C  	TIMSHR=0		;NO TIME-SHARING DISK 
 = 0000                      C  	TSDISK=0		;NO TIME-SHARING DISK FOR US 
 = 0000                      C  	SPCDSK=0		;MAY HAVE MM'S DISK CODE 
 = 0000                      C  	SPCNDS=0 
 = 0001                      C  	FAST=1			;CONSTANT COMPRESSION, RENUM & FRIENDS 
 = 0000                      C  	KEYSTA=0 
 = 0000                      C  	ISIS=0			;FOR VERSION TO RUN UNDER INTEL'S ISIS II DOS 
 = 0000                      C  	MDSISS=0		;FOR MDS VERSION THAT RUNS UNDER ISIS-II 
 = 0001                      C  	CPM=1			;FOR CPM compatible operating systems 
 = 0001                      C  	CPM2=1			;VERSION 2. CPM 
 = 0000                      C  	CPM86=0			;FOR CP/M-86 operating system 
 = 0001                      C  	SCP=1			;MS-DOS operating system 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	CPMSER=0		;CHECK CPM SERIAL #'S 
 = 0000                      C  	CPMADD=0		;FOR VERSION TO RUN ON ADDS CPM 
 = 0000                      C  	CPMA75=0		;FOR VERSION TO RUN ON ADDS SYSTEM 75 
                             C  				;CP/M 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-4
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	CPMRSH=0		;FOR RADIO SHACK CPM/M 
 = 0000                      C  	CPM110=0		;FOR CP/M @1100 HEX (INTERALIA) 
 = 0000                      C  	CPMSBC=0		;FOR VERSION TO RUN ON SBC CP/M AT 4100H 
 = 0000                      C  	CPMPER=0		;FOR PERTEC VERSION OF CPM 
 = 0000                      C  	CPMLIF=0		;LIFEBOAT CP/M AT 4200H 
 = 0000                      C  	CPMMDS=0		;MOHAWK DATA SYSTEMS CP/M 
 = 0000                      C  	CPMCON=0 
 = 0000                      C  	Z80=0 
 = 0001                      C  	DISK=1 
 = 0001                      C  	NCRLPT=1 
 = 0001                      C  	RSTLES=1 
 = 0000                      C  	DRVPOS=CPMADD 
 = 0000                      C  	TRNCHR=CPMADD 
 = 0000                      C  	INLADD=CPMADD 
 = 0001                      C  	LISTEN=1		;ON MEANS LISTEN FOR ^C 
 = 0001                      C  	LISTEN=1 
 = 0000                      C  	LEN2=0 
 = 0001                      C  	LEN2=1 
 = 0001                      C  	HEXOCT=1 
 = 0002                      C  	LENGTH=2 
 = 0001                      C  	RSTLES=1 
 = 0001                      C  	FIVLPT=1 
 = 0000                      C  	I8251=0			;THIS SWITCH IS USED FOR ROSEMOUNT VERSION 
 = 0001                      C  	CONTRO=1		;ALLOW ^O 
 = 0001                      C  	LEN3=LEN2 OR CASSW 
                             C   
                             C   
                             C   
 = 0001                      C  	STRING=1 
 = 0001                      C  	NCRLPT=1 
                             C   
                             C  ; *** OEM Switches which need to be defaulted to 0 
                             C  ; 
 = 0000                      C  	CMPUTN=0 
 = 0000                      C  	DUPONT=0 
 = 0000                      C  	EXIDY=0 
 = 0000                      C  	GESBC=0 
 = 0000                      C  	HEATH=0 
 = 0000                      C  	LOKHED=0 
 = 0000                      C  	MOSTEK=0 
 = 0000                      C  	TEK=0 
 = 0000                      C  	TRSER2=0 
 = 0000                      C  	NASCOM=0 
 = 0000                      C  	NATROM=0 
 = 0000                      C  	NCRBAS=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRDEB=0 
 = 0000                      C  	NCRELS=0 
 = 0000                      C  	ONTEL=0 
 = 0000                      C  	PCS=0 
 = 0000                      C  	SGSATS=0 
 = 0000                      C  	ALTAIR=0 
 = 0000                      C  	DMC=0 
 = 0000                      C  	PANBAS=0 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-5
Common file to produce 2-segment 8086 GW-CPM BASIC          

 = 0000                      C  	XTNSYS=0 
 = 0000                      C  	NECBAS=0 
                             C  ;******************************************************************* 
                             C  ; Z80 related macros 
                             C  ;******************************************************************* 
 = 0001                      C  	Z80=1			;FOR VERSION THAT RUNS ON BOTH 
                             C  				;8080'S AND ZILOG Z-80'S 
 = 0001                      C  	Z80MAC=1		;USE 8080 MACROS INSTEAD OF Z80 INSTRUCTIONS 
 = 0000                      C  	Z80=0 
 = 0001                      C  	Z80=1 
                             C  LDIR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	INXF	H 
                             C  	INXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  LDDR	MACRO 
                             C  	MOV	WORD PTR A,WORD PTR M 
                             C  	STAX	D 
                             C  	DCXF	H 
                             C  	DCXF	D 
                             C  	DCXF	B 
                             C  	MOV	WORD PTR A,WORD PTR B 
                             C  	ORA	C 
                             C  	JNZ	_-8D 
                             C  ENDM 
                             C  DJNZ	MACRO	    DEST 
                             C  	DCR	B 
                             C  	JNZ	DEST 
                             C  ENDM 
                             C  ;******************************************************************* 
                             C  ; Define reset routines. 
                             C  ;******************************************************************* 
                             C  FSIGN	MACRO 
                             C  	CALL	SIGN 
                             C  ENDM 
                             C  PUSHM	MACRO 
                             C  	MOV	WORD PTR C,WORD PTR M 
                             C  	INX	H 
                             C  	MOV	WORD PTR B,WORD PTR M 
                             C  	INX	H 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  SYNCHK	MACRO	X 
                             C  	CALL	SYNCHR 
                             C  	DB	OFFSET X 
                             C  ENDM 
                             C  OUTCHR	MACRO 
                             C  	CALL	OUTDO 
                             C  ENDM 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-6
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  CHRGET	MACRO 
                             C  	CALL	CHRGTR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	CALL	DCOMPR 
                             C  ENDM 
                             C  GETYPE	MACRO 
                             C  	CALL	GETYPR 
                             C  ENDM 
                             C  COMPAR	MACRO 
                             C  	DB	73O 
                             C  	DB	332O 
                             C   ENDM 
                             C  ACRLF	MACRO 
                             C  	DB	13D 
                             C  	DB	10D 
                             C  ENDM 
                             C  PUSHR	MACRO 
                             C  	PUSH	WORD PTR D 
                             C  	PUSH	WORD PTR B 
                             C  ENDM 
                             C  POPR	MACRO 
                             C  	POP	WORD PTR B 
                             C  	POP	WORD PTR D 
                             C  ENDM 
                             C  MOVRI	MACRO	B,C,D,E 
                             C  	DB	1O		; "LXI  B" 
                             C  	DB	OFFSET C 
                             C  	DB	OFFSET B 
                             C  	DB	21O		; "LXI  D" 
                             C  	DB	OFFSET E 
                             C  	DB	OFFSET D 
                             C  ENDM 
                             C  INST	MACRO	X 
                             C  	DB	OX 
                             C  ENDM 
                             C   
                             C   
 = 000F                      C  	CONTO=15		;CHARACTER TO SUPRESS OUTPUT (USUALLY CONTROL-O) 
 = 0000                      C  	DBLTRN=0		;FOR DOUBLE PRECISION TRANSCENDENTALS 
                             C   
 = 000E                      C  	CLMWID=14D		;MAKE COMMA COLUMNS FOURTEEN CHARACTERS 
 = 0080                      C  	DATPSC=128D		;NUMBER OF DATA BYTES IN DISK SECTOR 
 = 0050                      C  	LINLN=80D		;TERMINAL LINE LENGTH 
 = 0084                      C  	LPTLEN=132D 
 = 00FF                      C  	BUFLEN=255		;LONG LINES 
 = 0028                      C  	NAMLEN=40D		;MAXIMUM LENGTH NAME -- 3 TO 127 
                             C   
 = 006E                      C  	NUMLEV=110D		;NUMBER OF STACK LEVELS RESERVED 
                             C  				;BY AN EXPLICIT CALL TO GETSTK 
 = 0004                      C  	STRSIZ=4 
 = 0003                      C  	STRSIZ=3 
 = 0003                      C  	NUMTMP=3		;NUMBER OF STRING TEMPORARIES 
 = 000A                      C  	NUMTMP=10 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-7
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C   
 0008                        C  	.RADIX	8 
                             C  ; 
                             C  ; Useful macros 
                             C  ; 
                             C   
                             C  ACRLF   MACRO 
                             C          DB      13D 
                             C          DB      10D 
                             C  ENDM 
                             C   
                             C  INS86   MACRO   A,B,C,D 
                             C          DB      A&O 
                             C  IFNB    <B> 
                             C          DB      B&O 
                             C  ENDIF 
                             C  IFNB    <D> 
                             C          DB      C&O 
                             C          DB      D&O 
                             C  ENDIF 
                             C  IFB     <D> 
                             C   IFNB   <C> 
                             C          DW      C 
                             C    ENDIF 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  CALLOS  MACRO 
                             C          CALL    CPMENT 
                             C  ENDM 
                             C   
                             C  POPR    MACRO 
                             C          POP     CX 
                             C          POP     DX 
                             C  ENDM 
                             C   
                             C  ADR     MACRO   X 
                             C          DW      X 
                             C  ENDM 
                             C   
                             C  DC      MACRO   ARG 
                             C          IRPC    ZZ,<ARG> 
                             C              IFDIF       <ZZ>,<">
                             C                  DB      "&ZZ&" 
                             C                  _A="&ZZ&" 
                             C              ENDIF 
                             C          ENDM 
                             C  ENDM 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-8
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C          PAGE 
                             C   
                             C  DBGBRK	MACRO 
                             C  	DB	0CDh,06h,0CCh 
                             C  	ENDM 
                             C   
                             C   
                             C  MOVRI   MACRO   B,C,D,E 
                             C          DB      271O            ; "LXI  B" 
                             C          DB      C 
                             C          DB      B 
                             C          DB      272O            ; "LXI  D" 
                             C          DB      E 
                             C          DB      D 
                             C  ENDM 
                             C   
                             C  ; 
                             C  ; Reserve word table generating Macros 
                             C  ; 
                             C  un_def  MACRO   RESWRD 
                             C          %OUT +++ Undefined reserved word - &RESWRD 
                             C  ENDM 
                             C   
                             C  T       MACRO   RESWRD 
                             C          QQ=QQ+1 
                             C          $&RESWRD=QQ 
                             C  ENDM 
                             C   
                             C  Q       MACRO   RESWRD 
                             C   IFDEF  $&RESWRD 
                             C          $F=0 
                             C    IRPC  XX,<RESWRD> 
                             C     IF   $F 
                             C          $Q="&XX&" 
                             C          DB      "&XX&" 
                             C     ENDIF 
                             C     IFE  $F-1 
                             C          .XLIST 
                             C     ENDIF 
                             C          $F=$F+1 
                             C    ENDM 
                             C          .LIST 
                             C          ORG     $-1 
                             C          DB      $Q+128D 
                             C          DB      $&RESWRD 
                             C   ELSE 
                             C          un_def  RESWRD 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  QF      MACRO   RESWRD 
                             C   IFDEF  $&RESWRD 
                             C          $F=0 
                             C    IRPC  XX,<RESWRD> 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-9
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C     IF   $F 
                             C          $Q="&XX&" 
                             C          DB      "&XX&" 
                             C     ENDIF 
                             C     IFE  $F-1 
                             C          .XLIST 
                             C     ENDIF 
                             C          $F=$F+1 
                             C    ENDM 
                             C          .LIST 
                             C          ORG     $-1 
                             C          DB      $Q+128D 
                             C          DB      $&RESWRD-128D 
                             C   ELSE 
                             C          un_def  RESWRD 
                             C   ENDIF 
                             C  ENDM 
                             C   
                             C  DERMAK  MACRO   X 
                             C          PUBLIC  DER&X 
                             C  DER&X:  MOV     DL,OFFSET ERR&X 
                             C          DB      271O                    ; LXI B over next error 
                             C  ENDM 
                             C  ; 
                             C  ; Dispatch table generating Macros.  We have to play games with the 
                             C  ; external declarations as ASM86 won't allow something to be declared 
                             C  ; external during pass 2.  Instead we build a chain of dummy macros 
                             C  ; that could generate the declaration for all potentially external 
                             C  ; reserve word dispatch addresses. 
                             C  ; 
                             C   
                             C  ; 
                             C  ; play games with a possible external.  Create a new 
                             C  ; macro for the symbol and text, and string it together 
                             C  ; with a central invoker 
                             C  ; 
                             C  ENDIF 
                             C   
                             C  ?z0 macro               ; Bottom of the chain 
                             C  endm 
                             C   
                             C  ; 
                             C  ; add an external declaration to S with type NEAR if it is not defined 
                             C  ; 
                             C  add_ext macro   s 
                             C      IFNDEF   ?&s 
                             C          ?i = ?i + 1 
                             C          def_mac     ?z&%?i,?z&%(?i-1),s 
                             C      ENDIF 
                             C  endm 
                             C   
                             C  ; 
                             C  ; define a macro called that possibly externals S:NEAR and then calls macro n 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-10
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  def_mac macro   m,n,s 
                             C  m   macro 
                             C      ifndef s 
                             C          extrn s:NEAR 
                             C      endif 
                             C      purge m 
                             C      n 
                             C  endm 
                             C  ?&s macro 
                             C  &endm 
                             C  endm 
                             C   
                             C  ; 
                             C  ; call the macro chain 
                             C  ; 
                             C  do_ext  macro 
                             C      expand_mac  ?z%?i 
                             C  endm 
                             C   
                             C  expand_mac macro m 
                             C      m 
                             C  endm 
                             C  ; 
                             C  R       MACRO   RESWRD 
                             C   IFNDEF RESWRD 
                             C          add_ext RESWRD 
                             C   ENDIF 
                             C          DW      RESWRD 
                             C          QQ=QQ+1 
                             C          $&RESWRD=QQ 
                             C  ENDM 
                             C   
                             C  R2      MACRO   RESWRD,RESDSP 
                             C   IFNDEF RESDSP 
                             C          add_ext RESDSP 
                             C   ENDIF 
                             C          DW      RESDSP 
                             C          QQ=QQ+1 
                             C          $&RESWRD=QQ 
                             C  ENDM 
                             C  ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-11
Common file to produce 2-segment 8086 GW-CPM BASIC          

                             C  PAGE 
                             C   
                                 
                                 
                                	TITLE	GWMAIN Copied from BINTRP.MAC 
                                 
 000A                           	.RADIX	10 
                                 
                                COMMENT * 
                                 
                                --------- ---- -- ---- ----- --- ---- ----- 
                                COPYRIGHT 1975 BY BILL GATES AND PAUL ALLEN 
                                --------- ---- -- ---- ----- --- ---- ----- 
                                 
                                ORIGINALLY WRITTEN ON THE PDP-10 FROM 
                                FEBRUARY 9 TO  APRIL 9 1975 
                                 
                                BILL GATES WROTE A LOT OF STUFF. 
                                PAUL ALLEN WROTE A LOT OF OTHER STUFF AND FAST CODE. 
                                MONTE DAVIDOFF WROTE THE MATH PACKAGE (F4I.MAC). 
                                 
                                * 
                                 
                                	.LIST 
                                 
                                ;Local Switches 
                                ; 
 = 0000                         	LTRACE=ALPCPM		;trace output selectable 
 = 0000                         	LABEL=PC8A 
 = 0000                         	HLPEDT=PC8A 
 = 0000                         	UCEMSG=NNECBS		;Upper case error messages. 
 = 0000                         	OLD86=MELCO AND CPM86	;For "old" 8086 error messages (prior 
                                				;to alignment for IBM compatibility). 
                                 
 = 0001                         	OLDBLD=ALPCPM OR ALPS OR OKI OR HAL OR PC8A OR BUBL OR GW OR TSHIBA 
                                 
                             C  	INCLUDE GIO86U.INC 
                             C  ; [ This translation created 12-Jan-83 by Version 4.3 ] 
                             C   
                             C  	SUBTTL GIO86U - Device Independent I/O Constants and Macros 
                             C   
                             C  COMMENT	* 
                             C   
                             C  --------- --- ---- -- --------- 
                             C  COPYRIGHT (C) 1982 BY MICROSOFT 
                             C  --------- --- ---- -- --------- 
                             C   
                             C          Programmer: Tom Corbett,  Microsoft Inc. 
                             C   
                             C          * 
                             C   
                             C  ROFFST	MACRO	NAME,SIZE	;define record macro 
                             C  	NAME=_OFFST 
                             C  	_OFFST=_OFFST+SIZE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-12
GIO86U - Device Independent I/O Constants and Macros        

                             C  ENDM  
                             C   
                             C   
                             C  ;ASCII character definitions 
                             C  ; 
 = 0003                      C  	ASCCTC=3D		;CTL-C 
 = 0008                      C  	ASCBS=8D		;backspace 
 = 0009                      C  	ASCTAB=9D		;Tab 
 = 000A                      C  	ASCLF=10D		;Line Feed 
 = 000D                      C  	ASCCR=13D		;Carriage Return 
 = 0013                      C  	ASCCTS=19D		;CTL-S 
 = 001A                      C  	ASCCTZ=26D		;Control Z (End-of-file for some devices) 
 = 001B                      C  	ASCESC=27D		;Escape 
 = 0020                      C  	ASCSPC=32D		;Space 
                             C   
                             C  ;Special File ID's (identified by 1st byte of file) 
                             C  ; 
 = 00FF                      C  	BINFID=255D		;files created by SAVE "fn" 
 = 00FE                      C  	PROFID=254D		;files created by SAVE "fn",P 
 = 00FD                      C  	BSVFID=253D		;files created by BSAVE "fn" 
                             C   
                             C  ;Generalized I/O Function Codes: 
                             C  ; 
 = 0000                      C  	_OFFST=0		;initialize count 
                             C  	ROFFST	G_EOF,2		;test EOF for file opened to this device 
                             C  	ROFFST	G_LOC,2		;LOC 
                             C  	ROFFST	G_LOF,2		;LOF 
                             C  	ROFFST	G_CLS,2		;perform special CLOSE functions for this device 
                             C  	ROFFST	G_SWD,2		;set device width 
                             C  	ROFFST	G_RND,2		;GET/PUT random record from/to this device 
                             C  	ROFFST	G_OPN,2		;perform special OPEN functions for this device 
                             C  	ROFFST	G_SIN,2		;input 1 byte from file opened on this device 
                             C  	ROFFST	G_SOT,2		;output 1 byte to file opened on this device 
                             C  	ROFFST	G_GPS,2		;POS 
                             C  	ROFFST	G_GWD,2		;get device width 
                             C  	ROFFST	G_SCW,2		;set device column width 
                             C  	ROFFST	G_GCW,2		;get device column width 
                             C  	ROFFST	G_BIN,2		;block input from file opened on this device 
                             C  	ROFFST	G_BOT,2		;block output to file opened on this device 
                             C   
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-13
GIO86U - Device Independent I/O Constants and Macros        

                             C          PAGE 
                                 
                             C  	INCLUDE MSDOSU.INC	;MSDOS constants 
                             C  ; [ This translation created 12-Jan-83 by Version 4.3 ] 
                             C   
                             C  	SUBTTL    MSDOSU - MS-DOS Constants and Data-Structure Definitions 
                             C   
                             C  COMMENT	* 
                             C   
                             C  --------- --- ---- -- --------- 
                             C  COPYRIGHT (C) 1982 BY MICROSOFT 
                             C  --------- --- ---- -- --------- 
                             C   
                             C  	Programmer: Tom Corbett,  Microsoft Inc. 
                             C   
                             C  	* 
                             C   
                             C  CALLOS	MACRO	FUNC 
                             C  IFNB	<FUNC>   
                             C  	MOV	AH,LOW OFFSET FUNC 
                             C  ENDIF  
                             C  	INT	33D		;MSDOS system call 
                             C  ENDM  
                             C   
                             C  ROFFST	MACRO	NAME,SIZE	;define record macro 
                             C  	NAME=_OFFST 
                             C  	_OFFST=_OFFST+SIZE 
                             C  ENDM  
                             C   
                             C   
                             C  ; MSDOS System Call codes 
                             C  ; 
 = 0005                      C  	C_PRTO=5D		;Printer output 
 = 0006                      C  	C_DCIO=6D		;Direct console I/O 
 = 000D                      C  	C_REST=13D		;INITIALIZE BDOS 
 = 000E                      C  	C_SDRV=14D		;SET CURRENTLY SELECTED DRIVE 
 = 000F                      C  	C_OPEN=15D 
 = 0010                      C  	C_CLOS=16D 
 = 0011                      C  	C_SEAR=17D		;SEARCH FOR FILE 
 = 0013                      C  	C_DELE=19D 
 = 0014                      C  	C_READ=20D 
 = 0016                      C  	C_MAKE=22D 
 = 0017                      C  	C_RENA=23D 
 = 0019                      C  	C_GDRV=25D		;GET CURRENTLY SELECTED DRIVE 
 = 001A                      C  	C_BUFF=26D		;SET DMA ADDRESS 
 = 0021                      C  	C_RNDR=33D		;Random read 
 = 0022                      C  	C_RNDW=34D		;Random write 
 = 0027                      C  	C_RBR=39D		;Random Block Read 
 = 0029                      C  	C_PARS=41D		;Parse Filename 
                             C   
 = 000B                      C  	FNAML=11D		;number of bytes in Filename with extension 
 = 0080                      C  	DATPSC=128D		;bytes per sector 
 = 0026                      C  	FCBSIZ=38D		;File Control Block size 
                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-14
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

                             C  ;MS-DOS FILE-DATA-BLOCK Record Definition 
                             C  ; 
 = 0000                      C  	_OFFST=0		;initialize count 
                             C  	ROFFST	F_NUL1,1	;not used by basic interpreter 
                             C  	ROFFST	F_NUM,1		;file number 0..255 
                             C  	ROFFST	F_NUL2,2	;not used by basic interpreter 
                             C  	ROFFST	F_NEXT,2	;thread for linked list, [MEMSIZ]=end 
                             C  	ROFFST	F_MODE,1	;file mode: 
 = 0001                      C  	MD_SQI=1D		;sequential input 
 = 0002                      C  	MD_SQO=2D		;sequential output 
 = 0004                      C  	MD_RND=4D		;random 
 = 0008                      C  	MD_APP=8D		;append 
                             C  	ROFFST	F_FCB,FCBSIZ	;File Control Block: used to communicate with OS 
                             C  	ROFFST	F_CLOC,2	;for seq files: num sectors read/written   (LOCOFS) 
                             C  				;for rnd files: last record number + 1 
                             C  	ROFFST	F_ORCT,1	;"Original Byte Count"                     (ORNOFS) 
                             C  				;for seq input: #bytes in sector when read 
                             C  				;for seq output: #bytes in output sector 
                             C  				;for random files: bytes per sector 
                             C  	ROFFST	F_BREM,1	;number of bytes till end-of-buffer        (NMLOFS) 
                             C  	ROFFST	F_CODE,1	;file encoding: 
 = 0000                      C  	FC_ASC=0		;Ascii SAVE, Data files 
 = 0001                      C  	FC_BIN=1		;binary file (BSAVE, binary SAVE) 
                             C  	ROFFST	F_BAKC,1	;holds next sequential input when F.FLBS.FL.BKC is true 
                             C  	ROFFST	F_NUL3,1	;not used by basic interpreter 
                             C  	ROFFST	F_DEV,1		;Device number                             (FL.DSK) 
                             C  	ROFFST	F_WID,1		;File width 
                             C  	ROFFST	F_NUL4,1	;not used by basic interpreter 
                             C  	ROFFST	F_FLGS,1	;flags 
 = 0080                      C  	FL_BKC=200O		;when true, F.BAKC contains next sequential input 
                             C  	ROFFST	F_POS,1		;Current column position                   (FL.OPS) 
                             C  	ROFFST	FDBSIZ,0	;size of device independent part of FDB 
                             C  				;device dependant FDB entries start here 
                             C   
                             C  	ROFFST	DATOFS,DATPSC	;Operating System interface buffer 
                             C  	ROFFST	FD_SIZ,2	;variable record length for random files 
                             C  	ROFFST	FD_PHY,2	;current physical record number 
                             C  	ROFFST	FD_LOG,2	;current logical record number 
                             C  	ROFFST	F_NUL5,1	;Future use 
                             C  	ROFFST	FD_OPS,2	;current output position for sequential I/O 
                             C  	ROFFST	FD_DAT,0	;field buffer of random file 
                             C   
                             C  ; OFFSETS INTO MSDOS FCB 
                             C  ; 
 = 0007                      C  	FCB_DV=F_FCB+0D		;DRIVE (0=default, 1=A:, 2=B:, ...) 
 = 0008                      C  	FCB_FN=F_FCB+1D		;FILE NAME 
 = 0010                      C  	FCB_FT=F_FCB+9D		;EXTENSION 
 = 0013                      C  	FCB_EX=F_FCB+12D	;FILE EXTENT (identifies block of 128 logical records) 
 = 0015                      C  	FCB_RC=F_FCB+14D	;RECORD SIZE 
 = 0017                      C  	FCB_FS=F_FCB+16D	;FILE SIZE IN BYTES 
 = 001B                      C  	FCB_DT=F_FCB+20D	;Date of last write to file 
 = 001D                      C  	FCB_DT=F_FCB+22D	;Time of last write to file 
 = 0027                      C  	FCB_NR=F_FCB+32D	;NEXT RECORD NUMBER 
 = 0028                      C  	FCB_RN=F_FCB+33D	;CP/M 2.x Random Record Number 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-15
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

                             C   
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-16
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

                             C          PAGE 
                                 
                                 
                                 
                                 
                                 
                                	EXTRN	INIT:NEAR 
                                 
                                 
                                 
                                	EXTRN	SETGSB:NEAR 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	ASSUME DS:DSEG 
                                	EXTRN	ONGSBF:WORD 
 0000                           DSEG	ENDS 
                                 
                                 
 = 0000                         	BUFOFS=0 
                                 
 = 0002                         	BUFOFS=2		;MUST CRUNCH INTO ERALIER PLACE FOR 
                                				; SINGLE QUOTE 
                                 
 = 013E                         	KBFLEN=BUFLEN+(BUFLEN/4)	;MAKE KRUNCH BUFFER SOMEWHAT 
                                				; LARGER THAN SOURCE BUFFER (BUF) 
                                 
                                 
                                 
                                 
                                	EXTRN	NAME:NEAR 
                                	EXTRN	INLIN:NEAR,CRDO:NEAR,CRDONZ:NEAR,STRCMP:NEAR,PPSWRT:NEAR 
                                 
                                	EXTRN	OUTDO:NEAR 
                                 
                                	EXTRN	BLTU:NEAR,CLEARC:NEAR,GTMPRT:NEAR,ISLET:NEAR,ISLET2:NEAR 
                                	EXTRN	PTRGET:NEAR 
                                	EXTRN	QINLIN:NEAR,SCRTCH:NEAR,STKINI:NEAR,RUNC:NEAR,RESFIN:NEAR 
                                	EXTRN	PTRGT2:NEAR,STPEND:NEAR 
                                 
                                	EXTRN	SYNCHR:NEAR 
                                 
                                	EXTRN	SIGN:NEAR 
                                 
                                	EXTRN	PRGFIN:NEAR,FILIND:NEAR 
                                 
                                	EXTRN	FILINP:NEAR,INDSKC:NEAR 
                                 
                                 
                                	EXTRN	LRUN:NEAR 
                                 
                                 
                                	EXTRN	INXHRT:NEAR 
                                	EXTRN	ZERO:NEAR,MOVE:NEAR,FOUT:NEAR,FIN:NEAR,PUSHF:NEAR 
                                	EXTRN	MOVFR:NEAR,MOVRF:NEAR,MOVRM:NEAR,INPRT:NEAR,LINPRT:NEAR 
                                	EXTRN	MOVFM:NEAR,MOVMF:NEAR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-17
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

                                	EXTRN	INRART:NEAR,NEG:NEAR 
                                	EXTRN	FREFAC:NEAR,FRETMS:NEAR,STRCPY:NEAR,GETSTK:NEAR 
                                	EXTRN	STRLIT:NEAR,STRLT2:NEAR,STRLT3:NEAR,STRLTI:NEAR,STROUT:NEAR 
                                	EXTRN	STRPRT:NEAR,STROUI:NEAR 
                                	EXTRN	GETSPA:NEAR,PUTNEW:NEAR,STOP:NEAR,OMERR:NEAR,REASON:NEAR 
                                 
                                 
                                	EXTRN	INSTR:NEAR 
                                 
                                	EXTRN	PRINUS:NEAR,PUTTMP:NEAR 
                                 
                                	EXTRN	FOUTH:NEAR,FOUTO:NEAR,STRO$:NEAR,STRH$:NEAR 
                                 
                                 
                                	EXTRN	STRNG$:NEAR 
                                	EXTRN	TON:NEAR,TOFF:NEAR 
                                	EXTRN	SPACE$:NEAR 
                                 
                                	EXTRN	SIGNS:NEAR 
                                 
                                 
                                 
                                 
                                	EXTRN	UMULT:NEAR 
                                 
                                	EXTRN	SIGNC:NEAR,POPHRT:NEAR 
                                 
                                	EXTRN	FINLPT:NEAR 
                                 
                                	EXTRN	VMOVFA:NEAR,VMOVAF:NEAR,ISIGN:NEAR,VSIGN:NEAR,VDFACS:NEAR 
                                	EXTRN	VMOVMF:NEAR,VMOVFM:NEAR,FRCINT:NEAR,FRCDBL:NEAR,FRCSNG:NEAR 
                                	EXTRN	VNEG:NEAR,PUFOUT:NEAR,DCXBRT:NEAR,IADD:NEAR 
                                	EXTRN	FINDBL:NEAR 
                                	EXTRN	VMOVE:NEAR,VALINT:NEAR,VALSNG:NEAR,FRCSTR:NEAR,CHKSTR:NEAR 
                                	EXTRN	MAKINT:NEAR 
                                	EXTRN	MOVE1:NEAR 
                                 
                                	EXTRN	SCNSEM:NEAR 
                                	EXTRN	WHILE:NEAR,WEND:NEAR 
                                	EXTRN	CALLS:NEAR 
                                	EXTRN	PROCHK:NEAR 
                                	EXTRN	WRITE:NEAR 
                                ;The following block of externals was added on Dec 19, 1982 when BINTRP was 
                                ; Split up after the freeze of GW-BASIC Version 1.0 
                                ; This Split-up was not reflected in the PS1:<BASIC>BINTRP.MAC source. 
                                ; See Tom Corbett if you have any questions. 
                                ; 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	MEMSIZ:WORD,FRETOP:WORD,VARTAB:WORD,STREND:WORD,TXTTAB:WORD 
                                	EXTRN	ARYTAB:WORD 
                                	EXTRN	CURLIN:WORD,DOT:WORD,DATLIN:WORD,NLONLY:WORD,ERRLIN:WORD 
                                	EXTRN	ERRTXT:WORD 
                                	EXTRN	MRGFLG:WORD,CHNFLG:WORD 
                                	EXTRN	SAVSTK:WORD,SAVTXT:WORD,OLDLIN:WORD,NXTLIN:WORD,OLDTXT:WORD 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-18
MSDOSU - MS-DOS Constants and Data-Structure Definitions    

                                	EXTRN	ONELIN:WORD,ONEFLG:WORD 
                                	EXTRN	CNTOFL:WORD,TRCFLG:WORD,CONSAV:WORD,CONTXT:WORD,CONTYP:WORD 
                                	EXTRN	NUMCON:WORD,CONLO:WORD 
                                	EXTRN	AUTFLG:WORD,AUTLIN:WORD,AUTINC:WORD 
                                	EXTRN	KBUF:WORD,BUFMIN:WORD,BUF:WORD 
                                	EXTRN	PTRFIL:WORD,PTRFLG:WORD,DORES:WORD,VALTYP:WORD,FACLO:WORD 
                                	EXTRN	DFACLO:WORD,FAC:WORD 
                                	EXTRN	TEMP:WORD,TEMP2:WORD,TEMP3:WORD,TEMPA:WORD 
                                	EXTRN	DSCTMP:WORD,TEMPST:WORD 
                                	EXTRN	OPRTYP:WORD 
                                	EXTRN	SUBFLG:WORD,FVALSV:WORD,DEFTBL:WORD,FLGINP:WORD,FLGSCN:WORD 
                                	EXTRN	OVCSTR:WORD,INPPAS:WORD 
                                	EXTRN	USRTAB:WORD,DONUM:WORD,ENDPRG:WORD,ENDFOR:WORD,DATPTR:WORD 
                                	EXTRN	FLGOVC:WORD 
                                	EXTRN	ERRFLG:WORD,SAVSEG:WORD,PRMLN2:WORD,PRMSIZ:WORD,PARM2:WORD 
                                	EXTRN	PRMLEN:WORD,PRMSTK:WORD,PARM1:WORD 
                                	EXTRN	FUNACT:WORD,NOFUNS:WORD,OPTVAL:WORD,OPTFLG:WORD,RNDX:WORD 
 0000                           DSEG	ENDS 
                                 
                                	EXTRN	INEG2:NEAR,FADD:NEAR 
                                	EXTRN	$OVMSG:NEAR,ERRTAB:NEAR,LSTERR:NEAR,DSKERR:NEAR,NONDSK:NEAR 
                                	EXTRN	REDDY:NEAR 
                                	EXTRN	ERRSN:NEAR,ERRDV0:NEAR,ERRRE:NEAR,ERROV:NEAR,ERRMO:NEAR 
                                	EXTRN	ERRTM:NEAR,ERRNF:NEAR 
                                	EXTRN	ERRNR:NEAR,ERRLBO:NEAR,ERRDD:NEAR,ERRUF:NEAR,ERRFC:NEAR 
                                	EXTRN	ERRIFN:NEAR,ERRFNO:NEAR,ERRDNA:NEAR,ERRFDR:NEAR,ERRRAD:NEAR 
                                	EXTRN	ERRDFL:NEAR 
                                	EXTRN	ERRIOE:NEAR,ERRBFM:NEAR,ERRFNF:NEAR,ERRBFN:NEAR,ERRIER:NEAR 
                                	EXTRN	ERRRPE:NEAR 
                                	EXTRN	ERRFAO:NEAR,ERRNMF:NEAR,ERRWH:NEAR,ERRBRN:NEAR,ERRFOV:NEAR 
                                	EXTRN	ERRTMF:NEAR 
                                	EXTRN	ERRFAE:NEAR,ERRUS:NEAR,ERRRG:NEAR,ERROD:NEAR,ERRFN:NEAR 
                                	EXTRN	ERRUE1:NEAR	;ERRUE+DSKERR-NONDSK 
                                	EXTRN	DSKER1:NEAR	;DSKERR-NONDSK 
                                 
                                ;The following externs are defined in GWEVAL.MAC 
                                ; 
                                	EXTRN	MAKUPL:NEAR,MAKUPS:NEAR,GETYPR:NEAR,OCTCNS:NEAR,DOCNVF:NEAR 
                                	EXTRN	ISMID$:NEAR 
                                	EXTRN	FRMEVL:NEAR,FRMCHK:NEAR,GETINT:NEAR,GETBYT:NEAR,GETIN2:NEAR 
                                	EXTRN	SNGFLT:NEAR 
                                 
                                ;The following externs are defined in GWLIST.MAC 
                                ; 
                                	EXTRN	DELETE:NEAR,DEL:NEAR,TSTANM:NEAR,PLOOP2:NEAR 
                                 
                                 
                                 
                                	SUBTTL ROM VERSION INITALIZATION, AND CONSTANTS 
                                 
                                 
                                 
                                ; 
                                ; The reserved word tables are in another module.  Consequently 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-19
ROM VERSION INITALIZATION, AND CONSTANTS                    

                                ; many things must be declared external.  All of these things 
                                ; are in the code segement or are absolutes (like tokens). 
                                ; I.e., they are not in the data segment. 
                                ; 
                                 
                                	EXTRN	ALPTAB:NEAR 
                                	EXTRN	EQULTK:NEAR 
                                	EXTRN	STMDSP:NEAR 
                                	EXTRN	GREATK:NEAR 
                                	EXTRN	INSRTK:NEAR 
                                	EXTRN	LESSTK:NEAR,LSTOPK:NEAR 
                                	EXTRN	MIDTK:NEAR,MINUTK:NEAR 
                                	EXTRN	NMREL:NEAR,NOTTK:NEAR,NUMCMD:NEAR 
                                	EXTRN	ONEFUN:NEAR 
                                	EXTRN	POS:NEAR,PLUSTK:NEAR,PRINT:NEAR 
                                	EXTRN	RESLST:NEAR 
                                	EXTRN	SNGQTK:NEAR,SPCTAB:NEAR,SQRTK:NEAR,STEPTK:NEAR 
                                	EXTRN	THENTK:NEAR 
                                	EXTRN	USRTK:NEAR 
                                	EXTRN	$AUTO:NEAR 
                                	EXTRN	$DATA:NEAR,$DATCO:NEAR,$DELETE:NEAR 
                                	EXTRN	$EDIT:NEAR,$ELSE:NEAR,$END:NEAR,$ERL:NEAR,$ERROR:NEAR 
                                	EXTRN	$FN:NEAR,$FOR:NEAR 
                                	EXTRN	$GOSUB:NEAR,$GOTO:NEAR 
                                	EXTRN	$IF:NEAR,$INKEY$:NEAR,$INPUT:NEAR 
                                	EXTRN	$LIST:NEAR,$LLIST:NEAR 
                                	EXTRN	$NEXT:NEAR 
                                	EXTRN	$POINT:NEAR,$PRINT:NEAR 
                                	EXTRN	$REM:NEAR,$REMCO:NEAR,$RENUM:NEAR,$RESTORE:NEAR,$RESUME:NEAR 
                                	EXTRN	$RETURN:NEAR,$RND:NEAR,$RUN:NEAR 
                                	EXTRN	$SCREEN:NEAR,$STOP:NEAR,$STRING$:NEAR 
                                	EXTRN	$THEN:NEAR,$TO:NEAR 
                                	EXTRN	$USR:NEAR 
                                	EXTRN	$VARPTR:NEAR 
                                	EXTRN	$WEND:NEAR,$WHILE:NEAR 
                                 
                                ; 
                                ; Since the dispatch table is also no longer in BINTRP many 
                                ; addresses need to be declared internal. 
                                ; 
                                 
                                	PUBLIC	AUTO 
                                	PUBLIC	DATAS,DEFDBL,DEFINT,DEFREA,DEFSTR 
                                	PUBLIC	ELSES,ERRORS 
                                	PUBLIC	FOR 
                                	PUBLIC	GOSUB,GOTO 
                                	PUBLIC	IFS,INPUT 
                                	PUBLIC	LET,LINE 
                                	PUBLIC	ONGOTO,OPTION 
                                	PUBLIC	PEEK,POKE 
                                	PUBLIC	RANDOM,READ,REM,RESEQ,RESUME,RETURN,RUN 
                                 
                                 
                                	SUBTTL	      GENERAL STORAGE MANAGEMENT ROUTINES - FNDFOR, BLTU, GETSTK 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-20
GENERAL STORAGE MANAGEMENT ROUTINES - FNDFOR, BLTU, GETSTK  

                                ; 
                                ; FIND A "FOR" ENTRY ON THE STACK WITH THE VARIABLE POINTER 
                                ; PASSED IN [D,E]. 
                                ; 
                                PUBLIC	FNDFOR 
 0000  BB 0004                  FNDFOR: MOV	BX,OFFSET 4+0	;IGNORING EVERYONES "NEWSTT" 
                                				;AND THE RETURN ADDRESS OF THIS 
 0003  03 DC                    	ADD	BX,SP		;SUBROUTINE, SET [H,L]=SP 
 0005                           LOOPER: 
                                 
 0005  43                       	INC	BX		;8086 USES TWO BYTE ENTRIES 
                                 
 0006  8A 07                    	MOV	AL,BYTE PTR [BX]	;SEE WHAT TYPE OF THING IS ON THE STACK 
 0008  43                       	INC	BX 
                                 
 = 0006                         	WHLSIZ=6 
 0009  3C 00 E                  	CMP	AL,LOW OFFSET $WHILE 
 000B  75 07                    	JNZ	SHORT STKSRC 
 000D  B9 0006                  	MOV	CX,OFFSET WHLSIZ 
 0010  03 D9                    	ADD	BX,CX 
 0012  EB F1                    	JMP	SHORT LOOPER 
 0014                           STKSRC: 
                                 
 0014  3C 00 E                  	CMP	AL,LOW OFFSET $FOR	;IS THIS STACK ENTRY A "FOR"? 
 0016  74 01                    	JZ	SHORT $+3 
 0018  C3                       	RET			;NO SO OK 
 0019  8A 0F                    	MOV	CL,BYTE PTR [BX] 
 001B  43                       	INC	BX		;DO EQUIVALENT OF PUSHM / XTHL 
 001C  8A 2F                    	MOV	CH,BYTE PTR [BX] 
 001E  43                       	INC	BX 
 001F  53                       	PUSH	BX		;PUT H  ON 
 0020  8B D9                    	MOV	BX,CX 
                                 
 0022  0B D2                    	OR	DX,DX		;"NEXT" STATMENT WITHOUT AN ARGUMENT ? 
                                				;WE MATCH ON ANYTHING 
 0024  87 DA                    	XCHG	BX,DX		;MAKE SURE WE RETURN [D,E] 
 0026  74 04                    	JZ	SHORT POPGOF	;POINTING TO THE VARIABLE 
 0028  87 DA                    	XCHG	BX,DX 
                                 
 002A  3B DA                    	CMP	BX,DX 
 = 0010                         	FORSIZ=16 
                                 
 = 0011                         	FORSIZ=17 
 = 0013                         	FORSIZ=FORSIZ+2	;For text pointer into NEXT. 
                                 
                                ; 
                                ; Note - 8086 versions force stack entries to be an even length 
                                ; so stack accesses won't cross word boundaries.  This is done 
                                ; for speed.  To accomplish this, an extra byte is pushed on 
                                ; top of the FOR token.  This extra byte is NOT reflected in 
                                ; the value of FORSIZ but is taken care of by the code. 
                                ; 
                                 
                                PUBLIC	FORSZC 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-21
GENERAL STORAGE MANAGEMENT ROUTINES - FNDFOR, BLTU, GETSTK  

 = 0013                         	FORSZC=0+FORSIZ 
 002C  B9 0010                  POPGOF: MOV	CX,OFFSET FORSZC-3	;TO WIPE OUT A "FOR" ENTRY 
                                				;Note that the pointer has already 
                                				;been incremented three times. 
 002F  5B                       	POP	BX 
 0030  75 01                    	JNZ	SHORT $+3 
 0032  C3                       	RET			;IF VARIABLE IN THIS ENTRY MATCHES 
                                				;RETURN WITH [H,L] POINTING THE BOTTOM 
                                				;OF THE ENTRY 
 0033  03 D9                    	ADD	BX,CX 
 0035  EB CE                    	JMP	SHORT LOOPER	;NOW POINTING TO THE START OF THE NEXT 
                                				;ENTRY. SEE IF ITS A "FOR" ENTRY 
                                				;AND IF THE VARIABLE MATCHES 
                                 
                                 
                                 
                                 
                                	SUBTTL ERROR HANDLING 
                                 
                                 
                                 
                                ; 
                                ; THIS ROUTINE IS CALLED TO RESET THE STACK IF BASIC IS 
                                ; EXTERNALLY STOPPED AND THEN RESTARTED. 
                                ; 
                                PUBLIC	READYR 
 0037  B9 0193 R                READYR: MOV	CX,OFFSET STPRDY	;ADDRESS GO TO, ALSO POP OFF GARBAGE STACK ENTRY. 
 003A  E9 00DF R                	JMP	ERESET		;RESET STACK, GOTO READY. 
                                 
 003D                           PRGEND: 
 003D  8B 1E 0000 E             	MOV	BX,CURLIN	;GET CURRENT LINE # 
 0041  8A C7                    	MOV	AL,BH		;SEE IF DIRECT 
 0043  22 C3                    	AND	AL,BL		;AND TOGETHER 
 0045  FE C0                    	INC	AL		;SET CC'S 
 0047  74 09                    	JZ	SHORT ENDCNJ	;IF DIRECT DONE, ALLOW FOR DEBUGGING PURPOSES 
 0049  A0 0000 E                	MOV	AL,BYTE PTR ONEFLG	;SEE IF IN ON ERROR 
 004C  0A C0                    	OR	AL,AL		;SET CC 
 004E  B2 00 E                  	MOV	DL,LOW OFFSET ERRNR	;"NO RESUME" ERROR 
 0050  75 5C                    	JNZ	SHORT ERROR	;YES, FORGOT RESUME 
                                	EXTRN	ENDCON:NEAR 
 0052  E9 0000 E                ENDCNJ: JMP	ENDCON		;NO, LET IT END 
                                 
                                	DERMAK	IFN		;"Illegal File Name" 
                                	DERMAK	FNO		;"File Not Open" 
                                	DERMAK	DNA		;"Device not available" 
                                	DERMAK	FDR		;"Direct statement in file" 
                                	DERMAK	RAD		;"Rename across disk" 
                                	DERMAK	DFL		;"DISK FULL" 
                                	DERMAK	IOE		;"DISK I/O ERROR" 
                                	DERMAK	BFM		;"BAD FILE MODE" 
                                	DERMAK	FNF		;"FILE NOT FOUND" 
                                	DERMAK	BFN		;"BAD FILE NUMBER" 
                                	DERMAK	IER		;"INTERNAL ERROR" 
                                	DERMAK	RPE		;"READ PAST END" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-22
ERROR HANDLING                                              

                                	DERMAK	FAO		;"FILE ALREADY OPEN" 
                                	DERMAK	NMF		;"BAD FILE NAME" 
                                	DERMAK	BRN		;"BAD RECORD NUMBER" 
                                	DERMAK	FOV		;"FIELD OVERFLOW" 
                                	DERMAK	TMF		;"TOO MANY FILES" 
                                	DERMAK	FAE		;"FILE ALREADY EXISTS" 
 008A                           	ORG	$-1 
                                 
 008A  EB 22                    	JMP	SHORT ERROR 
                                 
 008C  8B 1E 0000 E             DATSNE: MOV	BX,DATLIN	;GET DATA LINE 
 0090  89 1E 0000 E             	MOV	CURLIN,BX	;MAKE IT CURRENT LINE 
                                 
                                PUBLIC	$SNERR 
 0094                           $SNERR: 
                                 
                                PUBLIC	SNERR 
 0094  B2 00 E                  SNERR:	MOV	DL,LOW OFFSET ERRSN	;"SYNTAX ERROR" 
 0096  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT 2 
                                PUBLIC	DV0ERR 
 0097  B2 00 E                  DV0ERR: MOV	DL,LOW OFFSET ERRDV0	;DIVISION BY ZERO 
 0099  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT 2 
                                PUBLIC	NFERR 
 009A  B2 00 E                  NFERR:	MOV	DL,LOW OFFSET ERRNF	;"NEXT WITHOUT FOR" ERROR 
 009C  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT TWO BYTES 
                                PUBLIC	DDERR 
 009D  B2 00 E                  DDERR:	MOV	DL,LOW OFFSET ERRDD	;"REDIMENSIONED VARIABLE" 
 009F  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT 2 BYTES 
                                PUBLIC	UFERR 
 00A0  B2 00 E                  UFERR:	MOV	DL,LOW OFFSET ERRUF	;"UNDEFINED FUNCTION" ERROR 
 00A2  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT TWO 
 00A3  B2 00 E                  REERR:	MOV	DL,LOW OFFSET ERRRE	;"RESUME WITHOUT ERROR" 
 00A5  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT TWO 
                                PUBLIC	$OVERR 
 00A6                           $OVERR: 
                                PUBLIC	OVERR 
 00A6  B2 00 E                  OVERR:	MOV	DL,LOW OFFSET ERROV	;SET OVERFLOW ERROR CODE 
 00A8  B9                       	DB	271O	; SKIP  ;"LXI B," OVER NEXT TWO 
                                PUBLIC	MOERR 
 00A9  B2 00 E                  MOERR:	MOV	DL,LOW OFFSET ERRMO	;MISSING OPERAND ERROR 
 00AB  B9                       	DB	271O	; SKIP  ;"LXI   B," OVER THE NEXT TWO 
                                PUBLIC	$TMERR 
 00AC                           $TMERR: 
                                PUBLIC	TMERR 
 00AC  B2 00 E                  TMERR:	MOV	DL,LOW OFFSET ERRTM	;TYPE MISMATCH ERROR 
                                PUBLIC	ERROR 
 00AE                           ERROR: 
 00AE  32 C0                    	XOR	AL,AL 
 00B0  A2 0000 E                	MOV	BYTE PTR NLONLY,AL	;Clear Don't close files flag 
 0000                           DSEG	SEGMENT PUBLIC 'DATASG' 
                                	EXTRN	INITFG:WORD 
 0000                           DSEG	ENDS 
                                	EXTRN	CMDERR:NEAR 
 00B3  A0 0000 E                	MOV	AL,BYTE PTR INITFG 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-23
ERROR HANDLING                                              

 00B6  0A C0                    	OR	AL,AL		;0 implies initialization is incomplete 
 00B8  74 03                    	JZ	SHORT ??L000 
 00BA  EB 04 90                 	JMP	INITOK		;Initialization has completed 
 00BD                           ??L000: 
 00BD  E9 0000 E                	JMP	CMDERR		;Execute command line error routine 
                                				;which returns to the OS 
 00C0                           INITOK: 
 = 0000                         	HLPEDT=PC8A 
 00C0  8B 1E 0000 E             	MOV	BX,CURLIN	;GET CURRENT LINE NUMBER 
 00C4  89 1E 0000 E             	MOV	ERRLIN,BX	;SAVE IT FOR ERL VARIABLE 
 00C8  32 C0                    	XOR	AL,AL		;CLEAR CHAIN FLAG IN CASE OF ERROR 
 00CA  A2 0000 E                	MOV	BYTE PTR MRGFLG,AL	;ALSO MERGE FLAG 
 00CD  A2 0000 E                	MOV	BYTE PTR CHNFLG,AL	;SO IT DOESNT TRY TO CHAIN 
 00D0  8A C7                    	MOV	AL,BH		;ONLY SET UP DOT IF IT ISNT DIRECT 
 00D2  22 C3                    	AND	AL,BL 
 00D4  FE C0                    	INC	AL 
 00D6  74 04                    	JZ	SHORT ERRESM 
 00D8  89 1E 0000 E             	MOV	DOT,BX		;SAVE IT FOR EDIT OR LIST 
 00DC  B9 00E6 R                ERRESM: MOV	CX,OFFSET ERRMOR	;GET RETURN ADDRESS IN [B,C] 
                                	EXTRN	STKERR:NEAR 
                                PUBLIC	ERESET 
 00DF  8B 1E 0000 E             ERESET: MOV	BX,SAVSTK	;GET A GOOD STACK BACK 
 00E3  E9 0000 E                	JMP	STKERR		;JUMP INTO STKINI 
 00E6  59                       ERRMOR: POP	CX		;POP OFF FNDFOR STOPPER 
 00E7  8A C2                    	MOV	AL,DL		;[A]=ERROR NUMBER 
 00E9  8A CA                    	MOV	CL,DL		;ALSO SAVE IT FOR LATER RESTORE 
 00EB  A2 0000 E                	MOV	BYTE PTR ERRFLG,AL	;SAVE IT SO WE KNOW WHETHER TO CALL "EDIT" 
 00EE  8B 1E 0000 E             	MOV	BX,SAVTXT	;GET SAVED TEXT POINTER 
 00F2  89 1E 0000 E             	MOV	ERRTXT,BX	;SAVE FOR RESUME. 
 00F6  87 DA                    	XCHG	BX,DX		;SAVE SAVTXT PTR 
 00F8  8B 1E 0000 E             	MOV	BX,ERRLIN	;GET ERROR LINE # 
 00FC  8A C7                    	MOV	AL,BH		;TEST IF DIRECT LINE 
 00FE  22 C3                    	AND	AL,BL		;SET CC'S 
 0100  FE C0                    	INC	AL		;SETS ZERO IF DIRECT LINE (65535) 
 0102  74 0A                    	JZ	SHORT NTMDCN	;IF DIRECT, DONT MODIFY OLDTXT & OLDLIN 
 0104  89 1E 0000 E             	MOV	OLDLIN,BX	;SET OLDLIN=ERRLIN. 
 0108  87 DA                    	XCHG	BX,DX		;GET BACK SAVTXT 
 010A  89 1E 0000 E             	MOV	OLDTXT,BX	;SAVE IN OLDTXT. 
 010E  8B 1E 0000 E             NTMDCN: MOV	BX,ONELIN	;SEE IF WE ARE TRAPPING ERRORS. 
 0112  0B DB                    	OR	BX,BX		;BY CHECKING FOR LINE ZERO. 
 0114  87 DA                    	XCHG	BX,DX		;PUT LINE TO GO TO IN [D,E] 
 0116  BB 0000 E                	MOV	BX,OFFSET ONEFLG	;POINT TO ERROR FLAG 
 0119  74 0B                    	JZ	SHORT NOTRAP	;SORRY, NO TRAPPING... 
 011B  22 07                    	AND	AL,BYTE PTR [BX]	;A IS NON-ZERO, SETZERO IF ONEFLG ZERO 
 011D  75 07                    	JNZ	SHORT NOTRAP	;IF FLAG ALREADY SET, FORCE ERROR 
 011F  FE 0F                    	DEC	BYTE PTR [BX]	;IF ALREADY IN ERROR ROUTINE, FORCE ERROR 
 0121  87 DA                    	XCHG	BX,DX		;GET LINE POINTER IN [H,L] 
 0123  E9 07D6 R                	JMP	GONE4		;GO DIRECTLY TO NEWSTT CODE 
 0126  32 C0                    NOTRAP: XOR	AL,AL		;A MUST BE ZERO FOR CONTRO 
 0128  88 07                    	MOV	BYTE PTR [BX],AL	;RESET ONEFLG 
 012A  8A D1                    	MOV	DL,CL		;GET BACK ERROR CODE 
 012C  A2 0000 E                	MOV	BYTE PTR CNTOFL,AL	;FORCE OUTPUT 
 012F  E8 0000 E                	CALL	CRDONZ		;CRLF 
 0132  BB 0000 E                	MOV	BX,OFFSET ERRTAB	;GET START OF ERROR TABLE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-24
ERROR HANDLING                                              

 0135  8A C2                    	MOV	AL,DL		;GET ERROR CODE 
 0137  3C 00 E                  	CMP	AL,LOW OFFSET LSTERR	;IS IT PAST LAST ERROR? 
 0139  73 08                    	JAE	SHORT UPERR	;YES, TOO BIG TO PRINT 
 013B  3C 01 E                  	CMP	AL,LOW OFFSET DSKERR+1	;DISK ERROR? 
 013D  73 06                    	JAE	SHORT NTDER2	;YES 
 013F  3C 01 E                  	CMP	AL,LOW OFFSET NONDSK+1	;IS IT BETWEEN LAST NORMAL & FIRST DISK? 
 0141  72 06                    	JB	SHORT NTDERR	;YES, OK TO PRINT IT 
 0143  B0 00 E                  UPERR:	MOV	AL,LOW OFFSET ERRUE1	;PRINT "UNPRINTABLE ERROR" 
 0145  2C 00 E                  NTDER2: SUB	AL,LOW OFFSET DSKER1	;FIX OFFSET INTO TABLE OF MESSAGES 
 0147  8A D0                    	MOV	DL,AL		;SAVE BACK ERROR CODE 
 0149                           NTDERR: 
                                				;ON "SYNTAX ERROR"S 
 0149                           LEPSKP: INS86	56		;CODE SEGMENT FETCH 
 014A  8A 07                    	MOV	AL,BYTE PTR [BX] 
 014C  43                       	INC	BX		;POINT TO NEXT CHARACTER 
 014D  0A C0                    	OR	AL,AL 
 014F  74 02                    	JZ	SHORT ??L001 
 0151  EB F6                    	JMP	LEPSKP 
 0153                           ??L001: 
 0153  4B                       	DEC	BX 
 0154  43                       	INC	BX		;SKIP OVER THIS ERROR MESSAGE 
 0155  FE CA                    	DEC	DL		;DECREMENT ERROR COUNT 
 0157  75 F0                    	JNZ	SHORT LEPSKP	;SKIP SOME MORE 
 0159  53                       	PUSH	BX		;SAVE TEXT POINTER 
 015A  8B 1E 0000 E             	MOV	BX,ERRLIN	;GET ERROR LINE NUMBER 
 015E  5E                       	POP	SI		;XTHL 
 015F  87 F3                    	XCHG	SI,BX 
 0161  56                       	PUSH	SI		;GET BACK ERROR TEXT POINTER 
                                PUBLIC	ERRFIN 
 0162                           ERRFIN: 
                                	INS86	56		;CODE SEGMENT OVERRIDE FOR 8086 BASIC 
 0163  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET 1ST CHAR OF ERROR 
 0165  3C 3F                    	CMP	AL,LOW "?"      ;PADDED ERROR? 
 0167  75 06                    	JNZ	SHORT ERRFN1	;NO,PRINT 
 0169  5B                       	POP	BX		;GET LINE # OFF STACK 
 016A  BB 0000 E                	MOV	BX,OFFSET ERRTAB 
 016D  EB D4                    	JMP	SHORT UPERR	;MAKE UNPRINTABLE ERROR 
                                 
 016F                           ERRFN1: 
 016F  E8 0000 E                	CALL	STROUT		;PRINT MESSAGE 
 0172  5B                       	POP	BX		;RESTORE LINE NUMBER 
 0173  BA FFFE                  	MOV	DX,65534	;IS INIT EXECUTING? 
 0176  3B DA                    	CMP	BX,DX 
 0178  75 03                    	JNZ	SHORT ??L002 
 017A  E8 0000 E                	CALL	CRDO		;DO CRLF 
 017D                           ??L002: 
                                	EXTRN	SYSTME:NEAR 
 017D  75 03                    	JNZ	SHORT ??L003 
 017F  E9 0000 E                	JMP	SYSTME		;SYSTEM error exit 
 0182                           ??L003: 
 0182  8A C7                    	MOV	AL,BH		;SEE IF IN DIRECT MODE 
 0184  22 C3                    	AND	AL,BL 
 0186  FE C0                    	INC	AL		;ZERO SAYS DIRECT MODE 
 0188  74 03                    	JZ	SHORT ??L004 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-25
ERROR HANDLING                                              

 018A  E8 0000 E                	CALL	INPRT		;PRINT LINE NUMBER IN [H,L] 
 018D                           ??L004: 
 018D  B0 FF                    	MOV	AL,LOW 377O 
 018F  E8 0000 E                	CALL	OUTDO		;FLAG AS NOT USER INPUT 
                                ; NOW FALL INTO MAIN INTERPRETER LOOP 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-26
ERROR HANDLING                                              

                                	PAGE 
                                 
                                	SUBTTL STPRDY, READY, MAIN, CHEAD 
                                ; 
                                ; FOR "LIST" COMMAND STOPPING 
                                ; AND FOR RETURNING FROM A FAILED "CVER" 
                                ; AND TO CORRECT A DIRECT GOSUB WHICH DOES INPUT 
                                ; 
 0192  B0                       	DB	260O	; SKIP  ;SKIP THE NEXT BYTE WITH "MVI A,0" 
                                PUBLIC	STPRDY 
 0193  59                       STPRDY: POP	CX 
                                PUBLIC	READY 
 0194                           READY: 
 0194  E8 0000 E                	CALL	FINLPT		;PRINT ANY LEFT OVERS 
 0197  32 C0                    	XOR	AL,AL 
 0199  A2 0000 E                	MOV	BYTE PTR CNTOFL,AL	;FORCE OUTPUT 
 019C  E8 0000 E                	CALL	PRGFIN		;FINISH OUTPUT OF A FILE 
 019F  E8 0000 E                	CALL	CRDONZ		;IF NOT ALREADY AT LEFT, SEND CRLF 
 01A2  BB 0000 E                	MOV	BX,OFFSET REDDY ;"OK" CRLF 
 01A5                           REPINI: 
 01A5  E8 0000 E                	CALL	STROUT 
 01A8  A0 0000 E                	MOV	AL,BYTE PTR ERRFLG	;SEE IF IT WAS A "SYNTAX ERROR" 
 01AB  2C 00 E                  	SUB	AL,LOW OFFSET ERRSN 
                                	EXTRN	ERREDT:NEAR 
 01AD  75 03                    	JNZ	SHORT ??L005 
 01AF  E8 0000 E                	CALL	ERREDT		;"EDIT" THE BAD LINE 
 01B2                           ??L005: 
                                PUBLIC	MAIN 
 01B2                           MAIN: 
 01B2  BB FFFF                  	MOV	BX,65535 
 01B5  89 1E 0000 E             	MOV	CURLIN,BX	;SETUP CURLIN FOR DIRECT MODE 
 01B9  BB 0000 E                	MOV	BX,OFFSET ENDPRG 
 01BC  89 1E 0000 E             	MOV	SAVTXT,BX	;SAVTXT POINTS AT FAKE END OF PROGRAM 
 01C0  A0 0000 E                	MOV	AL,BYTE PTR AUTFLG	;IN AN AUTO COMMAND? 
 01C3  0A C0                    	OR	AL,AL		;SET CC'S 
 01C5  74 19                    	JZ	SHORT NTAUTO	;NO, REUGLAR MODE 
 01C7  8B 1E 0000 E             	MOV	BX,AUTLIN	;GET CURRENT AUTO LINE 
 01CB  53                       	PUSH	BX		;SAVE AWAY FOR LATER USE 
 01CC  E8 0000 E                	CALL	LINPRT		;PRINT THE LINE # 
 01CF  5A                       	POP	DX		;GET IT BACK 
 01D0  52                       	PUSH	DX		;SAVE BACK AGAIN 
 01D1  E8 036F R                	CALL	FNDLIN		;SEE IF IT EXISTS 
 01D4  B0 2A                    	MOV	AL,LOW "*"      ;CHAR TO PRINT IF LINE ALREADY EXISTS 
 01D6  72 02                    	JB	SHORT AUTELN	;DOESNT EXIST 
 01D8  B0 20                    	MOV	AL,LOW " "      ;PRINT SPACE 
 01DA  E8 0000 E                AUTELN: CALL	OUTDO		;PRINT CHAR 
 01DD  A2 0000 E                	MOV	BYTE PTR AUTFLG,AL	;SAVE WHETHER HAVE ASTERISK OR NOT 
 01E0                           NTAUTO: 
                                	EXTRN	PINLIN:NEAR 
 01E0  E8 0000 E                	CALL	PINLIN		;GET PROGRAM LINE INPUT 
 01E3  73 07                    	JAE	SHORT NTSTOP 
 01E5  32 C0                    	XOR	AL,AL 
 01E7  A2 0000 E                	MOV	BYTE PTR AUTFLG,AL	;IN CASE OF AUTO, CLEAR IT 
 01EA  EB C6                    	JMP	MAIN 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-27
STPRDY, READY, MAIN, CHEAD                                  

 01EC                           NTSTOP: 
 01EC  E8 083A R                	CALL	CHRGTR		;GET THE FIRST 
 01EF  FE C0                    	INC	AL		;SEE IF 0 SAVING THE CARRY FLAG 
 01F1  FE C8                    	DEC	AL 
 01F3  74 BD                    	JZ	SHORT MAIN	;IF SO, A BLANK LINE WAS INPUT 
 01F5  9C                       	PUSHF			;SAVE STATUS INDICATOR FOR 1ST CHARACTER 
 01F6  E8 098E R                	CALL	LINGET		;READ IN A LINE # 
 01F9  73 08                    	JAE	SHORT MAINBX	;ANOTHER DIGIT AFTER LINE#? 
 01FB  E8 0000 E                	CALL	ISFLIO		;AND COMING FROM TERMINAL? 
 01FE  75 03                    	JNZ	SHORT ??L006 
 0200  E9 0094 R                	JMP	SNERR		;IF SO, BAD INPUT 
 0203                           ??L006: 
 0203                           MAINBX: 
 0203  E8 0695 R                	CALL	BAKSP		;BACK UP THE POINTER 
 0206  A0 0000 E                	MOV	AL,BYTE PTR AUTFLG 
 0209  0A C0                    	OR	AL,AL 
 020B  74 0B                    	JZ	SHORT NTASTC	;NOT AUTO, DON'T CHECK FOR ASTERISK 
 020D  3C 2A                    	CMP	AL,LOW "*" 
 020F  75 07                    	JNZ	SHORT NTASTC	;AUTO DID NOT APPEND ASTERISK 
 0211  3A 07                    	CMP	AL,BYTE PTR [BX]	;DO WE HAVE ASTERISK? 
 0213  75 03                    	JNZ	SHORT ??L007 
 0215  E8 0000 E                	CALL	INXHRT		;YES, SKIP IT 
 0218                           ??L007: 
 0218                           NTASTC: 
 0218  0B D2                    	OR	DX,DX 
 021A  75 03                    	JNZ	SHORT ??L008 
 021C  EB 0A 90                 	JMP	EDENT		;BRIF no line number, don't skip space 
 021F                           ??L008: 
 021F  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET THE CHAR 
 0221  3C 20                    	CMP	AL,LOW " "      ;CHARACTER A SPACE? 
 0223  75 03                    	JNZ	SHORT ??L009 
 0225  E8 0000 E                	CALL	INXHRT		;THEN EAT PAST IT 
 0228                           ??L009: 
                                				;ONE SPACE ALWAYS PRINTED AFTER LINE # 
                                PUBLIC	EDENT 
 0228                           EDENT: 
 0228  52                       	PUSH	DX		;SAVE LINE # 
 0229  E8 0394 R                	CALL	CRUNCH		;CRUNCH THE LINE DOWN 
 022C  5A                       	POP	DX		;RESTORE LINE # 
 022D  9D                       	POPF			;WAS THERE A LINE #? 
 022E  89 1E 0000 E             	MOV	SAVTXT,BX	;FOR RESUMING A DIRECT STMT 
                                	EXTRN	DIRDO:NEAR 
 0232  72 03                    	JNAE	SHORT ??L010 
 0234  E9 0000 E                	JMP	DIRDO		;MAKE SURE WE'RE NOT READING A FILE 
 0237                           ??L010: 
 0237  52                       	PUSH	DX 
 0238  51                       	PUSH	CX		;SAVE LINE # AND CHARACTER COUNT 
 0239  E8 0000 E                	CALL	PROCHK		;DONT ALLOW ANY FUNNY BUSINESS WITH EXISTING PGM 
 023C  E8 083A R                	CALL	CHRGTR		;REMEMBER IF THIS LINE IS 
 023F  0A C0                    	OR	AL,AL		;SET THE ZERO FLAG ON ZERO 
                                				;LINES THAT START WITH ":" SHOULD NOT BE 
                                				;IGNORED 
 0241  9C                       	PUSHF			;BLANK SO WE DON'T INSERT IT 
 0242  89 16 0000 E             	MOV	DOT,DX		;SAVE THIS LINE # IN DOT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-28
STPRDY, READY, MAIN, CHEAD                                  

 0246  8B 1E 0000 E             	MOV	BX,AUTINC	;GET INCREMENT 
 024A  03 DA                    	ADD	BX,DX		;ADD INCREMENT TO THIS LINE 
 024C  72 0F                    	JB	SHORT AUTRES	;CHECK FOR PATHETIC CASE 
 024E  52                       	PUSH	DX		;SAVE LINE NUMBER # 
 024F  BA FFFA                  	MOV	DX,65530D	;CHECK FOR LINE # TOO BIG 
 0252  3B DA                    	CMP	BX,DX 
 0254  5A                       	POP	DX		;GET BACK LINE # 
 0255  73 06                    	JAE	SHORT AUTRES	;IF TOO BIG, QUIT 
 0257  89 1E 0000 E             	MOV	AUTLIN,BX	;SAVE IN NEXT LINE 
 025B  EB 05                    	JMP	SHORT AUTGOD 
 025D  32 C0                    AUTRES: XOR	AL,AL 
 025F  A2 0000 E                	MOV	BYTE PTR AUTFLG,AL	;LINE NUMBER TOO BIG, QUIT 
 0262                           AUTGOD: 
 0262  E8 036F R                	CALL	FNDLIN		;GET A POINTER TO THE LINE 
 0265  72 19                    	JB	SHORT LEXIST	;LINE EXISTS, DELETE IT 
 0267  9D                       	POPF			;GET FLAG SAYS WHETHER LINE BLANK 
 0268  9C                       	PUSHF			;SAVE BACK 
 0269  74 03                    	JZ	SHORT ??L011 
 026B  EB 0F 90                 	JMP	LXISTS		;Line exists - OK 
 026E                           ??L011: 
 026E  A0 0000 E                	MOV	AL,BYTE PTR AUTFLG 
 0271  0A C0                    	OR	AL,AL		;If not AUTO mode then error. 
 0273  75 03                    	JNZ	SHORT ??L012 
 0275  E9 0A79 R                	JMP	USERR		;TRYING TO DELETE NON-EXISTANT LINE, ERROR 
 0278                           ??L012: 
 0278  51                       	PUSH	CX		;Prepare to leave 
 0279  EB 7E 90                 	JMP	FINI 
 027C  0A C0                    LXISTS: OR	AL,AL		;CLEAR FLAG THAT SAYS LINE EXISTS 
 027E  EB 16                    	JMP	SHORT INONLY 
 0280                           LEXIST:			;SAVE THE POINTER 
 0280  9D                       	POPF			;Don't erase line on null input when 
 0281  9C                       	PUSHF			; in AUTO mode. 
 0282  74 03                    	JZ	SHORT ??L013 
 0284  EB 0F 90                 	JMP	ERAINS		;Line not null - go erase/insert 
 0287                           ??L013: 
 0287  A0 0000 E                	MOV	AL,BYTE PTR AUTFLG 
 028A  0A C0                    	OR	AL,AL		;AUTO mode? 
 028C  75 03                    	JNZ	SHORT ??L014 
 028E  EB 05 90                 	JMP	ERAINS		;No - go erase/insert 
 0291                           ??L014: 
 0291  51                       	PUSH	CX		;Prepare to exit 
 0292  EB 65 90                 	JMP	FINI 
 0295  F9                       ERAINS: STC 
 0296                           INONLY: 
 0296  51                       	PUSH	CX 
 0297  9C                       	PUSHF			;SAVE REGISTERS 
 0298  53                       	PUSH	BX		;SAVE [H,L] 
 0299  E8 1154 R                	CALL	DEPTR		;GET RID OF PTRS IN PGM 
 029C  5B                       	POP	BX		;GET BACK POINTER TO NEXT LINE 
 029D  9D                       	POPF			;GET BACK PSW 
 029E  59                       	POP	CX		;RESTORE POINTER TO THIS LINE 
 029F  51                       	PUSH	CX		;SAVE BACK AGAIN 
 02A0  73 03                    	JNB	SHORT ??L015 
 02A2  E8 0000 E                	CALL	DEL 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-29
STPRDY, READY, MAIN, CHEAD                                  

 02A5                           ??L015: 
 02A5  5A                       NODEL:	POP	DX		;POP POINTER AT PLACE TO INSERT 
 02A6  9D                       	POPF			;SEE IF THIS LINE HAD 
                                				;ANYTHING ON IT 
 02A7  52                       	PUSH	DX		;SAVE PLACE TO START FIXING LINKS 
 02A8  74 4F                    	JZ	SHORT FINI	;IF NOT DON'T INSERT 
 02AA  5A                       	POP	DX		;GET RID OF START OF LINK FIX 
 02AB  A0 0000 E                	MOV	AL,BYTE PTR CHNFLG	;ONLY CHANGET FRETOP IF NOT CHAINING 
 02AE  0A C0                    	OR	AL,AL 
 02B0  75 08                    	JNZ	SHORT LEVFRE	;LEAVE FRETOP ALONE 
 02B2  8B 1E 0000 E             	MOV	BX,MEMSIZ	;DELETE ALL STRINGS 
 02B6  89 1E 0000 E             	MOV	FRETOP,BX	;SO REASON DOESNT USE THEM 
 02BA                           LEVFRE: 
 02BA  BB 0000                  	MOV	BX,0		;Clear error trap before inserting 
 02BD  89 1E 0000 E             	MOV	ONELIN,BX	; to prevent OM error from being trapped 
 02C1  8B 1E 0000 E             	MOV	BX,VARTAB	;CURRENT END 
 02C5  5E                       	POP	SI		;XTHL 
 02C6  87 F3                    	XCHG	SI,BX 
 02C8  56                       	PUSH	SI		;[H,L]=CHARACTER COUNT. VARTAB 
                                				;ONTO THE STACK 
 02C9  59                       	POP	CX		;[B,C]=OLD VARTAB 
 02CA  53                       	PUSH	BX		;Save count of chars to move 
 02CB  03 D9                    	ADD	BX,CX 
 02CD  53                       	PUSH	BX		;SAVE NEW VARTAB 
 02CE  E8 0000 E                	CALL	BLTU 
 02D1  5B                       	POP	BX		;POP OFF VARTAB 
 02D2  89 1E 0000 E             	MOV	VARTAB,BX	;UPDATE VARTAB 
 02D6  87 DA                    	XCHG	BX,DX 
 02D8  88 3F                    	MOV	BYTE PTR [BX],BH	;FOOL CHEAD WITH NON-ZERO LINK 
 02DA  59                       	POP	CX		;Restore count of chars to move 
 02DB  5A                       	POP	DX		;GET LINE # OFF STACK 
 02DC  53                       	PUSH	BX		;SAVE START OF PLACE TO FIX LINKS 
 02DD  43                       	INC	BX		;SO IT DOESN'T THINK 
                                				;THIS LINK IS THE 
                                				;END OF THE PROGRAM 
 02DE  43                       	INC	BX 
 02DF  89 17                    	MOV	[BX],DX 
 02E1  43                       	INC	BX 
 02E2  43                       	INC	BX		;PUT DOWN LINE # 
 02E3  BA 0000 E                	MOV	DX,OFFSET KBUF	;MOVE LINE FRM KBUF TO PROGRAM AREA 
 02E6  49                       	DEC	CX		;FIX UP COUNT OF CHARS TO MOVE 
 02E7  49                       	DEC	CX		;(DONT INCLUDE LINE # & LINK) 
 02E8  49                       	DEC	CX		; 
 02E9  49                       	DEC	CX 
 02EA  8B F2                    MLOOPR: MOV	SI,DX 
 02EC  8A 04                    	MOV	AL,[SI]	;NOW TRANSFERING LINE 
                                				;IN FROM BUF 
 02EE  88 07                    	MOV	BYTE PTR [BX],AL 
 02F0  43                       	INC	BX 
 02F1  42                       	INC	DX 
 02F2  49                       	DEC	CX		;DECREMENT CHAR COUNT BY 1 
 02F3  8A C1                    	MOV	AL,CL		;TEST FOR COUNT EXHAUSTED 
 02F5  0A C5                    	OR	AL,CH		;BY SEEING IF [B,C]=0 
 02F7  75 F1                    	JNZ	SHORT MLOOPR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-30
STPRDY, READY, MAIN, CHEAD                                  

                                PUBLIC	FINI 
 02F9                           FINI: 
 02F9  5A                       EDTXIT: POP	DX		;GET START OF LINK FIXING AREA 
 02FA  E8 0309 R                	CALL	CHEAD		;FIX LINKS 
 02FD  E8 0000 E                	CALL	RUNC		;DO CLEAR & SET UP STACK 
 0300  E9 01B2 R                	JMP	MAIN		;GO TO MAIN CODE 
                                PUBLIC	LINKER 
 0303                           LINKER: 
 0303  8B 1E 0000 E             	MOV	BX,TXTTAB 
 0307  87 DA                    	XCHG	BX,DX 
                                ; 
                                ; CHEAD GOES THROUGH PROGRAM STORAGE AND FIXES 
                                ; UP ALL THE LINKS. THE END OF EACH 
                                ; LINE IS FOUND BY SEARCHING FOR THE ZERO AT THE END. 
                                ; THE DOUBLE ZERO LINK IS USED TO DETECT THE END OF THE PROGRAM 
                                ; 
                                PUBLIC	CHEAD 
 0309  8A FE                    CHEAD:	MOV	BH,DH		;[H,L]=[D,E] 
 030B  8A DA                    	MOV	BL,DL 
 030D  8A 07                    	MOV	AL,BYTE PTR [BX]	;SEE IF END OF CHAIN 
 030F  43                       	INC	BX		;BUMP POINTER 
 0310  0A 07                    	OR	AL,BYTE PTR [BX]	;2ND BYTE 
 0312  75 01                    	JNZ	SHORT $+3 
 0314  C3                       	RET 
 0315  43                       	INC	BX		;FIX H TO START OF TEXT 
 0316  43                       	INC	BX 
 0317  43                       CZLOOP: INC	BX		;BUMP POINTER 
 0318  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET BYTE 
 031A  0A C0                    CZLOO2: OR	AL,AL		;SET CC'S 
 031C  74 10                    	JZ	SHORT CZLIN	;END OF LINE, DONE. 
 031E  3C 20                    	CMP	AL,LOW OFFSET DBLCON+1	;EMBEDDED CONSTANT? 
 0320  73 F5                    	JAE	SHORT CZLOOP	;NO, GET NEXT 
 0322  3C 0B                    	CMP	AL,LOW 11	;IS IT LINEFEED OR BELOW? 
 0324  72 F1                    	JB	SHORT CZLOOP	;THEN SKIP PAST 
 0326  E8 083B R                	CALL	CHRGT2		;GET CONSTANT 
 0329  E8 083A R                	CALL	CHRGTR		;GET OVER IT 
 032C  EB EC                    	JMP	SHORT CZLOO2	;GO BACK FOR MORE 
 032E  43                       CZLIN:	INC	BX		;MAKE [H,L] POINT AFTER TEXT 
 032F  87 DA                    	XCHG	BX,DX		;SWITCH TEMP 
 0331  89 17                    	MOV	[BX],DX	;STORE FIXUP 
 0333  EB D4                    	JMP	SHORT CHEAD	;KEEP CHAINING TIL DONE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-31
STPRDY, READY, MAIN, CHEAD                                  

                                	PAGE 
                                 
                                	SUBTTL SCNLIN, FNDLIN - SCAN LINE RANGE AND FIND LINE # IN PROGRAM 
                                ; 
                                ; SCNLIN SCANS A LINE RANGE OF 
                                ; THE FORM  #-# OR # OR #- OR -# OR BLANK 
                                ; AND THEN FINDS THE FIRST LINE IN THE RANGE 
                                ; 
                                PUBLIC	SCNLIN 
 0335  BA 0000                  SCNLIN: MOV	DX,0		;ASSUME START LIST AT ZERO 
 0338  52                       	PUSH	DX		;SAVE INITIAL ASSUMPTION 
 0339  74 17                    	JZ	SHORT ALLLST	;IF FINISHED, LIST IT ALL 
 033B  3C 2C                    	CMP	AL,LOW 44D	;COMMA IS OK 
 033D  74 13                    	JZ	SHORT ALLLST	;Maybe list all to Gen Device. 
 033F  5A                       	POP	DX		;WE ARE GOING TO GRAB A # 
 0340  E8 0981 R                	CALL	LINSPC		;GET A LINE #. IF NONE, RETURNS ZERO 
 0343  52                       	PUSH	DX		;SAVE FIRST 
 0344  74 1D                    	JZ	SHORT SNGLIN	;IF ONLY # THEN DONE. 
 0346  3C 2C                    	CMP	AL,LOW 44D	;COMMA IS OK 
 0348  74 19                    	JZ	SHORT SNGLIN	;Maybe only one to Gen Device. 
 034A  E8 0000 E                	CALL	SYNCHR 
 034D  00 E                     	DB	OFFSET MINUTK	;MUST BE A DASH. 
 034E  74 02                    	JZ	SHORT ALLLST	;Brif EOS. 
 0350  3C 2C                    	CMP	AL,LOW 44D	; else must be comma or number. 
 0352  BA FFFA                  ALLLST: MOV	DX,65530	;ASSUME MAX END OF RANGE 
 0355  74 03                    	JZ	SHORT ??L016 
 0357  E8 0981 R                	CALL	LINSPC		;GET THE END OF RANGE 
 035A                           ??L016: 
 035A  74 07                    	JZ	SHORT SNGLIN	;Brif EOS. 
 035C  3C 2C                    	CMP	AL,LOW 44D 
 035E  74 03                    	JZ	SHORT ??L017 
 0360  E9 0094 R                	JMP	SNERR		;MUST BE TERMINATOR 
 0363                           ??L017: 
 0363                           SNGLIN: 
 0363  89 1E 0000 E             	MOV	TEMP,BX	; save Text pointer. 
 0367  87 DA                    	XCHG	BX,DX		;[H,L] = FINAL 
 0369  5A                       	POP	DX		;GET INITIAL IN [D,E] 
 036A  5E                       FNDLN1: POP	SI		;XTHL 
 036B  87 F3                    	XCHG	SI,BX 
 036D  56                       	PUSH	SI		;PUT MAX ON STACK, RETURN ADDR TO [H,L] 
 036E  53                       	PUSH	BX		;SAVE RETURN ADDRESS BACK 
                                ; 
                                ; FNDLIN SEARCHES THE PROGRAM TEXT FOR THE LINE 
                                ; WHOSE LINE # IS PASSED IN [D,E]. [D,E] IS PRESERVED. 
                                ; THERE ARE THREE POSSIBLE RETURNS: 
                                ; 
                                ;       1) ZERO FLAG SET. CARRY NOT SET.  LINE NOT FOUND. 
                                ;          NO LINE IN PROGRAM GREATER THAN ONE SOUGHT. 
                                ;          [B,C] POINTS TO TWO ZERO BYTES AT END OF PROGRAM. 
                                ;          [H,L]=[B,C] 
                                ; 
                                ;       2) ZERO, CARRY SET. 
                                ;          [B,C] POINTS TO THE LINK FIELD IN THE LINE 
                                ;          WHICH IS THE LINE SEARCHED FOR. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-32
SCNLIN, FNDLIN - SCAN LINE RANGE AND FIND LINE # IN PROGRAM 

                                ;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE. 
                                ; 
                                ;       3) NON-ZERO, CARRY NOT SET. 
                                ;          LINE NOT FOUND, [B,C]  POINTS TO LINE IN PROGRAM 
                                ;          GREATER THAN ONE SEARCHED FOR. 
                                ;          [H,L] POINTS TO THE LINK FIELD IN THE NEXT LINE. 
                                ; 
                                PUBLIC	FNDLIN 
 036F                           FNDLIN: 
 036F  8B 1E 0000 E             	MOV	BX,TXTTAB	;GET POINTER TO START OF TEXT 
 0373                           LOOP: 
 0373  8B CB                    	MOV	CX,BX		;IF EXITING BECAUSE OF END OF PROGRAM, 
                                				;SET [B,C] TO POINT TO DOUBLE ZEROES. 
 0375  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET WORD POINTER TO 
 0377  43                       	INC	BX		;BUMP  POINTER 
 0378  0A 07                    	OR	AL,BYTE PTR [BX]	;GET 2ND BYTE 
 037A  9F                       	LAHF 
 037B  4B                       	DEC	BX		;GO BACK 
 037C  9E                       	SAHF 
 037D  75 01                    	JNZ	SHORT $+3 
 037F  C3                       	RET			;IF ZERO THEN DONE 
 0380  43                       	INC	BX		;SKIP PAST AND GET THE LINE # 
 0381  43                       	INC	BX 
 0382  8B 1F                    	MOV	BX,[BX]	;INTO [H,L] FOR COMPARISON WITH 
                                				;THE LINE # BEING SEARCHED FOR 
                                				;WHICH IS IN [D,E] 
 0384  3B DA                    	CMP	BX,DX		;SEE IF IT MATCHES OR IF WE'VE GONE TOO FAR 
 0386  8B D9                    	MOV	BX,CX		;MAKE [H,L] POINT TO THE START OF THE 
                                				;LINE BEYOND THIS ONE, BY PICKING 
 0388  8B 1F                    	MOV	BX,[BX]	;UP THE LINK THAT [B,C] POINTS AT 
 038A  F5                       	CMC			;TURN CARRY ON 
 038B  75 01                    	JNZ	SHORT $+3 
 038D  C3                       	RET			;EQUAL RETURN 
 038E  F5                       	CMC			;MAKE CARRY ZERO 
 038F  72 01                    	JNAE	SHORT $+3 
 0391  C3                       	RET			;NO MATCH RETURN (GREATER) 
 0392  EB DF                    	JMP	SHORT LOOP	;KEEP LOOPING 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-33
SCNLIN, FNDLIN - SCAN LINE RANGE AND FIND LINE # IN PROGRAM 

                                	PAGE 
                                 
                                	SUBTTL PRE FAST CRUNCH - COMPACTIFICATION 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-34
PRE FAST CRUNCH - COMPACTIFICATION                          

                                	PAGE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-35
PRE FAST CRUNCH - COMPACTIFICATION                          

                                	PAGE 
                                 
                                	SUBTTL FAST CRUNCH - COMPACTIFICATION 
                                 
                                ; 
                                ; ALL "RESERVED" WORDS ARE TRANSLATED INTO SINGLE 
                                ; ONE OR TWO (IF TWO, FIRST IS ALWAYS 377 OCTAL) 
                                ; BYTES WITH THE MSB ON. THIS SAVES SPACE AND TIME 
                                ; BY ALLOWING FOR TABLE DISPATCH DURING EXECUTION. 
                                ; THEREFORE ALL STATEMENTS APPEAR TOGETHER IN THE 
                                ; RESERVED WORD LIST IN THE SAME 
                                ; ORDER THEY APPEAR IN IN STMDSP. 
                                ; 
                                ; NUMERIC CONSTANTS ARE ALSO CONVERTED TO THEIR INTERNAL 
                                ; BINARY REPRESENTATION TO IMPROVE EXECUTION SPEED 
                                ; LINE NUMBERS ARE ALSO PRECEEDED BY A SPECIAL TOKEN 
                                ; SO THAT LINE NUMBERS CAN BE CONVERTED TO POINTERS AT EXECUTION 
                                ; TIME. 
                                ; 
                                PUBLIC	CRUNCH 
 0394                           CRUNCH: 
 0394  32 C0                    	XOR	AL,AL		;SAY EXPECTING FLOATING NUMBERS 
 0396  A2 0000 E                	MOV	BYTE PTR DONUM,AL	;SET FLAG ACORDINGLY 
 0399  A2 0000 E                	MOV	BYTE PTR DORES,AL	;ALLOW CRUNCHING 
 039C  B9 013B                  	MOV	CX,OFFSET KBFLEN-3	;GET LENGTH OF KRUNCH BUFFER 
                                				;MINUS THREE BECAUSE OF ZEROS AT END 
 039F  BA 0000 E                	MOV	DX,OFFSET KBUF	;SETUP DESTINATION POINTER 
 03A2  8A 07                    KLOOP:	MOV	AL,BYTE PTR [BX]	;GET CHARACTER FROM BUF 
 03A4  0A C0                    	OR	AL,AL		;END OF LINE? 
 03A6  75 20                    	JNZ	SHORT NCRDON	;NO, CONTINUE 
 03A8                           CRDONE: 
 03A8  BB 0140                  	MOV	BX,OFFSET KBFLEN+2	;GET OFFSET 
 03AB  8A C3                    	MOV	AL,BL		;GET COUNT TO SUBTRACT FROM 
 03AD  2A C1                    	SUB	AL,CL		;SUBTRACT 
 03AF  8A C8                    	MOV	CL,AL 
 03B1  8A C7                    	MOV	AL,BH 
 03B3  1A C5                    	SBB	AL,CH 
 03B5  8A E8                    	MOV	CH,AL		;BC:=# OF CHARS CRUNCHED 
 03B7  BB FFFF E                	MOV	BX,OFFSET KBUF-1	;GET POINTER TO CHAR BEFORE KBUF 
                                				;AS "GONE" DOES A CHRGET 
 03BA  32 C0                    	XOR	AL,AL		;GET A ZERO 
 03BC  8B FA                    	MOV	DI,DX 
 03BE  AA                       	STOSB			;NEED THREE 0'S ON THE END 
 03BF  42                       	INC	DX		;ONE FOR END-OF-LINE 
 03C0  8B FA                    	MOV	DI,DX 
 03C2  AA                       	STOSB			;AND 2 FOR A ZERO LINK 
 03C3  42                       	INC	DX		;SINCE IF THIS IS A DIRECT STATEMENT 
 03C4  8B FA                    	MOV	DI,DX 
 03C6  AA                       	STOSB			;ITS END MUST LOOK LIKE THE END OF A PROGRAM 
 03C7  C3                       	RET			;END OF CRUNCHING 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-36
FAST CRUNCH - COMPACTIFICATION                              

                                	PAGE 
 03C8  3C 22                    NCRDON: CMP	AL,LOW 34	;QUOTE SIGN? 
 03CA  75 03                    	JNZ	SHORT ??L018 
 03CC  EB 34 90                 	JMP	STRNG		;YES, GO TO SPECIAL STRING HANDLING 
 03CF                           ??L018: 
 03CF  3C 20                    	CMP	AL,LOW " "      ;SPACE? 
 03D1  74 09                    	JZ	SHORT STUFFH	;JUST STUFF AWAY 
 03D3  A0 0000 E                	MOV	AL,BYTE PTR DORES	;IN DATA STATEMENT AND NO CRUNCH? 
 03D6  0A C0                    	OR	AL,AL 
 03D8  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET THE CHARACTER AGAIN 
 03DA  74 2F                    	JZ	SHORT NTDATA	;IF NO CRUNCHING JUST STORE 
                                				;THE CHARACTER 
 03DC  43                       STUFFH: INC	BX		;ENTRY TO BUMP [H,L] 
 03DD  50                       	PUSH	AX		;SAVE CHAR AS KRNSAV CLOBBERS 
 03DE  E8 063D R                	CALL	KRNSAV		;SAVE CHAR IN KRUNCH BUFFER 
 03E1  58                       	POP	AX		;RESTORE CHAR 
 03E2  2C 3A                    	SUB	AL,LOW ":"      ;SEE IF IT IS A COLON 
 03E4  74 06                    	JZ	SHORT COLIS	;IF SO ALLOW CRUNCHING AGAIN 
 03E6  3C 00 E                  	CMP	AL,LOW OFFSET $DATCO 
 03E8  75 08                    	JNZ	SHORT NODATT	;SEE IF IT IS A DATA TOKEN 
 03EA  B0 01                    	MOV	AL,LOW 1	;SET LINE NUMBER ALLOWED FLAG 
                                				;KLUDGE AS HAS TO BE NON-ZERO. 
 03EC  A2 0000 E                COLIS:	MOV	BYTE PTR DORES,AL	;SETUP FLAG 
 03EF  A2 0000 E                	MOV	BYTE PTR DONUM,AL	;SET NUMBER ALLOWED FLAG 
 03F2  2C 00 E                  NODATT: SUB	AL,LOW OFFSET $REMCO 
 03F4  75 AC                    	JNZ	SHORT KLOOP	;KEEP LOOPING 
 03F6  50                       	PUSH	AX		;SAVE TERMINATOR ON STACK 
 03F7  8A 07                    STR1:	MOV	AL,BYTE PTR [BX]	;GET A CHAR 
 03F9  0A C0                    	OR	AL,AL		;SET CONDITION CODES 
 03FB  58                       	POP	AX		;GET AL BACK WITHOUT AFFECTING PSW 
 03FC  74 AA                    	JZ	SHORT CRDONE	;IF END OF LINE THEN DONE 
 03FE  3A 07                    	CMP	AL,BYTE PTR [BX]	;COMPARE CHAR WITH THIS TERMINATOR 
 0400  74 DA                    	JZ	SHORT STUFFH	;IF YES, DONE WITH STRING 
 0402                           STRNG: 
 0402  50                       	PUSH	AX		;SAVE TERMINATOR 
 0403  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET BACK LINE CHAR 
 0405  43                       STRNG2: INC	BX		;INCREMENT TEXT POINTER 
 0406  E8 063D R                	CALL	KRNSAV		;SAVE CHAR IN KRUNCH BUFFER 
 0409  EB EC                    	JMP	SHORT STR1	;KEEP LOOPING 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-37
FAST CRUNCH - COMPACTIFICATION                              

                                	PAGE 
                                ; NOW CHECK HGHBIT CHARS, ? FOR PRINT 
 040B                           NTDATA: 
 040B  43                       	INC	BX		;IF SO SKIP IT 
 040C  0A C0                    	OR	AL,AL		;IS THIS A KANA CHARACTER IN A BAD PLACE? 
 040E  79 02                    	JNS	SHORT ??L019 
 0410  EB 90                    	JMP	KLOOP		;MOVE TO THE NEXT CHARACTER 
 0412                           ??L019: 
 0412  4B                       	DEC	BX		;RESTORE THE TEXT POINTER 
 0413  3C 3F                    	CMP	AL,LOW "?"      ;A QMARK? 
 0415  B0 00 E                  	MOV	AL,LOW OFFSET $PRINT 
 0417  52                       	PUSH	DX		;SAVE STORE POINTER 
 0418  51                       	PUSH	CX		;SAVE CHAR COUNT 
 0419  75 03                    	JNZ	SHORT ??L020 
 041B  E9 0501 R                	JMP	NOTFN2		;THEN USE A "PRINT" TOKEN 
 041E                           ??L020: 
                                				;***5.11 DONT ALLOW FOLLOWING LINE #*** 
 041E  BA 0000 E                	MOV	DX,OFFSET SPCTAB	;ASSUME WE'LL SEARCH SPECIAL CHAR TABLE 
 0421  E8 0000 E                	CALL	MAKUPL		;TRANSLATE THIS CHAR TO UPPER CASE 
 0424  E8 0000 E                	CALL	ISLET2		;LETTER? 
 0427  73 03                    	JAE	SHORT ??L021 
 0429  E9 0560 R                	JMP	TSTNUM		;NOT A LETTER, TEST FOR NUMBER 
 042C                           ??L021: 
 042C  53                       	PUSH	BX		;SAVE TEXT POINTER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-38
FAST CRUNCH - COMPACTIFICATION                              

                                	PAGE 
                                ; ANSI SAYS YOU CAN USE "GO TO" AND "GO SUB" WITH ANY NUMBER OF SPACES 
 042D  BA 046A R                	MOV	DX,OFFSET GOSTEX	;CHECK FOR "GO " 
 0430  E8 0453 R                	CALL	CHKRES		;THAT IT? 
 0433  75 3F                    	JNZ	SHORT NOTGOS	;NOPE 
 0435  E8 083A R                	CALL	CHRGTR		;SKIP ANY NUMBER OF SPACES 
 0438  BA 046E R                	MOV	DX,OFFSET TOTEX ;IS IT TO? 
 043B  E8 0453 R                	CALL	CHKRES		;CHECK 
 043E  B0 00 E                  	MOV	AL,LOW OFFSET $GOTO	;ASSUME SO 
 0440  75 03                    	JNZ	SHORT ??L022 
 0442  EB 0B 90                 	JMP	GPUTRS		;USE IT 
 0445                           ??L022: 
 0445  BA 0471 R                	MOV	DX,OFFSET SUBTEX	;"GO SUB" 
 0448  E8 0453 R                	CALL	CHKRES 
 044B  75 27                    	JNZ	SHORT NOTGOS	;NO 
 044D  B0 00 E                  	MOV	AL,LOW OFFSET $GOSUB 
 044F  59                       GPUTRS: POP	CX		;POP OFF THE OLD TEXT POINTER 
 0450  E9 0501 R                	JMP	NOTFN2		;STORE THE RESERVED WORD 
                                ; CHECK MEMORY POINTED TO BY TEXT POINTER WITH 
                                ; A SPECIFIED PARTIAL RESRWORD 
 0453                           CHKRES: 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 0457  0A C0                    	OR	AL,AL		;END OF MATCHED PARTIAL RESWORD? 
 0459  75 01                    	JNZ	SHORT $+3 
 045B  C3                       	RET			;YES, DONE 
 045C  8A C8                    	MOV	CL,AL		;SAVE CHAR 
 045E  E8 0000 E                	CALL	MAKUPL		;GET CHAR FROM TEXT 
 0461  3A C1                    	CMP	AL,CL		;CHARS THE SAME? 
 0463  74 01                    	JZ	SHORT $+3 
 0465  C3                       	RET			;DONE 
 0466  43                       	INC	BX		;BUMP POINTER INTO TEXT 
 0467  42                       	INC	DX		;AND RESWORD TEXT 
 0468  EB E9                    	JMP	SHORT CHKRES	;LOOP TILL DONE 
                                 
 046A  47 4F 20                 GOSTEX: DB"GO " 
 046D  00                       	DB	0 
                                 
 046E  54 4F                    TOTEX:	DB"TO" 
 0470  00                       	DB	0 
                                 
 0471  55 42                    SUBTEX: DB"UB" 
 0473  00                       	DB	0 
                                 
 0474  5B                       NOTGOS: POP	BX 
 0475  E8 0000 E                	CALL	MAKUPL		;GET BACK THE CHARACTER 
 0478  53                       	PUSH	BX		;RESAVE THE TEXT POINTER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-39
FAST CRUNCH - COMPACTIFICATION                              

                                	PAGE 
                                ; NOW SEARCH ALPHA CHARACTER TABLES 
                                ; TAKE THE FIRST CHARACTER AND USE IT AS AN INDEX INTO THE 
                                ; TWENTY-SIX TABLES THAT CONTAIN THE RESERVED WORDS FOR EACH 
                                ; LETTER 
                                ; 
 0479  BB 0000 E                	MOV	BX,OFFSET ALPTAB	;GET POINTER TO ALPHA DISPATCH TABLE 
 047C  2C 41                    	SUB	AL,LOW "A"      ;SUBTRACT ALPHA OFFSET 
 047E  02 C0                    	ADD	AL,AL		;MULTIPLY BY TWO 
 0480  8A C8                    	MOV	CL,AL		;SAVE OFFSET IN [C] FOR DAD. 
 0482  B5 00                    	MOV	CH,LOW 0	;MAKE HIGH PART OF OFFSET ZERO 
 0484  03 D9                    	ADD	BX,CX		;ADD TO TABLE ADDRESS 
                                	INS86	56 
 0487  8B 17                    	MOV	DX,[BX]	;GET POINTER IN [D,E] 
 0489  5B                       	POP	BX		;GET BACK SOURCE POINTER 
 048A  43                       	INC	BX		;POINT TO CHAR AFTER FIRST ALPHA 
 048B  53                       TRYAGA: PUSH	BX		;SAVE TXTPTR TO START OF SEARCH AREA 
 048C                           LOPPSI: 
 048C  E8 0000 E                	CALL	MAKUPL		;TRANSLATE THIS CHAR TO UPPER CASE 
 048F  8A C8                    	MOV	CL,AL		;SAVE CHAR IN [C] 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 0495  24 7F                    	AND	AL,LOW 127	;GET RID OF HIGH BIT 
 0497  75 03                    	JNZ	SHORT ??L023 
 0499  E9 064E R                	JMP	NOTRES		;IF=0 THEN END OF THIS CHARS RESLT 
 049C                           ??L023: 
 049C  43                       	INC	BX		;BUMP SOURCE POINTER 
 049D  3A C1                    	CMP	AL,CL		;COMPARE TO CHAR FROM SOURCE LINE 
 049F  75 50                    	JNZ	SHORT LOPSKP	;IF NO MATCH, SEARCH FOR NEXT RESWRD 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 04A5  42                       	INC	DX		;BUMP RESLST POINTER 
 04A6  0A C0                    	OR	AL,AL		;SET CC'S 
 04A8  78 02                    	JS	SHORT ??L024 
 04AA  EB E0                    	JMP	LOPPSI		;SEE IF REST OF CHARS MATCH 
 04AC                           ??L024: 
 04AC  8A C1                    	MOV	AL,CL		;GET LAST CHAR OF RESWRD 
 04AE  3C 28                    	CMP	AL,LOW "("      ;IF TAB( OR SPC(, SPACE NEED NOT FOLLOW 
 04B0  74 1D                    	JZ	SHORT ISRESW	;IS A RESWORD 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 04B6  3C 00 E                  	CMP	AL,LOW OFFSET $FN	;FUNCTION? 
 04B8  74 15                    	JZ	SHORT ISRESW	;THEN NO SPACE NEED AFTERWARD 
 04BA  3C 00 E                  	CMP	AL,LOW OFFSET $USR	;OR USR DEFINITION? 
 04BC  74 11                    	JZ	SHORT ISRESW 
 04BE  E8 0000 E                	CALL	MAKUPL		;GET NEXT CHAR IN LINE (MC 6/22/80) 
 04C1  3C 2E                    	CMP	AL,LOW "."      ;IS IT A DOT 
 04C3  74 03                    	JZ	SHORT ISVARS	;YES 
 04C5  E8 0000 E                	CALL	TSTANM		;IS IT A LETTER IMMEDIATELY FOLLOWING RESWRD 
 04C8  B0 00                    ISVARS: MOV	AL,LOW 0	;SET DONUM TO -1 
 04CA  72 03                    	JNAE	SHORT ??L025 
 04CC  E9 064E R                	JMP	NOTRES		;IF ALPHA, CANT BE RESERVED WORD 
 04CF                           ??L025: 
 04CF                           ISRESW: 
 04CF  58                       	POP	AX		;GET RID OF SAVED [H,L] 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 04D4  0A C0                    	OR	AL,AL		;SET CC'S 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-40
FAST CRUNCH - COMPACTIFICATION                              

 04D6  79 03                    	JNS	SHORT ??L026 
 04D8  EB 26 90                 	JMP	NOTFNT		;IF MINUS, WASNT FUNCTION TOKEN 
 04DB                           ??L026: 
 04DB  59                       	POP	CX		;GET CHAR COUNT OFF STACK 
 04DC  5A                       	POP	DX		;GET DEPOSIT POINTER OFF STACK 
 04DD  0C 80                    	OR	AL,LOW 200O	;MAKE HIGH ORDER BIT ONE 
 04DF  50                       	PUSH	AX		;SAVE FN CHAR 
 04E0  B0 FF                    	MOV	AL,LOW 377O	;GET BYTE WHICH PRECEEDS FNS 
                                PUBLIC	RENCRN 
 04E2                           RENCRN: 
 04E2  E8 063D R                	CALL	KRNSAV		;SAVE IN KRUNCH BUFFER 
 04E5  32 C0                    	XOR	AL,AL		;MAKE A ZERO 
 04E7  A2 0000 E                	MOV	BYTE PTR DONUM,AL	;TO RESET DONUM (FLOATINGS ALLOWED) 
 04EA  58                       	POP	AX		;GET FUNCTION TOKEN 
 04EB  E8 063D R                	CALL	KRNSAV		;STORE IT 
 04EE  E9 03A2 R                	JMP	KLOOP		;KEEP KRUNCHING 
                                 
 04F1  5B                       LOPSKP: POP	BX		;RESTORE UNDEFILED TEXT POINTER 
 04F2                           LOPSK2: 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 04F6  42                       	INC	DX		;BUMP RESLST POINTER 
 04F7  0A C0                    	OR	AL,AL		;SET CC'S 
 04F9  78 02                    	JS	SHORT ??L027 
 04FB  EB F5                    	JMP	LOPSK2		;NOT END OF RESWRD, KEEP SKIPPING 
 04FD                           ??L027: 
 04FD  42                       	INC	DX		;POINT AFTER TOKEN 
 04FE  EB 8B                    	JMP	TRYAGA		;TRY ANOTHER RESWRD 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-41
FAST CRUNCH - COMPACTIFICATION                              

                                	PAGE 
                                ; CHECK TO SEE IF RESERVED WORD MATCHES A LIST OF 
                                ; RESERVED WORDS THAT HAVE LINE NUMBERS FOLLOWING THEM INSTEAD 
                                ; OF FLOATING POINT NUMBERS. IF A MATCH IS FOUND, SET DONUM TO 
                                ; INDICATE THAT IF A NUMBER OCCURS, IT IS CRUNCHED AS A LINE NUMBER. 
                                ; 
 0500  4B                       NOTFNT: DEC	BX		;FIX TEXT POINTER 
 0501  50                       NOTFN2: PUSH	AX		;SAVE CHAR TO BE SAVED IN KRUNCH BUFFER 
 0502  BA 0516 R                	MOV	DX,OFFSET LINRES	;POINT TO RESERVED WORDS THAT HAVE LINE ARGS 
 0505  8A C8                    	MOV	CL,AL		;SAVE CHARACTER TO MATCH IN [C] 
 0507                           NOTFN3: 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 050B  0A C0                    	OR	AL,AL		;END OF LIST? 
 050D  74 17                    	JZ	SHORT NOTFN4	;YES, DONE 
 050F  42                       	INC	DX		;POINT TO NEXT RESWORD 
 0510  3A C1                    	CMP	AL,CL		;SAME AS ONE WERE LOOKING AT? 
 0512  75 F3                    	JNZ	SHORT NOTFN3	;KEEP LOOKING 
 0514  EB 14                    	JMP	SHORT NOTRS2	;DOESNT HAVE LINE # ARG 
                                 
 0516  00 E                     LINRES: DB	OFFSET $RESTORE ;RESTORE CAN HAVE FOLLOWING LINE NUMBER 
 0517  00 E                     	DB	OFFSET $AUTO	;AUTO COMMAND 
 0518  00 E                     	DB	OFFSET $RENUM	;RENUMBER? 
 0519  00 E                     	DB	OFFSET $DELETE	;DELETE? 
 051A  00 E                     	DB	OFFSET $EDIT	;EDIT? 
 051B  00 E                     	DB	OFFSET $RESUME	;RESUME? 
 051C  00 E                     	DB	OFFSET $ERL	;ERROR LINE 
                                				;SO THAT IF "ERL=...THEN" 
                                				;WILL RESEQUENCE PROPERLY 
                                				;THIS CAN MAKE STATEMENTS LIKE 
                                				;"PRINT ERL,1E20" DO STRANGE THINGS 
 051D  00 E                     	DB	OFFSET $ELSE	;IF ELSE CRUNCH FOLLOWING LINE # 
 051E  00 E                     	DB	OFFSET $RUN	;RUN? 
 051F  00 E                     	DB	OFFSET $LIST	;LIST? 
 0520  00 E                     	DB	OFFSET $LLIST	;LPT LIST? 
 0521  00 E                     	DB	OFFSET $GOTO	;IF GOTO, CRUNCH LINE # 
 0522  00 E                     	DB	OFFSET $RETURN	;NON LOCAL RETURN ALLOWS LINE # AFTER RETURN 
 0523  00 E                     	DB	OFFSET $THEN	;CRUNCH LINE #'S AFTER 'THEN' 
 0524  00 E                     	DB	OFFSET $GOSUB	;IF GOSUB, CRUNCH LINE #'S 
 0525  00                       	DB	0 
                                 
 0526  32 C0                    NOTFN4: XOR	AL,AL		;GET A ZERO (EXPECT USUALL NUMBERS) 
 0528  EB 02                    	JMP	SHORT NOTRS6 
 052A  B0 01                    NOTRS2: MOV	AL,LOW 1	;SAY LINE #'S ALLOWED. 
 052C  A2 0000 E                NOTRS6: MOV	BYTE PTR DONUM,AL	;SAVE IN FLAG 
 052F  58                       	POP	AX		;RESTORE CHARACTER TO SAVE IN KRUNCH BUFFER 
 0530  59                       	POP	CX		;GET BACK THE CHARACTER COUNT 
 0531  5A                       	POP	DX		;GET STUFF POINTER BACK 
 0532  3C 00 E                  	CMP	AL,LOW OFFSET $ELSE	;HAVE TO PUT A HIDDEN 
                                				;COLON IN FRONT OF "ELSE"S 
 0534  50                       	PUSH	AX		;SAVE CURRENT CHAR ($ELSE) 
 0535  75 03                    	JNZ	SHORT ??L028 
 0537  E8 063B R                	CALL	KRNSVC		;SAVE ":" IN CRUNCH BUFFER 
 053A                           ??L028: 
 053A  58                       	POP	AX		;GET BACK TOKEN 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-42
FAST CRUNCH - COMPACTIFICATION                              

 053B  3C 00 E                  	CMP	AL,LOW OFFSET $WHILE	;SEE IF WHILE TO IN A PLUS TO AVOID 
 053D  75 05                    	JNZ	SHORT CKSNGQ	;Brif not 
 053F  E8 063D R                	CALL	KRNSAV		;Emit WHILE Token, then Plus (+) 
 0542  B0 00 E                  	MOV	AL,LOW OFFSET PLUSTK	;PLUS SIGN IS OK AND AVOIDS CONSTANT 
 0544  3C 00 E                  CKSNGQ: CMP	AL,LOW OFFSET SNGQTK	;SINGLE QUOATATION MARK? 
 0546  74 03                    	JZ	SHORT ??L029 
 0548  E9 0618 R                	JMP	NTSNGT 
 054B                           ??L029: 
 054B  50                       	PUSH	AX		;SAVE SNGQTK 
 054C  E8 063B R                	CALL	KRNSVC		;SAVE ":" IN CRUNCH BUFFER 
 054F  B0 00 E                  	MOV	AL,LOW OFFSET $REM	;STORE ":$REM" IN FRONT FOR EXECUTION 
 0551  E8 063D R                	CALL	KRNSAV		;SAVE IT 
 0554  58                       	POP	AX		;GET SNGQTK BACK 
 0555  53                       	PUSH	BX		;save text pointer 
 0556  BB 0000                  	MOV	BX,0 
 0559  5E                       	POP	SI		;XTHL 
 055A  87 F3                    	XCHG	SI,BX 
 055C  56                       	PUSH	SI		;Save terminator (0), restore Txt Ptr 
 055D  E9 0405 R                	JMP	STRNG2		;STUFF THE REST OF THE LINE WITHOUT CRUNCHING 
 0560  8A 07                    TSTNUM: MOV	AL,BYTE PTR [BX]	;GET CHAR 
 0562  3C 2E                    	CMP	AL,LOW "."      ;TEST FOR START OF FLOATING # 
 0564  74 0E                    	JZ	SHORT NUMTRY	;TRY INPUTTING IT AS CONSTANT 
 0566  3C 3A                    	CMP	AL,LOW OFFSET "9"+1     ;IS IT A DIGIT? 
 0568  72 03                    	JNAE	SHORT ??L030 
 056A  E9 05FD R                	JMP	SRCSPC		;NO, TRY OTHER THINGS 
 056D                           ??L030: 
 056D  3C 30                    	CMP	AL,LOW "0"      ;TRY LOWER END 
 056F  73 03                    	JAE	SHORT ??L031 
 0571  E9 05FD R                	JMP	SRCSPC		;NO TRY OTHER POSSIBILITIES 
 0574                           ??L031: 
 0574  A0 0000 E                NUMTRY: MOV	AL,BYTE PTR DONUM	;TEST FOR NUMBERS ALLOWED 
 0577  0A C0                    	OR	AL,AL		;SET CC'S 
 0579  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET CHAR IF GOING TO STUFFH 
 057B  59                       	POP	CX		;RESTORE CHAR COUNT 
 057C  5A                       	POP	DX		;RESTORE DEP. POINTER 
 057D  79 03                    	JNS	SHORT ??L032 
 057F  E9 03DC R                	JMP	STUFFH		;NO, JUST STUFF IT (!) 
 0582                           ??L032: 
 0582  74 27                    	JZ	SHORT FLTGET	;IF DONUM=0 THEN FLOATING #'S ALLOWED 
 0584  3C 2E                    	CMP	AL,LOW "."      ;IS IT DOT? 
 0586  75 03                    	JNZ	SHORT ??L033 
 0588  E9 03DC R                	JMP	STUFFH		;YES, STUFF IT FOR HEAVENS SAKE! (EDIT .) 
 058B                           ??L033: 
 058B  B0 0E                    	MOV	AL,LOW OFFSET LINCON	;GET LINE # TOKEN 
 058D  E8 063D R                	CALL	KRNSAV		;SAVE IT 
 0590  52                       	PUSH	DX		;SAVE DEPOSIT POINTER 
 0591  E8 098E R                	CALL	LINGET		;GET THE LINE #. 
 0594  E8 0695 R                	CALL	BAKSP		;BACK UP POINTER TO AFTER LAST DIGIT 
 0597  5E                       SAVINT: POP	SI		;XTHL 
 0598  87 F3                    	XCHG	SI,BX 
 059A  56                       	PUSH	SI		;EXCHANGE CURRENT [H,L] WITH SAVED [D,E] 
 059B  87 DA                    	XCHG	BX,DX		;GET SAVED [D,E] IN [D,E] 
 059D  8A C3                    SAVI:	MOV	AL,BL		;GET LOW BYTE OF VALUE RETURNED BY LINGET 
 059F  E8 063D R                	CALL	KRNSAV		;SAVE THE LOW BYTE OF LINE # 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-43
FAST CRUNCH - COMPACTIFICATION                              

 05A2  8A C7                    	MOV	AL,BH		;GET HIGH BYTE 
 05A4  5B                       POPSTF: POP	BX		;RESTORE [H,L] 
 05A5  E8 063D R                	CALL	KRNSAV		;SAVE IT TOO 
 05A8  E9 03A2 R                	JMP	KLOOP		;EAT SOME MORE 
                                 
 05AB  52                       FLTGET: PUSH	DX		;SAVE DEPOSIT POINTER 
 05AC  51                       	PUSH	CX		;SAVE CHAR COUNT 
 05AD  8A 07                    	MOV	AL,BYTE PTR [BX]	;FIN ASSUMES CHAR IN [A] 
 05AF  E8 0000 E                	CALL	FIN		;READ THE # 
 05B2  E8 0695 R                	CALL	BAKSP		;BACK UP POINTER TO AFTER LAST DIGIT 
 05B5  59                       	POP	CX		;RESTORE CHAR COUNT 
 05B6  5A                       	POP	DX		;RESTORE DEPOSIT POINTER 
 05B7  53                       	PUSH	BX		;SAVE TEXT POINTER 
 05B8  A0 0000 E                	MOV	AL,BYTE PTR VALTYP	;GET VALUE TYPE 
 05BB  3C 02                    	CMP	AL,LOW 2	;INTEGER? 
 05BD  75 1A                    	JNZ	SHORT NTINTG	;NO 
 05BF  8B 1E 0000 E             	MOV	BX,FACLO	;GET IT 
 05C3  8A C7                    	MOV	AL,BH		;GET HIGH PART 
 05C5  0A C0                    	OR	AL,AL		;IS IT ZERO? 
 05C7  B0 02                    	MOV	AL,LOW 2	;RESTORE INT VALTYP 
 05C9  75 0E                    	JNZ	SHORT NTINTG	;THEN ISNT SINGLE BYTE INT 
 05CB  8A C3                    	MOV	AL,BL		;GET LOW BYTE 
 05CD  8A FB                    	MOV	BH,BL		;GET LOW BYTE IN HIGH BYTE TO STORE 
 05CF  B3 0F                    	MOV	BL,LOW OFFSET IN2CON	;GET CONSTANT FOR 1 BYTE INTS 
 05D1  3C 0A                    	CMP	AL,LOW 10	;IS IT TOO BIG FOR A SINGLE BYTE CONSTANT? 
 05D3  73 C8                    	JAE	SHORT SAVI	;TOO BIG, USE SINGLE BYTE INT 
 05D5  04 11                    	ADD	AL,LOW OFFSET ONECON	;MAKE SINGLE BYTE CONSTANT 
 05D7  EB CB                    	JMP	SHORT POPSTF	;POP H & STUFF AWAY CHAR 
 05D9  50                       NTINTG: PUSH	AX		;SAVE FOR LATER 
 05DA  D0 C8                    	ROR	AL,1		;DIVIDE BY TWO 
 05DC  04 1B                    	ADD	AL,LOW OFFSET INTCON-1	;ADD OFFSET TO GET TOKEN 
 05DE  E8 063D R                	CALL	KRNSAV		;SAVE THE TOKEN 
 05E1  BB 0000 E                	MOV	BX,OFFSET FACLO ;GET START POINTER 
 05E4  E8 0000 E                	CALL	GETYPR		;SET CC'S ON VALTYPE 
 05E7  72 03                    	JB	SHORT NTDBL	;IF NOT DOUBLE, START MOVING AT FACLO 
 05E9  BB 0000 E                	MOV	BX,OFFSET DFACLO	;DOUBLE, START MOVING AT DFACLO 
 05EC  58                       NTDBL:	POP	AX 
 05ED  50                       MOVCON: PUSH	AX		;SAVE BYTE MOVE COUNT 
 05EE  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET A BYTE 
 05F0  E8 063D R                	CALL	KRNSAV		;SAVE IT IN KRUNCH BUFFER 
 05F3  58                       	POP	AX		;GET BACK COUNT 
 05F4  43                       	INC	BX		;BUMP POINTER INTO FAC 
 05F5  FE C8                    	DEC	AL		;MOVE IT DOWN 
 05F7  75 F4                    	JNZ	SHORT MOVCON	;KEEP MOVING IT 
 05F9  5B                       	POP	BX		;GET BACK SAVED TEXT POINTER 
 05FA  E9 03A2 R                	JMP	KLOOP		;KEEP LOOPING 
                                 
 05FD  BA FFFF E                SRCSPC: MOV	DX,OFFSET SPCTAB-1	;GET POINTER TO SPECIAL CHARACTER TABLE 
 0600  42                       SRCSP2: INC	DX		;MOVE POINTER AHEAD 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 0605  24 7F                    	AND	AL,LOW 177O	;MASK OFF HIGH BIT 
 0607  75 03                    	JNZ	SHORT ??L034 
 0609  EB 6D 90                 	JMP	NOTRS5		;IF END OF TABLE, STUFF AWAY, DONT CHANGE DONUM 
 060C                           ??L034: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-44
FAST CRUNCH - COMPACTIFICATION                              

 060C  42                       	INC	DX		;BUMP POINTER 
 060D  3A 07                    	CMP	AL,BYTE PTR [BX]	;IS THIS SPECIAL CHAR SAME AS CURRENT TEXT CHAR? 
                                	INS86	213,362,56,254	;FETCH FROM CODE SEGMENT 
 0613  75 EB                    	JNZ	SHORT SRCSP2	;IF NO MATCH, KEEP LOOKING 
 0615  EB 71 90                 	JMP	NOTRS1		;FOUND, SAVE AWAY AND SET DONUM=1. 
                                 
 0618                           NTSNGT: 
 0618  3C 26                    	CMP	AL,LOW "&"      ;OCTAL CONSTANT? 
 061A  74 03                    	JZ	SHORT ??L035 
 061C  E9 03DC R                	JMP	STUFFH		;JUST STUFF IT AWAY 
 061F                           ??L035: 
 061F  53                       	PUSH	BX		;SAVE TEXT POINTER 
 0620  E8 083A R                	CALL	CHRGTR		;GET NEXT CHAR 
 0623  5B                       	POP	BX		;RESTORE TEXT POINTER 
 0624  E8 0000 E                	CALL	MAKUPS		;MAKE CHAR UPPER CASE 
 0627  3C 48                    	CMP	AL,LOW "H"      ;HEX CONSTANT? 
 0629  B0 0B                    	MOV	AL,LOW OFFSET OCTCON	;ASSUME OCTAL CONSTANT 
 062B  75 02                    	JNZ	SHORT WUZOCT	;YES, IT WAS 
 062D  B0 0C                    	MOV	AL,LOW OFFSET HEXCON	;NO, WAS HEX 
 062F  E8 063D R                WUZOCT: CALL	KRNSAV		;SAVE IT 
 0632  52                       	PUSH	DX		;SAVE CURRENT DEPOSIT POINTER 
 0633  51                       	PUSH	CX		;SAVE COUNT 
 0634  E8 0000 E                	CALL	OCTCNS		;GET THE VALUE 
 0637  59                       	POP	CX		;RESTORE [B,C] 
 0638  E9 0597 R                	JMP	SAVINT		;SAVE THE INTEGER IN THE KRUNCH BUFFER 
                                 
 063B  B0 3A                    KRNSVC: MOV	AL,LOW ":"      ;GET COLON 
 063D                           KRNSAV: 
 063D  8B FA                    	MOV	DI,DX 
 063F  AA                       	STOSB			;SAVE BYTE IN KRUNCH BUFFER 
 0640  42                       	INC	DX		;BUMP POINTER 
 0641  49                       	DEC	CX		;DECREMENT COUNT OF BYTES LEFT IN BUFFER 
 0642  8A C1                    	MOV	AL,CL		;TEST IF IT WENT TO ZERO 
 0644  0A C5                    	OR	AL,CH		;BY SEEING IF DOUBLE BYTE ZERO. 
 0646  74 01                    	JZ	SHORT $+3 
 0648  C3                       	RET			;ALL DONE IF STILL SPACE LEFT 
                                PUBLIC	LBOERR 
 0649  B2 00 E                  LBOERR: MOV	DL,LOW OFFSET ERRLBO	;GET ERROR CODE 
 064B  E9 00AE R                	JMP	ERROR		;JUMP TO ERROR ROUTINE 
                                 
 064E                           NOTRES: 
                                	EXTRN	CRUNCX:NEAR 
 064E  E9 0000 E                	JMP	CRUNCX		;Go to extended CRUNCH code. 
                                PUBLIC	NOTRFN 
 0651                           NOTRFN: 
 0651  5B                       	POP	BX		;GET BACK POINTER TO ORIGINAL CHAR 
 0652  4B                       	DEC	BX		;NOW POINT TO FIRST ALPHA CHAR 
 0653  FE C8                    	DEC	AL		;SET A TO MINUS ONE 
 0655  A2 0000 E                	MOV	BYTE PTR DONUM,AL	;FLAG WERE IN VARIABLE NAME 
 0658  59                       	POP	CX		;GET BACK CHAR COUNT 
 0659  5A                       	POP	DX		;GET BACK DEPOSIT POINTER 
 065A  E8 0000 E                	CALL	MAKUPL		;GET CHAR FROM LINE, MAKE UPPER CASE 
 065D  E8 063D R                KRNVAR: CALL	KRNSAV		;SAVE CHAR 
 0660  43                       	INC	BX		;INCRMENT SOURCE POINTER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-45
FAST CRUNCH - COMPACTIFICATION                              

 0661  E8 0000 E                	CALL	MAKUPL		;MAKE UPPER CASE (?) 
 0664  E8 0000 E                	CALL	ISLET2		;IS IT A LETTER? 
 0667  73 F4                    	JAE	SHORT KRNVAR	;YES, EAT 
 0669  3C 3A                    	CMP	AL,LOW OFFSET "9"+1     ;DIGIT? 
 066B  73 08                    	JAE	SHORT JKLOOP	;NO, TOO LARGE 
 066D  3C 30                    	CMP	AL,LOW "0" 
 066F  73 EC                    	JAE	SHORT KRNVAR	;YES, EAT 
 0671  3C 2E                    	CMP	AL,LOW "."      ;IS IT DOT 
 0673  74 E8                    	JZ	SHORT KRNVAR	;YES, DOTS OK IN VAR NAMES 
 0675  E9 03A2 R                JKLOOP: JMP	KLOOP		;DONE LOOKING AT VARIABLE NAME 
 0678  8A 07                    NOTRS5: MOV	AL,BYTE PTR [BX]	;GET CHAR FROM LINE 
 067A  3C 20                    	CMP	AL,LOW 32	;SPACE OR HIGHER ? 
 067C  73 0A                    	JAE	SHORT NOTRS1	;YES = SAVE IT 
 067E  3C 09                    	CMP	AL,LOW 9	;TAB ? 
 0680  74 06                    	JZ	SHORT NOTRS1	;YES = THAT'S OK 
 0682  3C 0A                    	CMP	AL,LOW 10	;ALSO ALLOW... 
 0684  74 02                    	JZ	SHORT NOTRS1	;...LINE FEEDS 
 0686  B0 20                    	MOV	AL,LOW 32	;FORCE REST TO SPACES 
 0688  50                       NOTRS1: PUSH	AX		;SAVE THIS CHAR 
 0689  A0 0000 E                	MOV	AL,BYTE PTR DONUM	;GET NUMBER OK FLAG 
 068C  FE C0                    	INC	AL		;SEE IF IN A VARIABLE NAME. 
 068E  74 02                    	JZ	SHORT JNTRS6	;IF SO & SPECIAL CHAR SEEN, RESET DONUM 
 0690  FE C8                    	DEC	AL		;OTHERWISE LEAVE DONUM UNCHANGED. 
 0692  E9 052C R                JNTRS6: JMP	NOTRS6 
                                 
                                ; ROUTINE TO BACK UP POINTER AFTER # EATEN 
 0695  4B                       BAKSP:	DEC	BX		;POINT TO PREVIOUS CHAR 
 0696  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET THE CHAR 
 0698  3C 20                    	CMP	AL,LOW " "      ;A SPACE? 
 069A  74 F9                    	JZ	SHORT BAKSP	;YES, KEEP BACKING UP 
 069C  3C 09                    	CMP	AL,LOW 9	;TAB? 
 069E  74 F5                    	JZ	SHORT BAKSP	;YES, BACK UP 
 06A0  3C 0A                    	CMP	AL,LOW 10	;LF? 
 06A2  74 F1                    	JZ	SHORT BAKSP 
 06A4  43                       	INC	BX		;POINT TO CHAR AFTER LAST NON-SPACE 
 06A5  C3                       	RET			;ALL DONE. 
                                 
                                	SUBTTL THE NON-EXTENDED "LIST" COMMAND 
                                 
                                 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-46
THE NON-EXTENDED "LIST" COMMAND                             

                                	PAGE 
                                 
                                	SUBTTL "FOR" STATEMENT 
                                ; 
                                ; A "FOR" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT: 
                                ; 
                                ; LOW ADDRESS 
                                ;       TOKEN ($FOR IN HIGH BYTE)  1 BYTE 
                                ;       A POINTER TO THE LOOP VARIABLE  2 BYTES 
                                ;       A BYTE REFLECTING THE SIGN OF THE INCREMENT 1 BYTE 
                                ;       THE STEP 4 BYTES 
                                ;       THE UPPER VALUE 4 BYTES 
                                ;       THE LINE # OF THE "FOR" STATEMENT 2 BYTES 
                                ;       A TEXT POINTER INTO THE "FOR" STATEMENT 2 BYTES 
                                ; HIGH ADDRESS 
                                ; 
                                ; TOTAL 16 BYTES 
                                ; 
 06A6  B0 64                    FOR:	MOV	AL,LOW 100 
 06A8  A2 0000 E                	MOV	BYTE PTR SUBFLG,AL	;DONT RECOGNIZE SUBSCRIPTED VARIABLES 
 06AB  E8 0000 E                	CALL	PTRGET		;GET POINTER TO LOOP VARIABLE 
 06AE  E8 0000 E                	CALL	SYNCHR 
 06B1  00 E                     	DB	OFFSET EQULTK	;SKIP OVER ASSIGNMENT "=" 
 06B2  52                       	PUSH	DX		;SAVE THE VARIABLE POINTER ON STACK 
                                				;AND IN TEMP 
 06B3  89 16 0000 E             	MOV	TEMP,DX	;FOR USE LATER ON 
 06B7  A0 0000 E                	MOV	AL,BYTE PTR VALTYP	;REMEMBER THE LOOP VARIABLE TYPE 
 06BA  50                       	PUSH	AX 
 06BB  E8 0000 E                	CALL	FRMEVL		;GET THE START VALUE 
 06BE  58                       	POP	AX		;REGET THE LOOP TYPE 
 06BF  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 06C0  E8 0000 E                	CALL	DOCNVF		;FORCE CONVERSION TO LOOP TYPE 
 06C3  BB 0000 E                	MOV	BX,OFFSET FVALSV	;PLACE TO SAVE THE VALUE 
 06C6  E8 0000 E                	CALL	MOVMF		;STORE FOR USE IN "NEXT" 
 06C9  5B                       	POP	BX		;GET BACK THE TEXT POINTER 
 06CA  5A                       	POP	DX		;GET BACK THE VARIABLE POINTER 
 06CB  59                       	POP	CX		;GET RID OF THE NEWSTT RETURN 
 06CC  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 06CD  E8 0ACF R                	CALL	DATA		;SET [H,L]=END OF STATEMENT 
 06D0  89 1E 0000 E             	MOV	ENDFOR,BX	;SAVE FOR COMPARISON 
 06D4  BB 0002                  	MOV	BX,2		;SET UP POINTER INTO STACK 
 06D7  03 DC                    	ADD	BX,SP 
 06D9  E8 0005 R                LPFORM: CALL	LOOPER		;MUST HAVE VARIABLE POINTER IN [D,E] 
 06DC  75 1E                    	JNZ	SHORT NOTOL	;IF NO MATCHING ENTRY, DON'T 
                                				;ELIMINATE ANYTHING 
 06DE  03 D9                    	ADD	BX,CX		;IN THE CASE OF "FOR" 
                                				;WE ELIMINATE THE MATCHING ENTRY 
                                				;AS WELL AS EVERYTHING AFTER IT 
 06E0  52                       	PUSH	DX		;SAVE THE VARIABLE POINTER 
 06E1  4B                       	DEC	BX		;SEE IF END TEXT POINTER OF MATCHING ENTRY 
 06E2  8A 37                    	MOV	DH,BYTE PTR [BX]	;MATCHES THE FOR WE ARE HANDLING 
 06E4  4B                       	DEC	BX		;PICK UP THE END OF THE "FOR" TEXT POINTER 
 06E5  8A 17                    	MOV	DL,BYTE PTR [BX]	;FOR THE ENTRY ON THE STACK 
 06E7  43                       	INC	BX		;WITHOUT CHANGING [H,L] 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-47
"FOR" STATEMENT                                             

 06E8  43                       	INC	BX 
 06E9  53                       	PUSH	BX		;SAVE THE STACK POINTER FOR THE COMPARISON 
 06EA  8B 1E 0000 E             	MOV	BX,ENDFOR	;GET ENDING TEXT POINTER FOR THIS "FOR" 
 06EE  3B DA                    	CMP	BX,DX		;SEE IF THEY MATCH 
 06F0  5B                       	POP	BX		;GET BACK THE STACK POINTER 
 06F1  5A                       	POP	DX		;GET BACK THE VARIABLE POINTER 
 06F2  75 E5                    	JNZ	SHORT LPFORM	;KEEP SEARCHING IF NO MATCH 
 06F4  5A                       	POP	DX		;GET BACK THE TEXT POINTER 
 06F5  8B E3                    	MOV	SP,BX		;DO THE ELIMINATION 
 06F7  89 1E 0000 E             	MOV	SAVSTK,BX	;UPDATE SAVED STACK 
                                				;SINCE A MATCHING ENTRY WAS FOUND 
 06FB  B1                       	DB	261O	; SKIP  ;MVI C,(POP D) 
 06FC  5A                       NOTOL:	POP	DX 
 06FD  87 DA                    	XCHG	BX,DX		;[H,L]=TEXT POINTER 
 06FF  B1 08                    	MOV	CL,LOW 8	;MAKE SURE 16 BYTES ARE AVAILABLE 
                                				;OFF OF THE STACK 
 0701  E8 0000 E                	CALL	GETSTK 
 0704  53                       	PUSH	BX		;REALLY SAVE THE TEXT POINTER 
 0705  8B 1E 0000 E             	MOV	BX,ENDFOR	;PICK UP POINTER AT END OF "FOR" 
                                				;JUST BEYOND THE TERMINATOR 
 0709  5E                       	POP	SI		;XTHL 
 070A  87 F3                    	XCHG	SI,BX 
 070C  56                       	PUSH	SI		;PUT [H,L] POINTER TO TERMINATOR ON THE STACK 
                                				;AND RESTORE [H,L] AS TEXT POINTER AT 
                                				;VARIABLE NAME 
 070D  53                       	PUSH	BX		;PUSH THE TEXT POINTER ONTO THE STACK 
 070E  8B 1E 0000 E             	MOV	BX,CURLIN	;[H,L] GET THE CURRENT LINE # 
 0712  5E                       	POP	SI		;XTHL 
 0713  87 F3                    	XCHG	SI,BX 
 0715  56                       	PUSH	SI		;NOW THE CURRENT LINE # IS ON THE STACK AND 
                                				;[H,L] IS THE TEXT POINTER 
 0716  E8 0000 E                	CALL	SYNCHR 
 0719  00 E                     	DB	OFFSET $TO	;"TO" IS NECESSARY 
 071A  E8 0000 E                	CALL	GETYPR		;SEE WHAT TYPE THIS VALUE HAS 
 071D  75 03                    	JNZ	SHORT ??L036 
 071F  E9 00AC R                	JMP	TMERR		;GIVE STRINGS A "TYPE MISMATCH" 
 0722                           ??L036: 
 0722  72 03                    	JNAE	SHORT ??L037 
 0724  E9 00AC R                	JMP	TMERR		;AS WELL AS DOUBLE-PRECISION 
 0727                           ??L037: 
 0727  9C                       	PUSHF			;SAVE THE INTEGER/FLOATING FLAG 
 0728  E8 0000 E                	CALL	FRMEVL		;EVALUATE THE TARGET VALUE FORMULA 
 072B  9D                       	POPF			;POP OFF THE FLAG 
 072C  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 072D  78 03                    	JS	SHORT ??L038 
 072F  EB 1D 90                 	JMP	SNGFOR		;POSITIVE MEANS SINGLE PRECISION "FOR"-LOOP 
 0732                           ??L038: 
 0732  E8 0000 E                	CALL	FRCINT		;COERCE THE FINAL VALUE 
 0735  5E                       	POP	SI		;XTHL 
 0736  87 F3                    	XCHG	SI,BX 
 0738  56                       	PUSH	SI		;SAVE IT ON THE STACK AND REGET THE 
                                				;TEXT POINTER 
 0739  BA 0001                  	MOV	DX,1		;DEFAULT THE STEP TO BE 1 
 073C  8A 07                    	MOV	AL,BYTE PTR [BX]	;SEE WHAT CHARACTER IS NEXT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-48
"FOR" STATEMENT                                             

 073E  3C 00 E                  	CMP	AL,LOW OFFSET STEPTK	;IS THERE A "STEP" CLAUSE? 
 0740  75 03                    	JNZ	SHORT ??L039 
 0742  E8 0000 E                	CALL	GETINT		;IF SO, READ THE STEP INTO [D,E] 
 0745                           ??L039: 
 0745  52                       	PUSH	DX		;PUT THE STEP ONTO THE STACK 
 0746  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 0747  87 DA                    	XCHG	BX,DX		;STEP INTO [H,L] 
 0749  E8 0000 E                	CALL	ISIGN		;THE SIGN OF THE STEP INTO [A] 
 074C  EB 25                    	JMP	SHORT STPSGN	;FINISH UP THE ENTRY 
                                				;BY PUTTING THE SIGN OF THE STEP 
                                				;AND THE DUMMY ENTRIES ON THE STACK 
 074E  E8 0000 E                SNGFOR: CALL	FRCSNG 
 0751  E8 0000 E                	CALL	MOVRF		;GET THE STUFF 
 0754  5B                       	POP	BX		;REGAIN TEXT POINTER 
 0755  51                       	PUSH	CX		;OPPOSITE OF PUSHR 
 0756  52                       	PUSH	DX		;SAVE THE SIGN OF THE INCREMENT 
 0757  B9 8100                  	MOV	CX,OFFSET 201O*256 
 075A  8A F1                    	MOV	DH,CL 
 075C  8A D6                    	MOV	DL,DH		;GET 1.0 IN THE REGISTERS 
 075E  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET TERMINATING CHARACTER 
 0760  3C 00 E                  	CMP	AL,LOW OFFSET STEPTK	;DO WE HAVE "STEP" ? 
 0762  B0 01                    	MOV	AL,LOW 1	;SETUP DEFAULT SIGN 
 0764  75 0E                    	JNZ	SHORT ONEON	;PUSH SOME CONSTANTS ON IF NOT 
 0766  E8 0000 E                	CALL	FRMCHK		;DON'T NEED TO CHECK THE TYPE 
 0769  53                       	PUSH	BX 
 076A  E8 0000 E                	CALL	FRCSNG 
 076D  E8 0000 E                	CALL	MOVRF		;SET UP THE REGISTERS 
 0770  E8 0000 E                	CALL	SIGN		;GET THE SIGN OF THE INCREMENT 
 0773  5B                       STPSGN: POP	BX		;POP OFF THE TEXT POINTER 
 0774  51                       ONEON:	PUSH	CX		;PUT VALUE ON BACKWARDS 
 0775  52                       	PUSH	DX		;OPPOSITE OF PUSHR 
                                ; 
                                ; If a step of zero is specified, change the sign of the step from 
                                ; 0 to 2.  This will ensure an infinite loop which is what ANSI 
                                ; requires.  This works because the test NEXT uses for loop 
                                ; termination is SGN(current value-target value)-SGN(step)=0, which 
                                ; could never be true for SGN(step)=2. 
                                ; Prior to installation of this code, a FOR loop whose initial and 
                                ; target values were equal, and whose step was zero was not executed 
                                ; even once since the above test was met when NEXT was called to 
                                ; scan for the matching NEXT. 
                                ; 
                                 
 0776  0A C0                    	OR	AL,AL		;Is the sign of the step zero? 
 0778  75 02                    	JNZ	SHORT NT0STP	;No, then the step is not zero. 
 077A  B0 02                    	MOV	AL,LOW 2	;Yes, force an infinite loop by making 
                                				;the sign of step a value such that 
                                				;the loop termination test can never 
                                				;be met. 
 077C                           NT0STP: 
 077C  8A C8                    	MOV	CL,AL		;[C]=SIGN OF STEP 
 077E  E8 0000 E                	CALL	GETYPR		;MUST PUT ON INTEGER/SINGLE-PRECISION FLAG 
                                				;MINUS IS SET FOR INTEGER CASE 
 0781  8A E8                    	MOV	CH,AL		;HIGH BYTE = INTEGER/SINGLE PRECISION FLAG 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-49
"FOR" STATEMENT                                             

 0783  51                       	PUSH	CX		;SAVE FLAG AND SIGN OF STEP BOTH 
 0784  4B                       	DEC	BX		;MAKE SURE THE "FOR" ENDED PROPERLY 
 0785  E8 083A R                	CALL	CHRGTR 
 0788  74 03                    	JZ	SHORT ??L040 
 078A  E9 0094 R                	JMP	SNERR 
 078D                           ??L040: 
 078D  E8 121E R                	CALL	NXTSCN		;SCAN UNTIL THE MATCHING "NEXT" IS FOUND 
 0790  E8 083A R                	CALL	CHRGTR		;FETCH FIRST CHARACTER OF "NEXT" 
 0793  53                       	PUSH	BX		;MAKE THE NEXT TXTPTR PART OF THE ENTRY 
 0794  53                       	PUSH	BX 
 0795  8B 1E 0000 E             	MOV	BX,NXTLIN	;GET THE LINE NUMBER OF NEXT 
 0799  89 1E 0000 E             	MOV	CURLIN,BX	;MAKE IT THE CURRENT LINE 
 079D  8B 1E 0000 E             	MOV	BX,TEMP	;GET THE POINTER TO THE VARIABLE BACK 
 07A1  5E                       	POP	SI		;XTHL 
 07A2  87 F3                    	XCHG	SI,BX 
 07A4  56                       	PUSH	SI		;PUT THE POINTER TO THE VARIABLE 
                                				;ONTO THE STACK AND RESTORE THE TEXT POINTER 
 07A5  B5 00 E                  	MOV	CH,LOW OFFSET $FOR	;FINISH UP "FOR" 
 07A7  51                       	PUSH	CX 
 07A8  9F                       	LAHF			; PUSH PSW 
 07A9  86 C4                    	XCHG	AL,AH 
 07AB  50                       	PUSH	AX 
 07AC  86 C4                    	XCHG	AL,AH		;SAVE THE CHARACTER 
 07AE  9F                       	LAHF			; PUSH PSW 
 07AF  86 C4                    	XCHG	AL,AH 
 07B1  50                       	PUSH	AX 
 07B2  86 C4                    	XCHG	AL,AH		;MAKE A STACK ENTRY TO SUBSTITUTE FOR "NEWSTT" 
                                	EXTRN	NEXTS:NEAR 
 07B4  E9 0000 E                	JMP	NEXTS		;GO EXECUTE "NEXT" WITH NXTFLG ZERO 
                                PUBLIC	NXTCON 
 07B7  B5 00 E                  NXTCON: MOV	CH,LOW OFFSET $FOR	;PUT A 'FOR' TOKEN ONTO THE STACK 
 07B9  51                       	PUSH	CX 
                                ;       JMP     NEWSTT          ;ALL DONE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-50
"FOR" STATEMENT                                             

                                	PAGE 
                                 
                                	SUBTTL NEW STATEMENT FETCHER 
                                ; 
                                ; BACK HERE FOR NEW STATEMENT. CHARACTER POINTED TO BY [H,L] 
                                ; ":" OR END-OF-LINE. THE ADDRESS OF THIS LOCATION IS 
                                ; LEFT ON THE STACK WHEN A STATEMENT IS EXECUTED SO 
                                ; IT CAN MERELY DO A RETURN WHEN IT IS DONE. 
                                ; 
 07BA  EB 43                    	JMP	SHORT NEWSTT	;GO TO NEWSTT 
 07BC  E9 003D R                GOPRGD: JMP	PRGEND		;FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE 
 07BF  E9 0094 R                GOSNER: JMP	SNERR		;GIVE SYNTAX ERROR 
 07C2  C3                       GORET:	RET			;SO PEOPLE CAN BRANCH HERE 
 07C3  E8 0842 R                GONCHR: CALL	CHRCON		;REST OF CHRGET 
 07C6  EB 59                    	JMP	SHORT GONE0 
 07C8                           GISMD$: 
                                	EXTRN	NEWSTX:NEAR 
 07C8  E8 0000 E                	CALL	NEWSTX		;Call extended statement dispatcher. 
 07CB  E9 0000 E                	JMP	ISMID$		;TRY FOR LHS MID$ STATEMENT 
                                 
 07CE  E9 0B05 R                GONLET: JMP	LET		;GOTO LET CODE 
                                 
 07D1  0A C0                    GONZER: OR	AL,AL 
 07D3  75 EA                    	JNZ	SHORT GOSNER	;MUST BE A ZERO 
 07D5  43                       	INC	BX 
 07D6  8A 07                    GONE4:	MOV	AL,BYTE PTR [BX]	;CHECK POINTER TO SEE IF 
                                				;IT IS ZERO, IF SO WE ARE AT THE 
                                				;END OF THE PROGRAM 
 07D8  43                       	INC	BX 
 07D9  0A 07                    	OR	AL,BYTE PTR [BX]	;OR IN HIGH PART 
 07DB  74 DF                    	JZ	SHORT GOPRGD	;FIX SYNTAX ERROR IN UNENDED ERROR ROUTINE 
 07DD  43                       	INC	BX 
 07DE  8B 17                    	MOV	DX,[BX] 
 07E0  43                       	INC	BX 
                                	INS86	211,26,CURLIN	;MOV CURLIN,DX 
                                				;SETUP CURLIN WITH THE CURRENT LINE # 
                                	INS86	366,6,TRCFLG	;TRACING? 
 07E9  FF                       	DB	377O		;TESTBI TRCFLG,^O377 
 07EA  74 2E                    	JZ	SHORT GONE	;SKIP THIS PRINTING 
 07EC  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 07ED  B0 5B                    	MOV	AL,LOW "["      ;FORMAT THE LINE NUMBER 
 07EF  E8 0000 E                	CALL	OUTDO		;OUTPUT IT 
 07F2  87 DA                    	XCHG	BX,DX		;PUT LINE NUMBER TO PRINT IN [H,L] 
 07F4  E8 0000 E                	CALL	LINPRT		;PRINT THE LINE # IN [H,L] 
 07F7  B0 5D                    	MOV	AL,LOW "]"      ;SOME MORE FORMATING 
 07F9  E8 0000 E                	CALL	OUTDO 
 07FC  5B                       	POP	BX		;[D,E]=TEXT POINTER 
 07FD  EB 1B                    	JMP	SHORT GONE	;CONTINUE EXECUTION 
                                PUBLIC	NEWSTT 
 07FF                           NEWSTT: 
 07FF  A0 0000 E                	MOV	AL,BYTE PTR ONGSBF 
 0802  0A C0                    	OR	AL,AL 
 0804  74 03                    	JZ	SHORT ??L041 
                                EXTRN	GOTRP:NEAR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-51
NEW STATEMENT FETCHER                                       

 0806  E8 0000 E                	CALL	GOTRP		;POSSIBLE ON GOSUB 
 0809                           ??L041: 
 0809                           NWSTRT:			;ENTRY FOR "device ON" STATEMENT 
 0809                           NEWST1: 
                                	INS86	211,46,SAVSTK	;MOV SAVSTK,SP 
 080D  89 1E 0000 E             	MOV	SAVTXT,BX	;SAVE TEXT POINTER 
                                	EXTRN	CHKINT:NEAR 
 0811  E8 0000 E                	CALL	CHKINT		;get key from keyboard & check for CTL C 
                                				;if CTL-C, control doesn't return here 
 0814  8A 07                    GONGET: MOV	AL,BYTE PTR [BX]	;GET CURRENT CHARACTER 
                                				;WHICH TERMINATED THE LAST STATEMENT 
 0816  3C 3A                    	CMP	AL,LOW ":"      ;IS IT A COLON? 
 0818  75 B7                    	JNZ	SHORT GONZER	;SHOULD BE ZERO AT EOL 
                                PUBLIC	GONE 
 081A  43                       GONE:	INC	BX		;DO PART OF CHRGETS WORK 
 081B  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET BYTE 
 081D  3C 3A                    	CMP	AL,LOW ":"      ;COLON? 
 081F  72 A2                    	JB	SHORT GONCHR	;DO REST OF CHRGET 
 0821  BA 07FF R                GONE0:	MOV	DX,OFFSET NEWSTT	;PUSH ON A RETURN ADDRESS OF NEWSTT 
 0824  52                       	PUSH	DX		;STATEMENT 
 0825  74 9B                    GONE3:	JZ	SHORT GORET	;IF A TERMINATOR TRY AGAIN 
                                				;"IF" COMES HERE 
 0827                           GONE2: 
 0827  2C 00 E                  	SUB	AL,LOW OFFSET $END	;"ON ... GOTO" AND "ON ... GOSUB" COME HERE 
 0829  72 A3                    	JB	SHORT GONLET	;MUST BE A LET 
 082B  3C 00 E                  	CMP	AL,LOW OFFSET NUMCMD 
 082D  73 99                    	JAE	SHORT GISMD$	;SEE IF LHS MID$ CASE 
                                	INS86	62,344		;XOR AH,AH 
 0831  02 C0                    	ADD	AL,AL		;TURN BYTE INTO OFFSET 
                                	INS86	213,360	;MOV SI,AX - GET OFFSET INTO [SI] 
                                	INS86	56		;CODE SEGMENT OVERRIDE 
                                	INS86	377,264,STMDSP	;PUSH STMDSP(SI) - PUSH ADDRESS 
                                				;STATEMENT ON STACK 
                                ; 
                                ; NEWSTT FALLS INTO CHRGET. THIS FETCHES THE FIRST CHAR AFTER 
                                ; THE STATEMENT TOKEN AND THE CHRGET'S "RET" DISPATCHES TO STATEMENT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-52
NEW STATEMENT FETCHER                                       

                                	PAGE 
                                 
                                	SUBTTL CHRGET - THE NEXT CHARACTER SCAN ROUTINE 
                                PUBLIC	CHRGTR 
 083A  43                       CHRGTR: INC	BX		;DUPLICATION OF CHRGET RST FOR SPEED 
                                PUBLIC	CHRGT2 
 083B  8A 07                    CHRGT2: MOV	AL,BYTE PTR [BX]	;SEE CHRGET RST FOR EXPLANATION 
 083D  3C 3A                    	CMP	AL,LOW ":" 
 083F  72 01                    	JB	SHORT CHRCON 
 0841  C3                       	RET 
                                ; 
                                ; CHRCON IS THE CONTINUATION OF THE CHRGET RST 
                                ; 
                                ; IN EXTENDED, CHECK FOR INLINE CONSTANT AND IF ONE 
                                ; MOVE IT INTO THE FAC & SET VALTYP APPROPRIATELY 
                                ; 
                                PUBLIC	OCTCON 
 = 000B                         	OCTCON=11		;EMBEDED OCTAL CONSTANT 
                                PUBLIC	HEXCON 
 = 000C                         	HEXCON=12		;EMBEDED HEXA CONSTANT 
 = 000D                         	PTRCON=13		;A LINE REFERENCE CONSTANT 
 = 000E                         	LINCON=14		;A LINE NUMBER UNCONVERTED TO POINTER 
 = 000F                         	IN2CON=15		;SINGLE BYTE (TWO BYTE WITH TOKEN) INTEGER 
                                PUBLIC	CONCN2 
 = 0010                         	CONCN2=16		;TOKEN RETURNED SECOND TYPE CONSTANT IS SCANNED. 
                                PUBLIC	ONECON 
 = 0011                         	ONECON=17		;FIRST OF 10 (0-9) INTEGER SPECIAL TOKENS 
 = 001C                         	INTCON=28		;REGULAR 16 BIT TWO'S COMPLEMENT INT 
 = 001D                         	SNGCON=29		;SINGLE PREC (4 BYTE) CONSTANT 
                                PUBLIC	CONCON 
 = 001E                         	CONCON=30		;TOKEN RETURNED BY CHRGET AFTER CONSTANT SCANNED 
                                PUBLIC	DBLCON 
 = 001F                         	DBLCON=31		;DOUBLE PREC (8 BYTE) CONSTANT 
                                PUBLIC	DBLCN1 
 = 0020                         	DBLCN1=DBLCON+1 
                                PUBLIC	CHRCON 
 0842  3C 20                    CHRCON: CMP	AL,LOW " "      ;MUST SKIP SPACES 
 0844  74 F4                    	JZ	SHORT CHRGTR	;GET ANOTHER CHARACTER 
 0846  72 08                    	JB	SHORT LOWCHR	;SOME FUNNY THING 
 0848  3C 30                    	CMP	AL,LOW "0"      ;ALL CHARACTERS GREATER THAN 
                                				;"9" HAVE RETURNED, SO SEE IF NUMERIC 
 084A  F5                       	CMC			;MAKE NUMERICS HAVE CARRY ON 
 084B  FE C0                    	INC	AL		;SET ZERO IF [A]=0 
 084D  FE C8                    	DEC	AL 
 084F  C3                       	RET 
 0850                           LOWCHR: 
 0850  0A C0                    	OR	AL,AL		;NULL AT EOL? 
 0852  75 01                    	JNZ	SHORT $+3 
 0854  C3                       	RET			;YES, ALL DONE 
 0855  3C 0B                    	CMP	AL,LOW OFFSET OCTCON	;IS IT INLINE CONSTANT 
 0857  72 72                    	JB	SHORT NOTCON	;NO, SHOULD BE TAB OR LF 
 0859  3C 1E                    	CMP	AL,LOW OFFSET CONCON	;ARE WE TRYING TO RE-SCAN A CONSTANT? 
 085B  75 06                    	JNZ	SHORT NTRSCC	;NO. 
 085D  A0 0000 E                	MOV	AL,BYTE PTR CONSAV	;GET THE SAVED CONSTANT TOKEN 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-53
CHRGET - THE NEXT CHARACTER SCAN ROUTINE                    

 0860  0A C0                    	OR	AL,AL		;SET NON-ZERO, NON CARRY CC'S 
 0862  C3                       	RET			;ALL DONE 
                                 
 0863  3C 10                    NTRSCC: CMP	AL,LOW OFFSET CONCN2	;GOING TO SCAN PAST EMBEDDED CONSTANT? 
 0865  74 3C                    	JZ	SHORT CONSCN	;YES SCAN AND GO ON 
 0867  50                       NTRSC2: PUSH	AX		;SAVE TOKEN TO RETURN 
 0868  43                       	INC	BX		;POINT TO NUMBER 
 0869  A2 0000 E                	MOV	BYTE PTR CONSAV,AL	;SAVE CURRENT TOKEN 
 086C  2C 1C                    	SUB	AL,LOW OFFSET INTCON	;IS IT LESS THAN INTEGER CONSTANT? 
 086E  73 39                    	JAE	SHORT MAKTKN	;NO, NOT LINE NUMBER CONSTANT 
 0870  2C F5                    	SUB	AL,LOW 365O	;<ONECON-INTCON>&^O377 
                                				;LESS THAN EMBEDDED 1 BYTER 
 0872  73 07                    	JAE	SHORT ONEI	;WAS ONE BYTER 
 0874  3C FE                    	CMP	AL,LOW OFFSET IN2CON-ONECON	;IS IT TWO BYTER? 
 0876  75 1B                    	JNZ	SHORT FRCINC	;NOPE, NORMAL INT 
 0878  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET EMBEDED INT 
 087A  43                       	INC	BX		;POINT AFTER CONSTANT 
 087B  89 1E 0000 E             ONEI:	MOV	CONTXT,BX	;SAVE TEXT POINTER 
 087F  B7 00                    	MOV	BH,LOW 0	;GET UPPER BYTE OF ZERO 
 0881  8A D8                    ONEI2:	MOV	BL,AL		;GET VALUE 
 0883  89 1E 0000 E             	MOV	CONLO,BX	;SAVE CONSTANT VALUE 
 0887  B0 02                    	MOV	AL,LOW 2	;GET VALTYPE 
 0889  A2 0000 E                	MOV	BYTE PTR CONTYP,AL	;SET IT UP IN SAVE PLACE 
 088C  BB 0000 E                	MOV	BX,OFFSET NUMCON	;POINT TO NUMBER RE-SCANNER 
 088F  58                       	POP	AX		;GET BACK TOKEN 
 0890  0A C0                    	OR	AL,AL		;MAKE SURE NUMBER FLAG RE-SET 
 0892  C3                       	RET			;RETURN TO CALLER 
                                 
 0893  8A 07                    FRCINC: MOV	AL,BYTE PTR [BX]	;GET LOW BYTE OF CONSTANT 
 0895  43                       	INC	BX		;POINT PAST IT 
 0896  43                       	INC	BX		;TO NEXT THING 
 0897  89 1E 0000 E             	MOV	CONTXT,BX	;SAVE POINTER PAST 
 089B  4B                       	DEC	BX		;BACK TO HIGH BYTE 
 089C  8A 3F                    	MOV	BH,BYTE PTR [BX]	;GET HIGH BYTE 
 089E  EB E1                    	JMP	SHORT ONEI2	;FINISH SCANNING 
                                 
                                PUBLIC	CONFAC 
 08A0  E8 08DA R                CONFAC: CALL	CONFC1		;SCAN FLOATING CONSTANT 
 08A3  8B 1E 0000 E             CONSCN: MOV	BX,CONTXT	;GET SAVED TEXT POINTER 
 08A7  EB 92                    	JMP	SHORT CHRGT2	;AND SCAN THING AFTER CONSTANT 
                                 
 08A9  FE C0                    MAKTKN: INC	AL		;CALCULATE VALTYPE 
 08AB  D0 C0                    	ROL	AL,1		;*2 TO GET VALTYPE 0=2, 1=4, 3=8 
 08AD  A2 0000 E                	MOV	BYTE PTR CONTYP,AL	;CONTYPE NOW SETUP 
 08B0  52                       	PUSH	DX		;SAVE SOME RGS 
 08B1  51                       	PUSH	CX 
 08B2  BA 0000 E                	MOV	DX,OFFSET CONLO ;PLACE TO STORE SAVED CONSTANT 
 08B5  87 DA                    	XCHG	BX,DX		;GET TEXT POINTER IN [D,E] 
 08B7  8A E8                    	MOV	CH,AL		;SETUP COUNTER IN [B] 
 08B9  E8 0000 E                	CALL	MOVE1		;MOVE DATA IN 
 08BC  87 DA                    	XCHG	BX,DX		;GET TEXT POINTER BACK 
 08BE  59                       	POP	CX		;RESTORE [B,C] 
 08BF  5A                       	POP	DX 
 08C0  89 1E 0000 E             FININ1: MOV	CONTXT,BX	;SAVE THE GOOD TEXT POINTER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-54
CHRGET - THE NEXT CHARACTER SCAN ROUTINE                    

 08C4  58                       	POP	AX		;RESTORE TOKEN 
 08C5  BB 0000 E                	MOV	BX,OFFSET NUMCON	;GET POINTER TO FAKE TEXT 
 08C8  0A C0                    	OR	AL,AL		;CLEAR CARRY SO OTHERS DONT THINK ITS A NUMBER 
                                				;AND SET NON-ZERO SO NOT TERMINATOR 
 08CA  C3                       	RET			;ALL DONE 
 08CB                           NOTCON: 
 08CB  3C 09                    	CMP	AL,LOW 9	;LINE FEED OR TAB? 
 08CD  72 03                    	JNAE	SHORT ??L042 
 08CF  E9 083A R                	JMP	CHRGTR		;YES, EAT. 
 08D2                           ??L042: 
 08D2  3C 30                    NOTLFT: CMP	AL,LOW "0"      ;ALL CHARACTERS GREATER THAN 
                                				;"9" HAVE RETURNED, SO SEE IF NUMERIC 
 08D4  F5                       	CMC			;MAKE NUMERICS HAVE CARRY ON 
 08D5  FE C0                    	INC	AL		;SET ZERO IF [A]=0 
 08D7  FE C8                    	DEC	AL 
 08D9  C3                       	RET 
                                 
                                 
                                ; THIS ROUTINE MOVES THE SAVED CONSTANT INTO THE FAC 
                                PUBLIC	CONFC1 
 08DA                           CONFC1: 
 08DA  A0 0000 E                	MOV	AL,BYTE PTR CONSAV	;GET CONSTANT TOKEN 
 08DD  3C 0F                    	CMP	AL,LOW OFFSET LINCON+1	;LINE# CONSTANT? (ERL=#) 
 08DF  73 17                    	JAE	SHORT NTLINE	;NO 
 08E1  3C 0D                    	CMP	AL,LOW OFFSET PTRCON	;LINE POINTER CONSTANT? 
 08E3  72 13                    	JB	SHORT NTLINE	;NO 
 08E5  8B 1E 0000 E             	MOV	BX,CONLO	;GET VALUE 
 08E9  75 0A                    	JNZ	SHORT FLTLIN	;MUST BE LINE NUMBER, NOT POINTER 
 08EB  43                       	INC	BX		;POINT TO LINE # 
 08EC  43                       	INC	BX 
 08ED  43                       	INC	BX 
 08EE  8A 17                    	MOV	DL,BYTE PTR [BX]	;GET LINE # IN [D,E] 
 08F0  43                       	INC	BX 
 08F1  8A 37                    	MOV	DH,BYTE PTR [BX]	;GET HIGH PART 
 08F3  87 DA                    	XCHG	BX,DX		;VALUE TO [H,L] 
 08F5  E9 0000 E                FLTLIN: JMP	INEG2		;FLOAT IT 
 08F8                           NTLINE: 
 08F8  A0 0000 E                	MOV	AL,BYTE PTR CONTYP	;GET SAVED CONSTANT VALTYP 
 08FB  A2 0000 E                	MOV	BYTE PTR VALTYP,AL	;SAVE IN REAL VALTYP 
 08FE  3C 08                    	CMP	AL,LOW 8	;DOUBLE PRECISION 
 0900  74 11                    	JZ	SHORT CONFDB	;YES 
 0902  8B 1E 0000 E             	MOV	BX,CONLO	;GET LOW TWO BYTES OF FAC 
 0906  89 1E 0000 E             	MOV	FACLO,BX	;SAVE THEM 
 090A  8B 1E 0002 E             	MOV	BX,CONLO+2	;GET NEXT TWO BYTES 
 090E  89 1E 0002 E             	MOV	FACLO+2,BX	;SAVE THEM 
 0912  C3                       	RET 
                                 
 0913  BB 0000 E                CONFDB: MOV	BX,OFFSET CONLO ;GET POINTER TO SAVED CONSTANT AREA 
 0916  E9 0000 E                	JMP	VMOVFM		;MOVE INTO FAC 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-55
CHRGET - THE NEXT CHARACTER SCAN ROUTINE                    

                                	PAGE 
                                 
                                	SUBTTL DEFSTR, DEFINT, DEFSNG, DEFDBL, INTIDX 
 0919  B2 03                    DEFSTR: MOV	DL,LOW 3	;DEFAULT SOME LETTERS TO STRING 
 091B  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT 2 BYTES 
 091C  B2 02                    DEFINT: MOV	DL,LOW 2	;DEFAULT SOME LETTERS TO INTEGER 
 091E  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT 2 BYTES 
 091F  B2 04                    DEFREA: MOV	DL,LOW 4	;DEFAULT SOME LETTERS TO SINGLE PRECISION 
 0921  B9                       	DB	271O	; SKIP  ;"LXI B," OVER THE NEXT 2 BYTES 
 0922  B2 08                    DEFDBL: MOV	DL,LOW 8	;DEFAULT SOME LETTERS TO DOUBLE PRECISION 
 0924  E8 0000 E                DEFCON: CALL	ISLET		;MAKE SURE THE ARGUMENT IS A LETTER 
 0927  B9 0094 R                	MOV	CX,OFFSET SNERR ;PREPARE "SYNTAX ERROR" RETURN 
 092A  51                       	PUSH	CX 
 092B  73 01                    	JNB	SHORT $+3 
 092D  C3                       	RET			;RETURN IF THERES NO LETTER 
 092E  2C 41                    	SUB	AL,LOW "A"      ;MAKE AN OFFSET INTO DEFTBL 
 0930  8A C8                    	MOV	CL,AL		;SAVE THE INITIAL OFFSET 
 0932  8A E8                    	MOV	CH,AL		;ASSUME IT WILL BE THE FINAL OFFSET 
 0934  E8 083A R                	CALL	CHRGTR		;GET THE POSSIBLE DASH 
 0937  3C 00 E                  	CMP	AL,LOW OFFSET MINUTK	;A RANGE ARGUMENT? 
 0939  75 10                    	JNZ	SHORT NOTRNG	;IF NOT, JUST ONE LETTER 
 093B  E8 083A R                	CALL	CHRGTR		;GET THE FINAL POSITION 
 093E  E8 0000 E                	CALL	ISLET		;CHECK FOR A LETTER 
 0941  73 01                    	JNB	SHORT $+3 
 0943  C3                       	RET			;GIVE A SYNTAX ERROR IF IMPROPER 
 0944  2C 41                    	SUB	AL,LOW "A"      ;MAKE IT AN OFFSET 
 0946  8A E8                    	MOV	CH,AL		;PUT THE FINAL IN [B] 
 0948  E8 083A R                	CALL	CHRGTR		;GET THE TERMINATOR 
 094B  8A C5                    NOTRNG: MOV	AL,CH		;GET THE FINAL CHARACTER 
 094D  2A C1                    	SUB	AL,CL		;SUBTRACT THE START 
 094F  73 01                    	JNB	SHORT $+3 
 0951  C3                       	RET			;IF IT'S LESS THATS NONSENSE 
 0952  FE C0                    	INC	AL		;SETUP THE COUNT RIGHT 
 0954  5E                       	POP	SI		;XTHL 
 0955  87 F3                    	XCHG	SI,BX 
 0957  56                       	PUSH	SI		;SAVE THE TEXT POINTER AND GET RID 
                                				;OF THE "SYNTAX ERROR" RETURN 
 0958  BB 0000 E                	MOV	BX,OFFSET DEFTBL	;POINT TO THE TABLE OF DEFAULTS 
 095B  B5 00                    	MOV	CH,LOW 0	;SETUP A TWO-BYTE STARTING OFFSET 
 095D  03 D9                    	ADD	BX,CX		;MAKE [H,L] POINT TO THE FIRST ENTRY 
                                				;TO BE MODIFIED 
 095F  88 17                    LPDCHG: MOV	BYTE PTR [BX],DL	;MODIFY THE DEFAULT TABLE 
 0961  43                       	INC	BX 
 0962  FE C8                    	DEC	AL		;COUNT DOUNT THE NUMBER OF CHANGES TO MAKE 
 0964  75 F9                    	JNZ	SHORT LPDCHG 
 0966  5B                       	POP	BX		;GET BACK THE TEXT POINTER 
 0967  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET LAST CHARACTER 
 0969  3C 2C                    	CMP	AL,LOW 44	;IS IT A COMMA? 
 096B  74 01                    	JZ	SHORT $+3 
 096D  C3                       	RET			;IF NOT STATEMENT SHOULD HAVE ENDED 
 096E  E8 083A R                	CALL	CHRGTR		;OTHERWISE SET UP TO SCAN NEW RANGE 
 0971  EB B1                    	JMP	SHORT DEFCON 
                                ; 
                                ; INTIDX READS A FORMULA FROM THE CURRENT POSITION AND 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-56
DEFSTR, DEFINT, DEFSNG, DEFDBL, INTIDX                      

                                ; TURNS IT INTO A POSITIVE INTEGER 
                                ; LEAVING THE RESULT IN [D,E].  NEGATIVE ARGUMENTS 
                                ; ARE NOT ALLOWED. [H,L] POINTS TO THE TERMINATING 
                                ; CHARACTER OF THE FORMULA ON RETURN. 
                                ; 
                                PUBLIC	INTIDX 
 0973  E8 083A R                INTIDX: CALL	CHRGTR 
                                PUBLIC	INTID2 
 0976  E8 0000 E                INTID2: CALL	GETIN2		;READ A FORMULA AND GET THE 
                                				;RESULT AS AN INTEGER IN [D,E] 
                                				;ALSO SET THE CONDITION CODES BASED ON 
                                				;THE HIGH ORDER OF THE RESULT 
 0979  78 01                    	JS	SHORT $+3 
 097B  C3                       	RET			;DON'T ALLOW NEGATIVE NUMBERS 
                                PUBLIC	$FCERR 
 097C                           $FCERR: 
                                PUBLIC	FCERR 
 097C  B2 00 E                  FCERR:	MOV	DL,LOW OFFSET ERRFC	;TOO BIG. FUNCTION CALL ERROR 
 097E  E9 00AE R                	JMP	ERROR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-57
DEFSTR, DEFINT, DEFSNG, DEFDBL, INTIDX                      

                                	PAGE 
                                 
                                	SUBTTL LINSPC, LINGET 
                                ; 
                                ; LINSPC IS THE SAME AS LINGET EXCEPT IN ALLOWS THE 
                                ; CURRENT LINE (.) SPECIFIER 
                                ; 
                                PUBLIC	LINSPC 
 0981  8A 07                    LINSPC: MOV	AL,BYTE PTR [BX]	;GET CHAR FROM MEMORY 
 0983  3C 2E                    	CMP	AL,LOW "."      ;IS IT CURRENT LINE SPECIFIER 
 0985  8B 16 0000 E             	MOV	DX,DOT		;GET CURRENT LINE # 
 0989  75 03                    	JNZ	SHORT ??L043 
 098B  E9 083A R                	JMP	CHRGTR		;ALL DONE. 
 098E                           ??L043: 
                                ; 
                                ; LINGET READS A LINE # FROM THE CURRENT TEXT POSITION 
                                ; 
                                ; LINE NUMBERS RANGE FROM 0 TO 65529 
                                ; 
                                ; THE ANSWER IS RETURNED IN [D,E]. 
                                ; [H,L] IS UPDATED TO POINT TO THE TERMINATING CHARACTER 
                                ; AND [A] CONTAINS THE TERMINATING CHARACTER WITH CONDITION 
                                ; CODES SET UP TO REFLECT ITS VALUE. 
                                ; 
                                PUBLIC	LINGET 
 098E  4B                       LINGET: DEC	BX		;BACKSPACE PTR 
 098F  E8 083A R                LINGT2: CALL	CHRGTR		;FETCH CHAR (GOBBLE LINE CONSTANTS) 
 0992  3C 0E                    	CMP	AL,LOW OFFSET LINCON	;EMBEDDED LINE CONSTANT? 
 0994  74 02                    	JZ	SHORT LINGT3	;YES, RETURN DOUBLE BYTE VALUE 
 0996  3C 0D                    	CMP	AL,LOW OFFSET PTRCON	;ALSO CHECK FOR POINTER 
 0998  8B 16 0000 E             LINGT3: MOV	DX,CONLO	;GET EMBEDDED LINE # 
 099C  75 03                    	JNZ	SHORT ??L044 
 099E  E9 083A R                	JMP	CHRGTR		;EAT FOLLOWING CHAR 
 09A1                           ??L044: 
 09A1  32 C0                    	XOR	AL,AL		;SET FLAG THAT NO CONSTANT WAS SEEN SO 
 09A3  A2 0000 E                	MOV	BYTE PTR CONSAV,AL	;GOTO2 DOESN'T CHANGE LINCON TO PTRCON 
 09A6  BA 0000                  	MOV	DX,0		;ZERO ACCUMULATED LINE # 
 09A9  4B                       	DEC	BX		;BACK UP POINTER 
 09AA                           MORLIN: 
 09AA  E8 083A R                	CALL	CHRGTR 
 09AD  72 01                    	JNAE	SHORT $+3 
 09AF  C3                       	RET 
 09B0  53                       	PUSH	BX 
 09B1  9F                       	LAHF 
 09B2  50                       	PUSH	AX 
 09B3  BB 1998                  	MOV	BX,6552	;SEE IF THE LINE # IS TOO BIG 
 09B6  3B DA                    	CMP	BX,DX 
 09B8  72 1B                    	JB	SHORT POPHSR	;YES, DON'T SCAN ANY MORE DIGITS IF SO 
                                				;FORCE CALLER TO SEE DIGIT AND GIVE SYNTAX ERROR 
                                				;CAN'T JUST GO TO SYNTAX ERROR BECAUSE OF NON-FAST 
                                				;RENUM WHICH CAN'T TERMINATE 
 09BA  8A FE                    	MOV	BH,DH		;SAVE [D,E] 
 09BC  8A DA                    	MOV	BL,DL 
 09BE  03 DA                    	ADD	BX,DX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-58
LINSPC, LINGET                                              

 09C0  03 DB                    	ADD	BX,BX 
 09C2  03 DA                    	ADD	BX,DX 
 09C4  03 DB                    	ADD	BX,BX		;PUTTING [D,E]*10 INTO [H,L] 
 09C6  58                       	POP	AX 
 09C7  9E                       	SAHF 
 09C8  2C 30                    	SUB	AL,LOW "0" 
 09CA  8A D0                    	MOV	DL,AL 
 09CC  B6 00                    	MOV	DH,LOW 0 
 09CE  03 DA                    	ADD	BX,DX		;ADD THE NEW DIGIT 
 09D0  87 DA                    	XCHG	BX,DX 
 09D2  5B                       	POP	BX		;GET BACK TEXT POINTER 
 09D3  EB D5                    	JMP	SHORT MORLIN 
                                 
 09D5  58                       POPHSR: POP	AX 
 09D6  9E                       	SAHF			;GET OFF TERMINATING DIGIT 
 09D7  5B                       	POP	BX		;GET BACK OLD TEXT POINTER 
 09D8  C3                       	RET 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-59
LINSPC, LINGET                                              

                                	PAGE 
                                 
                                	SUBTTL RUN, GOTO, GOSUB, RETURN, DATA, REM 
                                 
 09D9  75 03                    RUN:	JNZ	SHORT ??L045 
 09DB  E9 0000 E                	JMP	RUNC		;NO LINE # ARGUMENT 
 09DE                           ??L045: 
 09DE  3C 0E                    	CMP	AL,LOW OFFSET LINCON	;LINE NUMBER CONSTANT? 
 09E0  74 07                    	JZ	SHORT CONRUN	;YES 
 09E2  3C 0D                    	CMP	AL,LOW OFFSET PTRCON	;LINE POINTER (RATHER UNLIKELY) 
 09E4  74 03                    	JZ	SHORT ??L046 
 09E6  E9 0000 E                	JMP	LRUN 
 09E9                           ??L046: 
 09E9                           CONRUN: 
                                				;CLEAN UP,SET [H,L]=[TXTTAB]-1 AND 
                                				;RETURN TO NEWSTT 
 09E9  E8 0000 E                	CALL	CLEARC		;CLEAN UP -- RESET THE STACK 
                                				;DATPTR,VARIABLES ... 
                                				;[H,L] IS THE ONLY THING PRESERVED 
 09EC  B9 07FF R                	MOV	CX,OFFSET NEWSTT 
 09EF  EB 43                    	JMP	SHORT RUNC2	;PUT "NEWSTT" ON AND FALL INTO "GOTO" 
                                ; 
                                ; A "GOSUB" ENTRY ON THE STACK HAS THE FOLLOWING FORMAT 
                                ; 
                                ; LOW ADDRESS 
                                ; 
                                ;       A TOKEN EQUAL TO $GOSUB 1 BYTE (1 word on 8086/8) 
                                ;       Pointer to event flag if On Event Gosub - else 0000H 
                                ;       THE LINE # OF THE THE "GOSUB" STATEMENT 2 BYTES 
                                ;       A POINTER INTO THE TEXT OF THE "GOSUB" 2 BYTES 
                                ; 
                                ; HIGH ADDRESS 
                                ; 
                                ; TOTAL 5 BYTES 
                                ; 
 09F1  B1 03                    GOSUB:	MOV	CL,LOW 3	;"GOSUB" ENTRIES ARE 5 BYTES LONG 
 09F3  E8 0000 E                	CALL	GETSTK		;MAKE SURE THERE IS ROOM 
                                 
 09F6  E8 098E R                	CALL	LINGET		;MUST SCAN LINE NUMBER NOW 
 09F9  59                       	POP	CX		;POP OFF RETURN ADDRESS OF "NEWSTT" 
 09FA  53                       	PUSH	BX		;REALLY PUSH THE TEXT POINTER 
 09FB  53                       	PUSH	BX		;SAVE TEXT POINTER 
 09FC  8B 1E 0000 E             	MOV	BX,CURLIN	;GET THE CURRENT LINE # 
 0A00  5E                       	POP	SI		;XTHL 
 0A01  87 F3                    	XCHG	SI,BX 
 0A03  56                       	PUSH	SI		;PUT CURLIN ON THE STACK AND [H,L]=TEXT PTR 
                                 
 0A04  B9 0000                  	MOV	CX,0		;so we know its not pointing to an 
 0A07  51                       	PUSH	CX		; event flag (on event gosub ...) 
 0A08  B9 07FF R                	MOV	CX,OFFSET NEWSTT	;RESTORE [B,C] CORRECT VALUE 
 0A0B  B0 00 E                  	MOV	AL,LOW OFFSET $GOSUB 
 0A0D  9F                       	LAHF			; PUSH PSW 
 0A0E  86 C4                    	XCHG	AL,AH 
 0A10  50                       	PUSH	AX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-60
RUN, GOTO, GOSUB, RETURN, DATA, REM                         

 0A11  86 C4                    	XCHG	AL,AH		;PUT GOSUB TOKEN ON THE STACK 
 0A13  51                       	PUSH	CX		;SAVE NEWSTT ON STACK 
 0A14  EB 22                    	JMP	SHORT GOTO2	;HAVE NOW GRAB LINE # PROPERLY 
                                ;ENTRY POINT FOR GOSUB WITH DE=LINE POINTER(NOT LINE NUMBER) 
                                PUBLIC	GOSUB2 
 0A16                           GOSUB2: 
 0A16  53                       	PUSH	BX		;PUT CURRENT TEXT POSN ON STACK 
 0A17  53                       	PUSH	BX 
 0A18  8B 1E 0000 E             	MOV	BX,CURLIN 
 0A1C  5E                       	POP	SI		;XTHL 
 0A1D  87 F3                    	XCHG	SI,BX 
 0A1F  56                       	PUSH	SI		;PUT CURLIN ON STACK 
 0A20  51                       	PUSH	CX		;SAVE ADDRESS OF RETRUN MODIFY ADDRESS 
 0A21  B0 00 E                  	MOV	AL,LOW OFFSET $GOSUB 
 0A23  9F                       	LAHF			; PUSH PSW 
 0A24  86 C4                    	XCHG	AL,AH 
 0A26  50                       	PUSH	AX 
 0A27  86 C4                    	XCHG	AL,AH		;PUT GOSUB ON STACK(FINAL GOSUB ENTRY) 
 0A29  87 DA                    	XCHG	BX,DX		;HL POINTS TO SUBROUTINE TEXT 
 0A2B  4B                       	DEC	BX		;NEWSTT does INX H after loading SAVTXT 
 0A2C  89 1E 0000 E             	MOV	SAVTXT,BX	;SAVE TXT PTR HERE, CURLIN LATER 
 0A30  43                       	INC	BX 
 0A31  E9 07D6 R                	JMP	GONE4		;CONTINUE WITH SUBROUTINE 
 0A34  51                       RUNC2:	PUSH	CX		;RESTORE RETURN ADDRESS 
                                				;OF "NEWSTT" 
                                ; AND SEARCH. IN THE 8K WE START WHERE WE 
                                ; ARE IF WE ARE  GOING TO A FORWARD LOCATION. 
                                ; 
 0A35  E8 098E R                GOTO:	CALL	LINGET		;PICK UP THE LINE # 
                                				;AND PUT IT IN [D,E] 
 0A38                           GOTO2: 
 0A38  A0 0000 E                	MOV	AL,BYTE PTR CONSAV	;GET TOKEN FOR LINE # BACK 
 0A3B  3C 0D                    	CMP	AL,LOW OFFSET PTRCON	;WAS IT A POINTER 
 0A3D  87 DA                    	XCHG	BX,DX		;ASSUME SO 
 0A3F  75 01                    	JNZ	SHORT $+3 
 0A41  C3                       	RET			;IF IT WAS, GO BACK TO NEWSTT 
                                				;WITH [H,L] AS TEXT PTR 
 0A42  3C 0E                    	CMP	AL,LOW OFFSET LINCON	;MAKE SURE IT IS A LINE NUMBER CONSTANT 
 0A44  74 03                    	JZ	SHORT ??L047 
 0A46  E9 0094 R                	JMP	SNERR		;IF NOT, BAD ARGUEMMENT PRESENT 
 0A49                           ??L047: 
 0A49  87 DA                    	XCHG	BX,DX		;FLIP BACK IF NOT 
 0A4B  53                       	PUSH	BX		;SAVE CURRENT TEXT PTR ON STACK 
 0A4C  8B 1E 0000 E             	MOV	BX,CONTXT	;GET POINTER TO RIGHT AFTER CONSTANT 
 0A50  5E                       	POP	SI		;XTHL 
 0A51  87 F3                    	XCHG	SI,BX 
 0A53  56                       	PUSH	SI		;SAVE ON STACK, RESTORE CURRENT TEXT PTR 
 0A54  E8 0AD3 R                	CALL	REM		;SKIP TO THE END OF THIS LINE 
 0A57  43                       	INC	BX		;POINT AT THE LINK BEYOND IT 
 0A58  53                       	PUSH	BX		;SAVE THE POINTER 
 0A59  8B 1E 0000 E             	MOV	BX,CURLIN	;GET THE CURRENT LINE # 
 0A5D  3B DA                    	CMP	BX,DX		;[D,E] CONTAINS WHERE WE ARE GOING 
                                				;[H,L] CONTAINS THE CURRENT LINE # 
                                				;SO COMPARING THEM TELLS US WHETHER TO 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-61
RUN, GOTO, GOSUB, RETURN, DATA, REM                         

                                				;START SEARCHING FROM WHERE WE ARE OR 
                                				;TO START SEARCHING FROM THE BEGINNING 
                                				;OF TXTTAB 
 0A5F  5B                       	POP	BX		;[H,L]=CURRENT POINTER 
 0A60  73 03                    	JNB	SHORT ??L048 
 0A62  E8 0373 R                	CALL	LOOP		;SEARCH FROM THIS POINT 
 0A65                           ??L048: 
 0A65  72 03                    	JNAE	SHORT ??L049 
 0A67  E8 036F R                	CALL	FNDLIN		;SEARCH FROM THE BEGINNING -- ACTUALLY 
 0A6A                           ??L049: 
                                				;SEARCH AGAIN IF ABOVE SEARCH FAILED 
 0A6A  73 0D                    	JAE	SHORT USERR	;LINE NOT FOUND, DEATH 
 0A6C  49                       	DEC	CX		;POINT TO ZERO AT END OF PREVIOUS LINE 
 0A6D  B0 0D                    	MOV	AL,LOW OFFSET PTRCON	;POINTER CONSTANT 
 0A6F  A2 0000 E                	MOV	BYTE PTR PTRFLG,AL	;SET PTRFLG 
 0A72  5B                       	POP	BX		;GET SAVED POINTER TO RIGHT AFTER CONSTANT 
 0A73  E8 1148 R                	CALL	CONCH2		;CHANGE LINE # TO PTR 
 0A76  8B D9                    	MOV	BX,CX		;[H,L]= POINTER TO THE START OF THE 
                                				;MATCHED LINE 
                                				;NOW POINTING AT THE FIRST BYTE OF THE POINTER 
                                				;TO THE START OF THE NEXT LINE 
 0A78  C3                       	RET			;GO TO NEWSTT 
                                PUBLIC	USERR 
 0A79  B2 00 E                  USERR:	MOV	DL,LOW OFFSET ERRUS 
 0A7B  E9 00AE R                	JMP	ERROR		;C=MATCH, SO IF NO MATCH WE 
                                				;GIVE A "US" ERROR 
                                ; 
                                ; SEE "GOSUB" FOR THE FORMAT OF THE STACK ENTRY 
                                ; "RETURN" RESTORES THE LINE NUMBER AND TEXT POINTER ON THE STACK 
                                ; AFTER ELIMINATING ALL THE "FOR" ENTRIES IN FRONT OF THE "GOSUB" 
                                ; ENTRY 
                                ; 
 0A7E                           RETURN: 
 0A7E  89 1E 0000 E             	MOV	TEMP,BX	;SAVE TEXT POINTER TO SEE IF LINE # 
 0A82  B6 FF                    	MOV	DH,LOW 255	;MAKE SURE THIS VARIABLE POINTER 
                                				;IN [D,E] NEVER GETS MATCHED 
 0A84  E8 0000 R                	CALL	FNDFOR		;GO PAST ALL THE "FOR" ENTRIES 
 0A87  3C 00 E                  	CMP	AL,LOW OFFSET $GOSUB	;see if matching GOSUB found 
 0A89  74 02                    	JZ	SHORT RTRNOK	;branch if so 
 0A8B  4B                       	DEC	BX		;else error, reset stack pointer 
 0A8C  4B                       	DEC	BX 
 0A8D                           RTRNOK: 
 0A8D  8B E3                    	MOV	SP,BX		;UPDATE THE STACK 
 0A8F  89 1E 0000 E             	MOV	SAVSTK,BX	;UPDATE SAVED STACK 
 0A93  3C 00 E                  	CMP	AL,LOW OFFSET $GOSUB 
 0A95  B2 00 E                  	MOV	DL,LOW OFFSET ERRRG	;ERROR ERRRG IS "RETURN WITHOUT GOSUB" 
 0A97  74 03                    	JZ	SHORT ??L050 
 0A99  E9 00AE R                	JMP	ERROR 
 0A9C                           ??L050: 
 = 0001                         	F_TRPO=1		;AFTER A GOSUB WHICH WAS A TR AP WE AUTOMATICALLY 
 = 0002                         	F_TRPS=2		;STOP A REPEAT - THE RETURN RECLEARS THE STOP BIT 
 0A9C  5B                       	POP	BX		;GET TRAP BITS REENABLE ADDRESS IF GOSUB 
 0A9D  0B DB                    	OR	BX,BX		;see if [HL] is 0 
 0A9F  74 09                    	JZ	SHORT NOTEVT	;branch if not On Event Gosub 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-62
RUN, GOTO, GOSUB, RETURN, DATA, REM                         

 0AA1  8A 07                    	MOV	AL,BYTE PTR [BX]	;WAS A TRAP ELSE JUST FAC ADDRESS 
 0AA3  24 01                    	AND	AL,LOW OFFSET F_TRPO	;IS TRAP ON? 
 0AA5  74 03                    	JZ	SHORT ??L051 
                                EXTRN	RSTTRP:NEAR 
 0AA7  E8 0000 E                	CALL	RSTTRP		;IF YES, RESET STOP 
 0AAA                           ??L051: 
 0AAA                           NOTEVT: 
 0AAA  59                       	POP	CX		;GET LINE NUMBER OF GOSUB 
 0AAB  BB 07FF R                	MOV	BX,OFFSET NEWSTT 
 0AAE  5E                       	POP	SI		;XTHL 
 0AAF  87 F3                    	XCHG	SI,BX 
 0AB1  56                       	PUSH	SI		;PUT RETURN ADDRESS OF "NEWSTT" 
                                				;BACK ONTO THE STACK. GET TEXT POINTER 
                                				;FROM "GOSUB" 
 0AB2  87 DA                    	XCHG	BX,DX 
 0AB4  8B 1E 0000 E             	MOV	BX,TEMP	;GO BACK TO START 
 0AB8  9F                       	LAHF 
 0AB9  4B                       	DEC	BX 
 0ABA  9E                       	SAHF 
 0ABB  E8 083A R                	CALL	CHRGTR 
 0ABE  74 03                    	JZ	SHORT ??L052 
 0AC0  E9 0A35 R                	JMP	GOTO		;GO PROCESS RETURN [LINE #]  
 0AC3                           ??L052: 
 0AC3  8A FD                    	MOV	BH,CH		;SET CURLIN FOR GOSUB 
 0AC5  8A D9                    	MOV	BL,CL 
 0AC7  89 1E 0000 E             	MOV	CURLIN,BX 
 0ACB  87 DA                    	XCHG	BX,DX 
                                				;SKIP OVER SOME CHARACTERS 
                                				;SINCE WHEN "GOSUB" STUCK THE TEXT POINTER 
                                				;ONTO THE STACK THE LINE # ARGUMENT HADN'T 
                                				;BEEN READ IN YET. 
                                 
 0ACD  B0                       	DB	260O	; SKIP  ;"MVI A," AROUND POP H. 
 0ACE  5B                       DATAH:	POP	BX		;GET TEXT POINTER OFF STACK 
                                PUBLIC	DATA 
 0ACF                           DATA: 
 0ACF  B1                       	DB	261O	; SKIP  ;"LXI B," TO PICK UP ":" INTO C AND SKIP 
 0AD0  3A                       	DB	":"	      ;"DATA" TERMINATES ON ":" 
                                				;AND 0. ":" ONLY APPLIES IF 
                                				;QUOTES HAVE MATCHED UP 
                                ; ON 8086, USE JMPR TO GO TO REMZER BECAUSE NOP IS NOT ZERO OPCODE 
 0AD1  EB 02                    	JMP	SHORT REMZER 
 0AD3                           ELSES:				;EXECUTED "ELSE"S ARE SKIPPED 
                                ; 
                                ; NOTE: REM MUST PRESERVE [D,E] BECAUSE OF "GO TO" AND ERROR 
                                ; 
 0AD3  B1                       REM:	DB	261O	; SKIP  ;"MVI C,"   THE ONLY TERMINATOR IS ZERO 
 0AD4  00                       	DB	0	; SKIP  ;NO-OPERATION 
                                				;"DATA" ACTUALLY EXECUTES THIS 0 
 0AD5  B5 00                    REMZER: MOV	CH,LOW 0	;INSIDE QUOTES THE ONLY TERMINATOR IS ZERO 
 0AD7  8A C1                    EXCHQT: MOV	AL,CL		;WHEN A QUOTE IS SEEN THE SECOND 
 0AD9  8A CD                    	MOV	CL,CH		;TERMINATOR IS TRADED, SO IN "DATA" 
 0ADB  8A E8                    	MOV	CH,AL		;COLONS INSIDE QUOTATIONS WILL HAVE NO EFFECT 
 0ADD                           REMER: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-63
RUN, GOTO, GOSUB, RETURN, DATA, REM                         

 0ADD  4B                       	DEC	BX		;NOP THE INX H IN CHRGET 
 0ADE  E8 083A R                REMER1: CALL	CHRGTR		;GET A CHAR 
 0AE1  0A C0                    	OR	AL,AL		;ZERO IS ALWAYS A TERMINATOR 
 0AE3  75 01                    	JNZ	SHORT $+3 
 0AE5  C3                       	RET 
 0AE6  3A C5                    	CMP	AL,CH		;TEST FOR THE OTHER TERMINATOR 
 0AE8  75 01                    	JNZ	SHORT $+3 
 0AEA  C3                       	RET 
 0AEB  43                       	INC	BX 
 0AEC  3C 22                    	CMP	AL,LOW 34	;IS IT A QUOTE? 
 0AEE  74 E7                    	JZ	SHORT EXCHQT	;IF SO TIME TO TRADE 
                                ; 
                                ; WHEN AN "IF" TAKES A FALSE BRANCH IT MUST FIND THE APPROPRIATE "ELSE" 
                                ; TO START EXECUTION AT. "DATA" COUNTS THE NUMBER OF "IF"S 
                                ; IT SEES SO THAT THE "ELSE" CODE CAN MATCH "ELSE"S WITH 
                                ; "IF"S. THE COUNT IS KEPT IN [D] 
                                				;BECAUSE THEN S HAVE TNO COLON 
                                				;MULTIPLE IFS CAN BE FOUND IN A SINGLE 
                                				;STATEMENT SCAN 
                                				;THIS CAUSES A PROBLEM FOR 8-BIT DATA 
                                				;IN UNQUOTED STRING DATA BECAUSE $IF MIGHT 
                                				;BE MATCHED. FIX IS TO HAVE FALSIF IGNORE CHANGES 
                                				;IN [D] IF ITS A DATA STATEMENT 
                                ; 
 0AF0  FE C0                    	INC	AL		;FUNCTION TOKEN? 
 0AF2  74 EA                    	JZ	SHORT REMER1	;THEN IGNORE FOLLOWING FN NUMBER 
 0AF4  2C 01 E                  	SUB	AL,LOW OFFSET $IF+1	;IS IT AN "IF" 
 0AF6  75 E5                    	JNZ	SHORT REMER	;IF NOT, CONTINUE ON 
 0AF8  3A C5                    	CMP	AL,CH		;SINCE "REM" CAN'T SMASH 
                                				;[D,E] WE HAVE TO BE CAREFUL 
                                				;SO ONLY IF B DOESN'T EQUAL 
                                				;ZERO WE INCREMENT D. (THE "IF" COUNT) 
 0AFA  12 C6                    	ADC	AL,DH		;CARRY ON IF [B] NOT ZERO 
 0AFC  8A F0                    	MOV	DH,AL		;UPDATE [D] 
 0AFE  EB DD                    	JMP	SHORT REMER 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-64
RUN, GOTO, GOSUB, RETURN, DATA, REM                         

                                	PAGE 
                                 
                                	SUBTTL "LET" 
                                 
                                ; LETCON IS LET ENTRY POINT WITH VALTYP-3 IN [A] 
                                ; BECAUSE GETYPR HAS BEEN CALLED 
                                PUBLIC	LETCON 
 0B00  58                       LETCON: POP	AX		;GET VALTYPE OFF STACK 
 0B01  04 03                    	ADD	AL,LOW 3	;MAKE VALTYPE CORRECT 
 0B03  EB 14                    	JMP	SHORT LETCN2	;CONTINUE 
 0B05  E8 0000 E                LET:	CALL	PTRGET		;GET THE POINTER TO THE VARIABLE 
                                				;NAMED IN TEXT AND PUT 
                                				;IT INTO [D,E] 
 0B08  E8 0000 E                	CALL	SYNCHR 
 0B0B  00 E                     	DB	OFFSET EQULTK	;CHECK FOR "=" 
                                				;MUST SET UP TEMP FOR "FOR" 
 0B0C  89 16 0000 E             	MOV	TEMP,DX	;UP HERE SO WHEN USER-FUNCTIONS 
 0B10  52                       REDINP: PUSH	DX 
 0B11  A0 0000 E                	MOV	AL,BYTE PTR VALTYP 
 0B14  50                       	PUSH	AX 
 0B15  E8 0000 E                	CALL	FRMEVL		;GET THE VALUE OF THE FORMULA 
 0B18  58                       	POP	AX		;GET THE VALTYP OF THE 
                                				;VARIABLE INTO [A] 
                                				;INTO FAC 
 0B19  5E                       LETCN2: POP	SI		;XTHL 
 0B1A  87 F3                    	XCHG	SI,BX 
 0B1C  56                       	PUSH	SI		;[H,L]=POINTER TO VARIABLE 
                                				;TEXT POINTER TO ON TOP OF STACK 
 0B1D  8A E8                    INPCOM: MOV	CH,AL		;SAVE VALTYP 
 0B1F  A0 0000 E                	MOV	AL,BYTE PTR VALTYP	;GET PRESENT VALTYPE 
 0B22  3A C5                    	CMP	AL,CH		;COMPARE THE TWO 
 0B24  8A C5                    	MOV	AL,CH		;GET BACK CURRENT 
 0B26  74 06                    	JZ	SHORT LETCN5	;VALTYPE ALREADY SET UP, GO! 
 0B28  E8 0000 E                	CALL	DOCNVF		;FORCE VALTPES TO BE [A]'S 
                                PUBLIC	LETCN4 
 0B2B  A0 0000 E                LETCN4: MOV	AL,BYTE PTR VALTYP	;GET VALTYPE 
 0B2E  BA 0000 E                LETCN5: MOV	DX,OFFSET FACLO ;ASSUME THIS IS WHERE TO START MOVEING 
 0B31  3C 05                    	CMP	AL,LOW 5	;IS IT? 
 0B33  72 03                    	JB	SHORT LETCN6	;YES 
 0B35  BA 0000 E                	MOV	DX,OFFSET DFACLO	;NO, USE D.P. FAC 
 0B38  53                       LETCN6: PUSH	BX		;SAVE THE POINTER AT THE VALUE POSITION 
 0B39  3C 03                    	CMP	AL,LOW 3	;STRING? 
 0B3B  75 38                    	JNZ	SHORT COPNUM	;NUMERIC, SO FORCE IT AND COPY 
                                ; The following code makes a new copy of the string iff: 
                                ; - the string data resides in keyboard or File buffers (since data 
                                ;    in these buffers is temporary). 
                                ; - the string data resides in string space (each string var must have 
                                ;   its own copy of its string data) 
                                ; - the source string descriptor is not a temporary descriptor. 
                                ; 
 0B3D  8B 1E 0000 E             	MOV	BX,FACLO	;GET POINTER TO THE DESCRIPTOR OF THE RESULT 
 0B41  53                       	PUSH	BX		;SAVE THE POINTER AT THE DESCRIPTOR 
 0B42  43                       	INC	BX 
 0B43  8B 17                    	MOV	DX,[BX] 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-65
"LET"                                                       

 0B45  8B 1E 0000 E             	MOV	BX,TXTTAB	;IF THE DATA IS IN BUF, OR IN DISK 
 0B49  3B DA                    	CMP	BX,DX		;SINCE BUF CHANGES ALL THE TIME 
 0B4B  73 18                    	JAE	SHORT INBUFC	;GO COPY, IF DATA REALLY IS IN BUF 
 0B4D  8B 1E 0000 E             	MOV	BX,STREND	;SEE IF IT POINTS INTO STRING SPACE 
 0B51  3B DA                    	CMP	BX,DX		;IF NOT DON'T COPY 
 0B53  5A                       	POP	DX		;GET BACK THE POINTER AT THE DESCRIPTOR 
 0B54  73 18                    	JAE	SHORT DNTCPY	;DON'T COPY LITERALS 
 0B56  BB FFFF E                	MOV	BX,OFFSET DSCTMP-1 
 0B59  3B DA                    	CMP	BX,DX		;IS THE DESCRIPTOR A TEMP? 
 0B5B  72 07                    	JB	SHORT INBFC0	;NO, MUST POINT TO VARIABLE(COPY IT!) 
 0B5D  BB FFFF E                	MOV	BX,OFFSET TEMPST-1 
 0B60  3B DA                    	CMP	BX,DX 
 0B62  72 0A                    	JB	SHORT DNTCPY	;YES, DON'T COPY 
 0B64                           INBFC0: 
 0B64  B0                       	DB	260O	; SKIP  ;SKIP THE NEXT BYTE WITH A "MVI A," 
 0B65  5A                       INBUFC: POP	DX		;GET THE POINTER TO THE DESCRIPTOR 
                                				;IN [D,E] 
 0B66  E8 0000 E                	CALL	FRETMS		;FREE UP A TEMORARY POINTING INTO BUF 
 0B69  87 DA                    	XCHG	BX,DX		;STRCPY COPIES [H,L] 
 0B6B  E8 0000 E                	CALL	STRCPY		;COPY VARIABLES IN STRING SPACE OR 
                                				;STRINGS WITH DATA IN BUF 
 0B6E  E8 0000 E                DNTCPY: CALL	FRETMS		;FREE UP THE TEMPORARY WITHOUT 
                                				;FREEING UP ANY STRING SPACE 
 0B71  5E                       	POP	SI		;XTHL 
 0B72  87 F3                    	XCHG	SI,BX 
 0B74  56                       	PUSH	SI		;[H,L]=PLACE TO STORE THE DESCRIPTOR 
                                				;LEAVE A NONSENSE ENTRY ON THE STACK, 
                                				;SINCE THE "POP D" DOESN'T EVER 
                                				;MATTER IN THIS CASE 
 0B75  E8 0000 E                COPNUM: CALL	VMOVE		;COPY A DESCRIPTOR OR A VALUE 
 0B78  5A                       	POP	DX		;FOR "FOR" POP OFF A POINTER 
                                				;AT THE LOOP VARIABLE INTO [D,E] 
 0B79  5B                       	POP	BX		;GET THE TEXT POINTER BACK 
 0B7A  C3                       	RET 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-66
"LET"                                                       

                                	PAGE 
                                 
                                	SUBTTL ON..GOTO, ON ERROR GOTO CODE 
                                 
 0B7B                           ONGOTO: 
 0B7B  3C 00 E                  	CMP	AL,LOW OFFSET $ERROR	;"ON...ERROR"? 
 0B7D  75 34                    	JNZ	SHORT NTOERR	;NO. 
 0B7F  E8 083A R                	CALL	CHRGTR		;GET NEXT THING 
 0B82  E8 0000 E                	CALL	SYNCHR 
 0B85  00 E                     	DB	OFFSET $GOTO	;MUST HAVE ...GOTO 
 0B86  E8 098E R                	CALL	LINGET		;GET FOLLOWING LINE # 
 0B89  0B D2                    	OR	DX,DX		;IS LINE NUMBER ZERO? 
 0B8B  74 0D                    	JZ	SHORT RESTRP	;IF ON ERROR GOTO 0, RESET TRAP 
 0B8D  E8 036A R                	CALL	FNDLN1		;SEE IF LINE EXISTS (SAVE [H,L] ON STACK) 
 0B90  8A F5                    	MOV	DH,CH		;GET POINTER TO LINE IN [D,E] 
 0B92  8A D1                    	MOV	DL,CL		;(LINK FIELD OF LINE) 
 0B94  5B                       	POP	BX		;RESTORE [H,L] 
 0B95  72 03                    	JNAE	SHORT ??L053 
 0B97  E9 0A79 R                	JMP	USERR		;ERROR IF LINE NOT FOUND 
 0B9A                           ??L053: 
 0B9A  89 16 0000 E             RESTRP: MOV	ONELIN,DX	;SAVE POINTER TO LINE OR ZERO IF 0. 
 0B9E  73 01                    	JNB	SHORT $+3 
 0BA0  C3                       	RET			;YOU WOULDN'T BELIEVE IT IF I TOLD YOU 
 0BA1  A0 0000 E                	MOV	AL,BYTE PTR ONEFLG	;ARE WE IN AN "ON...ERROR" ROUTINE? 
 0BA4  0A C0                    	OR	AL,AL		;SET CONDITION CODES 
 0BA6  8A C2                    	MOV	AL,DL		;WANT AN EVEN STACK PTR. FOR 8086 
 0BA8  75 01                    	JNZ	SHORT $+3 
 0BAA  C3                       	RET			;IF NOT, HAVE ALREADY DISABLED TRAPPING. 
 0BAB  A0 0000 E                	MOV	AL,BYTE PTR ERRFLG	;GET ERROR CODE 
 0BAE  8A D0                    	MOV	DL,AL		;INTO E. 
 0BB0  E9 00DC R                	JMP	ERRESM		;FORCE THE ERROR TO HAPPEN 
 0BB3                           NTOERR: 
                                	EXTRN	ONGOTP:NEAR 
 0BB3  E8 0000 E                	CALL	ONGOTP		;CHECK FOR "ON event GOSUB ..." 
 0BB6  72 59                    	JB	SHORT NTONGS	;NOT AN event TRAP 
 0BB8  51                       	PUSH	CX		;SAVE START TRAP NUM FOR event(IN B) 
                                				;AND NUMBER OF EVENTS POSSIBLE(IN C) 
 0BB9  E8 083A R                	CALL	CHRGTR		;SKIP OVER EVENT TOKEN 
 0BBC  E8 0000 E                	CALL	SYNCHR 
 0BBF  00 E                     	DB	OFFSET $GOSUB	;Is ON event GOSUB nn,nn, ... 
 0BC0  32 C0                    	XOR	AL,AL		;A = LINE NUMBER COUNT 
 0BC2  59                       ONGSB0: POP	CX 
 0BC3  51                       	PUSH	CX 
 0BC4  3A C1                    	CMP	AL,CL		;WITHIN RANGE OF ALLOWBLE TRAPS? 
 0BC6  72 03                    	JNAE	SHORT ??L054 
 0BC8  E9 0094 R                	JMP	SNERR 
 0BCB                           ??L054: 
 0BCB  9F                       	LAHF			; PUSH PSW 
 0BCC  86 C4                    	XCHG	AL,AH 
 0BCE  50                       	PUSH	AX 
 0BCF  86 C4                    	XCHG	AL,AH 
 0BD1  E8 098E R                	CALL	LINGET 
 0BD4  8A C6                    	MOV	AL,DH 
 0BD6  0A C2                    	OR	AL,DL		;LINE 0? 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-67
ON..GOTO, ON ERROR GOTO CODE                                

 0BD8  74 0D                    	JZ	SHORT RSTRAP	;YES, JUST RESET PORT TRAP 
 0BDA  E8 036A R                	CALL	FNDLN1		;LINE NUMBER EXIST?(SAVE HL ON STACK) 
 0BDD  8A F5                    	MOV	DH,CH 
 0BDF  8A D1                    	MOV	DL,CL 
 0BE1  5B                       	POP	BX		;RESTORE TEXT POINTER 
 0BE2  72 03                    	JNAE	SHORT ??L055 
 0BE4  E9 0A79 R                	JMP	USERR		;ERROR IF LINE NOT FOUND 
 0BE7                           ??L055: 
 0BE7  58                       RSTRAP: POP	AX		; POP PSW 
 0BE8  86 C4                    	XCHG	AL,AH 
 0BEA  9E                       	SAHF			;A = PORT NUMBER 
 0BEB  59                       	POP	CX 
 0BEC  9F                       	LAHF			; PUSH PSW 
 0BED  86 C4                    	XCHG	AL,AH 
 0BEF  50                       	PUSH	AX 
 0BF0  86 C4                    	XCHG	AL,AH 
 0BF2  02 C5                    	ADD	AL,CH 
 0BF4  51                       	PUSH	CX 
 0BF5  E8 0000 E                	CALL	SETGSB		;SET GOSUB ADDR FOR THIS AREA IN A 
 0BF8  9F                       	LAHF 
 0BF9  4B                       	DEC	BX 
 0BFA  9E                       	SAHF 
 0BFB  E8 083A R                	CALL	CHRGTR 
 0BFE  59                       	POP	CX 
 0BFF  5A                       	POP	DX 
 0C00  75 01                    	JNZ	SHORT $+3 
 0C02  C3                       	RET 
 0C03  51                       	PUSH	CX 
 0C04  52                       	PUSH	DX 
 0C05  E8 0000 E                	CALL	SYNCHR 
 0C08  2C                       	DB	OFFSET 54O 
 0C09  58                       	POP	AX		; POP PSW 
 0C0A  86 C4                    	XCHG	AL,AH 
 0C0C  9E                       	SAHF 
 0C0D  FE C0                    	INC	AL		;NEXT AREA 
 0C0F  EB B1                    	JMP	SHORT ONGSB0	;DO NEXT GOSUB ADDR 
 0C11                           NTONGS: 
                                 
 0C11  E8 0000 E                	CALL	GETBYT		;GET VALUE INTO [E] 
                                PUBLIC	NTONG1 
 0C14                           NTONG1:			;jumped to by MENU statement 
 0C14  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET THE TERMINATOR BACK 
 0C16  8A E8                    	MOV	CH,AL		;SAVE THIS CHARACTER FOR LATER 
 0C18  3C 00 E                  	CMP	AL,LOW OFFSET $GOSUB	;AN "ON ... GOSUB" PERHAPS? 
 0C1A  74 05                    	JZ	SHORT ISGOSU	;YES, SOME FEATURE USE 
 0C1C  E8 0000 E                	CALL	SYNCHR 
 0C1F  00 E                     	DB	OFFSET $GOTO	;OTHERWISE MUST BE "GOTO" 
 0C20  4B                       	DEC	BX		;BACK UP CHARACTER POINTER 
 0C21  8A CA                    ISGOSU: MOV	CL,DL		;GET COUNT INTO  [C] 
 0C23  FE C9                    LOOPON: DEC	CL		;SEE IF ENOUGH SKIPS 
 0C25  8A C5                    	MOV	AL,CH		;PUT DISPATCH CHARACTER IN PLACE 
 0C27  75 03                    	JNZ	SHORT ??L056 
 0C29  E9 0827 R                	JMP	GONE2		;IF DONE, GO OFF 
 0C2C                           ??L056: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-68
ON..GOTO, ON ERROR GOTO CODE                                

 0C2C  E8 098F R                	CALL	LINGT2		;SKIP OVER A LINE # 
 0C2F  3C 2C                    	CMP	AL,LOW 44	;A COMMA 
 0C31  74 01                    	JZ	SHORT $+3 
 0C33  C3                       	RET			;IF A COMMA DOESN'T DELIMIT THE END OF 
                                				;THE CURRENT LINE # WE MUST BE THE END OF THE LINE 
 0C34  EB ED                    	JMP	SHORT LOOPON	;CONTINUE GOBBLING LINE #S 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-69
ON..GOTO, ON ERROR GOTO CODE                                

                                	PAGE 
                                 
                                	SUBTTL RESUME, ERROR STATEMENT CODE 
 0C36                           RESUME: 
 0C36  A0 0000 E                	MOV	AL,BYTE PTR ONEFLG	;Get flag 
 0C39  0A C0                    	OR	AL,AL		;Were we called by an ON ERROR? 
 0C3B  75 03                    	JNZ	SHORT ??L057 
 0C3D  E9 00A3 R                	JMP	REERR		;Not in an ON ERROR routine 
 0C40                           ??L057: 
 0C40  32 C0                    	XOR	AL,AL 
 0C42  A2 0000 E                	MOV	BYTE PTR ERRFLG,AL	;CLEAR ERROR FLAG SO ^C DOESN'T GIVE ERROR 
 0C45  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET CURRENT CHAR BACK 
 0C47  3C 00 E                  	CMP	AL,LOW OFFSET $NEXT	;RESUME NEXT? 
 0C49  74 13                    	JZ	SHORT RESNXT	;YUP. 
 0C4B  E8 098E R                	CALL	LINGET 
 0C4E  74 01                    	JZ	SHORT $+3 
 0C50  C3                       	RET			;SHOULD TERMINATE 
 0C51  0B D2                    	OR	DX,DX		;IS LINE NUMBER ZERO? 
 0C53  74 11                    	JZ	SHORT RES0	;Yep, go set non-zero CC's 
 0C55  E8 0A38 R                	CALL	GOTO2		;Go find line 
 0C58  32 C0                    	XOR	AL,AL		;Now zero flag (otherwise RESUME non- 
                                				; existent line number would be trapped 
                                				; by the ON ERROR routine and we would 
                                				; loop infinitely). 
 0C5A  A2 0000 E                	MOV	BYTE PTR ONEFLG,AL 
 0C5D  C3                       	RET 
                                ; 
 0C5E  E8 083A R                RESNXT: CALL	CHRGTR		;MUST TERMINATE 
 0C61  74 01                    	JZ	SHORT $+3 
 0C63  C3                       	RET			;BLOW HIM UP 
 0C64  EB 07                    	JMP	SHORT RESTXT 
                                ; 
 0C66  32 C0                    RES0:	XOR	AL,AL 
 0C68  A2 0000 E                	MOV	BYTE PTR ONEFLG,AL	;clear RESUME-TRAP flag 
 0C6B  FE C0                    	INC	AL		;Set nonzero CC's 
 0C6D  8B 1E 0000 E             RESTXT: MOV	BX,ERRTXT	;GET POINTER INTO LINE. 
 0C71  87 DA                    	XCHG	BX,DX		;SAVE ERRTXT IN [D,E] 
 0C73  8B 1E 0000 E             	MOV	BX,ERRLIN	;GET LINE # 
 0C77  89 1E 0000 E             	MOV	CURLIN,BX	;SAVE IN CURRENT LINE # 
 0C7B  87 DA                    	XCHG	BX,DX 
 0C7D  74 01                    	JZ	SHORT $+3 
 0C7F  C3                       	RET			;GO TO NEWSTT IF JUST "RESUME" 
 0C80  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET ":" OR LINE HEADER 
 0C82  0A C0                    	OR	AL,AL		;SET CC 
 0C84  75 04                    	JNZ	SHORT NOTBGL	;#0 MEANS MUST BE ":" 
 0C86  43                       	INC	BX		;SKIP HEADER 
 0C87  43                       	INC	BX 
 0C88  43                       	INC	BX 
 0C89  43                       	INC	BX 
 0C8A  43                       NOTBGL: INC	BX		;POINT TO START OF THIS STATEMENT 
 0C8B  32 C0                    	XOR	AL,AL		;Now zero flag (otherwise RESUME non- 
                                				; existent line number would be trapped 
                                				; by the ON ERROR routine and we would 
                                				; loop infinitely). 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-70
RESUME, ERROR STATEMENT CODE                                

 0C8D  A2 0000 E                	MOV	BYTE PTR ONEFLG,AL 
 0C90  E9 0ACF R                	JMP	DATA		;GET NEXT STMT 
                                 
                                ; THIS IS THE ERROR <CODE> STATEMENT WHICH FORCES 
                                ; AN ERROR OF TYPE <CODE> TO OCCUR 
                                ; <CODE> MUST BE .GE. 0 AND .LE. 255 
 0C93  E8 0000 E                ERRORS: CALL	GETBYT		;GET THE PARAM 
 0C96  74 01                    	JZ	SHORT $+3 
 0C98  C3                       	RET			;SHOULD HAVE TERMINATED 
 0C99  0A C0                    	OR	AL,AL		;ERROR CODE 0? 
 0C9B  75 03                    	JNZ	SHORT ??L058 
 0C9D  E9 097C R                	JMP	FCERR		;YES, ERROR IN ITSELF 
 0CA0                           ??L058: 
 0CA0  E9 00AE R                GOERR:	JMP	ERROR		;FORCE AN ERROR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-71
RESUME, ERROR STATEMENT CODE                                

                                	PAGE 
                                 
                                	SUBTTL AUTO COMMAND 
                                ; THE AUTO [BEGGINNING LINE[,[INCREMENT]]] 
                                ; COMMAND IS USED TO AUTOMATICALLY GENERATE LINE NUMBERS 
                                ; FOR LINES TO BE INSERTED. BEGINNING LINE IS 
                                ; USED TO SPECIFY THE INITAL LINE (10 IS ASSUMED IF OMMITED) 
                                ; AND THE INCREMENT IS USED TO SPECIFY THE INCREMENT USED 
                                ; TO GENERATE THE NEXT LINE #. IF ONLY A COMMA IS USED AFTER THE 
                                ; BEGGINING LINE, THE OLD INCREMENT IS USED. 
 0CA3  BA 000A                  AUTO:	MOV	DX,10		;ASSUME INITIAL LINE # OF 10 
 0CA6  52                       	PUSH	DX		;SAVE IT 
 0CA7  74 1F                    	JZ	SHORT SNGAUT	;IF END OF COMMAND USE 10,10 
 0CA9  E8 0981 R                	CALL	LINSPC		;GET LINE #, ALLOW USE OF . FOR CURRENT LINE 
 0CAC  87 DA                    	XCHG	BX,DX		;GET TXT PTR IN [D,E] 
 0CAE  5E                       	POP	SI		;XTHL 
 0CAF  87 F3                    	XCHG	SI,BX 
 0CB1  56                       	PUSH	SI		;PUT INIT ON STACK, GET 10 IN [H,L] 
 0CB2  74 16                    	JZ	SHORT SNGAU1	;IF TERMINATOR, USE INC OF 10 
 0CB4  87 DA                    	XCHG	BX,DX		;GET TEXT PTR BACK IN [H,L] 
 0CB6  E8 0000 E                	CALL	SYNCHR 
 0CB9  2C                       	DB	OFFSET 54O	;COMMA MUST FOLLOW 
 0CBA  8B 16 0000 E             	MOV	DX,AUTINC	;GET PREVIOUS INC 
 0CBE  74 08                    	JZ	SHORT SNGAUT	;USE PREVIOUS INC IF TERMINATOR 
 0CC0  E8 098E R                	CALL	LINGET		;GET INC 
 0CC3  74 03                    	JZ	SHORT ??L059 
 0CC5  E9 0094 R                	JMP	SNERR		;SHOULD HAVE FINISHED. 
 0CC8                           ??L059: 
 0CC8  87 DA                    SNGAUT: XCHG	BX,DX		;GET INC IN [H,L] 
 0CCA  8A C7                    SNGAU1: MOV	AL,BH		;SEE IF ZERO 
 0CCC  0A C3                    	OR	AL,BL 
 0CCE  75 03                    	JNZ	SHORT ??L060 
 0CD0  E9 097C R                	JMP	FCERR		;ZERO INC GIVES FCERR 
 0CD3                           ??L060: 
 0CD3  89 1E 0000 E             	MOV	AUTINC,BX	;SAVE INCREMENT 
 0CD7  A2 0000 E                	MOV	BYTE PTR AUTFLG,AL	;SET FLAG TO USE AUTO IN MAIN CODE. 
 0CDA  5B                       	POP	BX		;GET INITIAL LINE # 
 0CDB  89 1E 0000 E             	MOV	AUTLIN,BX	;SAVE IN INTIAL LINE 
 0CDF  59                       	POP	CX		;GET RID OF NEWSTT ADDR 
 0CE0  E9 01B2 R                	JMP	MAIN		;JUMP INTO MAIN CODE (FOR REST SEE AFTER MAIN:) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-72
AUTO COMMAND                                                

                                	PAGE 
                                 
                                	SUBTTL IF ... THEN CODE 
 0CE3  E8 0000 E                IFS:	CALL	FRMEVL		;EVALUATE A FORMULA 
 0CE6  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET TERMINATING CHARACTER OF FORMULA 
 0CE8  3C 2C                    	CMP	AL,LOW 44 
 0CEA  75 03                    	JNZ	SHORT ??L061 
 0CEC  E8 083A R                	CALL	CHRGTR		;IF SO SKIP IT 
 0CEF                           ??L061: 
 0CEF  3C 00 E                  	CMP	AL,LOW OFFSET $GOTO	;ALLOW "GOTO" AS WELL 
 0CF1  74 05                    	JZ	SHORT OKGOTO 
 0CF3  E8 0000 E                	CALL	SYNCHR 
 0CF6  00 E                     	DB	OFFSET THENTK	;MUST HAVE A THEN 
 0CF7  4B                       	DEC	BX 
 0CF8                           OKGOTO: 
 0CF8  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 0CF9  E8 0000 E                	CALL	VSIGN 
 0CFC  5B                       	POP	BX		;GET BACK THE TEXT POINTER 
 0CFD  74 19                    	JZ	SHORT FALSIF	;HANDLE POSSIBLE "ELSE" 
 0CFF  E8 083A R                DOCOND: CALL	CHRGTR		;PICK UP THE FIRST LINE # CHARACTER 
 0D02  75 01                    	JNZ	SHORT $+3 
 0D04  C3                       	RET			;RETURN FOR "THEN :" OR "ELSE :" 
 0D05  3C 0E                    	CMP	AL,LOW OFFSET LINCON	;LINE NUMBER CONSTANT? 
 0D07  75 03                    	JNZ	SHORT ??L062 
 0D09  E9 0A35 R                	JMP	GOTO		;DO A "GOTO" 
 0D0C                           ??L062: 
 0D0C  3C 0D                    	CMP	AL,LOW OFFSET PTRCON	;POINTER CONSTANT 
 0D0E  74 03                    	JZ	SHORT ??L063 
 0D10  E9 0827 R                	JMP	GONE2		;EXECUTE STATEMENT, NOT GOTO 
 0D13                           ??L063: 
 0D13  8B 1E 0000 E             	MOV	BX,CONLO	;GET TEXT POINTER 
 0D17  C3                       	RET			;FETCH NEW STATMENT 
                                ; 
                                ; "ELSE" HANDLER. HERE ON FALSE "IF" CONDITION 
                                ; 
 0D18  B6 01                    FALSIF: MOV	DH,LOW 1	;NUMBER OF "ELSE"S THAT MUST 
                                				;BE SEEN. "DATA" INCREMENTS THIS 
                                				;COUNT EVERY TIME AN "IF" IS SEEN 
 0D1A  E8 0ACF R                SKPMRF: CALL	DATA		;SKIP A STATEMENT 
                                				;":" IS STUCK IN FRONT OF "ELSE"S 
                                				;SO THAT "DATA" WILL STOP BEFORE "ELSE" CLAUSES 
 0D1D  0A C0                    	OR	AL,AL		;END OF LINE? 
 0D1F  75 01                    	JNZ	SHORT $+3 
 0D21  C3                       	RET			;IF SO, NO "ELSE" CLAUSE 
 0D22  E8 083A R                	CALL	CHRGTR		;SEE IF WE HIT AN "ELSE" 
 0D25  3C 00 E                  	CMP	AL,LOW OFFSET $ELSE 
 0D27  75 F1                    	JNZ	SHORT SKPMRF	;NO, STILL IN THE "THEN" CLAUSE 
 0D29  FE CE                    	DEC	DH		;DECREMENT THE NUMBER OF "ELSE"S THAT 
                                				;MUST BE SEEN 
 0D2B  75 ED                    	JNZ	SHORT SKPMRF	;SKIP MORE IF HAVEN'T SEEN 
                                				;ENOUGH 
 0D2D  EB D0                    	JMP	SHORT DOCOND	;FOUND THE RIGHT "ELSE" -- GO EXECUTE 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-73
IF ... THEN CODE                                            

                                	PAGE 
                                 
                                	SUBTTL PRINT CODE 
                                 
                                	EXTRN	LPRINT:NEAR,LPRINT:NEAR,FINPRT:NEAR 
                                 
                                	SUBTTL LINE INPUT, INPUT AND READ CODE 
 0D2F                           LINE: 
                                	EXTRN	GLINE:NEAR 
 0D2F  3C 00 E                  	CMP	AL,LOW OFFSET $INPUT 
 0D31  74 03                    	JZ	SHORT ??L064 
 0D33  E9 0000 E                	JMP	GLINE		;MUST BE GRAPHICS TYPE LINE 
 0D36                           ??L064: 
 0D36  E8 0000 E                	CALL	SYNCHR 
 0D39  00 E                     	DB	OFFSET $INPUT 
 0D3A  3C 23                    	CMP	AL,LOW "#"      ;SEE IF THERE IS A FILE NUMBER 
                                	EXTRN	DLINE:NEAR 
 0D3C  75 03                    	JNZ	SHORT ??L065 
 0D3E  E9 0000 E                	JMP	DLINE		;DO DISK INPUT LINE 
 0D41                           ??L065: 
 0D41  E8 0000 E                	CALL	SCNSEM		;SCAN SEMICOLON FOR NO-CR 
 0D44  E8 0DB9 R                	CALL	QTINP		;PRINT QUOTED STRING IF ONE 
 0D47  E8 0000 E                	CALL	PTRGET		;READ STRING TO STORE INTO 
 0D4A  E8 0000 E                	CALL	CHKSTR		;MAKE SURE ITS A STRING 
 0D4D  52                       	PUSH	DX		;SAVE POINTER AT VARIABLE 
 0D4E  53                       	PUSH	BX		;SAVE TEXT POINTER 
                                	EXTRN	SINLIN:NEAR 
 0D4F  E8 0000 E                	CALL	SINLIN		;READ A LINE OF INPUT 
 0D52  5A                       	POP	DX		;GET TEXT POINTER 
 0D53  59                       	POP	CX		;GET POINTER AT VARIABLE 
 0D54  73 03                    	JAE	SHORT ??L066 
 0D56  E9 0000 E                	JMP	STPEND		;IF CONTROL-C, STOP 
 0D59                           ??L066: 
 0D59  51                       RELINE: PUSH	CX		;SAVE BACK VARIABLE POINTER 
 0D5A  52                       	PUSH	DX		;SAVE TEXT POINTER 
 0D5B  B5 00                    	MOV	CH,LOW 0	;SETUP ZERO AS ONLY TERMINATOR 
 0D5D  E8 0000 E                	CALL	STRLT3		;LITERALIZE THE INPUT 
 0D60  5B                       	POP	BX		;RESTORE [H,L]=TEXT POINTER 
 0D61  B0 03                    	MOV	AL,LOW 3	;SET THREE FOR STRING 
 0D63  E9 0B19 R                	JMP	LETCN2		;DO THE ASSIGNMENT 
                                 
 0D66                           TRYAGN: 
 0D66  3F 52 65 64 6F 20 66     	DB"?Redo from start" 
       72 6F 6D 20 73 74 61     
       72 74                    
                                	ACRLF 
 0D78  00                       	DB	0 
                                ; 
                                ; HERE WHEN PASSING OVER STRING LITERAL IN SUBSCRIPT OF VARIABLE IN INPUT LIST 
                                ; ON THE FIRST PASS OF INPUT CHECKING FOR TYPE MATCH AND NUMBER 
                                ; 
 0D79  43                       SCNSTR: INC	BX		;LOOK AT THE NEXT CHARACTER 
 0D7A  8A 07                    	MOV	AL,BYTE PTR [BX]	;FETCH IT 
 0D7C  0A C0                    	OR	AL,AL		;END OF LINE? 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-74
LINE INPUT, INPUT AND READ CODE                             

 0D7E  75 03                    	JNZ	SHORT ??L067 
 0D80  E9 0094 R                	JMP	SNERR		;ENDING IN STRING IN SUBSCRIPT IS BAD SYNTAX 
 0D83                           ??L067: 
 0D83  3C 22                    	CMP	AL,LOW 34	;ONLY OTHER TERMINATOR IS QUOTE 
 0D85  75 F2                    	JNZ	SHORT SCNSTR	;CONTINUE UNTIL QUOTE OR 0 IS FOUND 
 0D87  E9 0E2B R                	JMP	SCNCON		;CONTINUE MATCHING PARENS SINCE STRING ENDED 
                                 
 0D8A  5B                       INPBAK: POP	BX		;GET RID OF PASS1 DATA POINTER 
 0D8B  5B                       	POP	BX		;GET RID OF PASS2 DATA POINTER 
 0D8C  EB 0A                    	JMP	SHORT RDOIN2	;GET RID OF PASS2 VARLST POINTER AND RETRY 
                                ; 
                                ; HERE WHEN THE DATA THAT WAS TYPED IN OR IN "DATA" STATEMENTS 
                                ; IS IMPROPERLY FORMATTED. FOR "INPUT" WE START AGAIN. 
                                ; FOR "READ" WE GIVE A SYNTAX ERROR AT THE DATA LINE 
                                ; 
 0D8E                           TRMNOK: 
 0D8E  A0 0000 E                	MOV	AL,BYTE PTR FLGINP	;WAS IT READ OR INPUT? 
 0D91  0A C0                    	OR	AL,AL		;ZERO=INPUT 
 0D93  74 03                    	JZ	SHORT ??L068 
 0D95  E9 008C R                	JMP	DATSNE		;GIVE ERROR AT DATA LINE 
 0D98                           ??L068: 
 0D98  59                       RDOIN2: POP	CX		;GET RID OF THE POINTER INTO THE VARIABLE LIST 
 0D99                           RDOINP: 
 0D99  BB 0D66 R                	MOV	BX,OFFSET TRYAGN 
 0D9C  E8 0000 E                	CALL	STROUT		;PRINT "?REDO FROM START" 
 0D9F  8B 1E 0000 E             	MOV	BX,SAVTXT	;GET SAVED TEXT POINTER 
 0DA3  C3                       	RET			;GO BACK TO NEWSTT 
                                				;OF THE "INPUT" STATEMENT 
 0DA4  E8 0000 E                FILSTI: CALL	FILINP 
 0DA7  53                       	PUSH	BX		;PUT THE TEXT POINTER ON THE STACK 
 0DA8  BB 0000 E                	MOV	BX,OFFSET BUFMIN	;POINT AT A COMMA 
 0DAB  E9 0EAC R                	JMP	INPCN3 
 0DAE                           INPUT: 
                                 
 0DAE  3C 23                    	CMP	AL,LOW "#" 
 0DB0  74 F2                    	JZ	SHORT FILSTI 
 0DB2  E8 0000 E                	CALL	SCNSEM		;SCAN SEMICOLON FOR NO-CR 
 0DB5  B9 0DE5 R                	MOV	CX,OFFSET NOTQTI	;WHERE TO GO 
 0DB8  51                       	PUSH	CX		;WHEN DONE WITH QUOTED STRING 
 0DB9  3C 22                    QTINP:	CMP	AL,LOW 34	;IS IT A QUOTE? 
 0DBB  B0 00                    	MOV	AL,LOW 0	;BE TALKATIVE 
 0DBD  A2 0000 E                	MOV	BYTE PTR CNTOFL,AL	;FORCE OUTPUT 
 0DC0  B0 FF                    	MOV	AL,LOW 255	;MAKE NON-ZERO VALUE 
 0DC2  A2 0001 E                	MOV	BYTE PTR TEMPA+1,AL	;FLAG TO DO "? " 
 0DC5  74 01                    	JZ	SHORT $+3 
 0DC7  C3                       	RET			;JUST RETURN 
 0DC8  E8 0000 E                	CALL	STRLTI		;MAKE THE MESSAGE A STRING 
 0DCB  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET CHAR 
 0DCD  3C 2C                    	CMP	AL,LOW 54O	;COMMA? 
 0DCF  75 0A                    	JNZ	SHORT NTICMA	;NO 
 0DD1  32 C0                    	XOR	AL,AL		;FLAG NOT TO DO IT 
 0DD3  A2 0001 E                	MOV	BYTE PTR TEMPA+1,AL 
 0DD6  E8 083A R                	CALL	CHRGTR		;FETCH NEXT CHAR 
 0DD9  EB 04                    	JMP	SHORT INPCMA	;CONTINUE 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-75
LINE INPUT, INPUT AND READ CODE                             

 0DDB                           NTICMA: 
 0DDB  E8 0000 E                	CALL	SYNCHR 
 0DDE  3B                       	DB	OFFSET 59	;MUST END WITH SEMI-COLON 
 0DDF                           INPCMA: 
 0DDF  53                       	PUSH	BX		;REMEMBER WHERE IT ENDED 
 0DE0  E8 0000 E                	CALL	STRPRT		;PRINT IT OUT 
 0DE3  5B                       	POP	BX		;GET BACK SAVED TEXT PTR 
 0DE4  C3                       	RET			;ALL DONE 
 0DE5                           NOTQTI: 
 0DE5  53                       	PUSH	BX 
 0DE6                           GETAGN: 
 0DE6  A0 0001 E                	MOV	AL,BYTE PTR TEMPA+1	;DO "? " 
 0DE9  0A C0                    	OR	AL,AL 
 0DEB  74 0A                    	JZ	SHORT SUPPRS	;THEN SUPPRESS "?" 
 0DED  B0 3F                    	MOV	AL,LOW "?"      ;TYPE "?" AND INPUT A LINE OF TEXT 
 0DEF  E8 0000 E                	CALL	OUTDO 
 0DF2  B0 20                    	MOV	AL,LOW " " 
 0DF4  E8 0000 E                	CALL	OUTDO 
 0DF7                           SUPPRS: 
 0DF7  E8 0000 E                	CALL	SINLIN 
 0DFA  59                       	POP	CX		;TAKE OFF SINCE MAYBE LEAVING 
 0DFB  73 03                    	JAE	SHORT ??L069 
 0DFD  E9 0000 E                	JMP	STPEND		;IF EMPTY LEAVE 
 0E00                           ??L069: 
 0E00  51                       	PUSH	CX		;PUT BACK  SINCE DIDN'T LEAVE 
                                ; 
                                ; THIS IS THE FIRST PASS DICTATED BY ANSI REQUIRMENT THAN NO VALUES BE ASSIGNED 
                                ; BEFORE CHECKING TYPE AND NUMBER. THE VARIABLE LIST IS SCANNED WITHOUT EVALUATING 
                                ; SUBSCRIPTS AND THE INPUT IS SCANNED TO GET ITS TYPE. NO ASSIGNMENT 
                                ; IS DONE 
                                ; 
 0E01  32 C0                    	XOR	AL,AL		;FLAG AS INPUT SO SCNVAL WILL WORK 
 0E03  A2 0000 E                	MOV	BYTE PTR FLGINP,AL	;WHEN SCANNING STRINGS WITH ":" 
 0E06  C6 07 2C                 	MOV	BYTE PTR [BX],LOW 44	;PUT A COMMA IN FRONT OF BUF 
 0E09  87 DA                    	XCHG	BX,DX		;SAVE DATA POINTER IN [D,E] 
 0E0B  5B                       	POP	BX		;GET THE VARLST POINTER INTO [H,L] 
 0E0C  53                       	PUSH	BX		;RESAVE THE VARLST POINTER 
 0E0D  52                       	PUSH	DX		;SAVE A COPY OF THE DATA POINTER FOR PASS2 
 0E0E  52                       	PUSH	DX		;SAVE THE DATA POINTER FOR PASS1 
 0E0F  4B                       	DEC	BX		;READ THE FIRST VARIABLE NAME 
 0E10  B0 80                    VARLOP: MOV	AL,LOW 128	;DON'T ALLOW SUBSCRIPTS -- RETURN POINTING TO "(" 
 0E12  A2 0000 E                	MOV	BYTE PTR SUBFLG,AL 
 0E15  E8 083A R                	CALL	CHRGTR		;ADVANCE TEXT POINTER 
                                	EXTRN	PTRGTN:NEAR 
 0E18  E8 0000 E                	CALL	PTRGTN		;SCAN NAME AND RETURN POINTER IN [D,E] 
 0E1B  8A 07                    	MOV	AL,BYTE PTR [BX]	;SEE IF IT ENDED ON "(" 
 0E1D  4B                       	DEC	BX		;RESCAN THE TERMINATOR 
 0E1E  3C 5B                    	CMP	AL,LOW "["      ;allow brackets also 
 0E20  74 04                    	JZ	SHORT SCNBKT 
 0E22  3C 28                    	CMP	AL,LOW "("      ;ARRAY OR NOT? 
 0E24  75 28                    	JNZ	SHORT ENDSCN	;IF NOT, VARIABLE NAME IS DONE 
 0E26  43                       SCNBKT: INC	BX		;NOW SCAN THE SUBSCRIPT EXPRESSION 
 0E27  B5 00                    	MOV	CH,LOW 0	;INITIALIZE THE PAREN COUNT 
 0E29  FE C5                    SCNOPN: INC	CH		;UP THE COUNT FOR EVERY "(" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-76
LINE INPUT, INPUT AND READ CODE                             

 0E2B  E8 083A R                SCNCON: CALL	CHRGTR		;GET THE NEXT CHARACTER 
 0E2E  75 03                    	JNZ	SHORT ??L070 
 0E30  E9 0094 R                	JMP	SNERR		;SHOULDN'T END STATEMENT IN EXPRESSION 
 0E33                           ??L070: 
 0E33  3C 22                    	CMP	AL,LOW 34	;IS THERE A QUOTED STRING CONSTANT 
 0E35  75 03                    	JNZ	SHORT ??L071 
 0E37  E9 0D79 R                	JMP	SCNSTR		;GO SCAN THE ENDTIRE CONSTANT (MAY CONTAIN PARENS) 
 0E3A                           ??L071: 
 0E3A  3C 28                    	CMP	AL,LOW "("      ;ANOTHER LEVEL OF NESTING? 
 0E3C  74 EB                    	JZ	SHORT SCNOPN	;INCREMENT COUTN AND KEEP SCANNING 
 0E3E  3C 5B                    	CMP	AL,LOW "["      ;left bracket? 
 0E40  74 E9                    	JZ	SHORT SCNCON	;yes, ok 
 0E42  3C 5D                    	CMP	AL,LOW "]"      ;left bracket? 
 0E44  74 04                    	JZ	SHORT LEFPRN	;yes 
 0E46  3C 29                    	CMP	AL,LOW ")"      ;ONE LESS LEVEL OF PARENS? 
 0E48  75 E1                    	JNZ	SHORT SCNCON	;NO, KEEP SCANNING 
                                				;DECREMENT PAREN COUNT. OUT OF SUBSCRIPT? 
 0E4A  FE CD                    LEFPRN: DEC	CH 
 0E4C  75 DD                    	JNZ	SHORT SCNCON	;IF NOT AT ZERO LEVEL, KEEP SCANNING 
 0E4E  E8 083A R                ENDSCN: CALL	CHRGTR		;GET TERMINATING CHARACTER 
 0E51  74 07                    	JZ	SHORT OKVLST	;LAST VARIABLE IN INPUT LIST 
 0E53  3C 2C                    	CMP	AL,LOW 44	;OTHERWISE IT MUST BE A COMMA 
 0E55  74 03                    	JZ	SHORT ??L072 
 0E57  E9 0094 R                	JMP	SNERR		;BADLY FORMED INPUT -- SYNTAX ERROR 
 0E5A                           ??L072: 
 0E5A  5E                       OKVLST: POP	SI		;XTHL 
 0E5B  87 F3                    	XCHG	SI,BX 
 0E5D  56                       	PUSH	SI		;SAVE THE VARLST POINTER 
                                				;GET THE DATA POINTER INTO [H,L] 
 0E5E  8A 07                    	MOV	AL,BYTE PTR [BX]	;DATA SHOULD ALWAYS HAVE A LEADING COMMA 
 0E60  3C 2C                    	CMP	AL,LOW 44	;IS IT PROPERLY FORMED? 
 0E62  74 03                    	JZ	SHORT ??L073 
 0E64  E9 0D8A R                	JMP	INPBAK		;NO, ASK FOR COMPLETE REINPUT 
 0E67                           ??L073: 
 0E67  B0 01                    	MOV	AL,LOW 1	;SET OVCSTR=1 
 0E69  A2 0000 E                	MOV	BYTE PTR OVCSTR,AL 
 0E6C  A2 0000 E                	MOV	BYTE PTR FLGSCN,AL	;Flag to SCNVAL that call is from INPUT 
 0E6F  E8 0EDF R                	CALL	SCNVAL		;GO INTO PASS2 CODE AND SCAN A VALUE 
 0E72  A0 0000 E                	MOV	AL,BYTE PTR FLGSCN 
 0E75  FE C8                    	DEC	AL		;Restore flag 
 0E77  A2 0000 E                	MOV	BYTE PTR FLGSCN,AL 
 0E7A  A0 0000 E                	MOV	AL,BYTE PTR OVCSTR	;SEE IF IT WAS TOO BIG 
 0E7D  FE C8                    	DEC	AL 
 0E7F  74 03                    	JZ	SHORT ??L074 
 0E81  E9 0D8A R                	JMP	INPBAK 
 0E84                           ??L074: 
 0E84  53                       	PUSH	BX		;SAVE THE RETURNED DATA POINTER 
 0E85  E8 0000 E                	CALL	GETYPR		;RELEASE STRING 
 0E88  75 03                    	JNZ	SHORT ??L075 
 0E8A  E8 0000 E                	CALL	FREFAC 
 0E8D                           ??L075: 
 0E8D  5B                       	POP	BX 
 0E8E  4B                       	DEC	BX		;SKIP OVER SPACES LEFT AFTER VALUE SCAN 
 0E8F  E8 083A R                	CALL	CHRGTR 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-77
LINE INPUT, INPUT AND READ CODE                             

                                ; 
                                ; NOTE CHECK FOR OVERFLOW OF INPUT VALUE HERE 
                                ; 
 0E92  5E                       	POP	SI		;XTHL 
 0E93  87 F3                    	XCHG	SI,BX 
 0E95  56                       	PUSH	SI		;SAVE THE DATA POINTER 
                                				;[H,L]=DATA LIST POINTER 
 0E96  8A 07                    	MOV	AL,BYTE PTR [BX]	;DID VARIABLE LIST CONTINUE? 
 0E98  3C 2C                    	CMP	AL,LOW 44	;MUST HAVE HAD A COMMA 
 0E9A  75 03                    	JNZ	SHORT ??L076 
 0E9C  E9 0E10 R                	JMP	VARLOP		;GO CHECK ANOTHER 
 0E9F                           ??L076: 
 0E9F  5B                       	POP	BX		;GET FINAL DATA POINTER 
 0EA0  4B                       	DEC	BX		;SKIP OVER ANY TRAILING SPACES 
 0EA1  E8 083A R                	CALL	CHRGTR 
 0EA4  0A C0                    	OR	AL,AL		;IS IT A TRUE END? 
 0EA6  5B                       	POP	BX		;GET THE START OF DATA POINTER FOR PASS2 
 0EA7  74 03                    	JZ	SHORT ??L077 
 0EA9  E9 0D98 R                	JMP	RDOIN2		;IF DATA ENDED BADLY ASK FOR REINPUT 
 0EAC                           ??L077: 
 0EAC                           INPCN3: 
 0EAC  C6 07 2C                 	MOV	BYTE PTR [BX],LOW 44	;SETUP COMMA AT BUFMIN 
 0EAF  EB 06                    	JMP	SHORT INPCON 
 0EB1                           READ: 
 0EB1  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 0EB2  8B 1E 0000 E             	MOV	BX,DATPTR	;GET LAST DATA LOCATION 
 0EB6  0D                       	DB	15O	; SKIP  ;"ORI" TO SET [A] NON-ZERO 
 0EB7  32 C0                    INPCON: XOR	AL,AL		;SET FLAG THAT THIS IS AN INPUT 
 0EB9  A2 0000 E                	MOV	BYTE PTR FLGINP,AL	;STORE THE FLAG 
                                ; 
                                ; IN THE PROCESSING OF DATA AND READ STATEMENTS: 
                                ; ONE POINTER POINTS TO THE DATA (IE THE NUMBERS BEING FETCHED) 
                                ; AND ANOTHER POINTS TO THE LIST OF VARIABLES 
                                ; 
                                ; THE POINTER INTO THE DATA ALWAYS STARTS POINTING TO A 
                                ; TERMINATOR -- A , : OR END-OF-LINE 
                                ; 
 0EBC  5E                       	POP	SI		;XTHL 
 0EBD  87 F3                    	XCHG	SI,BX 
 0EBF  56                       	PUSH	SI		;[H,L]=VARIABLE LIST POINTER 
                                				;DATA POINTER GOES ON THE STACK 
 0EC0  EB 04                    	JMP	SHORT LOPDAT 
 0EC2  E8 0000 E                LOPDT2: CALL	SYNCHR 
 0EC5  2C                       	DB	OFFSET 44	;MAKE SURE THERE IS A "," 
 0EC6  E8 0000 E                LOPDAT: CALL	PTRGET		;READ THE VARIABLE LIST 
                                				;AND GET THE POINTER TO A VARIABLE INTO [D,E] 
 0EC9  5E                       	POP	SI		;XTHL 
 0ECA  87 F3                    	XCHG	SI,BX 
 0ECC  56                       	PUSH	SI		;PUT THE VARIABLE LIST POINTER ONTO THE 
                                				;STACK AND TAKE THE 
                                				;DATA LIST POINTER OFF 
                                ; 
                                ; NOTE AT THIS POINT WE HAVE A VARIABLE WHICH WANTS DATA 
                                ; AND SO WE MUST GET DATA OR COMPLAIN 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-78
LINE INPUT, INPUT AND READ CODE                             

                                ; 
 0ECD  52                       	PUSH	DX		;SAVE THE POINTER TO THE VARIABLE WE 
                                				;ARE ABOUT TO SET UP WITH A VALUE 
 0ECE  8A 07                    	MOV	AL,BYTE PTR [BX]	;SINCE THE DATA LIST POINTER ALWAYS POINTS 
                                				;AT A TERMINATOR LETS READ THE 
                                				;TERMINATOR INTO [A] AND SEE WHAT 
                                				;IT IS 
 0ED0  3C 2C                    	CMP	AL,LOW 44 
 0ED2  74 0A                    	JZ	SHORT DATBK	;A COMMA SO A VALUE MUST FOLLOW 
 0ED4  A0 0000 E                	MOV	AL,BYTE PTR FLGINP	;SEE WHAT TYPE OF STATEMENT THIS WAS 
 0ED7  0A C0                    	OR	AL,AL 
                                				;SEARCH FOR ANOTHER DATA STATEMENT 
 0ED9  74 03                    	JZ	SHORT ??L078 
 0EDB  E9 0F69 R                	JMP	DATLOP 
 0EDE                           ??L078: 
 0EDE                           DATBK: 
 0EDE  0D                       	DB	15O	; SKIP  ;SET A NON-ZERO 
 0EDF  32 C0                    SCNVAL: XOR	AL,AL		;SET ZERO FLAG IN [A] 
 0EE1  A2 0000 E                	MOV	BYTE PTR INPPAS,AL	;STORE SO EARLY RETURN CHECK WORKS 
                                EXTRN	ISFLIO:NEAR 
 0EE4  E8 0000 E                	CALL	ISFLIO		;SEE IF A FILE READ 
 0EE7  74 03                    	JZ	SHORT ??L079 
 0EE9  E9 0000 E                	JMP	FILIND		;IF SO, SPECIAL HANDLING 
 0EEC                           ??L079: 
 0EEC  E8 0000 E                	CALL	GETYPR		;IS IT A STRING? 
 0EEF  50                       	PUSH	AX		;SAVE THE TYPE INFORMATION 
 0EF0  75 38                    	JNZ	SHORT NUMINS	;IF NUMERIC, USE FIN TO GET IT 
                                				;ONLY THE VARAIBLE TYPE IS 
                                				;CHECKED SO AN UNQUOTED STRING 
                                				;CAN BE ALL DIGITS 
 0EF2  E8 083A R                	CALL	CHRGTR 
 0EF5  8A F0                    	MOV	DH,AL		;ASSUME QUOTED STRING 
 0EF7  8A E8                    	MOV	CH,AL		;SETUP TERMINATORS 
 0EF9  3C 22                    	CMP	AL,LOW 34	;QUOTE ? 
 0EFB  74 0E                    	JZ	SHORT NOWGET	;TERMINATORS OK 
 0EFD  A0 0000 E                	MOV	AL,BYTE PTR FLGINP	;INPUT SHOULDN'T TERMINATE ON ":" 
 0F00  0A C0                    	OR	AL,AL		;SEE IF READ OR INPUT 
 0F02  8A F0                    	MOV	DH,AL		;SET D TO ZERO FOR INPUT 
 0F04  74 02                    	JZ	SHORT NCOLST 
 0F06  B6 3A                    	MOV	DH,LOW ":"      ;UNQUOTED STRING TERMINATORS 
 0F08  B5 2C                    NCOLST: MOV	CH,LOW 44	;ARE COLON AND COMMA 
                                				;NOTE: ANSI USES [B]=44 AS A FLAG TO 
                                				;TRIGGER TRAILING SPACE SUPPRESSION 
 0F0A  4B                       	DEC	BX		;BACKUP SINCE START CHARACTER MUST BE INCLUDED 
                                				;IN THE QUOTED STRING CASE WE DON'T WANT TO 
                                				;INCLUDE THE STARTING OR ENDING QUOTE 
 0F0B  E8 0000 E                NOWGET: CALL	STRLT2		;MAKE A STRING DESCRIPTOR FOR THE VALUE 
                                				;AND COPY IF NECESSARY 
                                PUBLIC	DOASIG 
 0F0E  58                       DOASIG: POP	AX		;POP OFF THE TYPE INFORMATION 
 0F0F  04 03                    	ADD	AL,LOW 3	;MAKE VALTYPE CORRECT 
 0F11  8A C8                    	MOV	CL,AL		;SAVE VALUE TYPE IN [C] 
 0F13  A0 0000 E                	MOV	AL,BYTE PTR INPPAS	;SEE IF SCANNING VALUES FOR PASS1 
 0F16  0A C0                    	OR	AL,AL		;ZERO FOR PASS1 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-79
LINE INPUT, INPUT AND READ CODE                             

 0F18  75 01                    	JNZ	SHORT $+3 
 0F1A  C3                       	RET			;GO BACK TO PASS1 
 0F1B  8A C1                    	MOV	AL,CL		;RECOVER VALTYP 
 0F1D  87 DA                    	XCHG	BX,DX		;[D,E]=TEXT POINTER 
 0F1F  BB 0F3D R                	MOV	BX,OFFSET STRDN2	;RETURN LOC 
 0F22  5E                       	POP	SI		;XTHL 
 0F23  87 F3                    	XCHG	SI,BX 
 0F25  56                       	PUSH	SI		;[H,L]=PLACE TO STORE VARIABLE VALUE 
 0F26  52                       	PUSH	DX		;TEXT POINTER GOES ON 
 0F27  E9 0B1D R                	JMP	INPCOM		;DO ASSIGNMENT 
 0F2A  E8 083A R                NUMINS: CALL	CHRGTR 
 0F2D  58                       	POP	AX		;GET BACK VALTYPE OF SOURCE 
 0F2E  50                       	PUSH	AX		;SAVE BACK 
 0F2F  3C 05                    	CMP	AL,LOW 5	;REGEN CC'S 
 0F31  B9 0F0E R                	MOV	CX,OFFSET DOASIG	;ASSIGNMENT IS COMPLICATED 
                                				;EVEN FOR NUMERICS SO USE THE "LET" CODE 
 0F34  51                       	PUSH	CX		;SAVE ON STACK 
 0F35  73 03                    	JAE	SHORT ??L080 
 0F37  E9 0000 E                	JMP	FIN		;IF NOT DOUBLE, CALL USUAL # INPUTTER 
 0F3A                           ??L080: 
 0F3A  E9 0000 E                	JMP	FINDBL		;ELSE CALL SPECIAL ROUTINE WHICH EXPECTS DOUBLES 
 0F3D                           STRDN2: 
 0F3D  4B                       	DEC	BX 
 0F3E  E8 083A R                	CALL	CHRGTR 
 0F41  74 07                    	JZ	SHORT TRMOK 
 0F43  3C 2C                    	CMP	AL,LOW 44 
 0F45  74 03                    	JZ	SHORT ??L081 
 0F47  E9 0D8E R                	JMP	TRMNOK		;ENDED PROPERLY? 
 0F4A                           ??L081: 
 0F4A                           TRMOK: 
 0F4A  5E                       	POP	SI		;XTHL 
 0F4B  87 F3                    	XCHG	SI,BX 
 0F4D  56                       	PUSH	SI 
 0F4E  4B                       	DEC	BX		;LOOK AT TERMINATOR 
 0F4F  E8 083A R                	CALL	CHRGTR		;AND SET UP CONDITION CODES 
 0F52  74 03                    	JZ	SHORT ??L082 
 0F54  E9 0EC2 R                	JMP	LOPDT2		;NOT ENDING, CHECK FOR COMMA 
 0F57                           ??L082: 
                                				;AND GET ANOTHER VARIABLE 
                                				;TO FILL WITH DATA 
                                 
 0F57  5A                       	POP	DX		;POP OFF THE POINTER INTO DATA 
 0F58  A0 0000 E                	MOV	AL,BYTE PTR FLGINP	;FETCH THE STATEMENT TYPE FLAG 
 0F5B  0A C0                    	OR	AL,AL		;IF ZERO, INPUT STATEMENT 
 0F5D  87 DA                    	XCHG	BX,DX 
 0F5F  74 03                    	JZ	SHORT ??L083 
 0F61  E9 0000 E                	JMP	RESFIN		;UPDATE DATPTR 
 0F64                           ??L083: 
 0F64  52                       	PUSH	DX		;SAVE THE TEXT POINTER 
 0F65  5B                       FINPRG: POP	BX		;GET BACK THE TEXT POINTER 
 0F66  E9 0000 E                	JMP	FINPRT 
                                ; 
                                ; THE SEARCH FOR DATA STATMENTS IS MADE BY USING THE EXECUTION CODE 
                                ; FOR DATA TO SKIP OVER STATEMENTS. THE START WORD OF EACH STATEMENT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-80
LINE INPUT, INPUT AND READ CODE                             

                                ; IS COMPARED WITH $DATA. EACH NEW LINE NUMBER 
                                ; IS STORED IN DATLIN SO THAT IF AN ERROR OCCURS WHILE READING 
                                ; DATA THE ERROR MESSAGE WILL GIVE THE LINE NUMBER OF THE 
                                ; ILL-FORMATTED DATA 
                                ; 
 0F69  E8 0ACF R                DATLOP: CALL	DATA 
 0F6C  0A C0                    DATFND: OR	AL,AL 
 0F6E  75 15                    	JNZ	SHORT NOWLIN 
 0F70  43                       	INC	BX 
 0F71  8A 07                    	MOV	AL,BYTE PTR [BX] 
 0F73  43                       	INC	BX 
 0F74  0A 07                    	OR	AL,BYTE PTR [BX]	;IFE XERPAG 
 0F76  B2 00 E                  	MOV	DL,LOW OFFSET ERROD	;NO DATA IS ERROR ERROD 
 0F78  75 03                    	JNZ	SHORT ??L084 
 0F7A  E9 00AE R                	JMP	ERROR		;IF SO COMPLAIN 
 0F7D                           ??L084: 
 0F7D  43                       	INC	BX		;SKIP PAST LINE # 
 0F7E  8B 17                    	MOV	DX,[BX]	;GET DATA LINE # 
 0F80  43                       	INC	BX 
 0F81  89 16 0000 E             	MOV	DATLIN,DX	;SAVE DATA LINE NUMBER 
 0F85  E8 083A R                NOWLIN: CALL	CHRGTR		;GET THE STATEMENT TYPE 
 0F88  3C 00 E                  	CMP	AL,LOW OFFSET $DATA	;IS IS "DATA"? 
 0F8A  75 DD                    	JNZ	SHORT DATLOP	;NOT DATA SO LOOK SOME MORE 
 0F8C  E9 0EDE R                	JMP	DATBK		;CONTINUE READING 
                                 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-81
LINE INPUT, INPUT AND READ CODE                             

                                	PAGE 
                                 
                                	SUBTTL PEEK AND POKE 
                                ; 
                                ; NOTE: IN THE 8K PEEK ONLY ACCEPTS POSITIVE NUMBERS UP TO 32767 
                                ; POKE WILL ONLY TAKE AN ADDRESS UP TO 32767 , NO 
                                ; FUDGING ALLOWED. THE VALUE IS UNSIGNED. 
                                ; IN THE EXTENDED VERSION NEGATIVE NUMBERS CAN BE 
                                ; USED TO REFER TO LOCATIONS HIGHER THAN 32767. 
                                ; THE CORRESPONDENCE IS GIVEN BY SUBTRACTING 65536 FROM LOCATIONS 
                                ; HIGHER THAN 32767 OR BY SPECIFYING A POSITIVE NUMBER UP TO 65535. 
                                ; 
 0F8F  E8 0FD5 R                PEEK:	CALL	FRQINT		;GET AN INTEGER IN [H,L] 
                                	EXTRN	PRODIR:NEAR 
 0F92  E8 0000 E                	CALL	PRODIR		;DONT ALLOW DIRECT IF PROTECTED FILE 
                                	EXTRN	PEKFLT:NEAR	;PEEK filter 
                                	INS86	6		;PUSH   ES 
                                	INS86	216,6,SAVSEG	;MOV    ES,SAVSEG 
 0F9A  E8 0000 E                	CALL	PEKFLT		;Filter the PEEK 
 0F9D  75 03                    	JNZ	SHORT ??L085 
 0F9F  EB 04 90                 	JMP	PEKVAL		;Filter returned the appropriate value 
 0FA2                           ??L085: 
                                	INS86	46		;$ES 
 0FA3  8A 07                    	MOV	AL,BYTE PTR [BX]	;Fetch the PEEK value 
 0FA5                           PEKVAL: INS86	7		;POP    ES 
 0FA6  E9 0000 E                	JMP	SNGFLT		;AND FLOAT IT 
 0FA9  E8 0FCA R                POKE:	CALL	FRMQNT		;READ INTEGER FORMULA INTO [D,E] 
 0FAC  52                       	PUSH	DX		;SAVE VALUE FOR LATER 
 0FAD  E8 0000 E                	CALL	PRODIR		;DONT ALLOW DIRECT IF PROTECTED FILE 
 0FB0  E8 0000 E                	CALL	SYNCHR 
 0FB3  2C                       	DB	OFFSET 44	;CHECK FOR A COMMA 
 0FB4  E8 0000 E                	CALL	GETBYT 
 0FB7  5A                       	POP	DX		;GET THE ADDRESS BACK 
                                	INS86	6		;PUSH ES 
                                	INS86	216,6,SAVSEG	;MOV  ES,SAVSEG 
                                	EXTRN	POKFLT:NEAR 
 0FBD  E8 0000 E                	CALL	POKFLT		;Filter POKEs for "special" addresses 
 0FC0  75 03                    	JNZ	SHORT ??L086 
 0FC2  EB 04 90                 	JMP	POKEX		;Do not perform the POKE 
 0FC5                           ??L086: 
 0FC5  8B FA                    	MOV	DI,DX 
 0FC7  AA                       	STOSB			;STORE IT AWAY 
 0FC8                           POKEX: 
                                	INS86	7		;POP  ES 
 0FC9  C3                       	RET			;SCANNED EVERYTHING 
                                PUBLIC	FRMQNT 
 0FCA  E8 0000 E                FRMQNT: CALL	FRMEVL		;READ FORMULA 
 0FCD  53                       	PUSH	BX		;SAVE TEXT POINTER 
 0FCE  E8 0FD5 R                	CALL	FRQINT		;GET VALUE IN RANGE -32769-65535 
 0FD1  87 DA                    	XCHG	BX,DX		;VALUE TO [D,E] 
 0FD3  5B                       	POP	BX		;RESTORE TEXT POINTER 
 0FD4  C3                       	RET 
                                 
                                PUBLIC	FRQINT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-82
PEEK AND POKE                                               

 0FD5  B9 0000 E                FRQINT: MOV	CX,OFFSET FRCINT	;RETURN HERE 
 0FD8  51                       	PUSH	CX		;SAVE ADDR 
 0FD9  E8 0000 E                	CALL	GETYPR		;SET THE CC'S ON VALTYPE 
 0FDC  79 01                    	JNS	SHORT $+3 
 0FDE  C3                       	RET			;RETURN IF ALREADY INTEGER. 
 0FDF  A0 0000 E                	MOV	AL,BYTE PTR FAC ;GET EXPONENT 
 0FE2  3C 90                    	CMP	AL,LOW 220O	;IS MAGNITUDE .GT. 32767 
 0FE4  74 01                    	JZ	SHORT $+3 
 0FE6  C3                       	RET			;NO, FORCE INTEGER 
 0FE7  E8 0000 E                	CALL	SIGN		;GET SIGN OF NUMBER 
                                				;IS IT NEGATIVE, ONLY ALLOWABLE # IS -32768 
 0FEA  79 01                    	JNS	SHORT $+3 
 0FEC  C3                       	RET			;ASSUME THATS WHAT IT IS, ELSE GIVE OVERFLOW 
 0FED  E8 0000 E                	CALL	FRCSNG		;MAKE NUMBER A SINGLE 
                                	MOVRI	221O,200O,0,0	;GET -65536. 
 0FF6  E9 0000 E                	JMP	FADD		;SUBTRACT IT, AND THEN FORCE INTEGER 
                                 
                                ;PAGE 
                                	SUBTTL RENUMBER 
                                ; THE RESEQ(UENCE) COMMAND TAKE UP TO THREE ARGUMENTS 
                                ; RESEQ [NN[,MM[,INC]]] 
                                ; WHERE NN IS THE FIRST DESTINATION LINE OF THE 
                                ; LINES BEING RESEQUENCED, LINES LESS THAN MM ARE 
                                ; NOT RESEQUENCED, AND INC IS THE INCREMENT. 
 0FF9                           RESEQ: 
 0FF9  B9 000A                  	MOV	CX,10		;ASSUME INC=10 
 0FFC  51                       	PUSH	CX		;SAVE ON STACK 
 0FFD  8A F5                    	MOV	DH,CH		;RESEQ ALL LINES BY SETTING [D,E]=0 
 0FFF  8A D5                    	MOV	DL,CH 
 1001  74 35                    	JZ	SHORT RESNN	;IF JUST 'RESEQ' RESEQ 10 BY 10 
 1003  3C 2C                    	CMP	AL,LOW 54O	;COMMA 
 1005  74 0B                    	JZ	SHORT EATCOM	;DONT USE STARTING # OF ZERO 
 1007  52                       	PUSH	DX		;SAVE [D,E] 
 1008  E8 0981 R                	CALL	LINSPC		;GET NEW NN 
 100B  8A EE                    	MOV	CH,DH		;GET IN IN [B,C] WHERE IT BELONGS 
 100D  8A CA                    	MOV	CL,DL 
 100F  5A                       	POP	DX		;GET BACK [D,E] 
 1010  74 26                    	JZ	SHORT RESNN	;IF EOS, DONE 
 1012  E8 0000 E                EATCOM: CALL	SYNCHR 
 1015  2C                       	DB	OFFSET 54O	;EXPECT COMMA 
 1016  E8 0981 R                	CALL	LINSPC		;GET NEW MM 
 1019  74 1D                    	JZ	SHORT RESNN	;IF EOS, DONE 
 101B  58                       	POP	AX		;GET RID OF OLD INC 
 101C  E8 0000 E                	CALL	SYNCHR 
 101F  2C                       	DB	OFFSET 54O	;EXPECT COMMA 
 1020  52                       	PUSH	DX		;SAVE MM 
 1021  E8 098E R                	CALL	LINGET		;GET NEW INC 
 1024  74 03                    	JZ	SHORT ??L087 
 1026  E9 0094 R                	JMP	SNERR		;SHOULD HAVE TERMINATED. 
 1029                           ??L087: 
 1029  0B D2                    	OR	DX,DX		;SEE IF INC=0 (ILLEGAL) 
 102B  75 03                    	JNZ	SHORT ??L088 
 102D  E9 097C R                	JMP	FCERR		;YES, BLOW HIM UP NOW 
 1030                           ??L088: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-83
RENUMBER                                                    

 1030  87 DA                    	XCHG	BX,DX		;FLIP NEW INC & [H,L] 
 1032  5E                       	POP	SI		;XTHL 
 1033  87 F3                    	XCHG	SI,BX 
 1035  56                       	PUSH	SI		;NEW INC ONTO STACK 
 1036  87 DA                    	XCHG	BX,DX		;GET [H,L] BACK, ORIG [D,E] BACK 
 1038  51                       RESNN:	PUSH	CX		;SAVE NN ON STACK 
 1039  E8 036F R                	CALL	FNDLIN		;FIND MM LINE 
 103C  5A                       	POP	DX		;GET NN OFF STACK 
 103D  52                       	PUSH	DX		;SAVE NN BACK 
 103E  51                       	PUSH	CX		;SAVE POINTER TO MM LINE 
 103F  E8 036F R                	CALL	FNDLIN		;FIND FIRST LINE TO RESEQ. 
 1042  8B D9                    	MOV	BX,CX		;GET PTR TO THIS LINE IN [H,L] 
 1044  5A                       	POP	DX		;GET LINE PTD TO BY MM 
 1045  3B DA                    	CMP	BX,DX		;COMPARE TO FIRST LINE RESEQED 
 1047  87 DA                    	XCHG	BX,DX		;GET PTR TO MM LINE IN [H,L] 
 1049  73 03                    	JAE	SHORT ??L089 
 104B  E9 097C R                	JMP	FCERR		;CANT ALLOW PROGRAM TO BE RESEQUED 
 104E                           ??L089: 
                                				;ON TOP OF ITSELF 
 104E  5A                       	POP	DX		;GET NN BACK 
 104F  59                       	POP	CX		;GET INC IN [B,C] 
 1050  58                       	POP	AX		;GET RID OF NEWSTT 
 1051  53                       	PUSH	BX		;SAVE PTR TO FIRST LINE TO RESEQ. 
 1052  52                       	PUSH	DX		;SAVE NN ON STACK 
 1053  EB 15                    	JMP	SHORT NXTRSL 
 1055  03 D9                    NXTRSC: ADD	BX,CX		;ADD INCREMENT INTO 
 1057  73 03                    	JAE	SHORT ??L090 
 1059  E9 097C R                	JMP	FCERR		;UH OH, HIS INC WAS TOO LARGE. 
 105C                           ??L090: 
 105C  87 DA                    	XCHG	BX,DX		;FLIP LINK FIELD, ACCUM. 
 105E  53                       	PUSH	BX		;SAVE LINK FIELD 
 105F  BB FFF9                  	MOV	BX,65529	;TEST FOR TOO LARGE LINE 
 1062  3B DA                    	CMP	BX,DX		;COMPARE TO CURRENT # 
 1064  5B                       	POP	BX		;RESTORE LINK FIELD 
 1065  73 03                    	JAE	SHORT ??L091 
 1067  E9 097C R                	JMP	FCERR		;UH OH, HIS INC WAS TOO LARGE. 
 106A                           ??L091: 
 106A  52                       NXTRSL: PUSH	DX		;SAVE CURRENT LINE ACCUM 
 106B  8B 17                    	MOV	DX,[BX]	;GET LINK FIELD INTO [D,E] 
 106D  0B D2                    	OR	DX,DX		;SET CC'S ON LINK FIELD 
 106F  87 DA                    	XCHG	BX,DX		;SEE IF NEXT LINK ZERO 
 1071  5A                       	POP	DX		;GET BACK ACCUM LINE # 
 1072  74 0C                    	JZ	SHORT RESSD1	;ZERO, DONE 
 1074  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET FIRST BYTE OF LINK 
 1076  43                       	INC	BX		;INC POINTER 
 1077  0A 07                    	OR	AL,BYTE PTR [BX]	;SET CC'S 
 1079  9F                       	LAHF 
 107A  4B                       	DEC	BX		;MOVE POINTER BACK 
 107B  9E                       	SAHF 
 107C  87 DA                    	XCHG	BX,DX		;BACK IN [D,E] 
 107E  75 D5                    	JNZ	SHORT NXTRSC	;INC COUNT 
                                 
 1080  51                       RESSD1: PUSH	CX		;SAVE INC 
 1081  E8 10A8 R                	CALL	SCCLIN		;SCAN PROGRAM CONVERTING LINES TO PTRS. 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-84
RENUMBER                                                    

 1084  59                       	POP	CX		;GET BACK INC 
 1085  5A                       	POP	DX		;GET NN 
 1086  5B                       	POP	BX		;GET PTR TO FIRST LINE TO RESEQ 
                                 
 1087  52                       RESNX1: PUSH	DX		;SAVE CURRENT LINE 
 1088  8B 17                    	MOV	DX,[BX]	;PREPARE FOR ZERO LINK FIELD TEST 
 108A  43                       	INC	BX 
 108B  0B D2                    	OR	DX,DX		;END? 
 108D  74 14                    	JZ	SHORT SCCALL	;STOP RESEQING WHEN SEE END OF PGM 
 108F  87 DA                    	XCHG	BX,DX		;FLIP LINE PTR, LINK FIELD 
 1091  5E                       	POP	SI		;XTHL 
 1092  87 F3                    	XCHG	SI,BX 
 1094  56                       	PUSH	SI		;PUT LINK ON STACK, GET NEW LINE # OFF 
 1095  87 DA                    	XCHG	BX,DX		;PUT NEW LINE # IN [D,E], THIS LINE 
                                				;PTR IN [H,L] 
 1097  43                       	INC	BX		;POINT TO LINE # FIELD. 
 1098  89 17                    	MOV	[BX],DX	;CHANGE TO NEW LINE # 
 109A  87 DA                    	XCHG	BX,DX		;GET THIS LINE # IN [H,L] 
 109C  03 D9                    	ADD	BX,CX		;ADD INC 
 109E  87 DA                    	XCHG	BX,DX		;GET NEW LINE # BACK IN [D,E] 
 10A0  5B                       	POP	BX		;GET PTR TO NEXT LINE 
 10A1  EB E4                    	JMP	SHORT RESNX1	;KEEP RESEQING 
 10A3  B9 0193 R                SCCALL: MOV	CX,OFFSET STPRDY	;WHERE TO GO WHEN DONE 
 10A6  51                       	PUSH	CX		;SAVE ON STACK 
 10A7  3C                       	DB	74O	; SKIP  ;"CPI AL," CALL SCCPTR 
                                ; THE SUBROUTINES SCCLIN AND SCCPTR CONVERT ALL 
                                ; LINE #'S TO POINTERS AND VICE-VERSA. 
                                ; THE ONLY SPECIAL CASE IS "ON ERROR GOTO 0" WHERE THE "0" 
                                ; IS LEFT AS A LINE NUMBER TOKEN SO IT WONT BE CHANGED BY RESEQUENCE. 
 10A8  0D                       SCCLIN: DB	15O	; SKIP  ;"ORI AX," OVER NEXT BYTE 
                                PUBLIC	SCCPTR 
 10A9  32 C0                    SCCPTR: XOR	AL,AL		;SET A=0 
 10AB  A2 0000 E                	MOV	BYTE PTR PTRFLG,AL	;SET TO SAY WHETER LINES OR PTRS EXTANT 
 10AE  8B 1E 0000 E             SCNPGM: MOV	BX,TXTTAB	;GET PTR TO START OF PGM 
 10B2  4B                       	DEC	BX		;NOP NEXT INX. 
 10B3  43                       SCNPLN: INC	BX		;POINT TO BYTE AFTER ZERO AT END OF LINE 
 10B4  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET LINK FIELD INTO [D,E] 
 10B6  43                       	INC	BX		;BUMP PTR 
 10B7  0A 07                    	OR	AL,BYTE PTR [BX]	;SET CC'S 
 10B9  75 01                    	JNZ	SHORT $+3 
 10BB  C3                       	RET			;RETURN IF ALL DONE. 
 10BC  43                       	INC	BX		;POINT PAST LINE # 
 10BD  8B 17                    	MOV	DX,[BX]	;GET LOW BYTE OF LINE # 
 10BF  43                       	INC	BX 
                                PUBLIC	SCNEXT 
 10C0  E8 083A R                SCNEXT: CALL	CHRGTR		;GET NEXT CHAR FROM LINE 
 10C3  0A C0                    SCNEX2: OR	AL,AL		;END OF LINE 
 10C5  74 EC                    	JZ	SHORT SCNPLN	;SCAN NEXT LINE 
 10C7  8A C8                    	MOV	CL,AL		;SAVE [A] 
 10C9  A0 0000 E                	MOV	AL,BYTE PTR PTRFLG	;CHANGE LINE TOKENS WHICH WAY? 
 10CC  0A C0                    	OR	AL,AL		;SET CC'S 
 10CE  8A C1                    	MOV	AL,CL		;GET BACK CURRENT CHAR 
 10D0  74 59                    	JZ	SHORT SCNPT2	;CHANGING POINTERS TO #'S 
 10D2  3C 00 E                  	CMP	AL,LOW OFFSET $ERROR	;IS IT ERROR TOKEN? 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-85
RENUMBER                                                    

 10D4  75 18                    	JNZ	SHORT NTERRG	;NO. 
 10D6  E8 083A R                	CALL	CHRGTR		;SCAN NEXT CHAR 
 10D9  3C 00 E                  	CMP	AL,LOW OFFSET $GOTO	;ERROR GOTO? 
 10DB  75 E6                    	JNZ	SHORT SCNEX2	;GET NEXT ONE 
 10DD  E8 083A R                	CALL	CHRGTR		;GET NEXT CHAR 
 10E0  3C 0E                    	CMP	AL,LOW OFFSET LINCON	;LINE # CONSTANT? 
 10E2  75 DF                    	JNZ	SHORT SCNEX2	;NO, IGNORE. 
 10E4  52                       	PUSH	DX		;SAVE [D,E] 
 10E5  E8 0998 R                	CALL	LINGT3		;GET IT 
 10E8  0B D2                    	OR	DX,DX		;IS IT LINE # ZERO? 
 10EA  75 0A                    	JNZ	SHORT CHGPTR	;CHANGE IT TO A POINTER 
 10EC  EB 29                    	JMP	SHORT SCNEX3	;YES, DONT CHANGE IT 
 10EE  3C 0E                    NTERRG: CMP	AL,LOW OFFSET LINCON	;LINE # CONSTANT? 
 10F0  75 CE                    	JNZ	SHORT SCNEXT	;NOT, KEEP SCANNING 
 10F2  52                       	PUSH	DX		;SAVE CURRENT LINE # FOR POSSIBLE ERROR MSG 
 10F3  E8 0998 R                	CALL	LINGT3		;GET LINE # OF LINE CONSTANT INTO [D,E] 
 10F6                           CHGPTR: 
 10F6  53                       	PUSH	BX		;SAVE TEXT POINTER JUST AT END OF LINCON 3 BYTES 
 10F7  E8 036F R                	CALL	FNDLIN		;TRY TO FIND LINE IN PGM. 
 10FA  9F                       	LAHF 
 10FB  49                       	DEC	CX		;POINT TO ZERO AT END OF PREVIOUS LINE 
 10FC  9E                       	SAHF 
 10FD  B0 0D                    	MOV	AL,LOW OFFSET PTRCON	;CHANGE LINE # TO PTR 
 10FF  72 3F                    	JB	SHORT MAKPTR	;IF LINE FOUND CHANGE # TO PTR 
 1101  E8 0000 E                	CALL	CRDONZ		;PRINT CRLF IF REQUIRED 
 1104  BB 111B R                	MOV	BX,OFFSET LINM	;PRINT "UNDEFINED LINE" MESSAGE 
 1107  52                       	PUSH	DX		;SAVE LINE # 
 1108  E8 0000 E                	CALL	STROUT		;PRINT IT 
 110B  5B                       	POP	BX		;GET LINE # IN [H,L] 
 110C  E8 0000 E                	CALL	LINPRT		;PRINT IT 
 110F  59                       	POP	CX		;GET TEXT PTR OFF STACK 
 1110  5B                       	POP	BX		;GET CURRENT LINE # 
 1111  53                       	PUSH	BX		;SAVE BACK 
 1112  51                       	PUSH	CX		;SAVE BACK TEXT PTR 
 1113  E8 0000 E                	CALL	INPRT		;PRINT IT 
 1116  5B                       SCNPOP: POP	BX		;POP OFF CURRENT TEXT POINTER 
 1117  5A                       SCNEX3: POP	DX		;GET BACK CURRENT LINE # 
 1118  4B                       	DEC	BX		;BACKUP POINTER 
 1119  EB A5                    JSCNXT: JMP	SHORT SCNEXT	;KEEP SCANNING 
                                 
 111B  55 6E 64 65 66 69 6E     LINM:	DB"Undefined line " 
       65 64 20 6C 69 6E 65     
       20                       
 112A  00                       	DB	0 
                                 
 112B  3C 0D                    SCNPT2: CMP	AL,LOW OFFSET PTRCON	;POINTER 
 112D  75 EA                    	JNZ	SHORT JSCNXT	;NO, KEEP SCANNING 
 112F  52                       	PUSH	DX		;SAVE CURRENT LINE # 
 1130  E8 0998 R                	CALL	LINGT3		;GET # 
 1133  53                       	PUSH	BX		;SAVE TEXT POINTER 
 1134  87 DA                    	XCHG	BX,DX		;FLIP CURRENT TEXT PTR & PTR 
 1136  43                       	INC	BX		;BUMP POINTER 
 1137  43                       	INC	BX		;POINT TO LINE # FIELD 
 1138  43                       	INC	BX 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-86
RENUMBER                                                    

 1139  8A 0F                    	MOV	CL,BYTE PTR [BX]	;PICK UP LINE # 
 113B  43                       	INC	BX		;POINT TO HIGH PART 
 113C  8A 2F                    	MOV	CH,BYTE PTR [BX] 
 113E  B0 0E                    	MOV	AL,LOW OFFSET LINCON	;CHANGE TO LINE CONSTANT 
 1140  BB 1116 R                MAKPTR: MOV	BX,OFFSET SCNPOP	;PLACE TO RETURN TO AFTER CHANGING CONSTANT 
 1143  53                       	PUSH	BX		;SAVE ON STACK 
 1144  8B 1E 0000 E             CONCHG: MOV	BX,CONTXT	;GET TXT PTR AFTER CONSTANT IN [H,L] 
 1148  53                       CONCH2: PUSH	BX		;SAVE PTR TO END OF CONSTANT 
 1149  4B                       	DEC	BX 
 114A  88 2F                    	MOV	BYTE PTR [BX],CH 
 114C  4B                       	DEC	BX 
 114D  88 0F                    	MOV	BYTE PTR [BX],CL	;CHANGE TO VALUE IN [B,C] 
 114F  4B                       	DEC	BX		;POINT TO CONSTANT TOKEN 
 1150  88 07                    	MOV	BYTE PTR [BX],AL	;CHANGE TO VALUE IN [A] 
 1152  5B                       	POP	BX		;RESTORE POINTER TO AFTER CONSTANT 
 1153  C3                       	RET 
                                 
                                PUBLIC	DEPTR 
 1154  A0 0000 E                DEPTR:	MOV	AL,BYTE PTR PTRFLG	;DO LINE POINTERS EXIST IN PGM? 
 1157  0A C0                    	OR	AL,AL		;SET CC'S 
 1159  75 01                    	JNZ	SHORT $+3 
 115B  C3                       	RET			;NO, JUST RETURN 
 115C  E9 10A9 R                	JMP	SCCPTR		;CONVERT THEN TO LINE #'S 
                                 
                                 
                                 
                                 
                                	SUBTTL ANSI - THE ROUTINES TO HANDLE ANSI FEATURES 
 = 0ACF                         	DATAS=DATA 
 115F  E8 0000 E                OPTION: CALL	SYNCHR 
 1162  42                       	DB	OFFSET "B" 
 1163  E8 0000 E                	CALL	SYNCHR 
 1166  41                       	DB	OFFSET "A" 
 1167  E8 0000 E                	CALL	SYNCHR 
 116A  53                       	DB	OFFSET "S" 
 116B  E8 0000 E                	CALL	SYNCHR 
 116E  45                       	DB	OFFSET "E" 
 116F  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET THE BASE NUMBER 
 1171  2C 30                    	SUB	AL,LOW "0" 
 1173  73 03                    	JAE	SHORT ??L092 
 1175  E9 0094 R                	JMP	SNERR 
 1178                           ??L092: 
 1178  3C 02                    	CMP	AL,LOW 2	;ONLY 0 AND 1 ARE LEGAL 
 117A  72 03                    	JNAE	SHORT ??L093 
 117C  E9 0094 R                	JMP	SNERR 
 117F                           ??L093: 
 117F  8A E8                    	MOV	CH,AL 
 1181  A0 0000 E                	MOV	AL,BYTE PTR OPTVAL 
 1184  3A C5                    	CMP	AL,CH 
 1186  74 27                    	JZ	SHORT OLDOPT	;BRIF OLD OPTION BASE VALUE 
 1188  A0 0000 E                	MOV	AL,BYTE PTR OPTFLG 
 118B  0A C0                    	OR	AL,AL		;HAVE WE SEEN OPTION BASE BEFORE 
 118D  74 03                    	JZ	SHORT ??L094 
 118F  E9 009D R                	JMP	DDERR		;IF SO "DOUBLE DIMENSION ERROR" 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-87
ANSI - THE ROUTINES TO HANDLE ANSI FEATURES                 

 1192                           ??L094: 
 1192  53                       	PUSH	BX		;SAVE THE TEXT POINTER 
 1193  8B 1E 0000 E             	MOV	BX,ARYTAB	;SEE IF WE HAVE ANY ARRAYS YET 
 1197  87 DA                    	XCHG	BX,DX 
 1199  8B 1E 0000 E             	MOV	BX,STREND 
 119D  3B DA                    	CMP	BX,DX		;IF THESE ARE EQUAL WE HAVE NOT 
 119F  74 03                    	JZ	SHORT ??L095 
 11A1  E9 009D R                	JMP	DDERR 
 11A4                           ??L095: 
 11A4  5B                       	POP	BX 
 11A5  8A C5                    	MOV	AL,CH 
 11A7  A2 0000 E                	MOV	BYTE PTR OPTVAL,AL	;SAVE IF FOR DIM AND PTRGET 
 11AA  FE C0                    	INC	AL		;MAKE SURE [A] IS NON ZERO 
 11AC  A2 0000 E                	MOV	BYTE PTR OPTFLG,AL	;FLAG THAT WE HAVE SEEN "OPTION BASE" 
 11AF  E8 083A R                OLDOPT: CALL	CHRGTR		;FETCH THE TERMINATOR 
 11B2  C3                       	RET 
                                 
                                ; THIS ROUTINE IS CALLED BY THE MATH PACKAGE 
                                ; TO PRINT ERROR MESSAGES WITHOUT DISTURBING PTRFIL, ETC. 
                                PUBLIC	$STPRN 
 11B3                           $STPRN: 
 11B3                           STRPRN: 
                                	INS86	56		;FETCH FROM CODE SEGMENT 
 11B4  8A 07                    STRPN1: MOV	AL,BYTE PTR [BX]	;GET BYTE FROM MESSAGE 
 11B6  0A C0                    	OR	AL,AL		;END OF MESSAGE 
 11B8  75 01                    	JNZ	SHORT $+3 
 11BA  C3                       	RET			;YES, DONE 
 11BB  E8 0000 E                	CALL	CALTTY		;PRINT CHAR 
 11BE  43                       	INC	BX		;INCREMENT POINTER 
 11BF  EB F2                    	JMP	STRPRN		;PRINT NEXT CHAR 
                                	EXTRN	CALTTY:NEAR,$CATTY:NEAR 
 11C1  74 09                    RANDOM: JZ	SHORT INPRG	;IF NO ARGUMENT ASK FROM TERMINAL 
 11C3  E8 0000 E                	CALL	FRMEVL		;FETCH THE FORMULA ARGUMENT 
 11C6  53                       	PUSH	BX 
 11C7  E8 0000 E                	CALL	FRCINT		;ALLOW NORMAL INTEGERS 
 11CA  EB 20                    	JMP	SHORT STRNDS	;STORE THE NEW RANDOM SEED 
 11CC  53                       INPRG:	PUSH	BX 
 11CD                           INPRAG: 
 11CD  BB 11F5 R                	MOV	BX,OFFSET RANMES	;ASK FOR SOME RANDOM INPUT 
 11D0  E8 0000 E                	CALL	STROUT 
 11D3  E8 0000 E                	CALL	QINLIN 
 11D6  5A                       	POP	DX		;get back text pointer 
 11D7  73 03                    	JAE	SHORT ??L096 
 11D9  E9 0000 E                	JMP	STPEND		;go away if control c 
 11DC                           ??L096: 
 11DC  52                       	PUSH	DX		;resave text pointer 
 11DD  43                       	INC	BX		;MOVE PAST BUFMIN TO BUF 
 11DE  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET FIRST CHAR OF TYPEIN (FIN EXPECTS IT) 
 11E0  E8 0000 E                	CALL	FIN		;READ A NUMBER 
 11E3  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET THE TERMINATOR 
 11E5  0A C0                    	OR	AL,AL 
 11E7  75 E4                    	JNZ	SHORT INPRAG	;DON'T ALLOW BAD FORMAT 
 11E9  E8 0000 E                	CALL	FRCINT		;ALLOW NORMAL INTEGERS 
 11EC                           STRNDS: 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-88
ANSI - THE ROUTINES TO HANDLE ANSI FEATURES                 

 11EC  89 1E 0001 E             	MOV	RNDX+1,BX 
                                	EXTRN	RNDMN2:NEAR 
 11F0  E8 0000 E                	CALL	RNDMN2 
 11F3  5B                       	POP	BX		;GET BACK THE TEXT POINTER 
 11F4  C3                       	RET 
 11F5  52 61 6E 64 6F 6D 20     RANMES: DB"Random number seed (-32768 to 32767)" 
       6E 75 6D 62 65 72 20     
       73 65 65 64 20 28 2D     
       33 32 37 36 38 20 74     
       6F 20 33 32 37 36 37     
       29                       
 1219  00                       	DB	0 
                                 
                                ; 
                                ; THIS CODE SCANS AHEAD TO FIND THE "NEXT" THAT MATCHES A "FOR" 
                                ; IN ORDER TO 1) HANDLE EMPTY LOOPS AND 2) MAKE SURE LOOPS 
                                ; MATCH UP PROPERLY. 
                                ; 
                                PUBLIC	WNDSCN 
 121A  B1 00 E                  WNDSCN: MOV	CL,LOW OFFSET ERRWH	;SCAN FOR MATCHING WEND THIS IS ERROR IF FAIL 
 121C  EB 02                    	JMP	SHORT SCNCNT 
 121E  B1 00 E                  NXTSCN: MOV	CL,LOW OFFSET ERRFN 
 1220                           SCNCNT: 
 1220  B5 00                    	MOV	CH,LOW 0	;SET UP THE COUNT OF "FOR"S SEEN 
 1222  87 DA                    	XCHG	BX,DX		;INITIALIZE NXTLIN FOR NEXT ON SAME LINE 
 1224  8B 1E 0000 E             	MOV	BX,CURLIN 
 1228  89 1E 0000 E             	MOV	NXTLIN,BX 
 122C  87 DA                    	XCHG	BX,DX		;RESTORE THE TEXT POINTER TO [H,L] 
 122E  FE C5                    FORINC: INC	CH		;INCREMENT THE COUNT WHENEVER "FOR" IS SEEN 
 1230  4B                       FNLOP:	DEC	BX		;** FIX HERE FOR 5.03 CAN'T CALL DATA 
 1231  E8 083A R                SCANWF: CALL	CHRGTR		;TO SKIP TO STATEMENT BECAUSE COULD 
 1234  74 17                    	JZ	SHORT FORTRM	;HAVE STATEMENT AFTER "THEN" 
 1236  3C 22                    	CMP	AL,LOW 34D	;CHECK FOR QUOTE WHICH MAY HAVE 
 1238  75 0B                    	JNZ	SHORT NTQTSC	;EIGHT BIT LITERAL DATA SAME AS $THEN 
                                				;OR $WHILE OR $WEND OR $FOR OR $NEXT 
 123A  E8 083A R                QTLOPF: CALL	CHRGTR		;IN IT. SCAN THROUGH STRING. 
 123D  0A C0                    	OR	AL,AL 
 123F  74 0C                    	JZ	SHORT FORTRM	;TERMINATE ONLY ON ZERO NOT COLON 
 1241  3C 22                    	CMP	AL,LOW 34D 
 1243  75 F5                    	JNZ	SHORT QTLOPF 
 1245                           NTQTSC: 
 1245  3C 00 E                  	CMP	AL,LOW OFFSET $ELSE	;ELSE STATMENT 
 1247  74 1D                    	JZ	SHORT FNNWST	;THEN ALLOW NEXT OR WEND AFTER IT 
 1249  3C 00 E                  	CMP	AL,LOW OFFSET $THEN	;SO SCAN USING CHRGET WAITING FOR END 
 124B  75 E4                    	JNZ	SHORT SCANWF	;OF STATEMENT OR $THEN 
 124D  0A C0                    FORTRM: OR	AL,AL		;SEE HOW IT ENDED 
 124F  75 15                    	JNZ	SHORT FNNWST	;JUST NEW STATEMENT -- EXAMINE IT 
                                				;OR COULD BE COLON IN STRING BUT NO HARM 
                                				;IN NON KANABS (HGHBIT) VERSION SINCE NO RESERVED 
                                				;WORDS WILL MATCH THE NEXT CHARACTER 
 1251  43                       	INC	BX 
 1252  8A 07                    	MOV	AL,BYTE PTR [BX]	;SCAN THE LINK AT THE START OF THE NEXT LINE 
 1254  43                       	INC	BX 
 1255  0A 07                    	OR	AL,BYTE PTR [BX]	;TO SEE IF ITS ZERO (END OF PROGRAM) 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-89
ANSI - THE ROUTINES TO HANDLE ANSI FEATURES                 

 1257  8A D1                    	MOV	DL,CL		;SET UP ERROR NUMBER 
 1259  75 03                    	JNZ	SHORT ??L097 
 125B  E9 00AE R                	JMP	ERROR 
 125E                           ??L097: 
 125E  43                       	INC	BX		;PICK UP THE NEW LINE NUMBER 
 125F  8B 17                    	MOV	DX,[BX] 
 1261  43                       	INC	BX 
 1262  89 16 0000 E             	MOV	NXTLIN,DX	;SAVE AS "NEXT" LINE NUMBER 
 1266  E8 083A R                FNNWST: CALL	CHRGTR		;GET THE TYPE OF THE NEXT STATEMENT 
 1269  3C 00 E                  	CMP	AL,LOW OFFSET $REM	;REM STATEMENTS SINCE THEY HAVE COLONS 
 126B  75 07                    	JNZ	SHORT NTREMR	;IN THE MIDDLE WHICH MAY BE VIEWED AS 
 126D  51                       	PUSH	CX 
 126E  E8 0AD3 R                	CALL	REM		;STATEMENT TERMINATORS AND THE NEXT CHAR 
 1271  59                       	POP	CX 
 1272  EB D9                    	JMP	SHORT FORTRM	;MIGHT BE AN EIGTH BIT LITERAL THAT 
 1274  3C 00 E                  NTREMR: CMP	AL,LOW OFFSET $DATA	;ACCIDENTALLY MATCHES THE SEARCH 
 1276  75 07                    	JNZ	SHORT NTDATR	;SO WE CALL REM AND DATA TO DO THE SKIPPING 
 1278  51                       	PUSH	CX 
 1279  E8 0ACF R                	CALL	DATA 
 127C  59                       	POP	CX 
 127D  EB CE                    	JMP	SHORT FORTRM 
 127F                           NTDATR: 
 127F  8A C1                    	MOV	AL,CL		;GET THE ERROR NUMBER TO SEE WHAT WE ARE 
 1281  3C 00 E                  	CMP	AL,LOW OFFSET ERRFN	;SCANNING FOR 
 1283  8A 07                    	MOV	AL,BYTE PTR [BX]	;GET BACK THE CHARACTER 
 1285  74 0D                    	JZ	SHORT NXTLOK	;FOR/NEXT SEARCHING 
 1287  3C 00 E                  	CMP	AL,LOW OFFSET $WHILE	;ANOTHER WHILE/WEND NEST? 
 1289  74 A3                    	JZ	SHORT FORINC 
 128B  3C 00 E                  	CMP	AL,LOW OFFSET $WEND 
 128D  75 A1                    	JNZ	SHORT FNLOP 
 128F  FE CD                    	DEC	CH 
 1291  75 9D                    	JNZ	SHORT FNLOP 
 1293  C3                       	RET 
 1294                           NXTLOK: 
 1294  3C 00 E                  	CMP	AL,LOW OFFSET $FOR	;ANOTHER "FOR"? 
 1296  74 96                    	JZ	SHORT FORINC	;INCREMENT THE FOR COUNT 
 1298  3C 00 E                  	CMP	AL,LOW OFFSET $NEXT	;END WITH NEXT? 
 129A  75 94                    	JNZ	SHORT FNLOP	;SKIP OVER THIS STATEMENT 
 129C  FE CD                    DECNXT: DEC	CH		;DECREMENT THE LOOP COUNT 
 129E  75 01                    	JNZ	SHORT $+3 
 12A0  C3                       	RET			;RETURN WITH [H,L] ABOUT TO GET FIRST CHARACTER OF "NEXT" VARIABLE 
                                 
                                ; 
                                ; SCAN  THE VARIABLES LISTED IN A "NEXT" STATEMENT 
                                ; 
 12A1  E8 083A R                	CALL	CHRGTR		;SEE IF THERE IS A NAME 
 12A4  74 A7                    	JZ	SHORT FORTRM	;ONLY ONE SO SCAN MORE STATEMENTS 
 12A6  87 DA                    	XCHG	BX,DX		;SAVE TEXT POINTER IN [D,E] 
 12A8  8B 1E 0000 E             	MOV	BX,CURLIN	;SAVE THE CURRENT LINE NUMBER 
 12AC  53                       	PUSH	BX 
 12AD  8B 1E 0000 E             	MOV	BX,NXTLIN	;MAKE ERROR COME FROM "NEXT" 
 12B1  89 1E 0000 E             	MOV	CURLIN,BX 
 12B5  87 DA                    	XCHG	BX,DX		;[H,L]= TEXT POINTER 
 12B7  51                       	PUSH	CX		;SAVE THE "FOR" COUNT 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-90
ANSI - THE ROUTINES TO HANDLE ANSI FEATURES                 

 12B8  E8 0000 E                	CALL	PTRGET		;SKIP OVER THE VARIABLE NAME 
 12BB  59                       	POP	CX		;GET BACK THE "FOR" COUNT 
 12BC  4B                       	DEC	BX		;CHECK TERMINATOR 
 12BD  E8 083A R                	CALL	CHRGTR 
 12C0  BA 124D R                	MOV	DX,OFFSET FORTRM	;PLACE TO GO TO 
 12C3  74 08                    	JZ	SHORT TRMNXT	;END OF "NEXT" 
 12C5  E8 0000 E                	CALL	SYNCHR 
 12C8  2C                       	DB	OFFSET 44	;SHOULD HAVE COMMAS IN BETWEEN 
 12C9  4B                       	DEC	BX		;RESCAN FIRST CHARACTER 
 12CA  BA 129C R                	MOV	DX,OFFSET DECNXT	;PLACE TO GO BACK TO 
 12CD  5E                       TRMNXT: POP	SI		;XTHL 
 12CE  87 F3                    	XCHG	SI,BX 
 12D0  56                       	PUSH	SI		;SAVE THE TEXT POINTER ON THE STACK 
 12D1  89 1E 0000 E             	MOV	CURLIN,BX 
 12D5  5B                       	POP	BX 
 12D6  52                       	PUSH	DX		;GO OFF TO ADDRESS IN [B,C] 
 12D7  C3                       	RET 
                                ; 
                                ; THIS ROUTINE CLEARS FLGOVC TO RESET TO NORMAL OVERFLOW MODE. 
                                ; IN NORMAL MODE, OVERR ALWAYS PRINTS OVERFLOW BECAUSE FLGOVC=0 
                                ; FUNCTION DISPATCH, FIN (&FINDBL), AND EXPONENTIATION SET UP AN OVERFLOW 
                                ; MODE WHERE FLGOVC=1 AND AFTER ONE OVERFLOW FLGOVC=2 AND NO MORE 
                                ; OVERFLOW MESSAGES ARE PRINTED. FIN (&FINDBL) ALSO STORE FLGOVC IN OVCSTR 
                                ; BEFORE RESETTING FLGOVC SO A CALLER CAN DETECT OVERFLOW OCCURANCE. 
                                ; 
                                PUBLIC	$FLGOC 
 12D8                           $FLGOC: 
                                PUBLIC	FINOVC 
 12D8  9F                       FINOVC: LAHF 
 12D9  50                       	PUSH	AX 
 12DA  A0 0000 E                	MOV	AL,BYTE PTR FLGOVC	;STORE OVERFLOW FLAG TO INDICATE 
 12DD  A2 0000 E                	MOV	BYTE PTR OVCSTR,AL	;WHETHER AN OVERFLOW OCCURED 
 12E0  58                       	POP	AX 
 12E1  9E                       	SAHF 
                                PUBLIC	$CLROV 
 12E2                           $CLROV: 
                                PUBLIC	CLROVC 
 12E2  9F                       CLROVC: LAHF 
 12E3  50                       	PUSH	AX		;SAVE EVERYTHING 
 12E4  32 C0                    	XOR	AL,AL		;NORMAL OVERFLOW MODE 
 12E6  A2 0000 E                	MOV	BYTE PTR FLGOVC,AL 
 12E9  58                       	POP	AX 
 12EA  9E                       	SAHF 
 12EB  C3                       	RET 
                                 
                                 
                                ; 
                                ; The reserve word tables have dispatch address the could be external. 
                                ; ASM86 can only output external declarations during pass 1, so we 
                                ; have to construct a chain of possible externals and check each one. 
                                ; The following macro runs through the chain and declares any undefined 
                                ; addresses as external :NEAR.  For more information, see the file 
                                ; PS1:<BASIC.ASM86>BINTRP.H 
                                ; 
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Page     1-91
ANSI - THE ROUTINES TO HANDLE ANSI FEATURES                 

                                	DO_EXT 
                                ; 
 12EC                           CSEG	ENDS 
                                	END 

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-1
                                                             

Macros:

		N a m e			Lines

?Z0  . . . . . . . . . . . . . .  	   0
ACRLF  . . . . . . . . . . . . .  	   2
ADD_EXT  . . . . . . . . . . . .  	   4
ADR  . . . . . . . . . . . . . .  	   1
CALLOS . . . . . . . . . . . . .  	   4
CHRGET . . . . . . . . . . . . .  	   1
COMPAR . . . . . . . . . . . . .  	   2
DBGBRK . . . . . . . . . . . . .  	   1
DC . . . . . . . . . . . . . . .  	   6
DEF_MAC  . . . . . . . . . . . .  	   9
DERMAK . . . . . . . . . . . . .  	   3
DJNZ . . . . . . . . . . . . . .  	   2
DO_EXT . . . . . . . . . . . . .  	   1
EXPAND_MAC . . . . . . . . . . .  	   1
FSIGN  . . . . . . . . . . . . .  	   1
GETYPE . . . . . . . . . . . . .  	   1
INS86  . . . . . . . . . . . . .  	  13
INST . . . . . . . . . . . . . .  	   1
LDDR . . . . . . . . . . . . . .  	   8
LDIR . . . . . . . . . . . . . .  	   8
MOVRI  . . . . . . . . . . . . .  	   6
OUTCHR . . . . . . . . . . . . .  	   1
POPR . . . . . . . . . . . . . .  	   2
PUSHM  . . . . . . . . . . . . .  	   5
PUSHR  . . . . . . . . . . . . .  	   2
Q  . . . . . . . . . . . . . . .  	  19
QF . . . . . . . . . . . . . . .  	  19
R  . . . . . . . . . . . . . . .  	   6
R2 . . . . . . . . . . . . . . .  	   6
ROFFST . . . . . . . . . . . . .  	   2
SYNCHK . . . . . . . . . . . . .  	   2
T  . . . . . . . . . . . . . . .  	   2
UN_DEF . . . . . . . . . . . . .  	   1

Segments and Groups:

                N a m e         	Size	Align	Combine Class

CSEG . . . . . . . . . . . . . .  	12EC	PARA	PUBLIC	'CODESG'
DSEG . . . . . . . . . . . . . .  	0000	PARA	PUBLIC	'DATASG'

Symbols:            

                N a m e         	Type	Value	Attr         

ALLLST . . . . . . . . . . . . .  	L NEAR	0352	CSEG
ALPCPM . . . . . . . . . . . . .  	Number	0000	
ALPS . . . . . . . . . . . . . .  	Number	0000	
ALPTAB . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ALTAIR . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-2
                                                             

ANSI . . . . . . . . . . . . . .  	Number	0001	
ARYTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ASCBS  . . . . . . . . . . . . .  	Number	0008	
ASCCR  . . . . . . . . . . . . .  	Number	000D	
ASCCTC . . . . . . . . . . . . .  	Number	0003	
ASCCTS . . . . . . . . . . . . .  	Number	0013	
ASCCTZ . . . . . . . . . . . . .  	Number	001A	
ASCESC . . . . . . . . . . . . .  	Number	001B	
ASCLF  . . . . . . . . . . . . .  	Number	000A	
ASCSPC . . . . . . . . . . . . .  	Number	0020	
ASCTAB . . . . . . . . . . . . .  	Number	0009	
AUTELN . . . . . . . . . . . . .  	L NEAR	01DA	CSEG
AUTFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
AUTGOD . . . . . . . . . . . . .  	L NEAR	0262	CSEG
AUTINC . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
AUTLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
AUTO . . . . . . . . . . . . . .  	L NEAR	0CA3	CSEG	Global
AUTRES . . . . . . . . . . . . .  	L NEAR	025D	CSEG

BAKSP  . . . . . . . . . . . . .  	L NEAR	0695	CSEG
BASDEB . . . . . . . . . . . . .  	Number	0000	
BEEPSW . . . . . . . . . . . . .  	Number	0001	
BINCSW . . . . . . . . . . . . .  	Number	0000	
BINFID . . . . . . . . . . . . .  	Number	00FF	
BLODSW . . . . . . . . . . . . .  	Number	0001	
BLTU . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
BSVFID . . . . . . . . . . . . .  	Number	00FD	
BUBL . . . . . . . . . . . . . .  	Number	0000	
BUF  . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
BUFLEN . . . . . . . . . . . . .  	Number	00FF	
BUFMIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
BUFOFS . . . . . . . . . . . . .  	Number	0002	

CALLS  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CALTTY . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CAN8 . . . . . . . . . . . . . .  	Number	0000	
CASSW  . . . . . . . . . . . . .  	Number	0000	
CHEAD  . . . . . . . . . . . . .  	L NEAR	0309	CSEG	Global
CHGPTR . . . . . . . . . . . . .  	L NEAR	10F6	CSEG
CHKINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CHKRES . . . . . . . . . . . . .  	L NEAR	0453	CSEG
CHKSTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CHNFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CHRCON . . . . . . . . . . . . .  	L NEAR	0842	CSEG	Global
CHRGT2 . . . . . . . . . . . . .  	L NEAR	083B	CSEG	Global
CHRGTR . . . . . . . . . . . . .  	L NEAR	083A	CSEG	Global
CHSEAT . . . . . . . . . . . . .  	Number	0001	
CKSNGQ . . . . . . . . . . . . .  	L NEAR	0544	CSEG
CLEARC . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CLMWID . . . . . . . . . . . . .  	Number	000E	
CLROVC . . . . . . . . . . . . .  	L NEAR	12E2	CSEG	Global
CMDERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CMPUTN . . . . . . . . . . . . .  	Number	0000	
CNTOFL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-3
                                                             

COLIS  . . . . . . . . . . . . .  	L NEAR	03EC	CSEG
COMMNT . . . . . . . . . . . . .  	Number	0000	
CONCH2 . . . . . . . . . . . . .  	L NEAR	1148	CSEG
CONCHG . . . . . . . . . . . . .  	L NEAR	1144	CSEG
CONCN2 . . . . . . . . . . . . .  	Number	0010		Global
CONCON . . . . . . . . . . . . .  	Number	001E		Global
CONFAC . . . . . . . . . . . . .  	L NEAR	08A0	CSEG	Global
CONFC1 . . . . . . . . . . . . .  	L NEAR	08DA	CSEG	Global
CONFDB . . . . . . . . . . . . .  	L NEAR	0913	CSEG
CONLO  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CONRUN . . . . . . . . . . . . .  	L NEAR	09E9	CSEG
CONSAV . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CONSCN . . . . . . . . . . . . .  	L NEAR	08A3	CSEG
CONSSW . . . . . . . . . . . . .  	Number	0001	
CONTO  . . . . . . . . . . . . .  	Number	000F	
CONTRO . . . . . . . . . . . . .  	Number	0001	
CONTXT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CONTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
COPNUM . . . . . . . . . . . . .  	L NEAR	0B75	CSEG
CPM  . . . . . . . . . . . . . .  	Number	0001	
CPM110 . . . . . . . . . . . . .  	Number	0000	
CPM2 . . . . . . . . . . . . . .  	Number	0001	
CPM86  . . . . . . . . . . . . .  	Number	0000	
CPMA75 . . . . . . . . . . . . .  	Number	0000	
CPMADD . . . . . . . . . . . . .  	Number	0000	
CPMCON . . . . . . . . . . . . .  	Number	0000	
CPMLIF . . . . . . . . . . . . .  	Number	0000	
CPMMDS . . . . . . . . . . . . .  	Number	0000	
CPMPER . . . . . . . . . . . . .  	Number	0000	
CPMRSH . . . . . . . . . . . . .  	Number	0000	
CPMSBC . . . . . . . . . . . . .  	Number	0000	
CPMSER . . . . . . . . . . . . .  	Number	0000	
CRDO . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CRDONE . . . . . . . . . . . . .  	L NEAR	03A8	CSEG
CRDONZ . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CRONLY . . . . . . . . . . . . .  	Number	0000	
CRUNCH . . . . . . . . . . . . .  	L NEAR	0394	CSEG	Global
CRUNCX . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
CURLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
CZLIN  . . . . . . . . . . . . .  	L NEAR	032E	CSEG
CZLOO2 . . . . . . . . . . . . .  	L NEAR	031A	CSEG
CZLOOP . . . . . . . . . . . . .  	L NEAR	0317	CSEG
C_BUFF . . . . . . . . . . . . .  	Number	001A	
C_CLOS . . . . . . . . . . . . .  	Number	0010	
C_DCIO . . . . . . . . . . . . .  	Number	0006	
C_DELE . . . . . . . . . . . . .  	Number	0013	
C_GDRV . . . . . . . . . . . . .  	Number	0019	
C_MAKE . . . . . . . . . . . . .  	Number	0016	
C_OPEN . . . . . . . . . . . . .  	Number	000F	
C_PARS . . . . . . . . . . . . .  	Number	0029	
C_PRTO . . . . . . . . . . . . .  	Number	0005	
C_RBR  . . . . . . . . . . . . .  	Number	0027	
C_READ . . . . . . . . . . . . .  	Number	0014	
C_RENA . . . . . . . . . . . . .  	Number	0017	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-4
                                                             

C_REST . . . . . . . . . . . . .  	Number	000D	
C_RNDR . . . . . . . . . . . . .  	Number	0021	
C_RNDW . . . . . . . . . . . . .  	Number	0022	
C_SDRV . . . . . . . . . . . . .  	Number	000E	
C_SEAR . . . . . . . . . . . . .  	Number	0011	

DATA . . . . . . . . . . . . . .  	L NEAR	0ACF	CSEG	Global
DATAH  . . . . . . . . . . . . .  	L NEAR	0ACE	CSEG
DATAS  . . . . . . . . . . . . .  	NEAR 	0ACF	CSEG	Global
DATBK  . . . . . . . . . . . . .  	L NEAR	0EDE	CSEG
DATFND . . . . . . . . . . . . .  	L NEAR	0F6C	CSEG
DATLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DATLOP . . . . . . . . . . . . .  	L NEAR	0F69	CSEG
DATOFS . . . . . . . . . . . . .  	Number	0039	
DATPSC . . . . . . . . . . . . .  	Number	0080	
DATPTR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DATSNE . . . . . . . . . . . . .  	L NEAR	008C	CSEG
DBLCHR . . . . . . . . . . . . .  	Number	0000	
DBLCN1 . . . . . . . . . . . . .  	Number	0020		Global
DBLCON . . . . . . . . . . . . .  	Number	001F		Global
DBLTRN . . . . . . . . . . . . .  	Number	0000	
DCXBRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DDERR  . . . . . . . . . . . . .  	L NEAR	009D	CSEG	Global
DEBUG  . . . . . . . . . . . . .  	Text  		
DECNXT . . . . . . . . . . . . .  	L NEAR	129C	CSEG
DEFCON . . . . . . . . . . . . .  	L NEAR	0924	CSEG
DEFDBL . . . . . . . . . . . . .  	L NEAR	0922	CSEG	Global
DEFINT . . . . . . . . . . . . .  	L NEAR	091C	CSEG	Global
DEFREA . . . . . . . . . . . . .  	L NEAR	091F	CSEG	Global
DEFSTR . . . . . . . . . . . . .  	L NEAR	0919	CSEG	Global
DEFTBL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DEL  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DELETE . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DEPTR  . . . . . . . . . . . . .  	L NEAR	1154	CSEG	Global
DERBFM . . . . . . . . . . . . .  	L NEAR	006A	CSEG	Global
DERBFN . . . . . . . . . . . . .  	L NEAR	0070	CSEG	Global
DERBRN . . . . . . . . . . . . .  	L NEAR	007F	CSEG	Global
DERDFL . . . . . . . . . . . . .  	L NEAR	0064	CSEG	Global
DERDNA . . . . . . . . . . . . .  	L NEAR	005B	CSEG	Global
DERFAE . . . . . . . . . . . . .  	L NEAR	0088	CSEG	Global
DERFAO . . . . . . . . . . . . .  	L NEAR	0079	CSEG	Global
DERFDR . . . . . . . . . . . . .  	L NEAR	005E	CSEG	Global
DERFNF . . . . . . . . . . . . .  	L NEAR	006D	CSEG	Global
DERFNO . . . . . . . . . . . . .  	L NEAR	0058	CSEG	Global
DERFOV . . . . . . . . . . . . .  	L NEAR	0082	CSEG	Global
DERIER . . . . . . . . . . . . .  	L NEAR	0073	CSEG	Global
DERIFN . . . . . . . . . . . . .  	L NEAR	0055	CSEG	Global
DERIOE . . . . . . . . . . . . .  	L NEAR	0067	CSEG	Global
DERNMF . . . . . . . . . . . . .  	L NEAR	007C	CSEG	Global
DERRAD . . . . . . . . . . . . .  	L NEAR	0061	CSEG	Global
DERRPE . . . . . . . . . . . . .  	L NEAR	0076	CSEG	Global
DERTMF . . . . . . . . . . . . .  	L NEAR	0085	CSEG	Global
DFACLO . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DIRDO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-5
                                                             

DISK . . . . . . . . . . . . . .  	Number	0001	
DLINE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DMC  . . . . . . . . . . . . . .  	Number	0000	
DNTCPY . . . . . . . . . . . . .  	L NEAR	0B6E	CSEG
DOASIG . . . . . . . . . . . . .  	L NEAR	0F0E	CSEG	Global
DOCNVF . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DOCOND . . . . . . . . . . . . .  	L NEAR	0CFF	CSEG
DONUM  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DORES  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DOS  . . . . . . . . . . . . . .  	Number	0000	
DOT  . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DRVPOS . . . . . . . . . . . . .  	Number	0000	
DSCTMP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
DSKER1 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DSKERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
DUPONT . . . . . . . . . . . . .  	Number	0000	
DV0ERR . . . . . . . . . . . . .  	L NEAR	0097	CSEG	Global
DYNCOM . . . . . . . . . . . . .  	Number	0001	

EATCOM . . . . . . . . . . . . .  	L NEAR	1012	CSEG
EDENT  . . . . . . . . . . . . .  	L NEAR	0228	CSEG	Global
EDIT80 . . . . . . . . . . . . .  	Number	0000	
EDTXIT . . . . . . . . . . . . .  	L NEAR	02F9	CSEG
ELSES  . . . . . . . . . . . . .  	L NEAR	0AD3	CSEG	Global
ENDCNJ . . . . . . . . . . . . .  	L NEAR	0052	CSEG
ENDCON . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ENDFOR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ENDPRG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ENDSCN . . . . . . . . . . . . .  	L NEAR	0E4E	CSEG
EQULTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERAINS . . . . . . . . . . . . .  	L NEAR	0295	CSEG
ERESET . . . . . . . . . . . . .  	L NEAR	00DF	CSEG	Global
ERRBFM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRBFN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRBRN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRDD  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRDFL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRDNA . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRDV0 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERREDT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRESM . . . . . . . . . . . . .  	L NEAR	00DC	CSEG
ERRFAE . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFAO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFC  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFDR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFIN . . . . . . . . . . . . .  	L NEAR	0162	CSEG	Global
ERRFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ERRFN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFN1 . . . . . . . . . . . . .  	L NEAR	016F	CSEG
ERRFNF . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFNO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRFOV . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRIER . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRIFN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-6
                                                             

ERRIOE . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRLBO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ERRMO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRMOR . . . . . . . . . . . . .  	L NEAR	00E6	CSEG
ERRNF  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRNMF . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRNR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERROD  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERROR  . . . . . . . . . . . . .  	L NEAR	00AE	CSEG	Global
ERRORS . . . . . . . . . . . . .  	L NEAR	0C93	CSEG	Global
ERROV  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRRAD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRRE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRRG  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRRPE . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRSN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRTAB . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRTM  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRTMF . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRTXT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ERRUE1 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRUF  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRUS  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ERRWH  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ESCCTL . . . . . . . . . . . . .  	Number	0000	
EUROPE . . . . . . . . . . . . .  	Number	0000	
EXCHQT . . . . . . . . . . . . .  	L NEAR	0AD7	CSEG
EXIDY  . . . . . . . . . . . . .  	Number	0000	

FAC  . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FACLO  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FADD . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FALSIF . . . . . . . . . . . . .  	L NEAR	0D18	CSEG
FAST . . . . . . . . . . . . . .  	Number	0001	
FCBSIZ . . . . . . . . . . . . .  	Number	0026	
FCB_DT . . . . . . . . . . . . .  	Number	001D	
FCB_DV . . . . . . . . . . . . .  	Number	0007	
FCB_EX . . . . . . . . . . . . .  	Number	0013	
FCB_FN . . . . . . . . . . . . .  	Number	0008	
FCB_FS . . . . . . . . . . . . .  	Number	0017	
FCB_FT . . . . . . . . . . . . .  	Number	0010	
FCB_NR . . . . . . . . . . . . .  	Number	0027	
FCB_RC . . . . . . . . . . . . .  	Number	0015	
FCB_RN . . . . . . . . . . . . .  	Number	0028	
FCERR  . . . . . . . . . . . . .  	L NEAR	097C	CSEG	Global
FC_ASC . . . . . . . . . . . . .  	Number	0000	
FC_BIN . . . . . . . . . . . . .  	Number	0001	
FDBSIZ . . . . . . . . . . . . .  	Number	0039	
FDTOK  . . . . . . . . . . . . .  	Number	0000	
FD_DAT . . . . . . . . . . . . .  	Number	00C2	
FD_LOG . . . . . . . . . . . . .  	Number	00BD	
FD_OPS . . . . . . . . . . . . .  	Number	00C0	
FD_PHY . . . . . . . . . . . . .  	Number	00BB	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-7
                                                             

FD_SIZ . . . . . . . . . . . . .  	Number	00B9	
FETOK  . . . . . . . . . . . . .  	Number	0000	
FILIND . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FILINP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FILSTI . . . . . . . . . . . . .  	L NEAR	0DA4	CSEG
FIN  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FINDBL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FINI . . . . . . . . . . . . . .  	L NEAR	02F9	CSEG	Global
FININ1 . . . . . . . . . . . . .  	L NEAR	08C0	CSEG
FINLPT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FINOVC . . . . . . . . . . . . .  	L NEAR	12D8	CSEG	Global
FINPRG . . . . . . . . . . . . .  	L NEAR	0F65	CSEG
FINPRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FIVDSK . . . . . . . . . . . . .  	Number	0001	
FIVEO  . . . . . . . . . . . . .  	Number	0001	
FIVLPT . . . . . . . . . . . . .  	Number	0001	
FIVMEM . . . . . . . . . . . . .  	Number	0001	
FKEYON . . . . . . . . . . . . .  	Number	0001	
FLGINP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FLGOVC . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FLGSCN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FLTGET . . . . . . . . . . . . .  	L NEAR	05AB	CSEG
FLTLIN . . . . . . . . . . . . .  	L NEAR	08F5	CSEG
FL_BKC . . . . . . . . . . . . .  	Number	0080	
FN2SW  . . . . . . . . . . . . .  	Number	0000	
FNAML  . . . . . . . . . . . . .  	Number	000B	
FNDFOR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	Global
FNDLIN . . . . . . . . . . . . .  	L NEAR	036F	CSEG	Global
FNDLN1 . . . . . . . . . . . . .  	L NEAR	036A	CSEG
FNLOP  . . . . . . . . . . . . .  	L NEAR	1230	CSEG
FNNWST . . . . . . . . . . . . .  	L NEAR	1266	CSEG
FOR  . . . . . . . . . . . . . .  	L NEAR	06A6	CSEG	Global
FORINC . . . . . . . . . . . . .  	L NEAR	122E	CSEG
FORSIZ . . . . . . . . . . . . .  	Number	0013	
FORSZC . . . . . . . . . . . . .  	Number	0013		Global
FORTRM . . . . . . . . . . . . .  	L NEAR	124D	CSEG
FOUT . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FOUTH  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FOUTO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRCDBL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRCINC . . . . . . . . . . . . .  	L NEAR	0893	CSEG
FRCINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRCSNG . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRCSTR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FREFAC . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRETMS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRETOP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FRMCHK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRMEVL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
FRMQNT . . . . . . . . . . . . .  	L NEAR	0FCA	CSEG	Global
FRQINT . . . . . . . . . . . . .  	L NEAR	0FD5	CSEG	Global
FUNACT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
FVALSV . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
F_BAKC . . . . . . . . . . . . .  	Number	0032	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-8
                                                             

F_BREM . . . . . . . . . . . . .  	Number	0030	
F_CLOC . . . . . . . . . . . . .  	Number	002D	
F_CODE . . . . . . . . . . . . .  	Number	0031	
F_DEV  . . . . . . . . . . . . .  	Number	0034	
F_FCB  . . . . . . . . . . . . .  	Number	0007	
F_FLGS . . . . . . . . . . . . .  	Number	0037	
F_MODE . . . . . . . . . . . . .  	Number	0006	
F_NEXT . . . . . . . . . . . . .  	Number	0004	
F_NUL1 . . . . . . . . . . . . .  	Number	0000	
F_NUL2 . . . . . . . . . . . . .  	Number	0002	
F_NUL3 . . . . . . . . . . . . .  	Number	0033	
F_NUL4 . . . . . . . . . . . . .  	Number	0036	
F_NUL5 . . . . . . . . . . . . .  	Number	00BF	
F_NUM  . . . . . . . . . . . . .  	Number	0001	
F_ORCT . . . . . . . . . . . . .  	Number	002F	
F_POS  . . . . . . . . . . . . .  	Number	0038	
F_TRPO . . . . . . . . . . . . .  	Number	0001	
F_TRPS . . . . . . . . . . . . .  	Number	0002	
F_WID  . . . . . . . . . . . . .  	Number	0035	

GENBIN . . . . . . . . . . . . .  	Number	0001	
GENDSK . . . . . . . . . . . . .  	Number	0000	
GENFLS . . . . . . . . . . . . .  	Number	0000	
GENIO  . . . . . . . . . . . . .  	Number	0001	
GENWID . . . . . . . . . . . . .  	Number	0000	
GESBC  . . . . . . . . . . . . .  	Number	0000	
GETAGN . . . . . . . . . . . . .  	L NEAR	0DE6	CSEG
GETBYT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GETIN2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GETINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GETSPA . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GETSTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GETYPR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GIO86  . . . . . . . . . . . . .  	Number	0001	
GISMD$ . . . . . . . . . . . . .  	L NEAR	07C8	CSEG
GLINE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GOERR  . . . . . . . . . . . . .  	L NEAR	0CA0	CSEG
GONCHR . . . . . . . . . . . . .  	L NEAR	07C3	CSEG
GONE . . . . . . . . . . . . . .  	L NEAR	081A	CSEG	Global
GONE0  . . . . . . . . . . . . .  	L NEAR	0821	CSEG
GONE2  . . . . . . . . . . . . .  	L NEAR	0827	CSEG
GONE3  . . . . . . . . . . . . .  	L NEAR	0825	CSEG
GONE4  . . . . . . . . . . . . .  	L NEAR	07D6	CSEG
GONGET . . . . . . . . . . . . .  	L NEAR	0814	CSEG
GONLET . . . . . . . . . . . . .  	L NEAR	07CE	CSEG
GONZER . . . . . . . . . . . . .  	L NEAR	07D1	CSEG
GOPRGD . . . . . . . . . . . . .  	L NEAR	07BC	CSEG
GORET  . . . . . . . . . . . . .  	L NEAR	07C2	CSEG
GOSNER . . . . . . . . . . . . .  	L NEAR	07BF	CSEG
GOSTEX . . . . . . . . . . . . .  	L NEAR	046A	CSEG
GOSUB  . . . . . . . . . . . . .  	L NEAR	09F1	CSEG	Global
GOSUB2 . . . . . . . . . . . . .  	L NEAR	0A16	CSEG	Global
GOTO . . . . . . . . . . . . . .  	L NEAR	0A35	CSEG	Global
GOTO2  . . . . . . . . . . . . .  	L NEAR	0A38	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-9
                                                             

GOTRP  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GPUTRS . . . . . . . . . . . . .  	L NEAR	044F	CSEG
GREATK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GTMPRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
GW . . . . . . . . . . . . . . .  	Number	0001	
GWCASS . . . . . . . . . . . . .  	Number	0000	
GWDBUG . . . . . . . . . . . . .  	Number	0000	
G_BIN  . . . . . . . . . . . . .  	Number	001A	
G_BOT  . . . . . . . . . . . . .  	Number	001C	
G_CLS  . . . . . . . . . . . . .  	Number	0006	
G_EOF  . . . . . . . . . . . . .  	Number	0000	
G_GCW  . . . . . . . . . . . . .  	Number	0018	
G_GPS  . . . . . . . . . . . . .  	Number	0012	
G_GWD  . . . . . . . . . . . . .  	Number	0014	
G_LOC  . . . . . . . . . . . . .  	Number	0002	
G_LOF  . . . . . . . . . . . . .  	Number	0004	
G_OPN  . . . . . . . . . . . . .  	Number	000C	
G_RND  . . . . . . . . . . . . .  	Number	000A	
G_SCW  . . . . . . . . . . . . .  	Number	0016	
G_SIN  . . . . . . . . . . . . .  	Number	000E	
G_SOT  . . . . . . . . . . . . .  	Number	0010	
G_SWD  . . . . . . . . . . . . .  	Number	0008	

HAL  . . . . . . . . . . . . . .  	Number	0000	
HEATH  . . . . . . . . . . . . .  	Number	0000	
HEXCON . . . . . . . . . . . . .  	Number	000C		Global
HEXOCT . . . . . . . . . . . . .  	Number	0001	
HGHBIT . . . . . . . . . . . . .  	Number	0001	
HLPEDT . . . . . . . . . . . . .  	Number	0000	

I8086  . . . . . . . . . . . . .  	Number	0001	
I8251  . . . . . . . . . . . . .  	Number	0000	
IADD . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
IBMLIK . . . . . . . . . . . . .  	Number	0001	
IBMTOK . . . . . . . . . . . . .  	Number	0001	
IEESLV . . . . . . . . . . . . .  	Number	0000	
IFS  . . . . . . . . . . . . . .  	L NEAR	0CE3	CSEG	Global
IN2CON . . . . . . . . . . . . .  	Number	000F	
INBFC0 . . . . . . . . . . . . .  	L NEAR	0B64	CSEG
INBUFC . . . . . . . . . . . . .  	L NEAR	0B65	CSEG
INDSKC . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INEG2  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INIT . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INITFG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
INITOK . . . . . . . . . . . . .  	L NEAR	00C0	CSEG
INKEYF . . . . . . . . . . . . .  	Number	0001	
INLADD . . . . . . . . . . . . .  	Number	0000	
INLIN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INONLY . . . . . . . . . . . . .  	L NEAR	0296	CSEG
INPBAK . . . . . . . . . . . . .  	L NEAR	0D8A	CSEG
INPCMA . . . . . . . . . . . . .  	L NEAR	0DDF	CSEG
INPCN3 . . . . . . . . . . . . .  	L NEAR	0EAC	CSEG
INPCOM . . . . . . . . . . . . .  	L NEAR	0B1D	CSEG
INPCON . . . . . . . . . . . . .  	L NEAR	0EB7	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-10
                                                             

INPPAS . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
INPRAG . . . . . . . . . . . . .  	L NEAR	11CD	CSEG
INPRG  . . . . . . . . . . . . .  	L NEAR	11CC	CSEG
INPRT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INPUT  . . . . . . . . . . . . .  	L NEAR	0DAE	CSEG	Global
INRART . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INSRTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INSTR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
INSTSW . . . . . . . . . . . . .  	Number	0000	
INTCON . . . . . . . . . . . . .  	Number	001C	
INTDEX . . . . . . . . . . . . .  	Number	0000	
INTEL  . . . . . . . . . . . . .  	Number	0000	
INTFHW . . . . . . . . . . . . .  	Number	0000	
INTFSW . . . . . . . . . . . . .  	Number	0000	
INTID2 . . . . . . . . . . . . .  	L NEAR	0976	CSEG	Global
INTIDX . . . . . . . . . . . . .  	L NEAR	0973	CSEG	Global
INTLEC . . . . . . . . . . . . .  	Number	0000	
INTROM . . . . . . . . . . . . .  	Number	0000	
INXHRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ISC  . . . . . . . . . . . . . .  	Number	0000	
ISFLIO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ISGOSU . . . . . . . . . . . . .  	L NEAR	0C21	CSEG
ISIGN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ISIS . . . . . . . . . . . . . .  	Number	0000	
ISLET  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ISLET2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ISMID$ . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ISRESW . . . . . . . . . . . . .  	L NEAR	04CF	CSEG
ISVARS . . . . . . . . . . . . .  	L NEAR	04C8	CSEG

JISKTN . . . . . . . . . . . . .  	Number	0000	
JKLOOP . . . . . . . . . . . . .  	L NEAR	0675	CSEG
JNTRS6 . . . . . . . . . . . . .  	L NEAR	0692	CSEG
JSCNXT . . . . . . . . . . . . .  	L NEAR	1119	CSEG

KANABS . . . . . . . . . . . . .  	Number	0000	
KANJFN . . . . . . . . . . . . .  	Number	0000	
KBFLEN . . . . . . . . . . . . .  	Number	013E	
KBUF . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
KEYSTA . . . . . . . . . . . . .  	Number	0000	
KILLER . . . . . . . . . . . . .  	Number	0000	
KLOOP  . . . . . . . . . . . . .  	L NEAR	03A2	CSEG
KRNSAV . . . . . . . . . . . . .  	L NEAR	063D	CSEG
KRNSVC . . . . . . . . . . . . .  	L NEAR	063B	CSEG
KRNVAR . . . . . . . . . . . . .  	L NEAR	065D	CSEG

LABEL  . . . . . . . . . . . . .  	Number	0000	
LABKEY . . . . . . . . . . . . .  	Number	0001	
LBOERR . . . . . . . . . . . . .  	L NEAR	0649	CSEG	Global
LEFPRN . . . . . . . . . . . . .  	L NEAR	0E4A	CSEG
LEN2 . . . . . . . . . . . . . .  	Number	0001	
LEN3 . . . . . . . . . . . . . .  	Number	0001	
LENGTH . . . . . . . . . . . . .  	Number	0002	
LEPSKP . . . . . . . . . . . . .  	L NEAR	0149	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-11
                                                             

LESSTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
LET  . . . . . . . . . . . . . .  	L NEAR	0B05	CSEG	Global
LETCN2 . . . . . . . . . . . . .  	L NEAR	0B19	CSEG
LETCN4 . . . . . . . . . . . . .  	L NEAR	0B2B	CSEG	Global
LETCN5 . . . . . . . . . . . . .  	L NEAR	0B2E	CSEG
LETCN6 . . . . . . . . . . . . .  	L NEAR	0B38	CSEG
LETCON . . . . . . . . . . . . .  	L NEAR	0B00	CSEG	Global
LEVFRE . . . . . . . . . . . . .  	L NEAR	02BA	CSEG
LEXIST . . . . . . . . . . . . .  	L NEAR	0280	CSEG
LINCON . . . . . . . . . . . . .  	Number	000E	
LINE . . . . . . . . . . . . . .  	L NEAR	0D2F	CSEG	Global
LINGET . . . . . . . . . . . . .  	L NEAR	098E	CSEG	Global
LINGT2 . . . . . . . . . . . . .  	L NEAR	098F	CSEG
LINGT3 . . . . . . . . . . . . .  	L NEAR	0998	CSEG
LINKER . . . . . . . . . . . . .  	L NEAR	0303	CSEG	Global
LINLN  . . . . . . . . . . . . .  	Number	0050	
LINM . . . . . . . . . . . . . .  	L NEAR	111B	CSEG
LINPRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
LINRES . . . . . . . . . . . . .  	L NEAR	0516	CSEG
LINSPC . . . . . . . . . . . . .  	L NEAR	0981	CSEG	Global
LISTEN . . . . . . . . . . . . .  	Number	0001	
LNGVAR . . . . . . . . . . . . .  	Number	0001	
LNREAD . . . . . . . . . . . . .  	Number	0000	
LOKHED . . . . . . . . . . . . .  	Number	0000	
LONGI  . . . . . . . . . . . . .  	Number	0000	
LOOP . . . . . . . . . . . . . .  	L NEAR	0373	CSEG
LOOPER . . . . . . . . . . . . .  	L NEAR	0005	CSEG
LOOPON . . . . . . . . . . . . .  	L NEAR	0C23	CSEG
LOPDAT . . . . . . . . . . . . .  	L NEAR	0EC6	CSEG
LOPDT2 . . . . . . . . . . . . .  	L NEAR	0EC2	CSEG
LOPPSI . . . . . . . . . . . . .  	L NEAR	048C	CSEG
LOPSK2 . . . . . . . . . . . . .  	L NEAR	04F2	CSEG
LOPSKP . . . . . . . . . . . . .  	L NEAR	04F1	CSEG
LOWCHR . . . . . . . . . . . . .  	L NEAR	0850	CSEG
LPDCHG . . . . . . . . . . . . .  	L NEAR	095F	CSEG
LPFORM . . . . . . . . . . . . .  	L NEAR	06D9	CSEG
LPRINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
LPT3 . . . . . . . . . . . . . .  	Number	0000	
LPTLEN . . . . . . . . . . . . .  	Number	0084	
LPTSW  . . . . . . . . . . . . .  	Number	0001	
LRUN . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
LSTERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
LSTOPK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
LTRACE . . . . . . . . . . . . .  	Number	0000	
LXISTS . . . . . . . . . . . . .  	L NEAR	027C	CSEG

MAIN . . . . . . . . . . . . . .  	L NEAR	01B2	CSEG	Global
MAINBX . . . . . . . . . . . . .  	L NEAR	0203	CSEG
MAKINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MAKPTR . . . . . . . . . . . . .  	L NEAR	1140	CSEG
MAKTKN . . . . . . . . . . . . .  	L NEAR	08A9	CSEG
MAKUPL . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MAKUPS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MCI  . . . . . . . . . . . . . .  	Number	0000	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-12
                                                             

MDS  . . . . . . . . . . . . . .  	Number	0000	
MDSISS . . . . . . . . . . . . .  	Number	0000	
MD_APP . . . . . . . . . . . . .  	Number	0008	
MD_RND . . . . . . . . . . . . .  	Number	0004	
MD_SQI . . . . . . . . . . . . .  	Number	0001	
MD_SQO . . . . . . . . . . . . .  	Number	0002	
MELCO  . . . . . . . . . . . . .  	Number	0000	
MEMIMG . . . . . . . . . . . . .  	Number	0001	
MEMSIZ . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
MIDTK  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MINUTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MLOOPR . . . . . . . . . . . . .  	L NEAR	02EA	CSEG
MOERR  . . . . . . . . . . . . .  	L NEAR	00A9	CSEG	Global
MORLIN . . . . . . . . . . . . .  	L NEAR	09AA	CSEG
MOSTEK . . . . . . . . . . . . .  	Number	0000	
MOVCON . . . . . . . . . . . . .  	L NEAR	05ED	CSEG
MOVE . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MOVE1  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MOVFM  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MOVFR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MOVMF  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MOVRF  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MOVRM  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
MRGFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
MULSEG . . . . . . . . . . . . .  	Number	0001	

NAME . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NAMLEN . . . . . . . . . . . . .  	Number	0028	
NASCOM . . . . . . . . . . . . .  	Number	0000	
NATROM . . . . . . . . . . . . .  	Number	0000	
NBANKS . . . . . . . . . . . . .  	Number	0001	
NCOLST . . . . . . . . . . . . .  	L NEAR	0F08	CSEG
NCRBAS . . . . . . . . . . . . .  	Number	0000	
NCRCAS . . . . . . . . . . . . .  	Number	0000	
NCRDEB . . . . . . . . . . . . .  	Number	0000	
NCRDON . . . . . . . . . . . . .  	L NEAR	03C8	CSEG
NCRELS . . . . . . . . . . . . .  	Number	0000	
NCRLPT . . . . . . . . . . . . .  	Number	0001	
NECBAS . . . . . . . . . . . . .  	Number	0000	
NECPPC . . . . . . . . . . . . .  	Number	0000	
NEG  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NEWST1 . . . . . . . . . . . . .  	L NEAR	0809	CSEG
NEWSTT . . . . . . . . . . . . .  	L NEAR	07FF	CSEG	Global
NEWSTX . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NEXTS  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NFERR  . . . . . . . . . . . . .  	L NEAR	009A	CSEG	Global
NLONLY . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NMCOMT . . . . . . . . . . . . .  	Number	0002	
NMKEYF . . . . . . . . . . . . .  	Number	000A	
NMKEYT . . . . . . . . . . . . .  	Number	000E	
NMLINE . . . . . . . . . . . . .  	Number	0019	
NMLPT  . . . . . . . . . . . . .  	Number	0003	
NMPAGE . . . . . . . . . . . . .  	Number	0001	
NMPENT . . . . . . . . . . . . .  	Number	0001	
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-13
                                                             

NMREL  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NMSTRT . . . . . . . . . . . . .  	Number	0004	
NNECBS . . . . . . . . . . . . .  	Number	0000	
NOATDL . . . . . . . . . . . . .  	Number	0000	
NOCTLA . . . . . . . . . . . . .  	Number	0000	
NODATT . . . . . . . . . . . . .  	L NEAR	03F2	CSEG
NODEL  . . . . . . . . . . . . .  	L NEAR	02A5	CSEG
NODOT  . . . . . . . . . . . . .  	Number	0000	
NOEDIT . . . . . . . . . . . . .  	Number	0000	
NOFUNS . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NOIOS  . . . . . . . . . . . . .  	Number	0000	
NONDSK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NONULL . . . . . . . . . . . . .  	Number	0000	
NOPEKS . . . . . . . . . . . . .  	Number	0000	
NORNF  . . . . . . . . . . . . .  	Number	0000	
NOROMP . . . . . . . . . . . . .  	Number	0000	
NORUBT . . . . . . . . . . . . .  	Number	0000	
NOTBGL . . . . . . . . . . . . .  	L NEAR	0C8A	CSEG
NOTCON . . . . . . . . . . . . .  	L NEAR	08CB	CSEG
NOTEVT . . . . . . . . . . . . .  	L NEAR	0AAA	CSEG
NOTFN2 . . . . . . . . . . . . .  	L NEAR	0501	CSEG
NOTFN3 . . . . . . . . . . . . .  	L NEAR	0507	CSEG
NOTFN4 . . . . . . . . . . . . .  	L NEAR	0526	CSEG
NOTFNT . . . . . . . . . . . . .  	L NEAR	0500	CSEG
NOTGOS . . . . . . . . . . . . .  	L NEAR	0474	CSEG
NOTLFT . . . . . . . . . . . . .  	L NEAR	08D2	CSEG
NOTOL  . . . . . . . . . . . . .  	L NEAR	06FC	CSEG
NOTQTI . . . . . . . . . . . . .  	L NEAR	0DE5	CSEG
NOTRAP . . . . . . . . . . . . .  	L NEAR	0126	CSEG
NOTRES . . . . . . . . . . . . .  	L NEAR	064E	CSEG
NOTRFN . . . . . . . . . . . . .  	L NEAR	0651	CSEG	Global
NOTRNG . . . . . . . . . . . . .  	L NEAR	094B	CSEG
NOTRS1 . . . . . . . . . . . . .  	L NEAR	0688	CSEG
NOTRS2 . . . . . . . . . . . . .  	L NEAR	052A	CSEG
NOTRS5 . . . . . . . . . . . . .  	L NEAR	0678	CSEG
NOTRS6 . . . . . . . . . . . . .  	L NEAR	052C	CSEG
NOTTK  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NOUSR  . . . . . . . . . . . . .  	Number	0000	
NOVARP . . . . . . . . . . . . .  	Number	0000	
NOWGET . . . . . . . . . . . . .  	L NEAR	0F0B	CSEG
NOWLIN . . . . . . . . . . . . .  	L NEAR	0F85	CSEG
NT0STP . . . . . . . . . . . . .  	L NEAR	077C	CSEG
NTASTC . . . . . . . . . . . . .  	L NEAR	0218	CSEG
NTAUTO . . . . . . . . . . . . .  	L NEAR	01E0	CSEG
NTDATA . . . . . . . . . . . . .  	L NEAR	040B	CSEG
NTDATR . . . . . . . . . . . . .  	L NEAR	127F	CSEG
NTDBL  . . . . . . . . . . . . .  	L NEAR	05EC	CSEG
NTDER2 . . . . . . . . . . . . .  	L NEAR	0145	CSEG
NTDERR . . . . . . . . . . . . .  	L NEAR	0149	CSEG
NTERRG . . . . . . . . . . . . .  	L NEAR	10EE	CSEG
NTICMA . . . . . . . . . . . . .  	L NEAR	0DDB	CSEG
NTINTG . . . . . . . . . . . . .  	L NEAR	05D9	CSEG
NTLINE . . . . . . . . . . . . .  	L NEAR	08F8	CSEG
NTMDCN . . . . . . . . . . . . .  	L NEAR	010E	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-14
                                                             

NTOERR . . . . . . . . . . . . .  	L NEAR	0BB3	CSEG
NTONG1 . . . . . . . . . . . . .  	L NEAR	0C14	CSEG	Global
NTONGS . . . . . . . . . . . . .  	L NEAR	0C11	CSEG
NTQTSC . . . . . . . . . . . . .  	L NEAR	1245	CSEG
NTREMR . . . . . . . . . . . . .  	L NEAR	1274	CSEG
NTRSC2 . . . . . . . . . . . . .  	L NEAR	0867	CSEG
NTRSCC . . . . . . . . . . . . .  	L NEAR	0863	CSEG
NTSNGT . . . . . . . . . . . . .  	L NEAR	0618	CSEG
NTSTOP . . . . . . . . . . . . .  	L NEAR	01EC	CSEG
NUMCMD . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
NUMCON . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NUMINS . . . . . . . . . . . . .  	L NEAR	0F2A	CSEG
NUMLEV . . . . . . . . . . . . .  	Number	006E	
NUMTMP . . . . . . . . . . . . .  	Number	000A	
NUMTRP . . . . . . . . . . . . .  	Number	0015	
NUMTRY . . . . . . . . . . . . .  	L NEAR	0574	CSEG
NWSTRT . . . . . . . . . . . . .  	L NEAR	0809	CSEG
NXTCON . . . . . . . . . . . . .  	L NEAR	07B7	CSEG	Global
NXTLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
NXTLOK . . . . . . . . . . . . .  	L NEAR	1294	CSEG
NXTRSC . . . . . . . . . . . . .  	L NEAR	1055	CSEG
NXTRSL . . . . . . . . . . . . .  	L NEAR	106A	CSEG
NXTSCN . . . . . . . . . . . . .  	L NEAR	121E	CSEG

OCTCNS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
OCTCON . . . . . . . . . . . . .  	Number	000B		Global
OEMRAM . . . . . . . . . . . . .  	Number	0000	
OKGOTO . . . . . . . . . . . . .  	L NEAR	0CF8	CSEG
OKI  . . . . . . . . . . . . . .  	Number	0000	
OKVLST . . . . . . . . . . . . .  	L NEAR	0E5A	CSEG
OLD86  . . . . . . . . . . . . .  	Number	0000	
OLDBLD . . . . . . . . . . . . .  	Number	0001	
OLDLIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
OLDOPT . . . . . . . . . . . . .  	L NEAR	11AF	CSEG
OLDTXT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
OLVPPC . . . . . . . . . . . . .  	Number	0000	
OMERR  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ONECON . . . . . . . . . . . . .  	Number	0011		Global
ONEFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ONEFUN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ONEI . . . . . . . . . . . . . .  	L NEAR	087B	CSEG
ONEI2  . . . . . . . . . . . . .  	L NEAR	0881	CSEG
ONELIN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ONEON  . . . . . . . . . . . . .  	L NEAR	0774	CSEG
ONGOTO . . . . . . . . . . . . .  	L NEAR	0B7B	CSEG	Global
ONGOTP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
ONGSB0 . . . . . . . . . . . . .  	L NEAR	0BC2	CSEG
ONGSBF . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
ONTEL  . . . . . . . . . . . . .  	Number	0000	
OPRTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
OPTFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
OPTION . . . . . . . . . . . . .  	L NEAR	115F	CSEG	Global
OPTVAL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
OUTDO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-15
                                                             

OVCSTR . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
OVERR  . . . . . . . . . . . . .  	L NEAR	00A6	CSEG	Global

PALSIZ . . . . . . . . . . . . .  	Number	0000	
PANBAS . . . . . . . . . . . . .  	Number	0000	
PANDBL . . . . . . . . . . . . .  	Number	0000	
PARM1  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PARM2  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PC8A . . . . . . . . . . . . . .  	Number	0000	
PCS  . . . . . . . . . . . . . .  	Number	0000	
PEEK . . . . . . . . . . . . . .  	L NEAR	0F8F	CSEG	Global
PEKFLT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PEKVAL . . . . . . . . . . . . .  	L NEAR	0FA5	CSEG
PINLIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PLAYSW . . . . . . . . . . . . .  	Number	0001	
PLOOP2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PLUSTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
POKE . . . . . . . . . . . . . .  	L NEAR	0FA9	CSEG	Global
POKEX  . . . . . . . . . . . . .  	L NEAR	0FC8	CSEG
POKFLT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
POPGOF . . . . . . . . . . . . .  	L NEAR	002C	CSEG
POPHRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
POPHSR . . . . . . . . . . . . .  	L NEAR	09D5	CSEG
POPSTF . . . . . . . . . . . . .  	L NEAR	05A4	CSEG
POS  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PPSWRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRGEND . . . . . . . . . . . . .  	L NEAR	003D	CSEG
PRGFIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRINT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRINUS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRMLEN . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PRMLN2 . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PRMSIZ . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PRMSTK . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PROCHK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PRODIR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PROFID . . . . . . . . . . . . .  	Number	00FE	
PTRCON . . . . . . . . . . . . .  	Number	000D	
PTRFIL . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PTRFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
PTRGET . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PTRGT2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PTRGTN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PUFOUT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PURE . . . . . . . . . . . . . .  	Number	0001	
PUSHF  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PUTNEW . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
PUTTMP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

QINLIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
QTINP  . . . . . . . . . . . . .  	L NEAR	0DB9	CSEG
QTLOPF . . . . . . . . . . . . .  	L NEAR	123A	CSEG
QUEUE  . . . . . . . . . . . . .  	Number	0001	

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-16
                                                             

RANDOM . . . . . . . . . . . . .  	L NEAR	11C1	CSEG	Global
RANMES . . . . . . . . . . . . .  	L NEAR	11F5	CSEG
RDOIN2 . . . . . . . . . . . . .  	L NEAR	0D98	CSEG
RDOINP . . . . . . . . . . . . .  	L NEAR	0D99	CSEG
READ . . . . . . . . . . . . . .  	L NEAR	0EB1	CSEG	Global
READY  . . . . . . . . . . . . .  	L NEAR	0194	CSEG	Global
READYR . . . . . . . . . . . . .  	L NEAR	0037	CSEG	Global
REALIO . . . . . . . . . . . . .  	Number	0001	
REASON . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
REDDY  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
REDINP . . . . . . . . . . . . .  	L NEAR	0B10	CSEG
REERR  . . . . . . . . . . . . .  	L NEAR	00A3	CSEG
RELINE . . . . . . . . . . . . .  	L NEAR	0D59	CSEG
REM  . . . . . . . . . . . . . .  	L NEAR	0AD3	CSEG	Global
REMER  . . . . . . . . . . . . .  	L NEAR	0ADD	CSEG
REMER1 . . . . . . . . . . . . .  	L NEAR	0ADE	CSEG
REMZER . . . . . . . . . . . . .  	L NEAR	0AD5	CSEG
RENCRN . . . . . . . . . . . . .  	L NEAR	04E2	CSEG	Global
REPINI . . . . . . . . . . . . .  	L NEAR	01A5	CSEG
RES0 . . . . . . . . . . . . . .  	L NEAR	0C66	CSEG
RESEQ  . . . . . . . . . . . . .  	L NEAR	0FF9	CSEG	Global
RESFIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RESLST . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RESNN  . . . . . . . . . . . . .  	L NEAR	1038	CSEG
RESNX1 . . . . . . . . . . . . .  	L NEAR	1087	CSEG
RESNXT . . . . . . . . . . . . .  	L NEAR	0C5E	CSEG
RESSD1 . . . . . . . . . . . . .  	L NEAR	1080	CSEG
RESTRP . . . . . . . . . . . . .  	L NEAR	0B9A	CSEG
RESTXT . . . . . . . . . . . . .  	L NEAR	0C6D	CSEG
RESUME . . . . . . . . . . . . .  	L NEAR	0C36	CSEG	Global
RETURN . . . . . . . . . . . . .  	L NEAR	0A7E	CSEG	Global
RMX  . . . . . . . . . . . . . .  	Number	0000	
RNDMN2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RNDX . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
RSHACK . . . . . . . . . . . . .  	Number	0000	
RSTLES . . . . . . . . . . . . .  	Number	0001	
RSTRAP . . . . . . . . . . . . .  	L NEAR	0BE7	CSEG
RSTTRP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RTRNOK . . . . . . . . . . . . .  	L NEAR	0A8D	CSEG
RUN  . . . . . . . . . . . . . .  	L NEAR	09D9	CSEG	Global
RUNC . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
RUNC2  . . . . . . . . . . . . .  	L NEAR	0A34	CSEG

SAVI . . . . . . . . . . . . . .  	L NEAR	059D	CSEG
SAVINT . . . . . . . . . . . . .  	L NEAR	0597	CSEG
SAVSEG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SAVSTK . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SAVTXT . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SBC  . . . . . . . . . . . . . .  	Number	0000	
SBC86  . . . . . . . . . . . . .  	Number	0000	
SCANWF . . . . . . . . . . . . .  	L NEAR	1231	CSEG
SCCALL . . . . . . . . . . . . .  	L NEAR	10A3	CSEG
SCCLIN . . . . . . . . . . . . .  	L NEAR	10A8	CSEG
SCCPTR . . . . . . . . . . . . .  	L NEAR	10A9	CSEG	Global
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-17
                                                             

SCNBKT . . . . . . . . . . . . .  	L NEAR	0E26	CSEG
SCNCNT . . . . . . . . . . . . .  	L NEAR	1220	CSEG
SCNCON . . . . . . . . . . . . .  	L NEAR	0E2B	CSEG
SCNEX2 . . . . . . . . . . . . .  	L NEAR	10C3	CSEG
SCNEX3 . . . . . . . . . . . . .  	L NEAR	1117	CSEG
SCNEXT . . . . . . . . . . . . .  	L NEAR	10C0	CSEG	Global
SCNLIN . . . . . . . . . . . . .  	L NEAR	0335	CSEG	Global
SCNOPN . . . . . . . . . . . . .  	L NEAR	0E29	CSEG
SCNPGM . . . . . . . . . . . . .  	L NEAR	10AE	CSEG
SCNPLN . . . . . . . . . . . . .  	L NEAR	10B3	CSEG
SCNPOP . . . . . . . . . . . . .  	L NEAR	1116	CSEG
SCNPT2 . . . . . . . . . . . . .  	L NEAR	112B	CSEG
SCNSEM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SCNSTR . . . . . . . . . . . . .  	L NEAR	0D79	CSEG
SCNVAL . . . . . . . . . . . . .  	L NEAR	0EDF	CSEG
SCP  . . . . . . . . . . . . . .  	Number	0001	
SCRN86 . . . . . . . . . . . . .  	Number	0001	
SCRNIO . . . . . . . . . . . . .  	Number	0001	
SCROLT . . . . . . . . . . . . .  	Number	0001	
SCRTCH . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SETGSB . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SGS  . . . . . . . . . . . . . .  	Number	0000	
SGSATS . . . . . . . . . . . . .  	Number	0000	
SHORTJ . . . . . . . . . . . . .  	Number	0001	
SHTCHN . . . . . . . . . . . . .  	Number	0000	
SHTERR . . . . . . . . . . . . .  	Number	0000	
SHTINS . . . . . . . . . . . . .  	Number	0000	
SHTLHM . . . . . . . . . . . . .  	Number	0000	
SHTLIN . . . . . . . . . . . . .  	Number	0000	
SHTPRO . . . . . . . . . . . . .  	Number	0000	
SHTREN . . . . . . . . . . . . .  	Number	0000	
SIGN . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SIGNC  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SIGNS  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SINLIN . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SIRIUS . . . . . . . . . . . . .  	Number	0000	
SIXDIG . . . . . . . . . . . . .  	Number	0000	
SKPMRF . . . . . . . . . . . . .  	L NEAR	0D1A	CSEG
SMALL  . . . . . . . . . . . . .  	Number	0000	
SNERR  . . . . . . . . . . . . .  	L NEAR	0094	CSEG	Global
SNGAU1 . . . . . . . . . . . . .  	L NEAR	0CCA	CSEG
SNGAUT . . . . . . . . . . . . .  	L NEAR	0CC8	CSEG
SNGCON . . . . . . . . . . . . .  	Number	001D	
SNGFLT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SNGFOR . . . . . . . . . . . . .  	L NEAR	074E	CSEG
SNGLIN . . . . . . . . . . . . .  	L NEAR	0363	CSEG
SNGQTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SPACE$ . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SPCDSK . . . . . . . . . . . . .  	Number	0000	
SPCNDS . . . . . . . . . . . . .  	Number	0000	
SPCTAB . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SQRTK  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SRCSP2 . . . . . . . . . . . . .  	L NEAR	0600	CSEG
SRCSPC . . . . . . . . . . . . .  	L NEAR	05FD	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-18
                                                             

STEPTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STKERR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STKINI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STKSRC . . . . . . . . . . . . .  	L NEAR	0014	CSEG
STMDSP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STOP . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STPEND . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STPRDY . . . . . . . . . . . . .  	L NEAR	0193	CSEG	Global
STPSGN . . . . . . . . . . . . .  	L NEAR	0773	CSEG
STR1 . . . . . . . . . . . . . .  	L NEAR	03F7	CSEG
STRCMP . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRCPY . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRDN2 . . . . . . . . . . . . .  	L NEAR	0F3D	CSEG
STREND . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
STRH$  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRING . . . . . . . . . . . . .  	Number	0001	
STRLIT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRLT2 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRLT3 . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRLTI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRNDS . . . . . . . . . . . . .  	L NEAR	11EC	CSEG
STRNG  . . . . . . . . . . . . .  	L NEAR	0402	CSEG
STRNG$ . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRNG2 . . . . . . . . . . . . .  	L NEAR	0405	CSEG
STRO$  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STROUI . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STROUT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRPN1 . . . . . . . . . . . . .  	L NEAR	11B4	CSEG
STRPRN . . . . . . . . . . . . .  	L NEAR	11B3	CSEG
STRPRT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
STRSIZ . . . . . . . . . . . . .  	Number	0003	
STUFFH . . . . . . . . . . . . .  	L NEAR	03DC	CSEG
SUBFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
SUBTEX . . . . . . . . . . . . .  	L NEAR	0471	CSEG
SUPPRS . . . . . . . . . . . . .  	L NEAR	0DF7	CSEG
SUPRSH . . . . . . . . . . . . .  	Number	0001	
SWAPSW . . . . . . . . . . . . .  	Number	0001	
SYNCHR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
SYSTME . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

TEK  . . . . . . . . . . . . . .  	Number	0000	
TEMP . . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TEMP2  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TEMP3  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TEMPA  . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TEMPST . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
TETRA  . . . . . . . . . . . . .  	Number	0000	
THENTK . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TIMSHR . . . . . . . . . . . . .  	Number	0000	
TMERR  . . . . . . . . . . . . .  	L NEAR	00AC	CSEG	Global
TOFF . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TON  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TOTEX  . . . . . . . . . . . . .  	L NEAR	046E	CSEG
TRCFLG . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-19
                                                             

TRMNOK . . . . . . . . . . . . .  	L NEAR	0D8E	CSEG
TRMNXT . . . . . . . . . . . . .  	L NEAR	12CD	CSEG
TRMOK  . . . . . . . . . . . . .  	L NEAR	0F4A	CSEG
TRNCHR . . . . . . . . . . . . .  	Number	0000	
TRSER2 . . . . . . . . . . . . .  	Number	0000	
TRSHHC . . . . . . . . . . . . .  	Number	0000	
TRUANS . . . . . . . . . . . . .  	Number	0000	
TRUROM . . . . . . . . . . . . .  	Number	0001	
TRYAGA . . . . . . . . . . . . .  	L NEAR	048B	CSEG
TRYAGN . . . . . . . . . . . . .  	L NEAR	0D66	CSEG
TSDISK . . . . . . . . . . . . .  	Number	0000	
TSHIBA . . . . . . . . . . . . .  	Number	0000	
TSLPT  . . . . . . . . . . . . .  	Number	0000	
TSTANM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
TSTNUM . . . . . . . . . . . . .  	L NEAR	0560	CSEG
TXTTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External

UCEMSG . . . . . . . . . . . . .  	Number	0000	
UFERR  . . . . . . . . . . . . .  	L NEAR	00A0	CSEG	Global
UMULT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
UPERR  . . . . . . . . . . . . .  	L NEAR	0143	CSEG
USA  . . . . . . . . . . . . . .  	Number	0000	
USERR  . . . . . . . . . . . . .  	L NEAR	0A79	CSEG	Global
USRTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
USRTK  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

VALINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VALSNG . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VALTYP . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
VARLOP . . . . . . . . . . . . .  	L NEAR	0E10	CSEG
VARTAB . . . . . . . . . . . . .  	V WORD 	0000	DSEG	External
VDFACS . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VMOVAF . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VMOVE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VMOVFA . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VMOVFM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VMOVMF . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VNEG . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
VSIGN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

WEND . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
WHILE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
WHLSIZ . . . . . . . . . . . . .  	Number	0006	
WNDSCN . . . . . . . . . . . . .  	L NEAR	121A	CSEG	Global
WRITE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
WUZOCT . . . . . . . . . . . . .  	L NEAR	062F	CSEG

XTNSYS . . . . . . . . . . . . .  	Number	0000	

Z80  . . . . . . . . . . . . . .  	Number	0001	
Z80MAC . . . . . . . . . . . . .  	Number	0001	
ZENITH . . . . . . . . . . . . .  	Number	0000	
ZERO . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External

Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-20
                                                             

$AUTO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$CATTY . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$CLROV . . . . . . . . . . . . .  	L NEAR	12E2	CSEG	Global
$DATA  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$DATCO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$DELETE  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$EDIT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$ELSE  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$END . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$ERL . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$ERROR . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$FCERR . . . . . . . . . . . . .  	L NEAR	097C	CSEG	Global
$FLGOC . . . . . . . . . . . . .  	L NEAR	12D8	CSEG	Global
$FN  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$FOR . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$GOSUB . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$GOTO  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$IF  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$INKEY$  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$INPUT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$LIST  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$LLIST . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$NEXT  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$OVERR . . . . . . . . . . . . .  	L NEAR	00A6	CSEG	Global
$OVMSG . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$POINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$PRINT . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$REM . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$REMCO . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$RENUM . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$RESTORE . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$RESUME  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$RETURN  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$RND . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$RUN . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$SCREEN  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$SNERR . . . . . . . . . . . . .  	L NEAR	0094	CSEG	Global
$STOP  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$STPRN . . . . . . . . . . . . .  	L NEAR	11B3	CSEG	Global
$STRING$ . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$THEN  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$TMERR . . . . . . . . . . . . .  	L NEAR	00AC	CSEG	Global
$TO  . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$USR . . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$VARPTR  . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$WEND  . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
$WHILE . . . . . . . . . . . . .  	L NEAR	0000	CSEG	External
??L000 . . . . . . . . . . . . .  	L NEAR	00BD	CSEG
??L001 . . . . . . . . . . . . .  	L NEAR	0153	CSEG
??L002 . . . . . . . . . . . . .  	L NEAR	017D	CSEG
??L003 . . . . . . . . . . . . .  	L NEAR	0182	CSEG
??L004 . . . . . . . . . . . . .  	L NEAR	018D	CSEG
??L005 . . . . . . . . . . . . .  	L NEAR	01B2	CSEG
??L006 . . . . . . . . . . . . .  	L NEAR	0203	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-21
                                                             

??L007 . . . . . . . . . . . . .  	L NEAR	0218	CSEG
??L008 . . . . . . . . . . . . .  	L NEAR	021F	CSEG
??L009 . . . . . . . . . . . . .  	L NEAR	0228	CSEG
??L010 . . . . . . . . . . . . .  	L NEAR	0237	CSEG
??L011 . . . . . . . . . . . . .  	L NEAR	026E	CSEG
??L012 . . . . . . . . . . . . .  	L NEAR	0278	CSEG
??L013 . . . . . . . . . . . . .  	L NEAR	0287	CSEG
??L014 . . . . . . . . . . . . .  	L NEAR	0291	CSEG
??L015 . . . . . . . . . . . . .  	L NEAR	02A5	CSEG
??L016 . . . . . . . . . . . . .  	L NEAR	035A	CSEG
??L017 . . . . . . . . . . . . .  	L NEAR	0363	CSEG
??L018 . . . . . . . . . . . . .  	L NEAR	03CF	CSEG
??L019 . . . . . . . . . . . . .  	L NEAR	0412	CSEG
??L020 . . . . . . . . . . . . .  	L NEAR	041E	CSEG
??L021 . . . . . . . . . . . . .  	L NEAR	042C	CSEG
??L022 . . . . . . . . . . . . .  	L NEAR	0445	CSEG
??L023 . . . . . . . . . . . . .  	L NEAR	049C	CSEG
??L024 . . . . . . . . . . . . .  	L NEAR	04AC	CSEG
??L025 . . . . . . . . . . . . .  	L NEAR	04CF	CSEG
??L026 . . . . . . . . . . . . .  	L NEAR	04DB	CSEG
??L027 . . . . . . . . . . . . .  	L NEAR	04FD	CSEG
??L028 . . . . . . . . . . . . .  	L NEAR	053A	CSEG
??L029 . . . . . . . . . . . . .  	L NEAR	054B	CSEG
??L030 . . . . . . . . . . . . .  	L NEAR	056D	CSEG
??L031 . . . . . . . . . . . . .  	L NEAR	0574	CSEG
??L032 . . . . . . . . . . . . .  	L NEAR	0582	CSEG
??L033 . . . . . . . . . . . . .  	L NEAR	058B	CSEG
??L034 . . . . . . . . . . . . .  	L NEAR	060C	CSEG
??L035 . . . . . . . . . . . . .  	L NEAR	061F	CSEG
??L036 . . . . . . . . . . . . .  	L NEAR	0722	CSEG
??L037 . . . . . . . . . . . . .  	L NEAR	0727	CSEG
??L038 . . . . . . . . . . . . .  	L NEAR	0732	CSEG
??L039 . . . . . . . . . . . . .  	L NEAR	0745	CSEG
??L040 . . . . . . . . . . . . .  	L NEAR	078D	CSEG
??L041 . . . . . . . . . . . . .  	L NEAR	0809	CSEG
??L042 . . . . . . . . . . . . .  	L NEAR	08D2	CSEG
??L043 . . . . . . . . . . . . .  	L NEAR	098E	CSEG
??L044 . . . . . . . . . . . . .  	L NEAR	09A1	CSEG
??L045 . . . . . . . . . . . . .  	L NEAR	09DE	CSEG
??L046 . . . . . . . . . . . . .  	L NEAR	09E9	CSEG
??L047 . . . . . . . . . . . . .  	L NEAR	0A49	CSEG
??L048 . . . . . . . . . . . . .  	L NEAR	0A65	CSEG
??L049 . . . . . . . . . . . . .  	L NEAR	0A6A	CSEG
??L050 . . . . . . . . . . . . .  	L NEAR	0A9C	CSEG
??L051 . . . . . . . . . . . . .  	L NEAR	0AAA	CSEG
??L052 . . . . . . . . . . . . .  	L NEAR	0AC3	CSEG
??L053 . . . . . . . . . . . . .  	L NEAR	0B9A	CSEG
??L054 . . . . . . . . . . . . .  	L NEAR	0BCB	CSEG
??L055 . . . . . . . . . . . . .  	L NEAR	0BE7	CSEG
??L056 . . . . . . . . . . . . .  	L NEAR	0C2C	CSEG
??L057 . . . . . . . . . . . . .  	L NEAR	0C40	CSEG
??L058 . . . . . . . . . . . . .  	L NEAR	0CA0	CSEG
??L059 . . . . . . . . . . . . .  	L NEAR	0CC8	CSEG
??L060 . . . . . . . . . . . . .  	L NEAR	0CD3	CSEG
Microsoft (R) Macro Assembler  Version 4.00                 2/7/21 10:20:40
 
GWMAIN Copied from BINTRP.MAC                               Symbols-22
                                                             

??L061 . . . . . . . . . . . . .  	L NEAR	0CEF	CSEG
??L062 . . . . . . . . . . . . .  	L NEAR	0D0C	CSEG
??L063 . . . . . . . . . . . . .  	L NEAR	0D13	CSEG
??L064 . . . . . . . . . . . . .  	L NEAR	0D36	CSEG
??L065 . . . . . . . . . . . . .  	L NEAR	0D41	CSEG
??L066 . . . . . . . . . . . . .  	L NEAR	0D59	CSEG
??L067 . . . . . . . . . . . . .  	L NEAR	0D83	CSEG
??L068 . . . . . . . . . . . . .  	L NEAR	0D98	CSEG
??L069 . . . . . . . . . . . . .  	L NEAR	0E00	CSEG
??L070 . . . . . . . . . . . . .  	L NEAR	0E33	CSEG
??L071 . . . . . . . . . . . . .  	L NEAR	0E3A	CSEG
??L072 . . . . . . . . . . . . .  	L NEAR	0E5A	CSEG
??L073 . . . . . . . . . . . . .  	L NEAR	0E67	CSEG
??L074 . . . . . . . . . . . . .  	L NEAR	0E84	CSEG
??L075 . . . . . . . . . . . . .  	L NEAR	0E8D	CSEG
??L076 . . . . . . . . . . . . .  	L NEAR	0E9F	CSEG
??L077 . . . . . . . . . . . . .  	L NEAR	0EAC	CSEG
??L078 . . . . . . . . . . . . .  	L NEAR	0EDE	CSEG
??L079 . . . . . . . . . . . . .  	L NEAR	0EEC	CSEG
??L080 . . . . . . . . . . . . .  	L NEAR	0F3A	CSEG
??L081 . . . . . . . . . . . . .  	L NEAR	0F4A	CSEG
??L082 . . . . . . . . . . . . .  	L NEAR	0F57	CSEG
??L083 . . . . . . . . . . . . .  	L NEAR	0F64	CSEG
??L084 . . . . . . . . . . . . .  	L NEAR	0F7D	CSEG
??L085 . . . . . . . . . . . . .  	L NEAR	0FA2	CSEG
??L086 . . . . . . . . . . . . .  	L NEAR	0FC5	CSEG
??L087 . . . . . . . . . . . . .  	L NEAR	1029	CSEG
??L088 . . . . . . . . . . . . .  	L NEAR	1030	CSEG
??L089 . . . . . . . . . . . . .  	L NEAR	104E	CSEG
??L090 . . . . . . . . . . . . .  	L NEAR	105C	CSEG
??L091 . . . . . . . . . . . . .  	L NEAR	106A	CSEG
??L092 . . . . . . . . . . . . .  	L NEAR	1178	CSEG
??L093 . . . . . . . . . . . . .  	L NEAR	117F	CSEG
??L094 . . . . . . . . . . . . .  	L NEAR	1192	CSEG
??L095 . . . . . . . . . . . . .  	L NEAR	11A4	CSEG
??L096 . . . . . . . . . . . . .  	L NEAR	11DC	CSEG
??L097 . . . . . . . . . . . . .  	L NEAR	125E	CSEG
?I . . . . . . . . . . . . . . .  	Number	0000	
_OFFST . . . . . . . . . . . . .  	Number	00C2	


   4246 Source  Lines
   4745 Total   Lines
   1157 Symbols

  12216 Bytes symbol space free

      0 Warning Errors
      0 Severe  Errors
